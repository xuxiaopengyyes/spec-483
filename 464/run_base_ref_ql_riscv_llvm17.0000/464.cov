/home/xzp/speccpu2006-v1.0.1/benchspec/CPU2006/464.h264ref/run/build_base_ql_riscv_llvm17.0000/annexb.c:
    1|       |
    2|       |/*!
    3|       | *************************************************************************************
    4|       | * \file annexb.c
    5|       | *
    6|       | * \brief
    7|       | *    Annex B Byte Stream format NAL Unit writing routines
    8|       | *
    9|       | * \author
   10|       | *    Main contributors (see contributors.h for copyright, address and affiliation details)
   11|       | *      - Stephan Wenger                  <stewe@cs.tu-berlin.de>
   12|       | *************************************************************************************
   13|       | */
   14|       |
   15|       |#include <stdlib.h>
   16|       |#include <assert.h>
   17|       |
   18|       |#include "global.h"
   19|       |#include "nalucommon.h"
   20|       |
   21|       |static FILE *f = NULL;    // the output file
   22|       |
   23|       |
   24|       |/*!
   25|       | ********************************************************************************************
   26|       | * \brief 
   27|       | *    Writes a NALU to the Annex B Byte Stream
   28|       | *
   29|       | * \return
   30|       | *    number of bits written
   31|       | *
   32|       | ********************************************************************************************
   33|       |*/
   34|       |int WriteAnnexbNALU (NALU_t *n)
   35|    173|{
   36|    173|  int BitsWritten = 0;
   37|       |
   38|    173|  assert (n != NULL);
   39|    173|  assert (n->forbidden_bit == 0);
   40|    173|  assert (f != NULL);
   41|    173|  assert (n->startcodeprefix_len == 3 || n->startcodeprefix_len == 4);
   42|       |
   43|       |// printf ("WriteAnnexbNALU: writing %d bytes w/ startcode_len %d\n", n->len+1, n->startcodeprefix_len); 
   44|    173|  if (n->startcodeprefix_len > 3)
   45|    173|  {
   46|       |#if !defined(SPEC_CPU)
   47|       |    putc (0, f);
   48|       |#endif /* SPEC_CPU */
   49|    173|    BitsWritten =+ 8;
   50|    173|  }
   51|       |#if !defined(SPEC_CPU)
   52|       |  putc (0, f);
   53|       |  putc (0, f);
   54|       |  putc (1, f);
   55|       |#endif /* SPEC_CPU */
   56|    173|  BitsWritten += 24;
   57|       |
   58|    173|  n->buf[0] =
   59|    173|    n->forbidden_bit << 7      |
   60|    173|    n->nal_reference_idc << 5  |
   61|    173|    n->nal_unit_type;
   62|       |
   63|       |// printf ("First Byte %x, nal_ref_idc %x, nal_unit_type %d\n", n->buf[0], n->nal_reference_idc, n->nal_unit_type);
   64|       |
   65|       |#if !defined(SPEC_CPU)
   66|       |  if (n->len != fwrite (n->buf, 1, n->len, f))
   67|       |  {
   68|       |    printf ("Fatal: cannot write %d bytes to bitstream file, exit (-1)\n", n->len);
   69|       |    exit (-1);
   70|       |  }
   71|       |#endif /* SPEC_CPU */
   72|       |
   73|    173|  BitsWritten += n->len * 8;
   74|       |
   75|       |#if !defined(SPEC_CPU)
   76|       |  fflush (f);
   77|       |#endif /* SPEC_CPU */
   78|       |#if TRACE
   79|       |  fprintf (p_trace, "\n\nAnnex B NALU w/ %s startcode, len %d, forbidden_bit %d, nal_reference_idc %d, nal_unit_type %d\n\n",
   80|       |    n->startcodeprefix_len == 4?"long":"short", n->len, n->forbidden_bit, n->nal_reference_idc, n->nal_unit_type);
   81|       |  fflush (p_trace);
   82|       |#endif
   83|    173|  return BitsWritten;
   84|    173|}
   85|       |
   86|       |
   87|       |/*!
   88|       | ********************************************************************************************
   89|       | * \brief 
   90|       | *    Opens the output file for the bytestream    
   91|       | *
   92|       | * \param Filename
   93|       | *    The filename of the file to be opened
   94|       | *
   95|       | * \return
   96|       | *    none.  Function terminates the program in case of an error
   97|       | *
   98|       | ********************************************************************************************
   99|       |*/
  100|       |void OpenAnnexbFile (char *Filename)
  101|      1|{
  102|      1|  if ((f = fopen (Filename, "wb")) == NULL)
  103|      0|  {
  104|      0|    printf ("Fatal: cannot open Annex B bytestream file '%s', exit (-1)\n", Filename);
  105|      0|    exit (-1);
  106|      0|  }
  107|      1|}
  108|       |
  109|       |
  110|       |/*!
  111|       | ********************************************************************************************
  112|       | * \brief 
  113|       | *    Closes the output bit stream file
  114|       | *
  115|       | * \return
  116|       | *    none.  Funtion trerminates the program in case of an error
  117|       | ********************************************************************************************
  118|       |*/
  119|      1|void CloseAnnexbFile() {
  120|      1|  if (fclose (f))
  121|      0|  {
  122|      0|    printf ("Fatal: cannot close Annex B bytestream file, exit (-1)\n");
  123|      0|    exit (-1);
  124|      0|  }
  125|      1|}
  126|       |

/home/xzp/speccpu2006-v1.0.1/benchspec/CPU2006/464.h264ref/run/build_base_ql_riscv_llvm17.0000/biariencode.c:
    1|       |
    2|       |/*!
    3|       | *************************************************************************************
    4|       | * \file biariencode.c
    5|       | *
    6|       | * \brief
    7|       | *    Routines for binary arithmetic encoding
    8|       | *
    9|       | * \author
   10|       | *    Main contributors (see contributors.h for copyright, address and affiliation details)
   11|       | *    - Detlev Marpe                    <marpe@hhi.de>
   12|       | *    - Gabi Blaettermann               <blaetter@hhi.de>
   13|       | *************************************************************************************
   14|       | */
   15|       |
   16|       |#include <stdlib.h>
   17|       |#include <stdio.h>
   18|       |
   19|       |#include "global.h"
   20|       |#include "biariencode.h"
   21|       |
   22|       |int binCount = 0;
   23|       |
   24|       |/*!
   25|       | ************************************************************************
   26|       | * Macro for writing bytes of code
   27|       | ***********************************************************************
   28|       | */
   29|       |
   30|  67.1M|#define put_byte() { \
   31|  67.1M|                     Ecodestrm[(*Ecodestrm_len)++] = Ebuffer; \
   32|  67.1M|                     Ebits_to_go = 8; \
   33|   372M|                     while (eep->C > 7) { \
   34|   305M|                       eep->C-=8; \
   35|   305M|                       eep->E++; \
   36|   305M|                     } \
   37|  67.1M|                    } 
   38|       |
   39|   536M|#define put_one_bit(b) { \
   40|   536M|                         Ebuffer <<= 1; Ebuffer |= (b); \
   41|   536M|                         if (--Ebits_to_go == 0) \
   42|   536M|                           put_byte(); \
   43|   536M|                       }
   44|       |
   45|   276M|#define put_one_bit_plus_outstanding(b) { \
   46|   276M|                                          put_one_bit(b); \
   47|   536M|                                          while (Ebits_to_follow > 0) \
   48|   276M|                                          { \
   49|   259M|                                            Ebits_to_follow--; \
   50|   259M|                                            put_one_bit(!(b)); \
   51|   259M|                                          } \
   52|   276M|                                         }
   53|       |
   54|       |
   55|       |/*!
   56|       | ************************************************************************
   57|       | * \brief
   58|       | *    Allocates memory for the EncodingEnvironment struct
   59|       | ************************************************************************
   60|       | */
   61|       |EncodingEnvironmentPtr arienco_create_encoding_environment()
   62|      0|{
   63|      0|  EncodingEnvironmentPtr eep;
   64|       |
   65|      0|  if ( (eep = (EncodingEnvironmentPtr) calloc(1,sizeof(EncodingEnvironment))) == NULL)
   66|      0|    no_mem_exit("arienco_create_encoding_environment: eep");
   67|       |
   68|      0|  return eep;
   69|      0|}
   70|       |
   71|       |
   72|       |
   73|       |/*!
   74|       | ************************************************************************
   75|       | * \brief
   76|       | *    Frees memory of the EncodingEnvironment struct
   77|       | ************************************************************************
   78|       | */
   79|       |void arienco_delete_encoding_environment(EncodingEnvironmentPtr eep)
   80|      0|{
   81|      0|  if (eep == NULL)
   82|      0|  {
   83|      0|    snprintf(errortext, ET_SIZE, "Error freeing eep (NULL pointer)");
   84|      0|    error (errortext, 200);
   85|      0|  }
   86|      0|  else
   87|      0|    free(eep);
   88|      0|}
   89|       |
   90|       |
   91|       |
   92|       |/*!
   93|       | ************************************************************************
   94|       | * \brief
   95|       | *    Initializes the EncodingEnvironment for the arithmetic coder
   96|       | ************************************************************************
   97|       | */
   98|       |void arienco_start_encoding(EncodingEnvironmentPtr eep,
   99|       |                            unsigned char *code_buffer,
  100|       |                            int *code_len, /* int *last_startcode, */ int slice_type )
  101|    171|{
  102|    171|  Elow = 0;
  103|    171|  Ebits_to_follow = 0;
  104|    171|  Ebuffer = 0;
  105|    171|  Ebits_to_go = 9; // to swallow first redundant bit
  106|       |
  107|    171|  Ecodestrm = code_buffer;
  108|    171|  Ecodestrm_len = code_len;
  109|       |//  Ecodestrm_laststartcode = last_startcode;
  110|       |
  111|    171|  Erange = HALF-2;
  112|       |
  113|    171|  eep->C = 0;
  114|    171|  eep->B = *code_len;
  115|    171|  eep->E = 0;
  116|       |
  117|    171|}
  118|       |
  119|       |/*!
  120|       | ************************************************************************
  121|       | * \brief
  122|       | *    Returns the number of currently written bits
  123|       | ************************************************************************
  124|       | */
  125|       |int arienco_bits_written(EncodingEnvironmentPtr eep)
  126|   362M|{
  127|   362M|   return (8 * (*Ecodestrm_len /*-*Ecodestrm_laststartcode*/) + Ebits_to_follow + 8  - Ebits_to_go);
  128|   362M|}
  129|       |
  130|       |
  131|       |/*!
  132|       | ************************************************************************
  133|       | * \brief
  134|       | *    Terminates the arithmetic codeword, writes stop bit and stuffing bytes (if any)
  135|       | ************************************************************************
  136|       | */
  137|       |void arienco_done_encoding(EncodingEnvironmentPtr eep)
  138|    171|{
  139|    171|  put_one_bit_plus_outstanding((Elow >> (B_BITS-1)) & 1);
  140|    171|  put_one_bit((Elow >> (B_BITS-2))&1);
  141|    171|  put_one_bit(1);
  142|       |
  143|    171|  stats->bit_use_stuffingBits[img->type]+=(8-Ebits_to_go);
  144|       |
  145|    731|  while (Ebits_to_go != 8)
  146|    560|    put_one_bit(0);
  147|       |
  148|    171|  eep->E= eep->E*8 + eep->C; // no of processed bins
  149|    171|  eep->B= (*Ecodestrm_len - eep->B); // no of written bytes
  150|    171|  eep->E -= (img->current_mb_nr-img->currentSlice->start_mb_nr);
  151|    171|  eep->E = (eep->E + 31)>>5;
  152|       |  // eep->E now contains the minimum number of bytes for the NAL unit
  153|    171|}
  154|       |
  155|       |
  156|       |/*!
  157|       | ************************************************************************
  158|       | * \brief
  159|       | *    Actually arithmetic encoding of one binary symbol by using
  160|       | *    the probability estimate of its associated context model
  161|       | ************************************************************************
  162|       | */
  163|       |void biari_encode_symbol(EncodingEnvironmentPtr eep, signed short symbol, BiContextTypePtr bi_ct )
  164|   461M|{
  165|   461M|  register unsigned int range = Erange;
  166|   461M|  register unsigned int low = Elow;
  167|   461M|  unsigned int rLPS = rLPS_table_64x4[bi_ct->state][(range>>6) & 3];
  168|       |
  169|   461M|  extern int cabac_encoding;
  170|       |  
  171|       |#if TRACE
  172|       |//  if (cabac_encoding)
  173|       |//    fprintf(p_trace, "%d  0x%04x  %d  %d\n", binCount++, Erange , bi_ct->state, bi_ct->MPS );
  174|       |#endif
  175|       |  
  176|   461M|  if( cabac_encoding )
  177|  1.74M|  {
  178|  1.74M|    bi_ct->count++;
  179|  1.74M|  }
  180|       |
  181|       |  /* covers all cases where code does not bother to shift down symbol to be 
  182|       |   * either 0 or 1, e.g. in some cases for cbp, mb_Type etc the code symply 
  183|       |   * masks off the bit position and passes in the resulting value */
  184|       |
  185|   461M|  if (symbol != 0) 
  186|   194M|    symbol = 1;
  187|       |  
  188|   461M|  range -= rLPS;
  189|   461M|  if (symbol != bi_ct->MPS) 
  190|   221M|  {
  191|   221M|    low += range;
  192|   221M|    range = rLPS;
  193|       |    
  194|   221M|    if (!bi_ct->state)
  195|  11.3M|      bi_ct->MPS = bi_ct->MPS ^ 1;               // switch LPS if necessary
  196|   221M|    bi_ct->state = AC_next_state_LPS_64[bi_ct->state]; // next state
  197|   221M|  } 
  198|   240M|  else 
  199|   240M|    bi_ct->state = AC_next_state_MPS_64[bi_ct->state]; // next state
  200|       | 
  201|       |
  202|       |  /* renormalisation */    
  203|   968M|  while (range < QUARTER)
  204|   506M|  {
  205|   506M|    if (low >= HALF)
  206|  97.3M|    {
  207|  97.3M|      put_one_bit_plus_outstanding(1);
  208|  97.3M|      low -= HALF;
  209|  97.3M|    }
  210|   409M|    else 
  211|   409M|      if (low < QUARTER)
  212|   162M|      {
  213|   162M|        put_one_bit_plus_outstanding(0);
  214|   162M|      }
  215|   247M|      else
  216|   247M|      {
  217|   247M|        Ebits_to_follow++;
  218|   247M|        low -= QUARTER;
  219|   247M|      }
  220|   506M|    low <<= 1;
  221|   506M|    range <<= 1;
  222|   506M|  }
  223|   461M|  Erange = range;
  224|   461M|  Elow = low;
  225|   461M|  eep->C++;
  226|       |
  227|   461M|}
  228|       |
  229|       |
  230|       |
  231|       |
  232|       |/*!
  233|       | ************************************************************************
  234|       | * \brief
  235|       | *    Arithmetic encoding of one binary symbol assuming 
  236|       | *    a fixed prob. distribution with p(symbol) = 0.5
  237|       | ************************************************************************
  238|       | */
  239|       |void biari_encode_symbol_eq_prob(EncodingEnvironmentPtr eep, signed short symbol)
  240|  32.7M|{
  241|  32.7M|  register unsigned int low = (Elow<<1);
  242|       |
  243|       |  
  244|       |#if TRACE
  245|       |//  extern int cabac_encoding;
  246|       |//  if (cabac_encoding)
  247|       |//    fprintf(p_trace, "%d  0x%04x\n", binCount++, Erange );
  248|       |#endif
  249|       |  
  250|  32.7M|  if (symbol != 0)
  251|  16.0M|    low += Erange;
  252|       |
  253|       |  /* renormalisation as for biari_encode_symbol; 
  254|       |     note that low has already been doubled */ 
  255|  32.7M|  if (low >= ONE)
  256|  5.45M|  {
  257|  5.45M|    put_one_bit_plus_outstanding(1);
  258|  5.45M|    low -= ONE;
  259|  5.45M|  }
  260|  27.2M|  else 
  261|  27.2M|    if (low < HALF)
  262|  11.2M|    {
  263|  11.2M|      put_one_bit_plus_outstanding(0);
  264|  11.2M|    }
  265|  15.9M|    else
  266|  15.9M|    {
  267|  15.9M|      Ebits_to_follow++;
  268|  15.9M|      low -= HALF;
  269|  15.9M|    }
  270|  32.7M|    Elow = low;
  271|  32.7M|    eep->C++;
  272|       |    
  273|  32.7M|}
  274|       |
  275|       |/*!
  276|       | ************************************************************************
  277|       | * \brief
  278|       | *    Arithmetic encoding for last symbol before termination
  279|       | ************************************************************************
  280|       | */
  281|       |void biari_encode_symbol_final(EncodingEnvironmentPtr eep, signed short symbol)
  282|   551k|{
  283|   551k|  register unsigned int range = Erange-2;
  284|   551k|  register unsigned int low = Elow;
  285|       |  
  286|       |#if TRACE
  287|       |//  extern int cabac_encoding;
  288|       |//  if (cabac_encoding)
  289|       |//    fprintf(p_trace, "%d  0x%04x\n", binCount++, Erange);
  290|       |#endif
  291|       |  
  292|   551k|  if (symbol) {
  293|    171|    low += range;
  294|    171|    range = 2;
  295|    171|  }
  296|       |  
  297|   575k|  while (range < QUARTER)
  298|  24.6k|  {
  299|  24.6k|    if (low >= HALF)
  300|    125|    {
  301|    125|      put_one_bit_plus_outstanding(1);
  302|    125|      low -= HALF;
  303|    125|    }
  304|  24.5k|    else 
  305|  24.5k|      if (low < QUARTER)
  306|  10.7k|      {
  307|  10.7k|        put_one_bit_plus_outstanding(0);
  308|  10.7k|      }
  309|  13.7k|      else
  310|  13.7k|      {
  311|  13.7k|        Ebits_to_follow++;
  312|  13.7k|        low -= QUARTER;
  313|  13.7k|      }
  314|  24.6k|      low <<= 1;
  315|  24.6k|      range <<= 1;
  316|  24.6k|  }
  317|   551k|  Erange = range;
  318|   551k|  Elow = low;
  319|   551k|  eep->C++;
  320|   551k|}
  321|       |
  322|       |
  323|       |
  324|       |/*!
  325|       | ************************************************************************
  326|       | * \brief
  327|       | *    Initializes a given context with some pre-defined probability state
  328|       | ************************************************************************
  329|       | */
  330|       |void biari_init_context (BiContextTypePtr ctx, const int* ini)
  331|   145k|{
  332|   145k|  int pstate;
  333|       |
  334|   145k|  pstate = ((ini[0]* max(0, img->qp)) >> 4) + ini[1];
  335|   145k|  pstate = min (max ( 1, pstate), 126);
  336|       |
  337|   145k|  if ( pstate >= 64 )
  338|  95.0k|  {
  339|  95.0k|    ctx->state  = pstate - 64;
  340|  95.0k|    ctx->MPS    = 1;
  341|  95.0k|  }
  342|  50.6k|  else
  343|  50.6k|  {
  344|  50.6k|    ctx->state  = 63 - pstate;
  345|  50.6k|    ctx->MPS    = 0;
  346|  50.6k|  }
  347|       |  
  348|   145k|  ctx->count = 0;
  349|   145k|}
  350|       |

/home/xzp/speccpu2006-v1.0.1/benchspec/CPU2006/464.h264ref/run/build_base_ql_riscv_llvm17.0000/biariencode.h:
    1|       |
    2|       |/*!
    3|       | ***************************************************************************
    4|       | * \file
    5|       | *    biariencode.h
    6|       | *
    7|       | * \brief
    8|       | *    Headerfile for binary arithmetic encoding routines
    9|       | *
   10|       | * \author
   11|       | *    Detlev Marpe,
   12|       | *    Gabi Blaettermann
   13|       | *    Copyright (C) 2000 HEINRICH HERTZ INSTITUTE All Rights Reserved.
   14|       | *
   15|       | * \date
   16|       | *    21. Oct 2000
   17|       | **************************************************************************
   18|       | */
   19|       |
   20|       |
   21|       |#ifndef _BIARIENCOD_H_
   22|       |#define _BIARIENCOD_H_
   23|       |
   24|       |
   25|       |/************************************************************************
   26|       | * D e f i n i t i o n s
   27|       | ***********************************************************************
   28|       | */
   29|       |
   30|       |// some definitions to increase the readability of the source code
   31|       |
   32|   989M|#define Elow            (eep->Elow)
   33|   939M|#define Erange          (eep->Erange)
   34|  1.42G|#define Ebits_to_follow (eep->Ebits_to_follow)
   35|  1.14G|#define Ebuffer         (eep->Ebuffer)
   36|   966M|#define Ebits_to_go     (eep->Ebits_to_go)
   37|  67.1M|#define Ecodestrm       (eep->Ecodestrm)
   38|   429M|#define Ecodestrm_len   (eep->Ecodestrm_len)
   39|       |#define Ecodestrm_laststartcode   (eep->Ecodestrm_laststartcode)
   40|  2.31G|#define B_BITS     10 // Number of bits to represent the whole coding interval
   41|  38.1M|#define ONE                              (1 << B_BITS)
   42|   647M|#define HALF                     (1 << (B_BITS-1))
   43|  1.62G|#define QUARTER    (1 << (B_BITS-2))
   44|       |
   45|       |/* Range table for LPS */ 
   46|       |const byte rLPS_table_64x4[64][4]=
   47|       |{
   48|       |        { 128, 176, 208, 240},
   49|       |        { 128, 167, 197, 227},
   50|       |        { 128, 158, 187, 216},
   51|       |        { 123, 150, 178, 205},
   52|       |        { 116, 142, 169, 195},
   53|       |        { 111, 135, 160, 185},
   54|       |        { 105, 128, 152, 175},
   55|       |        { 100, 122, 144, 166},
   56|       |        {  95, 116, 137, 158},
   57|       |        {  90, 110, 130, 150},
   58|       |        {  85, 104, 123, 142},
   59|       |        {  81,  99, 117, 135},
   60|       |        {  77,  94, 111, 128},
   61|       |        {  73,  89, 105, 122},
   62|       |        {  69,  85, 100, 116},
   63|       |        {  66,  80,  95, 110},
   64|       |        {  62,  76,  90, 104},
   65|       |        {  59,  72,  86,  99},
   66|       |        {  56,  69,  81,  94},
   67|       |        {  53,  65,  77,  89},
   68|       |        {  51,  62,  73,  85},
   69|       |        {  48,  59,  69,  80},
   70|       |        {  46,  56,  66,  76},
   71|       |        {  43,  53,  63,  72},
   72|       |        {  41,  50,  59,  69},
   73|       |        {  39,  48,  56,  65},
   74|       |        {  37,  45,  54,  62},
   75|       |        {  35,  43,  51,  59},
   76|       |        {  33,  41,  48,  56},
   77|       |        {  32,  39,  46,  53},
   78|       |        {  30,  37,  43,  50},
   79|       |        {  29,  35,  41,  48},
   80|       |        {  27,  33,  39,  45},
   81|       |        {  26,  31,  37,  43},
   82|       |        {  24,  30,  35,  41},
   83|       |        {  23,  28,  33,  39},
   84|       |        {  22,  27,  32,  37},
   85|       |        {  21,  26,  30,  35},
   86|       |        {  20,  24,  29,  33},
   87|       |        {  19,  23,  27,  31},
   88|       |        {  18,  22,  26,  30},
   89|       |        {  17,  21,  25,  28},
   90|       |        {  16,  20,  23,  27},
   91|       |        {  15,  19,  22,  25},
   92|       |        {  14,  18,  21,  24},
   93|       |        {  14,  17,  20,  23},
   94|       |        {  13,  16,  19,  22},
   95|       |        {  12,  15,  18,  21},
   96|       |        {  12,  14,  17,  20},
   97|       |        {  11,  14,  16,  19},
   98|       |        {  11,  13,  15,  18},
   99|       |        {  10,  12,  15,  17},
  100|       |        {  10,  12,  14,  16},
  101|       |        {   9,  11,  13,  15},
  102|       |        {   9,  11,  12,  14},
  103|       |        {   8,  10,  12,  14},
  104|       |        {   8,   9,  11,  13},
  105|       |        {   7,   9,  11,  12},
  106|       |        {   7,   9,  10,  12},
  107|       |        {   7,   8,  10,  11},
  108|       |        {   6,   8,   9,  11},
  109|       |        {   6,   7,   9,  10},
  110|       |        {   6,   7,   8,   9},
  111|       |        {   2,   2,   2,   2}
  112|       |};
  113|       |
  114|       |
  115|       |const unsigned short AC_next_state_MPS_64[64] =    
  116|       |{
  117|       |                1,2,3,4,5,6,7,8,9,10,
  118|       |                11,12,13,14,15,16,17,18,19,20,
  119|       |                21,22,23,24,25,26,27,28,29,30,
  120|       |                31,32,33,34,35,36,37,38,39,40,
  121|       |                41,42,43,44,45,46,47,48,49,50,
  122|       |                51,52,53,54,55,56,57,58,59,60,
  123|       |                61,62,62,63
  124|       |};      
  125|       |
  126|       |const unsigned short AC_next_state_LPS_64[64] =    
  127|       |{
  128|       |                 0, 0, 1, 2, 2, 4, 4, 5, 6, 7,
  129|       |                 8, 9, 9,11,11,12,13,13,15,15, 
  130|       |                 16,16,18,18,19,19,21,21,22,22,
  131|       |                 23,24,24,25,26,26,27,27,28,29,
  132|       |                 29,30,30,30,31,32,32,33,33,33,
  133|       |                 34,34,35,35,35,36,36,36,37,37, 
  134|       |                 37,38,38,63 
  135|       |};
  136|       |
  137|       |
  138|       |#endif  // BIARIENCOD_H
  139|       |

/home/xzp/speccpu2006-v1.0.1/benchspec/CPU2006/464.h264ref/run/build_base_ql_riscv_llvm17.0000/block.c:
    1|       |
    2|       |/*!
    3|       | *************************************************************************************
    4|       | * \file block.c
    5|       | *
    6|       | * \brief
    7|       | *    Process one block
    8|       | *
    9|       | * \author
   10|       | *    Main contributors (see contributors.h for copyright, address and affiliation details)
   11|       | *    - Inge Lille-Langoy               <inge.lille-langoy@telenor.com>
   12|       | *    - Rickard Sjoberg                 <rickard.sjoberg@era.ericsson.se>
   13|       | *    - Stephan Wenger                  <stewe@cs.tu-berlin.de>
   14|       | *    - Jani Lainema                    <jani.lainema@nokia.com>
   15|       | *    - Detlev Marpe                    <marpe@hhi.de>
   16|       | *    - Thomas Wedi                     <wedi@tnt.uni-hannover.de>
   17|       | *    - Ragip Kurceren                  <ragip.kurceren@nokia.com>
   18|       | *    - Greg Conklin                    <gregc@real.com>
   19|       | *************************************************************************************
   20|       | */
   21|       |
   22|       |#include "contributors.h"
   23|       |
   24|       |
   25|       |#include <stdlib.h>
   26|       |#include <stdio.h>
   27|       |
   28|       |#include <string.h>
   29|       |#include <math.h>
   30|       |
   31|       |#include "global.h"
   32|       |
   33|       |#include "image.h"
   34|       |#include "mb_access.h"
   35|       |#include "block.h"
   36|       |#include "vlc.h"
   37|       |
   38|       |
   39|       |const int quant_coef[6][4][4] = {
   40|       |  {{13107, 8066,13107, 8066},{ 8066, 5243, 8066, 5243},{13107, 8066,13107, 8066},{ 8066, 5243, 8066, 5243}},
   41|       |  {{11916, 7490,11916, 7490},{ 7490, 4660, 7490, 4660},{11916, 7490,11916, 7490},{ 7490, 4660, 7490, 4660}},
   42|       |  {{10082, 6554,10082, 6554},{ 6554, 4194, 6554, 4194},{10082, 6554,10082, 6554},{ 6554, 4194, 6554, 4194}},
   43|       |  {{ 9362, 5825, 9362, 5825},{ 5825, 3647, 5825, 3647},{ 9362, 5825, 9362, 5825},{ 5825, 3647, 5825, 3647}},
   44|       |  {{ 8192, 5243, 8192, 5243},{ 5243, 3355, 5243, 3355},{ 8192, 5243, 8192, 5243},{ 5243, 3355, 5243, 3355}},
   45|       |  {{ 7282, 4559, 7282, 4559},{ 4559, 2893, 4559, 2893},{ 7282, 4559, 7282, 4559},{ 4559, 2893, 4559, 2893}}
   46|       |};
   47|       |
   48|       |const int dequant_coef[6][4][4] = {
   49|       |  {{10, 13, 10, 13},{ 13, 16, 13, 16},{10, 13, 10, 13},{ 13, 16, 13, 16}},
   50|       |  {{11, 14, 11, 14},{ 14, 18, 14, 18},{11, 14, 11, 14},{ 14, 18, 14, 18}},
   51|       |  {{13, 16, 13, 16},{ 16, 20, 16, 20},{13, 16, 13, 16},{ 16, 20, 16, 20}},
   52|       |  {{14, 18, 14, 18},{ 18, 23, 18, 23},{14, 18, 14, 18},{ 18, 23, 18, 23}},
   53|       |  {{16, 20, 16, 20},{ 20, 25, 20, 25},{16, 20, 16, 20},{ 20, 25, 20, 25}},
   54|       |  {{18, 23, 18, 23},{ 23, 29, 23, 29},{18, 23, 18, 23},{ 23, 29, 23, 29}}
   55|       |};
   56|       |static const int A[4][4] = {
   57|       |  { 16, 20, 16, 20},
   58|       |  { 20, 25, 20, 25},
   59|       |  { 16, 20, 16, 20},
   60|       |  { 20, 25, 20, 25}
   61|       |};
   62|       |
   63|       |
   64|       |// Notation for comments regarding prediction and predictors.
   65|       |// The pels of the 4x4 block are labelled a..p. The predictor pels above
   66|       |// are labelled A..H, from the left I..P, and from above left X, as follows:
   67|       |//
   68|       |//  X A B C D E F G H
   69|       |//  I a b c d
   70|       |//  J e f g h
   71|       |//  K i j k l
   72|       |//  L m n o p
   73|       |//
   74|       |
   75|       |// Predictor array index definitions
   76|  79.9M|#define P_X (PredPel[0])
   77|   133M|#define P_A (PredPel[1])
   78|   120M|#define P_B (PredPel[2])
   79|   113M|#define P_C (PredPel[3])
   80|  88.9M|#define P_D (PredPel[4])
   81|  60.1M|#define P_E (PredPel[5])
   82|  46.7M|#define P_F (PredPel[6])
   83|  33.4M|#define P_G (PredPel[7])
   84|  20.0M|#define P_H (PredPel[8])
   85|   126M|#define P_I (PredPel[9])
   86|   106M|#define P_J (PredPel[10])
   87|  93.4M|#define P_K (PredPel[11])
   88|  66.8M|#define P_L (PredPel[12])
   89|       |
   90|       |/*!
   91|       | ************************************************************************
   92|       | * \brief
   93|       | *    Make intra 4x4 prediction according to all 9 prediction modes.
   94|       | *    The routine uses left and upper neighbouring points from
   95|       | *    previous coded blocks to do this (if available). Notice that
   96|       | *    inaccessible neighbouring points are signalled with a negative
   97|       | *    value in the predmode array .
   98|       | *
   99|       | *  \par Input:
  100|       | *     Starting point of current 4x4 block image posision
  101|       | *
  102|       | *  \par Output:
  103|       | *      none
  104|       | ************************************************************************
  105|       | */
  106|       |void intrapred_luma(int img_x,int img_y, int *left_available, int *up_available, int *all_available)
  107|  6.72M|{
  108|  6.72M|  int i,j;
  109|  6.72M|  int s0;
  110|  6.72M|  int PredPel[13];  // array of predictor pels
  111|  6.72M|  imgpel **imgY = enc_picture->imgY;  // For MB level frame/field coding tools -- set default to imgY
  112|       |
  113|  6.72M|  int ioff = (img_x & 15);
  114|  6.72M|  int joff = (img_y & 15);
  115|  6.72M|  int mb_nr=img->current_mb_nr;
  116|       |
  117|  6.72M|  PixelPos pix_a[4];
  118|  6.72M|  PixelPos pix_b, pix_c, pix_d;
  119|       |
  120|  6.72M|  int block_available_up;
  121|  6.72M|  int block_available_left;
  122|  6.72M|  int block_available_up_left;
  123|  6.72M|  int block_available_up_right;
  124|       |
  125|  33.6M|  for (i=0;i<4;i++)
  126|  26.8M|  {
  127|  26.8M|    getNeighbour(mb_nr, ioff -1 , joff +i , 1, &pix_a[i]);
  128|  26.8M|  }
  129|       |  
  130|       |  
  131|  6.72M|  getNeighbour(mb_nr, ioff    , joff -1 , 1, &pix_b);
  132|  6.72M|  getNeighbour(mb_nr, ioff +4 , joff -1 , 1, &pix_c);
  133|  6.72M|  getNeighbour(mb_nr, ioff -1 , joff -1 , 1, &pix_d);
  134|       |
  135|  6.72M|  pix_c.available = pix_c.available && !(((ioff==4)||(ioff==12)) && ((joff==4)||(joff==12)));
  136|       |
  137|  6.72M|  if (input->UseConstrainedIntraPred)
  138|      0|  {
  139|      0|    for (i=0, block_available_left=1; i<4;i++)
  140|      0|      block_available_left  &= pix_a[i].available ? img->intra_block[pix_a[i].mb_addr]: 0;
  141|      0|    block_available_up       = pix_b.available ? img->intra_block [pix_b.mb_addr] : 0;
  142|      0|    block_available_up_right = pix_c.available ? img->intra_block [pix_c.mb_addr] : 0;
  143|      0|    block_available_up_left  = pix_d.available ? img->intra_block [pix_d.mb_addr] : 0;
  144|      0|  }
  145|  6.72M|  else
  146|  6.72M|  {
  147|  6.72M|    block_available_left     = pix_a[0].available;
  148|  6.72M|    block_available_up       = pix_b.available;
  149|  6.72M|    block_available_up_right = pix_c.available;
  150|  6.72M|    block_available_up_left  = pix_d.available;
  151|  6.72M|  }
  152|       |  
  153|  6.72M|  *left_available = block_available_left;
  154|  6.72M|  *up_available   = block_available_up;
  155|  6.72M|  *all_available  = block_available_up && block_available_left && block_available_up_left;
  156|       |
  157|  6.72M|  i = (img_x & 15);
  158|  6.72M|  j = (img_y & 15);
  159|       |
  160|       |  // form predictor pels
  161|  6.72M|  if (block_available_up)
  162|  6.67M|  {
  163|  6.67M|    P_A = imgY[pix_b.pos_y][pix_b.pos_x+0];
  164|  6.67M|    P_B = imgY[pix_b.pos_y][pix_b.pos_x+1];
  165|  6.67M|    P_C = imgY[pix_b.pos_y][pix_b.pos_x+2];
  166|  6.67M|    P_D = imgY[pix_b.pos_y][pix_b.pos_x+3];
  167|       |
  168|  6.67M|  }
  169|  43.0k|  else
  170|  43.0k|  {
  171|  43.0k|    P_A = P_B = P_C = P_D = img->dc_pred_value;
  172|  43.0k|  }
  173|       |
  174|  6.72M|  if (block_available_up_right)
  175|  4.56M|  {
  176|  4.56M|    P_E = imgY[pix_c.pos_y][pix_c.pos_x+0];
  177|  4.56M|    P_F = imgY[pix_c.pos_y][pix_c.pos_x+1];
  178|  4.56M|    P_G = imgY[pix_c.pos_y][pix_c.pos_x+2];
  179|  4.56M|    P_H = imgY[pix_c.pos_y][pix_c.pos_x+3];
  180|  4.56M|  }
  181|  2.15M|  else
  182|  2.15M|  {
  183|  2.15M|    P_E = P_F = P_G = P_H = P_D;
  184|  2.15M|  }
  185|       |
  186|  6.72M|  if (block_available_left)
  187|  6.69M|  {
  188|  6.69M|    P_I = imgY[pix_a[0].pos_y][pix_a[0].pos_x];
  189|  6.69M|    P_J = imgY[pix_a[1].pos_y][pix_a[1].pos_x];
  190|  6.69M|    P_K = imgY[pix_a[2].pos_y][pix_a[2].pos_x];
  191|  6.69M|    P_L = imgY[pix_a[3].pos_y][pix_a[3].pos_x];
  192|  6.69M|  }
  193|  26.6k|  else
  194|  26.6k|  {
  195|  26.6k|    P_I = P_J = P_K = P_L = img->dc_pred_value;
  196|  26.6k|  }
  197|       |
  198|  6.72M|  if (block_available_up_left)
  199|  6.65M|  {
  200|  6.65M|    P_X = imgY[pix_d.pos_y][pix_d.pos_x];
  201|  6.65M|  }
  202|  69.5k|  else
  203|  69.5k|  {
  204|  69.5k|    P_X = img->dc_pred_value;
  205|  69.5k|  }
  206|       |
  207|  67.2M|  for(i=0;i<9;i++)
  208|  60.5M|    img->mprr[i][0][0]=-1;
  209|       |
  210|       |  ///////////////////////////////
  211|       |  // make DC prediction
  212|       |  ///////////////////////////////
  213|  6.72M|  s0 = 0;
  214|  6.72M|  if (block_available_up && block_available_left)
  215|  6.65M|  {   
  216|       |    // no edge
  217|  6.65M|    s0 = (P_A + P_B + P_C + P_D + P_I + P_J + P_K + P_L + 4)/(2*BLOCK_SIZE);
  218|  6.65M|  }
  219|  69.5k|  else if (!block_available_up && block_available_left)
  220|  42.9k|  {
  221|       |    // upper edge
  222|  42.9k|    s0 = (P_I + P_J + P_K + P_L + 2)/BLOCK_SIZE;             
  223|  42.9k|  }
  224|  26.6k|  else if (block_available_up && !block_available_left)
  225|  26.5k|  {
  226|       |    // left edge
  227|  26.5k|    s0 = (P_A + P_B + P_C + P_D + 2)/BLOCK_SIZE;             
  228|  26.5k|  }
  229|    171|  else //if (!block_available_up && !block_available_left)
  230|    171|  {
  231|       |    // top left corner, nothing to predict from
  232|    171|    s0 = img->dc_pred_value;                           
  233|    171|  }
  234|       |
  235|  33.6M|  for (j=0; j < BLOCK_SIZE; j++)
  236|  26.8M|  {
  237|   134M|    for (i=0; i < BLOCK_SIZE; i++)
  238|   107M|    {
  239|       |      // store DC prediction
  240|   107M|      img->mprr[DC_PRED][i][j] = s0;
  241|   107M|    }
  242|  26.8M|  }
  243|       |
  244|       |  ///////////////////////////////
  245|       |  // make horiz and vert prediction
  246|       |  ///////////////////////////////
  247|       |
  248|  33.6M|  for (i=0; i < BLOCK_SIZE; i++)
  249|  26.8M|  {
  250|  26.8M|    img->mprr[VERT_PRED][0][i] = 
  251|  26.8M|    img->mprr[VERT_PRED][1][i] = 
  252|  26.8M|    img->mprr[VERT_PRED][2][i] = 
  253|  26.8M|    img->mprr[VERT_PRED][3][i] = (&P_A)[i];
  254|  26.8M|    img->mprr[HOR_PRED][i][0]  = 
  255|  26.8M|    img->mprr[HOR_PRED][i][1]  = 
  256|  26.8M|    img->mprr[HOR_PRED][i][2]  = 
  257|  26.8M|    img->mprr[HOR_PRED][i][3]  = (&P_I)[i];
  258|  26.8M|  }
  259|       |
  260|  6.72M|  if(!block_available_up)img->mprr[VERT_PRED][0][0]=-1;
  261|  6.72M|  if(!block_available_left)img->mprr[HOR_PRED][0][0]=-1;
  262|       |
  263|  6.72M|  if (block_available_up) 
  264|  6.67M|  {
  265|       |    // Mode DIAG_DOWN_LEFT_PRED
  266|  6.67M|    img->mprr[DIAG_DOWN_LEFT_PRED][0][0] = (P_A + P_C + 2*(P_B) + 2) / 4;
  267|  6.67M|    img->mprr[DIAG_DOWN_LEFT_PRED][0][1] = 
  268|  6.67M|    img->mprr[DIAG_DOWN_LEFT_PRED][1][0] = (P_B + P_D + 2*(P_C) + 2) / 4;
  269|  6.67M|    img->mprr[DIAG_DOWN_LEFT_PRED][0][2] =
  270|  6.67M|    img->mprr[DIAG_DOWN_LEFT_PRED][1][1] =
  271|  6.67M|    img->mprr[DIAG_DOWN_LEFT_PRED][2][0] = (P_C + P_E + 2*(P_D) + 2) / 4;
  272|  6.67M|    img->mprr[DIAG_DOWN_LEFT_PRED][0][3] = 
  273|  6.67M|    img->mprr[DIAG_DOWN_LEFT_PRED][1][2] = 
  274|  6.67M|    img->mprr[DIAG_DOWN_LEFT_PRED][2][1] = 
  275|  6.67M|    img->mprr[DIAG_DOWN_LEFT_PRED][3][0] = (P_D + P_F + 2*(P_E) + 2) / 4;
  276|  6.67M|    img->mprr[DIAG_DOWN_LEFT_PRED][1][3] = 
  277|  6.67M|    img->mprr[DIAG_DOWN_LEFT_PRED][2][2] = 
  278|  6.67M|    img->mprr[DIAG_DOWN_LEFT_PRED][3][1] = (P_E + P_G + 2*(P_F) + 2) / 4;
  279|  6.67M|    img->mprr[DIAG_DOWN_LEFT_PRED][2][3] = 
  280|  6.67M|    img->mprr[DIAG_DOWN_LEFT_PRED][3][2] = (P_F + P_H + 2*(P_G) + 2) / 4;
  281|  6.67M|    img->mprr[DIAG_DOWN_LEFT_PRED][3][3] = (P_G + 3*(P_H) + 2) / 4;
  282|       |
  283|       |    // Mode VERT_LEFT_PRED
  284|  6.67M|    img->mprr[VERT_LEFT_PRED][0][0] = (P_A + P_B + 1) / 2;
  285|  6.67M|    img->mprr[VERT_LEFT_PRED][0][1] = 
  286|  6.67M|    img->mprr[VERT_LEFT_PRED][2][0] = (P_B + P_C + 1) / 2;
  287|  6.67M|    img->mprr[VERT_LEFT_PRED][0][2] = 
  288|  6.67M|    img->mprr[VERT_LEFT_PRED][2][1] = (P_C + P_D + 1) / 2;
  289|  6.67M|    img->mprr[VERT_LEFT_PRED][0][3] = 
  290|  6.67M|    img->mprr[VERT_LEFT_PRED][2][2] = (P_D + P_E + 1) / 2;
  291|  6.67M|    img->mprr[VERT_LEFT_PRED][2][3] = (P_E + P_F + 1) / 2;
  292|  6.67M|    img->mprr[VERT_LEFT_PRED][1][0] = (P_A + 2*P_B + P_C + 2) / 4;
  293|  6.67M|    img->mprr[VERT_LEFT_PRED][1][1] = 
  294|  6.67M|    img->mprr[VERT_LEFT_PRED][3][0] = (P_B + 2*P_C + P_D + 2) / 4;
  295|  6.67M|    img->mprr[VERT_LEFT_PRED][1][2] = 
  296|  6.67M|    img->mprr[VERT_LEFT_PRED][3][1] = (P_C + 2*P_D + P_E + 2) / 4;
  297|  6.67M|    img->mprr[VERT_LEFT_PRED][1][3] = 
  298|  6.67M|    img->mprr[VERT_LEFT_PRED][3][2] = (P_D + 2*P_E + P_F + 2) / 4;
  299|  6.67M|    img->mprr[VERT_LEFT_PRED][3][3] = (P_E + 2*P_F + P_G + 2) / 4;
  300|       |
  301|  6.67M|  }
  302|       |
  303|       |  /*  Prediction according to 'diagonal' modes */
  304|  6.72M|  if (block_available_left) 
  305|  6.69M|  {
  306|       |    // Mode HOR_UP_PRED
  307|  6.69M|    img->mprr[HOR_UP_PRED][0][0] = (P_I + P_J + 1) / 2;
  308|  6.69M|    img->mprr[HOR_UP_PRED][0][1] = (P_I + 2*P_J + P_K + 2) / 4;
  309|  6.69M|    img->mprr[HOR_UP_PRED][0][2] = 
  310|  6.69M|    img->mprr[HOR_UP_PRED][1][0] = (P_J + P_K + 1) / 2;
  311|  6.69M|    img->mprr[HOR_UP_PRED][0][3] = 
  312|  6.69M|    img->mprr[HOR_UP_PRED][1][1] = (P_J + 2*P_K + P_L + 2) / 4;
  313|  6.69M|    img->mprr[HOR_UP_PRED][1][2] = 
  314|  6.69M|    img->mprr[HOR_UP_PRED][2][0] = (P_K + P_L + 1) / 2;
  315|  6.69M|    img->mprr[HOR_UP_PRED][1][3] = 
  316|  6.69M|    img->mprr[HOR_UP_PRED][2][1] = (P_K + 2*P_L + P_L + 2) / 4;
  317|  6.69M|    img->mprr[HOR_UP_PRED][3][0] = 
  318|  6.69M|    img->mprr[HOR_UP_PRED][2][2] = 
  319|  6.69M|    img->mprr[HOR_UP_PRED][2][3] = 
  320|  6.69M|    img->mprr[HOR_UP_PRED][3][1] = 
  321|  6.69M|    img->mprr[HOR_UP_PRED][3][2] = 
  322|  6.69M|    img->mprr[HOR_UP_PRED][3][3] = P_L;
  323|  6.69M|  }
  324|       |
  325|       |  /*  Prediction according to 'diagonal' modes */
  326|  6.72M|  if (block_available_up && block_available_left && block_available_up_left) 
  327|  6.65M|  {
  328|       |    // Mode DIAG_DOWN_RIGHT_PRED
  329|  6.65M|    img->mprr[DIAG_DOWN_RIGHT_PRED][3][0] = (P_L + 2*P_K + P_J + 2) / 4; 
  330|  6.65M|    img->mprr[DIAG_DOWN_RIGHT_PRED][2][0] =
  331|  6.65M|    img->mprr[DIAG_DOWN_RIGHT_PRED][3][1] = (P_K + 2*P_J + P_I + 2) / 4; 
  332|  6.65M|    img->mprr[DIAG_DOWN_RIGHT_PRED][1][0] =
  333|  6.65M|    img->mprr[DIAG_DOWN_RIGHT_PRED][2][1] = 
  334|  6.65M|    img->mprr[DIAG_DOWN_RIGHT_PRED][3][2] = (P_J + 2*P_I + P_X + 2) / 4; 
  335|  6.65M|    img->mprr[DIAG_DOWN_RIGHT_PRED][0][0] =
  336|  6.65M|    img->mprr[DIAG_DOWN_RIGHT_PRED][1][1] =
  337|  6.65M|    img->mprr[DIAG_DOWN_RIGHT_PRED][2][2] =
  338|  6.65M|    img->mprr[DIAG_DOWN_RIGHT_PRED][3][3] = (P_I + 2*P_X + P_A + 2) / 4; 
  339|  6.65M|    img->mprr[DIAG_DOWN_RIGHT_PRED][0][1] =
  340|  6.65M|    img->mprr[DIAG_DOWN_RIGHT_PRED][1][2] =
  341|  6.65M|    img->mprr[DIAG_DOWN_RIGHT_PRED][2][3] = (P_X + 2*P_A + P_B + 2) / 4;
  342|  6.65M|    img->mprr[DIAG_DOWN_RIGHT_PRED][0][2] =
  343|  6.65M|    img->mprr[DIAG_DOWN_RIGHT_PRED][1][3] = (P_A + 2*P_B + P_C + 2) / 4;
  344|  6.65M|    img->mprr[DIAG_DOWN_RIGHT_PRED][0][3] = (P_B + 2*P_C + P_D + 2) / 4;
  345|       |
  346|       |     // Mode VERT_RIGHT_PRED
  347|  6.65M|    img->mprr[VERT_RIGHT_PRED][0][0] = 
  348|  6.65M|    img->mprr[VERT_RIGHT_PRED][2][1] = (P_X + P_A + 1) / 2;
  349|  6.65M|    img->mprr[VERT_RIGHT_PRED][0][1] = 
  350|  6.65M|    img->mprr[VERT_RIGHT_PRED][2][2] = (P_A + P_B + 1) / 2;
  351|  6.65M|    img->mprr[VERT_RIGHT_PRED][0][2] = 
  352|  6.65M|    img->mprr[VERT_RIGHT_PRED][2][3] = (P_B + P_C + 1) / 2;
  353|  6.65M|    img->mprr[VERT_RIGHT_PRED][0][3] = (P_C + P_D + 1) / 2;
  354|  6.65M|    img->mprr[VERT_RIGHT_PRED][1][0] = 
  355|  6.65M|    img->mprr[VERT_RIGHT_PRED][3][1] = (P_I + 2*P_X + P_A + 2) / 4;
  356|  6.65M|    img->mprr[VERT_RIGHT_PRED][1][1] = 
  357|  6.65M|    img->mprr[VERT_RIGHT_PRED][3][2] = (P_X + 2*P_A + P_B + 2) / 4;
  358|  6.65M|    img->mprr[VERT_RIGHT_PRED][1][2] = 
  359|  6.65M|    img->mprr[VERT_RIGHT_PRED][3][3] = (P_A + 2*P_B + P_C + 2) / 4;
  360|  6.65M|    img->mprr[VERT_RIGHT_PRED][1][3] = (P_B + 2*P_C + P_D + 2) / 4;
  361|  6.65M|    img->mprr[VERT_RIGHT_PRED][2][0] = (P_X + 2*P_I + P_J + 2) / 4;
  362|  6.65M|    img->mprr[VERT_RIGHT_PRED][3][0] = (P_I + 2*P_J + P_K + 2) / 4;
  363|       |
  364|       |    // Mode HOR_DOWN_PRED
  365|  6.65M|    img->mprr[HOR_DOWN_PRED][0][0] = 
  366|  6.65M|    img->mprr[HOR_DOWN_PRED][1][2] = (P_X + P_I + 1) / 2;
  367|  6.65M|    img->mprr[HOR_DOWN_PRED][0][1] = 
  368|  6.65M|    img->mprr[HOR_DOWN_PRED][1][3] = (P_I + 2*P_X + P_A + 2) / 4;
  369|  6.65M|    img->mprr[HOR_DOWN_PRED][0][2] = (P_X + 2*P_A + P_B + 2) / 4;
  370|  6.65M|    img->mprr[HOR_DOWN_PRED][0][3] = (P_A + 2*P_B + P_C + 2) / 4;
  371|  6.65M|    img->mprr[HOR_DOWN_PRED][1][0] = 
  372|  6.65M|    img->mprr[HOR_DOWN_PRED][2][2] = (P_I + P_J + 1) / 2;
  373|  6.65M|    img->mprr[HOR_DOWN_PRED][1][1] = 
  374|  6.65M|    img->mprr[HOR_DOWN_PRED][2][3] = (P_X + 2*P_I + P_J + 2) / 4;
  375|  6.65M|    img->mprr[HOR_DOWN_PRED][2][0] = 
  376|  6.65M|    img->mprr[HOR_DOWN_PRED][3][2] = (P_J + P_K + 1) / 2;
  377|  6.65M|    img->mprr[HOR_DOWN_PRED][2][1] = 
  378|  6.65M|    img->mprr[HOR_DOWN_PRED][3][3] = (P_I + 2*P_J + P_K + 2) / 4;
  379|  6.65M|    img->mprr[HOR_DOWN_PRED][3][0] = (P_K + P_L + 1) / 2;
  380|  6.65M|    img->mprr[HOR_DOWN_PRED][3][1] = (P_J + 2*P_K + P_L + 2) / 4;
  381|  6.65M|  }
  382|  6.72M|}
  383|       |
  384|       |/*!
  385|       | ************************************************************************
  386|       | * \brief
  387|       | *    16x16 based luma prediction
  388|       | *
  389|       | * \par Input:
  390|       | *    Image parameters
  391|       | *
  392|       | * \par Output:
  393|       | *    none
  394|       | ************************************************************************
  395|       | */
  396|       |void intrapred_luma_16x16()
  397|   420k|{
  398|   420k|  int s0=0,s1,s2;
  399|   420k|  int s[16][2];
  400|   420k|  int i,j;
  401|       |
  402|   420k|  int ih,iv;
  403|   420k|  int ib,ic,iaa;
  404|       |
  405|   420k|  imgpel   **imgY_pred = enc_picture->imgY;  // For Mb level field/frame coding tools -- default to frame pred
  406|   420k|  int          mb_nr = img->current_mb_nr;
  407|       |
  408|   420k|  PixelPos up;          //!< pixel position p(0,-1)
  409|   420k|  PixelPos left[17];    //!< pixel positions p(-1, -1..15)
  410|       |
  411|   420k|  int up_avail, left_avail, left_up_avail;
  412|       |
  413|  7.56M|  for (i=0;i<17;i++)
  414|  7.14M|  {
  415|  7.14M|    getNeighbour(mb_nr, -1 ,  i-1 , 1, &left[i]);
  416|  7.14M|  }
  417|       |  
  418|   420k|  getNeighbour(mb_nr, 0     ,  -1 , 1, &up);
  419|       |
  420|   420k|  if (!(input->UseConstrainedIntraPred))
  421|   420k|  {
  422|   420k|    up_avail   = up.available;
  423|   420k|    left_avail = left[1].available;
  424|   420k|    left_up_avail = left[0].available;
  425|   420k|  }
  426|      0|  else
  427|      0|  {
  428|      0|    up_avail      = up.available ? img->intra_block[up.mb_addr] : 0;
  429|      0|    for (i=1, left_avail=1; i<17;i++)
  430|      0|      left_avail  &= left[i].available ? img->intra_block[left[i].mb_addr]: 0;
  431|      0|    left_up_avail = left[0].available ? img->intra_block[left[0].mb_addr]: 0;
  432|      0|  }
  433|       |
  434|   420k|  s1=s2=0;
  435|       |  // make DC prediction
  436|  7.14M|  for (i=0; i < MB_BLOCK_SIZE; i++)
  437|  6.72M|  {
  438|  6.72M|    if (up_avail)
  439|  6.54M|      s1 += imgY_pred[up.pos_y][up.pos_x+i];    // sum hor pix
  440|  6.72M|    if (left_avail)
  441|  6.61M|      s2 += imgY_pred[left[i+1].pos_y][left[i+1].pos_x];    // sum vert pix
  442|  6.72M|  }
  443|   420k|  if (up_avail && left_avail)
  444|   402k|    s0=(s1+s2+16)/(2*MB_BLOCK_SIZE);             // no edge
  445|   420k|  if (!up_avail && left_avail)
  446|  10.6k|    s0=(s2+8)/MB_BLOCK_SIZE;                     // upper edge
  447|   420k|  if (up_avail && !left_avail)
  448|  6.49k|    s0=(s1+8)/MB_BLOCK_SIZE;                     // left edge
  449|   420k|  if (!up_avail && !left_avail)
  450|    171|    s0=img->dc_pred_value;                       // top left corner, nothing to predict from
  451|       |
  452|  7.14M|  for (i=0; i < MB_BLOCK_SIZE; i++)
  453|  6.72M|  {
  454|       |    // vertical prediction
  455|  6.72M|    if (up_avail)
  456|  6.54M|      s[i][0]=imgY_pred[up.pos_y][up.pos_x+i];
  457|       |    // horizontal prediction
  458|  6.72M|    if (left_avail)
  459|  6.61M|      s[i][1]=imgY_pred[left[i+1].pos_y][left[i+1].pos_x];
  460|  6.72M|  }
  461|       |
  462|  7.14M|  for (j=0; j < MB_BLOCK_SIZE; j++)
  463|  6.72M|  {
  464|   114M|    for (i=0; i < MB_BLOCK_SIZE; i++)
  465|   107M|    {
  466|   107M|      img->mprr_2[VERT_PRED_16][j][i]=s[i][0]; // store vertical prediction
  467|   107M|      img->mprr_2[HOR_PRED_16 ][j][i]=s[j][1]; // store horizontal prediction
  468|   107M|      img->mprr_2[DC_PRED_16  ][j][i]=s0;      // store DC prediction
  469|   107M|    }
  470|  6.72M|  }
  471|   420k|  if (!up_avail || !left_avail || !left_up_avail) // edge
  472|  17.2k|    return;
  473|       |
  474|       |  // 16 bit integer plan pred
  475|       |
  476|   402k|  ih=0;
  477|   402k|  iv=0;
  478|  3.62M|  for (i=1;i<9;i++)
  479|  3.22M|  {
  480|  3.22M|    if (i<8)
  481|  2.82M|      ih += i*(imgY_pred[up.pos_y][up.pos_x+7+i] - imgY_pred[up.pos_y][up.pos_x+7-i]);
  482|   402k|    else
  483|   402k|      ih += i*(imgY_pred[up.pos_y][up.pos_x+7+i] - imgY_pred[left[0].pos_y][left[0].pos_x]);
  484|       |    
  485|  3.22M|    iv += i*(imgY_pred[left[8+i].pos_y][left[8+i].pos_x] - imgY_pred[left[8-i].pos_y][left[8-i].pos_x]);
  486|  3.22M|  }
  487|   402k|  ib=(5*ih+32)>>6;
  488|   402k|  ic=(5*iv+32)>>6;
  489|       |  
  490|   402k|  iaa=16*(imgY_pred[up.pos_y][up.pos_x+15]+imgY_pred[left[16].pos_y][left[16].pos_x]);
  491|       |
  492|  6.84M|  for (j=0;j< MB_BLOCK_SIZE;j++)
  493|  6.44M|  {
  494|   109M|    for (i=0;i< MB_BLOCK_SIZE;i++)
  495|   103M|    {
  496|   103M|      img->mprr_2[PLANE_16][j][i]=max(0,min((int)img->max_imgpel_value,(iaa+(i-7)*ib +(j-7)*ic + 16)/32));// store plane prediction
  497|   103M|    }
  498|  6.44M|  }
  499|   402k|}
  500|       |
  501|       |
  502|       |/*!
  503|       | ************************************************************************
  504|       | * \brief
  505|       | *    For new intra pred routines
  506|       | *
  507|       | * \par Input:
  508|       | *    Image par, 16x16 based intra mode
  509|       | *
  510|       | * \par Output:
  511|       | *    none
  512|       | ************************************************************************
  513|       | */
  514|       |int dct_luma_16x16(int new_intra_mode)
  515|   420k|{
  516|       |  //int qp_const;
  517|   420k|  int i,j;
  518|   420k|  int ii,jj;
  519|   420k|  int i1,j1;
  520|   420k|  int M1[16][16];
  521|   420k|  int M4[4][4];
  522|   420k|  int M5[4],M6[4];
  523|   420k|  int M0[4][4][4][4];
  524|   420k|  int run,scan_pos,coeff_ctr,level;
  525|   420k|  int qp_per,qp_rem,q_bits;
  526|   420k|  int ac_coef = 0;
  527|       |
  528|   420k|  Macroblock *currMB = &img->mb_data[img->current_mb_nr];
  529|       |
  530|   420k|  int   b8, b4;
  531|   420k|  int*  DCLevel = img->cofDC[0][0];
  532|   420k|  int*  DCRun   = img->cofDC[0][1];
  533|   420k|  int*  ACLevel;
  534|   420k|  int*  ACRun;
  535|       |
  536|   420k|  Boolean lossless_qpprime = ((currMB->qp + img->bitdepth_luma_qp_scale)==0 && img->lossless_qpprime_flag==1);
  537|       |
  538|   420k|  qp_per    = (currMB->qp + img->bitdepth_luma_qp_scale - MIN_QP)/6;
  539|   420k|  qp_rem    = (currMB->qp + img->bitdepth_luma_qp_scale - MIN_QP)%6;
  540|   420k|  q_bits    = Q_BITS+qp_per;
  541|       |  //qp_const  = (1<<q_bits)/3;
  542|       |
  543|  7.14M|  for (j=0;j<16;j++)
  544|  6.72M|  {
  545|   114M|    for (i=0;i<16;i++)
  546|   107M|    {
  547|       |      // Residue Color Transform
  548|   107M|      if(!img->residue_transform_flag)
  549|   107M|        M1[i][j]=imgY_org[img->opix_y+j][img->opix_x+i]-img->mprr_2[new_intra_mode][j][i];
  550|      0|      else
  551|      0|        M1[i][j]=img->m7[i][j];
  552|       |
  553|   107M|      M0[i%4][i/4][j%4][j/4]=M1[i][j];
  554|   107M|    }
  555|  6.72M|  }
  556|       |
  557|  2.10M|  for (jj=0;jj<4 && !lossless_qpprime;jj++)
  558|  1.68M|  {
  559|  8.40M|    for (ii=0;ii<4;ii++)
  560|  6.72M|    {
  561|  33.6M|      for (j=0;j<4;j++)
  562|  26.8M|      {
  563|  80.6M|        for (i=0;i<2;i++)
  564|  53.7M|        {
  565|  53.7M|          i1=3-i;
  566|  53.7M|          M5[i]=  M0[i][ii][j][jj]+M0[i1][ii][j][jj];
  567|  53.7M|          M5[i1]= M0[i][ii][j][jj]-M0[i1][ii][j][jj];
  568|  53.7M|        }
  569|  26.8M|        M0[0][ii][j][jj]=M5[0]+M5[1];
  570|  26.8M|        M0[2][ii][j][jj]=M5[0]-M5[1];
  571|  26.8M|        M0[1][ii][j][jj]=M5[3]*2+M5[2];
  572|  26.8M|        M0[3][ii][j][jj]=M5[3]-M5[2]*2;
  573|  26.8M|      }
  574|       |      // vertical
  575|  33.6M|      for (i=0;i<4;i++)
  576|  26.8M|      {
  577|  80.6M|        for (j=0;j<2;j++)
  578|  53.7M|        {
  579|  53.7M|          j1=3-j;
  580|  53.7M|          M5[j] = M0[i][ii][j][jj]+M0[i][ii][j1][jj];
  581|  53.7M|          M5[j1]= M0[i][ii][j][jj]-M0[i][ii][j1][jj];
  582|  53.7M|        }
  583|  26.8M|        M0[i][ii][0][jj]=M5[0]+M5[1];
  584|  26.8M|        M0[i][ii][2][jj]=M5[0]-M5[1];
  585|  26.8M|        M0[i][ii][1][jj]=M5[3]*2+M5[2];
  586|  26.8M|        M0[i][ii][3][jj]=M5[3] -M5[2]*2;
  587|  26.8M|      }
  588|  6.72M|    }
  589|  1.68M|  }
  590|       |
  591|       |  // pick out DC coeff
  592|       |
  593|  2.10M|  for (j=0;j<4;j++)
  594|  8.40M|    for (i=0;i<4;i++)
  595|  6.72M|      M4[i][j]= M0[0][i][0][j];
  596|       |
  597|  2.10M|  for (j=0;j<4 && !lossless_qpprime;j++)
  598|  1.68M|  {
  599|  5.04M|    for (i=0;i<2;i++)
  600|  3.36M|    {
  601|  3.36M|      i1=3-i;
  602|  3.36M|      M5[i]= M4[i][j]+M4[i1][j];
  603|  3.36M|      M5[i1]=M4[i][j]-M4[i1][j];
  604|  3.36M|    }
  605|  1.68M|    M4[0][j]=M5[0]+M5[1];
  606|  1.68M|    M4[2][j]=M5[0]-M5[1];
  607|  1.68M|    M4[1][j]=M5[3]+M5[2];
  608|  1.68M|    M4[3][j]=M5[3]-M5[2];
  609|  1.68M|  }
  610|       |
  611|       |  // vertical
  612|       |
  613|  2.10M|  for (i=0;i<4 && !lossless_qpprime;i++)
  614|  1.68M|  {
  615|  5.04M|    for (j=0;j<2;j++)
  616|  3.36M|    {
  617|  3.36M|      j1=3-j;
  618|  3.36M|      M5[j]= M4[i][j]+M4[i][j1];
  619|  3.36M|      M5[j1]=M4[i][j]-M4[i][j1];
  620|  3.36M|    }
  621|  1.68M|    M4[i][0]=(M5[0]+M5[1])>>1;
  622|  1.68M|    M4[i][2]=(M5[0]-M5[1])>>1;
  623|  1.68M|    M4[i][1]=(M5[3]+M5[2])>>1;
  624|  1.68M|    M4[i][3]=(M5[3]-M5[2])>>1;
  625|  1.68M|  }
  626|       |
  627|       |  // quant
  628|       |
  629|   420k|  run=-1;
  630|   420k|  scan_pos=0;
  631|       |
  632|  7.14M|  for (coeff_ctr=0;coeff_ctr<16;coeff_ctr++)
  633|  6.72M|  {
  634|  6.72M|    if (img->field_picture || ( mb_adaptive && img->field_mode )) 
  635|      0|    {  // Alternate scan for field coding
  636|      0|        i=FIELD_SCAN[coeff_ctr][0];
  637|      0|        j=FIELD_SCAN[coeff_ctr][1];
  638|      0|    }
  639|  6.72M|    else 
  640|  6.72M|    {
  641|  6.72M|        i=SNGL_SCAN[coeff_ctr][0];
  642|  6.72M|        j=SNGL_SCAN[coeff_ctr][1];
  643|  6.72M|    }
  644|       |
  645|  6.72M|    run++;
  646|       |
  647|  6.72M|    if(lossless_qpprime)
  648|      0|      level= abs(M4[i][j]);
  649|  6.72M|    else
  650|  6.72M|        level= (abs(M4[i][j]) * LevelScale4x4Luma_Intra[qp_rem][0][0] + (LevelOffset4x4Luma_Intra[qp_per][0][0]<<1)) >> (q_bits+1);
  651|       |      //level= (abs(M4[i][j]) * LevelScale4x4Luma_Intra[qp_rem][0][0] + (qp_const<<1)) >> (q_bits+1);
  652|       |
  653|  6.72M|    if (input->symbol_mode == UVLC && img->qp < 10) 
  654|      0|    {
  655|      0|      if (level > CAVLC_LEVEL_LIMIT) 
  656|      0|      {
  657|      0|        level = CAVLC_LEVEL_LIMIT;
  658|      0|      }
  659|      0|    }
  660|       |
  661|  6.72M|    if (level != 0)
  662|   855k|    {
  663|   855k|      DCLevel[scan_pos] = sign(level,M4[i][j]);
  664|   855k|      DCRun  [scan_pos] = run;
  665|   855k|      ++scan_pos;
  666|   855k|      run=-1;
  667|   855k|    }
  668|  6.72M|    if(!lossless_qpprime)
  669|  6.72M|      M4[i][j]=sign(level,M4[i][j]);
  670|  6.72M|  }
  671|   420k|  DCLevel[scan_pos]=0;
  672|       |
  673|       |  // invers DC transform
  674|  2.10M|  for (j=0;j<4 && !lossless_qpprime;j++)
  675|  1.68M|  {
  676|  8.40M|    for (i=0;i<4;i++)
  677|  6.72M|      M5[i]=M4[i][j];
  678|       |
  679|  1.68M|    M6[0]=M5[0]+M5[2];
  680|  1.68M|    M6[1]=M5[0]-M5[2];
  681|  1.68M|    M6[2]=M5[1]-M5[3];
  682|  1.68M|    M6[3]=M5[1]+M5[3];
  683|       |
  684|  5.04M|    for (i=0;i<2;i++)
  685|  3.36M|    {
  686|  3.36M|      i1=3-i;
  687|  3.36M|      M4[i][j]= M6[i]+M6[i1];
  688|  3.36M|      M4[i1][j]=M6[i]-M6[i1];
  689|  3.36M|    }
  690|  1.68M|  }
  691|       |
  692|  2.10M|  for (i=0;i<4 && !lossless_qpprime;i++)
  693|  1.68M|  {
  694|  8.40M|    for (j=0;j<4;j++)
  695|  6.72M|      M5[j]=M4[i][j];
  696|       |
  697|  1.68M|    M6[0]=M5[0]+M5[2];
  698|  1.68M|    M6[1]=M5[0]-M5[2];
  699|  1.68M|    M6[2]=M5[1]-M5[3];
  700|  1.68M|    M6[3]=M5[1]+M5[3];
  701|       |
  702|  5.04M|    for (j=0;j<2;j++)
  703|  3.36M|    {
  704|  3.36M|      j1=3-j;
  705|       |
  706|  3.36M|      if(qp_per<6)
  707|  3.36M|      {
  708|  3.36M|        M0[0][i][0][j]  = ((M6[j]+M6[j1])*InvLevelScale4x4Luma_Intra[qp_rem][0][0]+(1<<(5-qp_per)))>>(6-qp_per);
  709|  3.36M|        M0[0][i][0][j1] = ((M6[j]-M6[j1])*InvLevelScale4x4Luma_Intra[qp_rem][0][0]+(1<<(5-qp_per)))>>(6-qp_per);
  710|  3.36M|      }
  711|      0|      else
  712|      0|      {
  713|      0|        M0[0][i][0][j]  = ((M6[j]+M6[j1])*InvLevelScale4x4Luma_Intra[qp_rem][0][0])<<(qp_per-6);
  714|      0|        M0[0][i][0][j1] = ((M6[j]-M6[j1])*InvLevelScale4x4Luma_Intra[qp_rem][0][0])<<(qp_per-6);
  715|      0|      }
  716|  3.36M|    }
  717|  1.68M|  }
  718|       |
  719|       |  // AC inverse trans/quant for MB
  720|  2.10M|  for (jj=0;jj<4;jj++)
  721|  1.68M|  {
  722|  8.40M|    for (ii=0;ii<4;ii++)
  723|  6.72M|    {
  724|  6.72M|      run      = -1;
  725|  6.72M|      scan_pos =  0;
  726|  6.72M|      b8       = 2*(jj/2) + (ii/2);
  727|  6.72M|      b4       = 2*(jj%2) + (ii%2);
  728|  6.72M|      ACLevel  = img->cofAC [b8][b4][0];
  729|  6.72M|      ACRun    = img->cofAC [b8][b4][1];
  730|       |
  731|   107M|      for (coeff_ctr=1;coeff_ctr<16;coeff_ctr++) // set in AC coeff
  732|   100M|      {
  733|       |
  734|   100M|        if (img->field_picture || ( mb_adaptive && img->field_mode )) 
  735|      0|        {  // Alternate scan for field coding
  736|      0|          i=FIELD_SCAN[coeff_ctr][0];
  737|      0|          j=FIELD_SCAN[coeff_ctr][1];
  738|      0|        }
  739|   100M|        else 
  740|   100M|        {
  741|   100M|          i=SNGL_SCAN[coeff_ctr][0];
  742|   100M|          j=SNGL_SCAN[coeff_ctr][1];
  743|   100M|        }
  744|   100M|        run++;
  745|       |
  746|   100M|        if(lossless_qpprime)
  747|      0|          level= abs( M0[i][ii][j][jj]);
  748|   100M|        else          
  749|   100M|          level= ( abs( M0[i][ii][j][jj]) * LevelScale4x4Luma_Intra[qp_rem][i][j] + LevelOffset4x4Luma_Intra[qp_per][i][j]) >> q_bits;
  750|       |        //level= ( abs( M0[i][ii][j][jj]) * LevelScale4x4Luma_Intra[qp_rem][i][j] + qp_const) >> q_bits;
  751|       |
  752|   100M|        if (level != 0)
  753|   780k|        {
  754|   780k|          ac_coef = 15;
  755|   780k|          ACLevel[scan_pos] = sign(level,M0[i][ii][j][jj]);
  756|   780k|          ACRun  [scan_pos] = run;
  757|   780k|          ++scan_pos;
  758|   780k|          run=-1;
  759|   780k|        }
  760|       |        
  761|   100M|        if(!lossless_qpprime)
  762|   100M|        {
  763|   100M|          level=sign(level, M0[i][ii][j][jj]);
  764|   100M|          if(qp_per<4)
  765|      0|            M0[i][ii][j][jj]=(level*InvLevelScale4x4Luma_Intra[qp_rem][i][j]+(1<<(3-qp_per)))>>(4-qp_per);
  766|   100M|          else
  767|   100M|            M0[i][ii][j][jj]=(level*InvLevelScale4x4Luma_Intra[qp_rem][i][j])<<(qp_per-4);
  768|   100M|        }
  769|   100M|      }
  770|  6.72M|      ACLevel[scan_pos] = 0;
  771|       |
  772|       |
  773|       |      // IDCT horizontal
  774|       |
  775|  33.6M|      for (j=0;j<4 && !lossless_qpprime;j++)
  776|  26.8M|      {
  777|   134M|        for (i=0;i<4;i++)
  778|   107M|        {
  779|   107M|          M5[i]=M0[i][ii][j][jj];
  780|   107M|        }
  781|       |
  782|  26.8M|        M6[0]= M5[0]+M5[2];
  783|  26.8M|        M6[1]= M5[0]-M5[2];
  784|  26.8M|        M6[2]=(M5[1]>>1) -M5[3];
  785|  26.8M|        M6[3]= M5[1]+(M5[3]>>1);
  786|       |
  787|  80.6M|        for (i=0;i<2;i++)
  788|  53.7M|        {
  789|  53.7M|          i1=3-i;
  790|  53.7M|          M0[i][ii][j][jj] =M6[i]+M6[i1];
  791|  53.7M|          M0[i1][ii][j][jj]=M6[i]-M6[i1];
  792|  53.7M|        }
  793|  26.8M|      }
  794|       |
  795|       |      // vert
  796|  33.6M|      for (i=0;i<4 && !lossless_qpprime;i++)
  797|  26.8M|      {
  798|   134M|        for (j=0;j<4;j++)
  799|   107M|          M5[j]=M0[i][ii][j][jj];
  800|       |
  801|  26.8M|        M6[0]= M5[0]+M5[2];
  802|  26.8M|        M6[1]= M5[0]-M5[2];
  803|  26.8M|        M6[2]=(M5[1]>>1) -M5[3];
  804|  26.8M|        M6[3]= M5[1]+(M5[3]>>1);
  805|       |
  806|  80.6M|        for (j=0;j<2;j++)
  807|  53.7M|        {
  808|  53.7M|          j1=3-j;
  809|  53.7M|          M0[i][ii][ j][jj]=M6[j]+M6[j1];
  810|  53.7M|          M0[i][ii][j1][jj]=M6[j]-M6[j1];
  811|       |
  812|  53.7M|        }
  813|  26.8M|      }
  814|       |
  815|  6.72M|    }
  816|  1.68M|  }
  817|       |
  818|       |  // Residue Color Transform
  819|   420k|  if(!img->residue_transform_flag)
  820|   420k|  {
  821|  7.14M|    for (j=0;j<16;j++)
  822|  6.72M|    {
  823|   114M|      for (i=0;i<16;i++)
  824|   107M|      {
  825|   107M|        M1[i][j]=M0[i%4][i/4][j%4][j/4];
  826|   107M|      }
  827|  6.72M|    }
  828|   420k|  }
  829|      0|  else
  830|      0|  {
  831|      0|    for (j=0;j<16;j++)
  832|      0|    {
  833|      0|      for (i=0;i<16;i++)
  834|      0|      {
  835|      0|        if(lossless_qpprime)
  836|      0|          img->m7[i][j]=M0[i%4][i/4][j%4][j/4];
  837|      0|        else
  838|      0|          img->m7[i][j]=((M0[i%4][i/4][j%4][j/4]+DQ_ROUND)>>DQ_BITS);
  839|      0|      }
  840|      0|    }
  841|      0|  }
  842|       |
  843|   420k|  if(!img->residue_transform_flag)
  844|   420k|  {
  845|  7.14M|    for (j=0;j<16;j++)
  846|  6.72M|    {
  847|   114M|      for (i=0;i<16;i++)
  848|   107M|      {
  849|   107M|        if(lossless_qpprime)
  850|      0|          enc_picture->imgY[img->pix_y+j][img->pix_x+i]=(imgpel)(M1[i][j]+img->mprr_2[new_intra_mode][j][i]);
  851|   107M|        else
  852|   107M|          enc_picture->imgY[img->pix_y+j][img->pix_x+i]=(imgpel)min(img->max_imgpel_value, max(0,(M1[i][j]+((long)img->mprr_2[new_intra_mode][j][i]<<DQ_BITS)+DQ_ROUND)>>DQ_BITS));
  853|   107M|      }
  854|  6.72M|    }
  855|   420k|  }
  856|   420k|  return ac_coef;
  857|   420k|}
  858|       |
  859|       |
  860|       |/*!
  861|       |************************************************************************
  862|       |* \brief
  863|       |*    The routine performs transform,quantization,inverse transform, adds the diff.
  864|       |*    to the prediction and writes the result to the decoded luma frame. Includes the
  865|       |*    RD constrained quantization also.
  866|       |*
  867|       |* \par Input:
  868|       |*    block_x,block_y: Block position inside a macro block (0,4,8,12).
  869|       |*
  870|       |* \par Output_
  871|       |*    nonzero: 0 if no levels are nonzero.  1 if there are nonzero levels.             \n
  872|       |*    coeff_cost: Counter for nonzero coefficients, used to discard expensive levels.
  873|       |************************************************************************
  874|       |*/
  875|       |int dct_luma(int block_x,int block_y,int *coeff_cost, int intra)
  876|  73.7M|{
  877|  73.7M|  int sign(int a,int b);
  878|       |
  879|  73.7M|  int i,j,i1,j1,ilev,m5[4],m6[4],coeff_ctr;
  880|       |  //int qp_const;
  881|  73.7M|  int level,scan_pos,run;
  882|  73.7M|  int nonzero;
  883|  73.7M|  int qp_per,qp_rem,q_bits;
  884|       |
  885|  73.7M|  int   pos_x   = block_x/BLOCK_SIZE;
  886|  73.7M|  int   pos_y   = block_y/BLOCK_SIZE;
  887|  73.7M|  int   b8      = 2*(pos_y/2) + (pos_x/2);
  888|  73.7M|  int   b4      = 2*(pos_y%2) + (pos_x%2);
  889|  73.7M|  int*  ACLevel = img->cofAC[b8][b4][0];
  890|  73.7M|  int*  ACRun   = img->cofAC[b8][b4][1];
  891|       |
  892|  73.7M|  Macroblock *currMB = &img->mb_data[img->current_mb_nr];
  893|  73.7M|  Boolean lossless_qpprime = ((currMB->qp + img->bitdepth_luma_qp_scale)==0 && img->lossless_qpprime_flag==1);
  894|       |
  895|  73.7M|  qp_per    = (currMB->qp + img->bitdepth_luma_qp_scale - MIN_QP)/6; 
  896|  73.7M|  qp_rem    = (currMB->qp + img->bitdepth_luma_qp_scale - MIN_QP)%6; 
  897|  73.7M|  q_bits    = Q_BITS+qp_per;
  898|       |/*
  899|       |  if (img->type == I_SLICE)
  900|       |    qp_const=(1<<q_bits)/3;    // intra
  901|       |  else
  902|       |    qp_const=(1<<q_bits)/6;    // inter
  903|       |*/
  904|       |//  printf("q_bits %d %d %d %d\n",q_bits,qp_per,qp_const,LevelOffset4x4Luma_Intra[qp_per][0][0]);
  905|       |  //  Horizontal transform
  906|   368M|  for (j=0; j < BLOCK_SIZE && !lossless_qpprime; j++)
  907|   295M|  {
  908|   885M|    for (i=0; i < 2; i++)
  909|   590M|    {
  910|   590M|      i1=3-i;
  911|   590M|      m5[i]=img->m7[i][j]+img->m7[i1][j];
  912|   590M|      m5[i1]=img->m7[i][j]-img->m7[i1][j];
  913|   590M|    }
  914|   295M|    img->m7[0][j]=(m5[0]+m5[1]);
  915|   295M|    img->m7[2][j]=(m5[0]-m5[1]);
  916|   295M|    img->m7[1][j]=m5[3]*2+m5[2];
  917|   295M|    img->m7[3][j]=m5[3]-m5[2]*2;
  918|   295M|  }
  919|       |
  920|       |  //  Vertical transform
  921|   368M|  for (i=0; i < BLOCK_SIZE && !lossless_qpprime; i++)
  922|   295M|  {
  923|   885M|    for (j=0; j < 2; j++)
  924|   590M|    {
  925|   590M|      j1=3-j;
  926|   590M|      m5[j]=img->m7[i][j]+img->m7[i][j1];
  927|   590M|      m5[j1]=img->m7[i][j]-img->m7[i][j1];
  928|   590M|    }
  929|   295M|    img->m7[i][0]=(m5[0]+m5[1]);
  930|   295M|    img->m7[i][2]=(m5[0]-m5[1]);
  931|   295M|    img->m7[i][1]=m5[3]*2+m5[2];
  932|   295M|    img->m7[i][3]=m5[3]-m5[2]*2;
  933|   295M|  }
  934|       |
  935|       |  // Quant
  936|       |
  937|  73.7M|  nonzero=FALSE;
  938|       |
  939|  73.7M|  run=-1;
  940|  73.7M|  scan_pos=0;
  941|       |  
  942|  1.25G|  for (coeff_ctr=0;coeff_ctr < 16;coeff_ctr++)
  943|  1.18G|  {
  944|       |
  945|  1.18G|    if (img->field_picture || ( img->MbaffFrameFlag && currMB->mb_field )) //xxzp 换一下分支顺序？
  946|      0|    {  // Alternate scan for field coding
  947|      0|        i=FIELD_SCAN[coeff_ctr][0];
  948|      0|        j=FIELD_SCAN[coeff_ctr][1];
  949|      0|    }
  950|  1.18G|    else 
  951|  1.18G|    {
  952|  1.18G|        i=SNGL_SCAN[coeff_ctr][0];
  953|  1.18G|        j=SNGL_SCAN[coeff_ctr][1];
  954|  1.18G|    }
  955|       |    
  956|  1.18G|    run++;
  957|  1.18G|    ilev=0;
  958|       |    
  959|  1.18G|    if(lossless_qpprime)
  960|      0|      level = abs (img->m7[i][j]);
  961|  1.18G|    else if(intra == 1)
  962|   961M|      level = (abs (img->m7[i][j]) * LevelScale4x4Luma_Intra[qp_rem][i][j] + LevelOffset4x4Luma_Intra[qp_per][i][j]) >> q_bits;
  963|       |    //level = (abs (img->m7[i][j]) * LevelScale4x4Luma_Intra[qp_rem][i][j] + qp_const) >> q_bits;    
  964|   218M|    else
  965|   218M|      level = (abs (img->m7[i][j]) * LevelScale4x4Luma_Inter[qp_rem][i][j] + LevelOffset4x4Luma_Inter[qp_per][i][j]) >> q_bits;
  966|       |    //level = (abs (img->m7[i][j]) * LevelScale4x4Luma_Inter[qp_rem][i][j] + qp_const) >> q_bits;
  967|       |
  968|  1.18G|    if (level != 0)
  969|  23.8M|    {
  970|  23.8M|      nonzero=TRUE;
  971|  23.8M|      if (level > 1 || lossless_qpprime)
  972|  7.57M|        *coeff_cost += MAX_VALUE;                // set high cost, shall not be discarded
  973|  16.2M|      else
  974|  16.2M|        *coeff_cost += COEFF_COST[input->disthres][run];
  975|  23.8M|      ACLevel[scan_pos] = sign(level,img->m7[i][j]);
  976|  23.8M|      ACRun  [scan_pos] = run;
  977|  23.8M|      ++scan_pos;
  978|  23.8M|      run=-1;                     // reset zero level counter
  979|       |
  980|  23.8M|      level=sign(level, img->m7[i][j]);
  981|  23.8M|      if(lossless_qpprime)
  982|      0|      {
  983|      0|        ilev=level;
  984|      0|      }
  985|  23.8M|      else if(qp_per<4)
  986|      0|      {
  987|      0|        if(intra == 1)
  988|      0|          ilev=(level*InvLevelScale4x4Luma_Intra[qp_rem][i][j]+(1<<(3-qp_per)))>>(4-qp_per);
  989|      0|        else
  990|      0|          ilev=(level*InvLevelScale4x4Luma_Inter[qp_rem][i][j]+(1<<(3-qp_per)))>>(4-qp_per);
  991|      0|      }
  992|  23.8M|      else
  993|  23.8M|      {
  994|  23.8M|        if(intra == 1)
  995|  23.2M|          ilev=(level*InvLevelScale4x4Luma_Intra[qp_rem][i][j])<<(qp_per-4);
  996|   553k|        else
  997|   553k|          ilev=(level*InvLevelScale4x4Luma_Inter[qp_rem][i][j])<<(qp_per-4);
  998|  23.8M|      }
  999|  23.8M|    }
 1000|  1.18G|    if(!lossless_qpprime)
 1001|  1.18G|      img->m7[i][j]=ilev;
 1002|  1.18G|  }
 1003|  73.7M|  ACLevel[scan_pos] = 0;
 1004|       |  
 1005|       |  
 1006|       |  //     IDCT.
 1007|       |  //     horizontal
 1008|   368M|  for (j=0; j < BLOCK_SIZE && !lossless_qpprime; j++)// xxzp loop interchange //初步判断不行
 1009|   295M|  {
 1010|  1.47G|    for (i=0; i < BLOCK_SIZE; i++)
 1011|  1.18G|    {
 1012|  1.18G|      m5[i]=img->m7[i][j];
 1013|  1.18G|    }
 1014|   295M|    m6[0]=(m5[0]+m5[2]);
 1015|   295M|    m6[1]=(m5[0]-m5[2]);
 1016|   295M|    m6[2]=(m5[1]>>1)-m5[3];
 1017|   295M|    m6[3]=m5[1]+(m5[3]>>1);
 1018|       |
 1019|   885M|    for (i=0; i < 2; i++)
 1020|   590M|    {
 1021|   590M|      i1=3-i;
 1022|   590M|      img->m7[i][j]=m6[i]+m6[i1];
 1023|   590M|      img->m7[i1][j]=m6[i]-m6[i1];
 1024|   590M|    }
 1025|   295M|  }
 1026|       |
 1027|       |  //  vertical
 1028|   368M|  for (i=0; i < BLOCK_SIZE && !lossless_qpprime; i++)
 1029|   295M|  {
 1030|  1.47G|    for (j=0; j < BLOCK_SIZE; j++)
 1031|  1.18G|    {
 1032|  1.18G|      m5[j]=img->m7[i][j];
 1033|  1.18G|    }
 1034|   295M|    m6[0]=(m5[0]+m5[2]);
 1035|   295M|    m6[1]=(m5[0]-m5[2]);
 1036|   295M|    m6[2]=(m5[1]>>1)-m5[3];
 1037|   295M|    m6[3]=m5[1]+(m5[3]>>1);
 1038|       |
 1039|   885M|    for (j=0; j < 2; j++)
 1040|   590M|    {
 1041|   590M|      j1=3-j;
 1042|       |      // Residue Color Transform
 1043|   590M|      if (!img->residue_transform_flag)
 1044|   590M|      {
 1045|   590M|        img->m7[i][j] =min(img->max_imgpel_value,max(0,(m6[j]+m6[j1]+((long)img->mpr[i+block_x][j+block_y] <<DQ_BITS)+DQ_ROUND)>>DQ_BITS));
 1046|   590M|        img->m7[i][j1]=min(img->max_imgpel_value,max(0,(m6[j]-m6[j1]+((long)img->mpr[i+block_x][j1+block_y]<<DQ_BITS)+DQ_ROUND)>>DQ_BITS));
 1047|   590M|      } 
 1048|      0|      else 
 1049|      0|      {
 1050|      0|        if(lossless_qpprime)
 1051|      0|        {
 1052|      0|          img->m7[i][j] =m6[j]+m6[j1];
 1053|      0|          img->m7[i][j1]=m6[j]-m6[j1];
 1054|      0|        }
 1055|      0|        else
 1056|      0|        {
 1057|      0|          img->m7[i][j] =(m6[j]+m6[j1]+DQ_ROUND)>>DQ_BITS;
 1058|      0|          img->m7[i][j1]=(m6[j]-m6[j1]+DQ_ROUND)>>DQ_BITS;
 1059|      0|        }
 1060|      0|      }
 1061|   590M|    }
 1062|   295M|  }
 1063|       |  
 1064|       |  //  Decoded block moved to frame memory
 1065|  73.7M|  if (!img->residue_transform_flag)
 1066|  73.7M|  {
 1067|   368M|    for (j=0; j < BLOCK_SIZE; j++)//xxzp if换一下顺序
 1068|   295M|    {
 1069|  1.47G|      for (i=0; i < BLOCK_SIZE; i++)
 1070|  1.18G|      {
 1071|  1.18G|        if(lossless_qpprime)
 1072|      0|          enc_picture->imgY[img->pix_y+block_y+j][img->pix_x+block_x+i]=img->m7[i][j]+img->mpr[i+block_x][j+block_y];
 1073|  1.18G|        else
 1074|  1.18G|          enc_picture->imgY[img->pix_y+block_y+j][img->pix_x+block_x+i]=img->m7[i][j];
 1075|  1.18G|      }
 1076|   295M|    }
 1077|  73.7M|  }
 1078|  73.7M|  return nonzero;
 1079|  73.7M|}
 1080|       |
 1081|       |
 1082|       |/*!
 1083|       | ************************************************************************
 1084|       | * \brief
 1085|       | *    Transform,quantization,inverse transform for chroma.
 1086|       | *    The main reason why this is done in a separate routine is the
 1087|       | *    additional 2x2 transform of DC-coeffs. This routine is called
 1088|       | *    ones for each of the chroma components.
 1089|       | *
 1090|       | * \par Input:
 1091|       | *    uv    : Make difference between the U and V chroma component  \n
 1092|       | *    cr_cbp: chroma coded block pattern
 1093|       | *
 1094|       | * \par Output:
 1095|       | *    cr_cbp: Updated chroma coded block pattern.
 1096|       | ************************************************************************
 1097|       | */
 1098|       |int dct_chroma(int uv,int cr_cbp)
 1099|  2.73M|{
 1100|  2.73M|  int i,j,i1,j2,ilev,n2,n1,j1,mb_y,coeff_ctr,level ,scan_pos,run;
 1101|  2.73M|  int m1[BLOCK_SIZE],m5[BLOCK_SIZE],m6[BLOCK_SIZE];
 1102|  2.73M|  int coeff_cost;
 1103|  2.73M|  int cr_cbp_tmp;
 1104|  2.73M|  int DCcoded=0 ;
 1105|  2.73M|  Macroblock *currMB = &img->mb_data[img->current_mb_nr];
 1106|       | 
 1107|  2.73M|  int qp_per,qp_rem,q_bits;
 1108|  2.73M|  int qp_c;
 1109|       |
 1110|  2.73M|  int   b4;
 1111|  2.73M|  int*  DCLevel = img->cofDC[uv+1][0];
 1112|  2.73M|  int*  DCRun   = img->cofDC[uv+1][1];
 1113|  2.73M|  int*  ACLevel;
 1114|  2.73M|  int*  ACRun;
 1115|  2.73M|  int   intra = IS_INTRA (currMB);
 1116|  2.73M|  int   uv_scale = uv*(img->num_blk8x8_uv/2);
 1117|       |
 1118|       |  //FRExt
 1119|  2.73M|  int64 cbpblk_pattern[4]={0, 0xf0000, 0xff0000, 0xffff0000};
 1120|  2.73M|  int yuv = img->yuv_format;
 1121|  2.73M|  int b8;
 1122|  2.73M|  int m3[4][4];
 1123|  2.73M|  int m4[4][4];
 1124|  2.73M|  int qp_per_dc = 0;
 1125|  2.73M|  int qp_rem_dc = 0;
 1126|  2.73M|  int q_bits_422 = 0;	
 1127|  2.73M|  Boolean lossless_qpprime = ((currMB->qp + img->bitdepth_luma_qp_scale)==0 && img->lossless_qpprime_flag==1);
 1128|       |
 1129|  2.73M|  qp_c      = currMB->qp + img->chroma_qp_offset[uv];
 1130|  2.73M|  qp_c      = Clip3(-img->bitdepth_chroma_qp_scale,51,qp_c);
 1131|  2.73M|  qp_c      = (qp_c < 0)? qp_c : QP_SCALE_CR[qp_c - MIN_QP];
 1132|       |
 1133|  2.73M|  qp_per    = (qp_c + img->bitdepth_chroma_qp_scale)/6;              
 1134|  2.73M|  qp_rem    = (qp_c + img->bitdepth_chroma_qp_scale)%6;              
 1135|  2.73M|  q_bits    = Q_BITS+qp_per;
 1136|       |
 1137|  2.73M|  if (img->yuv_format == YUV422)
 1138|      0|  {
 1139|       |    //for YUV422 only
 1140|      0|    qp_per_dc = (qp_c + 3 + img->bitdepth_chroma_qp_scale)/6;
 1141|      0|    qp_rem_dc = (qp_c + 3 + img->bitdepth_chroma_qp_scale)%6;
 1142|       |    
 1143|      0|    q_bits_422 = Q_BITS+qp_per_dc;
 1144|       |  
 1145|      0|  }
 1146|       |
 1147|       |  
 1148|       |  //============= dct transform ===============	
 1149|  8.20M|  for (n2=0; n2 < img->mb_cr_size_y; n2 += BLOCK_SIZE)
 1150|  5.46M|  {
 1151|  16.4M|    for (n1=0; n1 < img->mb_cr_size_x; n1 += BLOCK_SIZE)
 1152|  10.9M|    {
 1153|       |
 1154|       |      //  Horizontal transform.
 1155|  54.6M|      for (j=0; j < BLOCK_SIZE && !lossless_qpprime; j++)
 1156|  43.7M|      {
 1157|  43.7M|        mb_y=n2+j;
 1158|   131M|        for (i=0; i < 2; i++)
 1159|  87.4M|        {
 1160|  87.4M|          i1=3-i;
 1161|  87.4M|          m5[i]=img->m7[i+n1][mb_y]+img->m7[i1+n1][mb_y];
 1162|  87.4M|          m5[i1]=img->m7[i+n1][mb_y]-img->m7[i1+n1][mb_y];
 1163|  87.4M|        }
 1164|  43.7M|        img->m7[n1][mb_y]  =(m5[0]+m5[1]);
 1165|  43.7M|        img->m7[n1+2][mb_y]=(m5[0]-m5[1]);
 1166|  43.7M|        img->m7[n1+1][mb_y]=m5[3]*2+m5[2];
 1167|  43.7M|        img->m7[n1+3][mb_y]=m5[3]-m5[2]*2;
 1168|  43.7M|      }
 1169|       |
 1170|       |      //  Vertical transform.
 1171|       |
 1172|  54.6M|      for (i=0; i < BLOCK_SIZE && !lossless_qpprime; i++)
 1173|  43.7M|      {
 1174|  43.7M|        j1=n1+i;
 1175|   131M|        for (j=0; j < 2; j++)
 1176|  87.4M|        {
 1177|  87.4M|          j2=3-j;
 1178|  87.4M|          m5[j]=img->m7[j1][n2+j]+img->m7[j1][n2+j2];
 1179|  87.4M|          m5[j2]=img->m7[j1][n2+j]-img->m7[j1][n2+j2];
 1180|  87.4M|        }
 1181|  43.7M|        img->m7[j1][n2+0]=(m5[0]+m5[1]);
 1182|  43.7M|        img->m7[j1][n2+2]=(m5[0]-m5[1]);
 1183|  43.7M|        img->m7[j1][n2+1]=m5[3]*2+m5[2];
 1184|  43.7M|        img->m7[j1][n2+3]=m5[3]-m5[2]*2;
 1185|  43.7M|      }
 1186|  10.9M|    }
 1187|  5.46M|  }
 1188|       |
 1189|  2.73M|  if (yuv == YUV420)
 1190|  2.73M|  {
 1191|       |    //================== CHROMA DC YUV420 ===================
 1192|       |    //     2X2 transform of DC coeffs.
 1193|  2.73M|    m1[0]=(img->m7[0][0]+img->m7[4][0]+img->m7[0][4]+img->m7[4][4]);
 1194|  2.73M|    m1[1]=(img->m7[0][0]-img->m7[4][0]+img->m7[0][4]-img->m7[4][4]);
 1195|  2.73M|    m1[2]=(img->m7[0][0]+img->m7[4][0]-img->m7[0][4]-img->m7[4][4]);
 1196|  2.73M|    m1[3]=(img->m7[0][0]-img->m7[4][0]-img->m7[0][4]+img->m7[4][4]);
 1197|       |    
 1198|       |    //     Quant of chroma 2X2 coeffs.
 1199|  2.73M|    run=-1;
 1200|  2.73M|    scan_pos=0;
 1201|       |    
 1202|  13.6M|    for (coeff_ctr=0; coeff_ctr < 4; coeff_ctr++)
 1203|  10.9M|    {
 1204|  10.9M|      run++;
 1205|  10.9M|      ilev=0;
 1206|       |      
 1207|  10.9M|      if(intra == 1)
 1208|  6.72M|        level =(abs(m1[coeff_ctr]) * LevelScale4x4Chroma_Intra[uv][qp_rem][0][0] + (LevelOffset4x4Chroma_Intra[uv][qp_per][0][0]<<1)) >> (q_bits+1);
 1209|  4.21M|      else
 1210|  4.21M|        level =(abs(m1[coeff_ctr]) * LevelScale4x4Chroma_Inter[uv][qp_rem][0][0] + (LevelOffset4x4Chroma_Inter[uv][qp_per][0][0]<<1)) >> (q_bits+1);
 1211|       |      
 1212|  10.9M|      if (input->symbol_mode == UVLC && img->qp < 4) 
 1213|      0|      {
 1214|      0|        if (level > CAVLC_LEVEL_LIMIT) 
 1215|      0|        {
 1216|      0|          level = CAVLC_LEVEL_LIMIT;
 1217|      0|        }
 1218|      0|      }
 1219|       |      
 1220|  10.9M|      if (level  != 0)
 1221|  1.14M|      {
 1222|  1.14M|        currMB->cbp_blk |= 0xf0000 << (uv << 2) ;    // if one of the 2x2-DC levels is != 0 set the
 1223|  1.14M|        cr_cbp=max(1,cr_cbp);                     // coded-bit all 4 4x4 blocks (bit 16-19 or 20-23)
 1224|  1.14M|        DCcoded = 1 ;
 1225|  1.14M|        DCLevel[scan_pos] = sign(level ,m1[coeff_ctr]);
 1226|  1.14M|        DCRun  [scan_pos] = run;
 1227|  1.14M|        scan_pos++;
 1228|  1.14M|        run=-1;
 1229|       |        
 1230|  1.14M|        ilev=sign(level, m1[coeff_ctr]);
 1231|  1.14M|      }
 1232|  10.9M|      m1[coeff_ctr]=ilev;
 1233|  10.9M|    }
 1234|  2.73M|    DCLevel[scan_pos] = 0;
 1235|       |    
 1236|       |    //  Inverse transform of 2x2 DC levels
 1237|  2.73M|    m5[0]=(m1[0]+m1[1]+m1[2]+m1[3]);
 1238|  2.73M|    m5[1]=(m1[0]-m1[1]+m1[2]-m1[3]);
 1239|  2.73M|    m5[2]=(m1[0]+m1[1]-m1[2]-m1[3]);
 1240|  2.73M|    m5[3]=(m1[0]-m1[1]-m1[2]+m1[3]);
 1241|  13.6M|    for(i=0; i<4; i++)
 1242|  10.9M|    {
 1243|  10.9M|      if(qp_per<5)
 1244|  10.9M|      {
 1245|  10.9M|        if(intra == 1)
 1246|  6.72M|          m1[i]=(m5[i]*InvLevelScale4x4Chroma_Intra[uv][qp_rem][0][0])>>(5-qp_per);
 1247|  4.21M|        else
 1248|  4.21M|          m1[i]=(m5[i]*InvLevelScale4x4Chroma_Inter[uv][qp_rem][0][0])>>(5-qp_per);
 1249|  10.9M|      }
 1250|      0|      else
 1251|      0|      {
 1252|      0|        if(intra == 1)
 1253|      0|          m1[i]=(m5[i]*InvLevelScale4x4Chroma_Intra[uv][qp_rem][0][0])<<(qp_per-5);
 1254|      0|        else
 1255|      0|          m1[i]=(m5[i]*InvLevelScale4x4Chroma_Inter[uv][qp_rem][0][0])<<(qp_per-5);
 1256|      0|      }
 1257|  10.9M|    }
 1258|  2.73M|    img->m7[0][0]=m1[0];
 1259|  2.73M|    img->m7[4][0]=m1[1];
 1260|  2.73M|    img->m7[0][4]=m1[2];
 1261|  2.73M|    img->m7[4][4]=m1[3];
 1262|  2.73M|  }
 1263|      0|  else if(yuv == YUV422)
 1264|      0|  {
 1265|       |    //================== CHROMA DC YUV422 ===================
 1266|       |    //transform DC coeff
 1267|       |    //horizontal
 1268|       |
 1269|       |    //pick out DC coeff
 1270|      0|    for (j=0; j < img->mb_cr_size_y; j+=BLOCK_SIZE)
 1271|      0|      for (i=0; i < img->mb_cr_size_x; i+=BLOCK_SIZE)
 1272|      0|        m3[i>>2][j>>2]= img->m7[i][j];
 1273|       |      
 1274|       |    //horizontal
 1275|      0|    m4[0][0] = m3[0][0] + m3[1][0];
 1276|      0|    m4[0][1] = m3[0][1] + m3[1][1];
 1277|      0|    m4[0][2] = m3[0][2] + m3[1][2];
 1278|      0|    m4[0][3] = m3[0][3] + m3[1][3];
 1279|       |    
 1280|      0|    m4[1][0] = m3[0][0] - m3[1][0];
 1281|      0|    m4[1][1] = m3[0][1] - m3[1][1];
 1282|      0|    m4[1][2] = m3[0][2] - m3[1][2];
 1283|      0|    m4[1][3] = m3[0][3] - m3[1][3];
 1284|       |
 1285|       |    // vertical
 1286|      0|    for (i=0;i<2;i++)
 1287|      0|    {
 1288|      0|      for (j=0;j<2;j++)
 1289|      0|      {
 1290|      0|        j1=3-j;
 1291|      0|        m5[j]= m4[i][j]+m4[i][j1];
 1292|      0|        m5[j1]=m4[i][j]-m4[i][j1];
 1293|      0|      }
 1294|      0|      m4[i][0]=(m5[0]+m5[1]);
 1295|      0|      m4[i][2]=(m5[0]-m5[1]);
 1296|      0|      m4[i][1]=(m5[3]+m5[2]);
 1297|      0|      m4[i][3]=(m5[3]-m5[2]);
 1298|      0|    }
 1299|       |
 1300|      0|    run=-1;
 1301|      0|    scan_pos=0;
 1302|       |
 1303|       |    //quant of chroma DC-coeffs
 1304|      0|    for (coeff_ctr=0;coeff_ctr<8;coeff_ctr++)
 1305|      0|    {
 1306|      0|      i=SCAN_YUV422[coeff_ctr][0];
 1307|      0|      j=SCAN_YUV422[coeff_ctr][1];
 1308|       |      
 1309|      0|      run++;
 1310|       |
 1311|      0|      if(intra == 1)
 1312|      0|        level =(abs(m4[i][j]) * LevelScale4x4Chroma_Intra[uv][qp_rem_dc][0][0] + (LevelOffset4x4Chroma_Intra[uv][qp_per_dc][0][0]*2)) >> (q_bits_422+1);
 1313|      0|      else
 1314|      0|        level =(abs(m4[i][j]) * LevelScale4x4Chroma_Inter[uv][qp_rem_dc][0][0] + (LevelOffset4x4Chroma_Inter[uv][qp_per_dc][0][0]*2)) >> (q_bits_422+1);
 1315|       |
 1316|      0|      if (level != 0)
 1317|      0|      {
 1318|       |        //YUV422
 1319|      0|        currMB->cbp_blk |= 0xff0000 << (uv << 3) ;   // if one of the DC levels is != 0 set the
 1320|      0|        cr_cbp=max(1,cr_cbp);												   // coded-bit all 4 4x4 blocks (bit 16-31 or 32-47) //YUV444
 1321|      0|        DCcoded = 1 ;
 1322|       |        
 1323|      0|        DCLevel[scan_pos] = sign(level,m4[i][j]);
 1324|      0|        DCRun  [scan_pos] = run;
 1325|      0|        ++scan_pos;
 1326|      0|        run=-1;
 1327|      0|      }
 1328|      0|      m3[i][j]=sign(level,m4[i][j]);
 1329|      0|    }
 1330|      0|    DCLevel[scan_pos]=0;
 1331|       |
 1332|       |    //inverse DC transform
 1333|       |    //horizontal
 1334|      0|    m4[0][0] = m3[0][0] + m3[1][0];
 1335|      0|    m4[0][1] = m3[0][1] + m3[1][1];
 1336|      0|    m4[0][2] = m3[0][2] + m3[1][2];
 1337|      0|    m4[0][3] = m3[0][3] + m3[1][3];
 1338|       |    
 1339|      0|    m4[1][0] = m3[0][0] - m3[1][0];
 1340|      0|    m4[1][1] = m3[0][1] - m3[1][1];
 1341|      0|    m4[1][2] = m3[0][2] - m3[1][2];
 1342|      0|    m4[1][3] = m3[0][3] - m3[1][3];
 1343|       |    
 1344|       |    
 1345|       |    // vertical
 1346|      0|    for (i=0;i<2;i++)
 1347|      0|    {
 1348|      0|      for (j=0; j < 4;j++)    //TODO: remove m5 with m4
 1349|      0|        m5[j]=m4[i][j]; 
 1350|       |      
 1351|      0|      m6[0]=m5[0]+m5[2];
 1352|      0|      m6[1]=m5[0]-m5[2];
 1353|      0|      m6[2]=m5[1]-m5[3];
 1354|      0|      m6[3]=m5[1]+m5[3];
 1355|       |      
 1356|      0|      for (j=0;j<2;j++)
 1357|      0|      {
 1358|      0|        j1=3-j;
 1359|       |		
 1360|      0|        if(qp_per_dc<4)
 1361|      0|        {
 1362|      0|          if(intra == 1)
 1363|      0|          {
 1364|      0|            img->m7[i*4][j*4 ]=((((m6[j]+m6[j1])*InvLevelScale4x4Chroma_Intra[uv][qp_rem_dc][0][0]+(1<<(3-qp_per_dc)))>>(4-qp_per_dc))+2)>>2;
 1365|      0|            img->m7[i*4][j1*4]=((((m6[j]-m6[j1])*InvLevelScale4x4Chroma_Intra[uv][qp_rem_dc][0][0]+(1<<(3-qp_per_dc)))>>(4-qp_per_dc))+2)>>2;
 1366|      0|          }
 1367|      0|          else
 1368|      0|          {
 1369|      0|            img->m7[i*4][j*4 ]=((((m6[j]+m6[j1])*InvLevelScale4x4Chroma_Inter[uv][qp_rem_dc][0][0]+(1<<(3-qp_per_dc)))>>(4-qp_per_dc))+2)>>2;
 1370|      0|            img->m7[i*4][j1*4]=((((m6[j]-m6[j1])*InvLevelScale4x4Chroma_Inter[uv][qp_rem_dc][0][0]+(1<<(3-qp_per_dc)))>>(4-qp_per_dc))+2)>>2;
 1371|      0|          }
 1372|      0|        }
 1373|      0|        else
 1374|      0|        {
 1375|      0|          if(intra == 1)
 1376|      0|          {
 1377|      0|            img->m7[i*4][j*4 ]=((((m6[j]+m6[j1])*InvLevelScale4x4Chroma_Intra[uv][qp_rem_dc][0][0])<<(qp_per_dc-4))+2)>>2;
 1378|      0|            img->m7[i*4][j1*4]=((((m6[j]-m6[j1])*InvLevelScale4x4Chroma_Intra[uv][qp_rem_dc][0][0])<<(qp_per_dc-4))+2)>>2;
 1379|      0|          }
 1380|      0|          else
 1381|      0|          {
 1382|      0|            img->m7[i*4][j*4 ]=((((m6[j]+m6[j1])*InvLevelScale4x4Chroma_Inter[uv][qp_rem_dc][0][0])<<(qp_per_dc-4))+2)>>2;
 1383|      0|            img->m7[i*4][j1*4]=((((m6[j]-m6[j1])*InvLevelScale4x4Chroma_Inter[uv][qp_rem_dc][0][0])<<(qp_per_dc-4))+2)>>2;
 1384|      0|          }
 1385|      0|        }
 1386|      0|      }//for (j=0;j<2;j++)
 1387|      0|    }//for (i=0;i<2;i++)    
 1388|      0|  }
 1389|      0|  else if(yuv == YUV444)
 1390|      0|  {
 1391|       |    //================== CHROMA DC YUV444 ===================
 1392|       |    //transform DC coeff
 1393|       |    //pick out DC coeff
 1394|      0|    for (j=0; j < img->mb_cr_size_y; j+=BLOCK_SIZE)
 1395|      0|      for (i=0; i < img->mb_cr_size_x; i+=BLOCK_SIZE)
 1396|      0|        m4[i>>2][j>>2]= img->m7[i][j];
 1397|       |      
 1398|       |    //horizontal
 1399|      0|    for (j=0;j<4 && !lossless_qpprime;j++)
 1400|      0|    {
 1401|      0|      for (i=0;i<2;i++)
 1402|      0|      {
 1403|      0|        i1=3-i;
 1404|      0|        m5[i] = m4[i][j]+m4[i1][j];
 1405|      0|        m5[i1]= m4[i][j]-m4[i1][j];
 1406|      0|      }
 1407|      0|      m4[0][j]=m5[0]+m5[1];
 1408|      0|      m4[2][j]=m5[0]-m5[1];
 1409|      0|      m4[1][j]=m5[3]+m5[2];
 1410|      0|      m4[3][j]=m5[3]-m5[2];
 1411|      0|    }
 1412|       |    // vertical
 1413|      0|    for (i=0;i<4 && !lossless_qpprime;i++)
 1414|      0|    {
 1415|      0|      for (j=0;j<2;j++)
 1416|      0|      {
 1417|      0|        j1=3-j;
 1418|      0|        m5[j]= m4[i][j]+m4[i][j1];
 1419|      0|        m5[j1]=m4[i][j]-m4[i][j1];
 1420|      0|      }
 1421|      0|      m4[i][0]=(m5[0]+m5[1])>>1;
 1422|      0|      m4[i][2]=(m5[0]-m5[1])>>1;
 1423|      0|      m4[i][1]=(m5[3]+m5[2])>>1;
 1424|      0|      m4[i][3]=(m5[3]-m5[2])>>1;
 1425|      0|    }
 1426|       |
 1427|      0|    run=-1;
 1428|      0|    scan_pos=0;
 1429|       |    
 1430|       |    //quant of chroma DC-coeffs
 1431|      0|    for (coeff_ctr=0;coeff_ctr<16;coeff_ctr++)
 1432|      0|    {
 1433|      0|      i=SNGL_SCAN[coeff_ctr][0];
 1434|      0|      j=SNGL_SCAN[coeff_ctr][1];
 1435|       |      
 1436|      0|      run++;
 1437|       |      
 1438|      0|      if(lossless_qpprime)
 1439|      0|        level = abs(m4[i][j]);
 1440|      0|      else if(intra == 1)        
 1441|      0|        level =(abs(m4[i][j]) * LevelScale4x4Chroma_Intra[uv][qp_rem][0][0] + (LevelOffset4x4Chroma_Intra[uv][qp_per][0][0]*2)) >> (q_bits+1);
 1442|      0|      else
 1443|      0|        level =(abs(m4[i][j]) * LevelScale4x4Chroma_Inter[uv][qp_rem][0][0] + (LevelOffset4x4Chroma_Inter[uv][qp_per][0][0]*2)) >> (q_bits+1);
 1444|       |      
 1445|      0|      if (level != 0)
 1446|      0|      {
 1447|       |        //YUV444
 1448|      0|        currMB->cbp_blk |= ((int64)0xffff0000) << (uv << 4) ;   // if one of the DC levels is != 0 set the
 1449|      0|        cr_cbp=max(1,cr_cbp);												   // coded-bit all 4 4x4 blocks (bit 16-31 or 32-47) //YUV444
 1450|      0|        DCcoded = 1 ;
 1451|       |        
 1452|      0|        DCLevel[scan_pos] = sign(level,m4[i][j]);
 1453|      0|        DCRun  [scan_pos] = run;
 1454|      0|        ++scan_pos;
 1455|      0|        run=-1;
 1456|      0|      }
 1457|      0|      if(!lossless_qpprime)
 1458|      0|        m4[i][j]=sign(level,m4[i][j]);
 1459|      0|    }
 1460|      0|    DCLevel[scan_pos]=0;
 1461|       |
 1462|       |    // inverse DC transform
 1463|       |    //horizontal
 1464|      0|    for (j=0;j<4 && !lossless_qpprime;j++)
 1465|      0|    {
 1466|      0|      for (i=0;i<4;i++)
 1467|      0|        m5[i]=m4[i][j];
 1468|       |      
 1469|      0|      m6[0]=m5[0]+m5[2];
 1470|      0|      m6[1]=m5[0]-m5[2];
 1471|      0|      m6[2]=m5[1]-m5[3];
 1472|      0|      m6[3]=m5[1]+m5[3];
 1473|       |      
 1474|      0|      for (i=0;i<2;i++)
 1475|      0|      {
 1476|      0|        i1=3-i;
 1477|      0|        m4[i][j]= m6[i]+m6[i1];
 1478|      0|        m4[i1][j]=m6[i]-m6[i1];
 1479|      0|      }
 1480|      0|    }
 1481|       |    
 1482|       |    //vertical
 1483|      0|    for (i=0;i<4 && !lossless_qpprime;i++)
 1484|      0|    {
 1485|      0|      for (j=0;j<4;j++)
 1486|      0|        m5[j]=m4[i][j];
 1487|       |      
 1488|      0|      m6[0]=m5[0]+m5[2];
 1489|      0|      m6[1]=m5[0]-m5[2];
 1490|      0|      m6[2]=m5[1]-m5[3];
 1491|      0|      m6[3]=m5[1]+m5[3];
 1492|       |      
 1493|      0|      for (j=0;j<2;j++)
 1494|      0|      {
 1495|      0|        j1=3-j;
 1496|      0|        if(qp_per<4)
 1497|      0|        {
 1498|      0|          if(intra == 1)
 1499|      0|          {
 1500|      0|            img->m7[i*4][j*4] =((((m6[j]+m6[j1])*InvLevelScale4x4Chroma_Intra[uv][qp_rem][0][0]+(1<<(3-qp_per)))>>(4-qp_per))+2)>>2;
 1501|      0|            img->m7[i*4][j1*4]=((((m6[j]-m6[j1])*InvLevelScale4x4Chroma_Intra[uv][qp_rem][0][0]+(1<<(3-qp_per)))>>(4-qp_per))+2)>>2;
 1502|      0|          }
 1503|      0|          else
 1504|      0|          {
 1505|      0|            img->m7[i*4][j*4] =((((m6[j]+m6[j1])*InvLevelScale4x4Chroma_Inter[uv][qp_rem][0][0]+(1<<(3-qp_per)))>>(4-qp_per))+2)>>2;
 1506|      0|            img->m7[i*4][j1*4]=((((m6[j]-m6[j1])*InvLevelScale4x4Chroma_Inter[uv][qp_rem][0][0]+(1<<(3-qp_per)))>>(4-qp_per))+2)>>2;
 1507|      0|          }
 1508|      0|        }
 1509|      0|        else
 1510|      0|        {
 1511|      0|          if(intra == 1)
 1512|      0|          {
 1513|      0|            img->m7[i*4][j*4] =((((m6[j]+m6[j1])*InvLevelScale4x4Chroma_Intra[uv][qp_rem][0][0])<<(qp_per-4))+2)>>2;
 1514|      0|            img->m7[i*4][j1*4]=((((m6[j]-m6[j1])*InvLevelScale4x4Chroma_Intra[uv][qp_rem][0][0])<<(qp_per-4))+2)>>2;
 1515|      0|          }
 1516|      0|          else
 1517|      0|          {
 1518|      0|            img->m7[i*4][j*4] =((((m6[j]+m6[j1])*InvLevelScale4x4Chroma_Inter[uv][qp_rem][0][0])<<(qp_per-4))+2)>>2;
 1519|      0|            img->m7[i*4][j1*4]=((((m6[j]-m6[j1])*InvLevelScale4x4Chroma_Inter[uv][qp_rem][0][0])<<(qp_per-4))+2)>>2;
 1520|      0|          }
 1521|      0|        }
 1522|      0|      } 
 1523|      0|    }
 1524|      0|  }
 1525|       |
 1526|       |  //     Quant of chroma AC-coeffs.
 1527|  2.73M|  coeff_cost=0;
 1528|  2.73M|  cr_cbp_tmp=0;
 1529|       |
 1530|  5.46M|  for (b8=0; b8 < (img->num_blk8x8_uv/2); b8++)
 1531|  2.73M|  {
 1532|  13.6M|    for (b4=0; b4 < 4; b4++)
 1533|  10.9M|    {
 1534|  10.9M|      n1 = hor_offset[yuv][b8][b4];
 1535|  10.9M|      n2 = ver_offset[yuv][b8][b4];
 1536|  10.9M|      ACLevel = img->cofAC[4+b8+uv_scale][b4][0];
 1537|  10.9M|      ACRun   = img->cofAC[4+b8+uv_scale][b4][1];
 1538|  10.9M|      run=-1;
 1539|  10.9M|      scan_pos=0;
 1540|       |
 1541|   174M|      for (coeff_ctr=1; coeff_ctr < 16; coeff_ctr++)// start change rd_quant
 1542|   164M|      {
 1543|       |
 1544|   164M|        if (img->field_picture || ( img->MbaffFrameFlag && currMB->mb_field )) 
 1545|      0|        {  // Alternate scan for field coding
 1546|      0|          i=FIELD_SCAN[coeff_ctr][0];
 1547|      0|          j=FIELD_SCAN[coeff_ctr][1];
 1548|      0|        }
 1549|   164M|        else 
 1550|   164M|        {
 1551|   164M|          i=SNGL_SCAN[coeff_ctr][0];
 1552|   164M|          j=SNGL_SCAN[coeff_ctr][1];
 1553|   164M|        }
 1554|   164M|        ++run;
 1555|   164M|        ilev=0;
 1556|       |
 1557|   164M|        if(lossless_qpprime)
 1558|      0|          level = abs(img->m7[n1+i][n2+j]);
 1559|   164M|        else if(intra == 1)          
 1560|   100M|          level=(abs(img->m7[n1+i][n2+j])*LevelScale4x4Chroma_Intra[uv][qp_rem][i][j]+LevelOffset4x4Chroma_Intra[uv][qp_per][i][j])>>q_bits;
 1561|  63.2M|        else
 1562|  63.2M|          level=(abs(img->m7[n1+i][n2+j])*LevelScale4x4Chroma_Inter[uv][qp_rem][i][j]+LevelOffset4x4Chroma_Inter[uv][qp_per][i][j])>>q_bits;
 1563|       |
 1564|   164M|        if (level  != 0)
 1565|  1.24M|        {
 1566|  1.24M|          currMB->cbp_blk |= ((int64)1) << cbp_blk_chroma[b8 + uv_scale][b4];
 1567|  1.24M|          if (level > 1 || lossless_qpprime)
 1568|   335k|            coeff_cost += MAX_VALUE;                // set high cost, shall not be discarded
 1569|   906k|          else
 1570|   906k|            coeff_cost += COEFF_COST[input->disthres][run];
 1571|       |
 1572|  1.24M|          cr_cbp_tmp=2;
 1573|  1.24M|          ACLevel[scan_pos] = sign(level,img->m7[n1+i][n2+j]);
 1574|  1.24M|          ACRun  [scan_pos] = run;
 1575|  1.24M|          ++scan_pos;
 1576|  1.24M|          run=-1;
 1577|       |
 1578|  1.24M|          level=sign(level, img->m7[n1+i][n2+j]);
 1579|  1.24M|          if(lossless_qpprime)
 1580|      0|          {
 1581|      0|            ilev = level;
 1582|      0|          }
 1583|  1.24M|          else if(qp_per<4)
 1584|      0|          {
 1585|      0|            if(intra == 1)
 1586|      0|              ilev=(level*InvLevelScale4x4Chroma_Intra[uv][qp_rem][i][j]+(1<<(3-qp_per)))>>(4-qp_per);
 1587|      0|            else
 1588|      0|              ilev=(level*InvLevelScale4x4Chroma_Inter[uv][qp_rem][i][j]+(1<<(3-qp_per)))>>(4-qp_per);
 1589|      0|          }
 1590|  1.24M|          else
 1591|  1.24M|          {
 1592|  1.24M|            if(intra == 1)
 1593|  1.15M|              ilev=(level*InvLevelScale4x4Chroma_Intra[uv][qp_rem][i][j])<<(qp_per-4);
 1594|  85.6k|            else
 1595|  85.6k|              ilev=(level*InvLevelScale4x4Chroma_Inter[uv][qp_rem][i][j])<<(qp_per-4);
 1596|  1.24M|          }
 1597|  1.24M|        }
 1598|   164M|        if(!lossless_qpprime)
 1599|   164M|          img->m7[n1+i][n2+j]=ilev;
 1600|   164M|      }
 1601|  10.9M|      ACLevel[scan_pos] = 0;
 1602|  10.9M|    }
 1603|  2.73M|  }
 1604|       |
 1605|       |  // * reset chroma coeffs
 1606|  2.73M|  if(coeff_cost < _CHROMA_COEFF_COST_ && !lossless_qpprime)
 1607|  2.48M|  {
 1608|  2.48M|    cr_cbp_tmp = 0 ;
 1609|       |    
 1610|  4.96M|    for (b8=0; b8 < (img->num_blk8x8_uv/2); b8++)
 1611|  2.48M|    {
 1612|  12.4M|      for (b4=0; b4 < 4; b4++)
 1613|  9.93M|      {
 1614|  9.93M|        n1 = hor_offset[yuv][b8][b4];
 1615|  9.93M|        n2 = ver_offset[yuv][b8][b4];
 1616|  9.93M|        ACLevel = img->cofAC[4+b8+uv_scale][b4][0];
 1617|  9.93M|        ACRun   = img->cofAC[4+b8+uv_scale][b4][1];
 1618|  9.93M|        if( DCcoded == 0) currMB->cbp_blk &= ~((int64)cbpblk_pattern[yuv] << (uv << (1+yuv)));  // if no chroma DC's: then reset coded-bits of this chroma subblock
 1619|       |        
 1620|  9.93M|        ACLevel[0] = 0;
 1621|   158M|        for (coeff_ctr=1; coeff_ctr < 16; coeff_ctr++)// ac coeff
 1622|   148M|        {
 1623|       |
 1624|   148M|          if (img->field_picture || ( img->MbaffFrameFlag && currMB->mb_field )) 
 1625|      0|          {  // Alternate scan for field coding
 1626|      0|            i=FIELD_SCAN[coeff_ctr][0];
 1627|      0|            j=FIELD_SCAN[coeff_ctr][1];
 1628|      0|          }
 1629|   148M|          else 
 1630|   148M|          {
 1631|   148M|            i=SNGL_SCAN[coeff_ctr][0];
 1632|   148M|            j=SNGL_SCAN[coeff_ctr][1];
 1633|   148M|          }
 1634|   148M|          img->m7[n1+i][n2+j]=0;
 1635|   148M|          ACLevel[coeff_ctr] = 0;
 1636|   148M|        }
 1637|  9.93M|      }
 1638|  2.48M|    }
 1639|  2.48M|  }
 1640|       |
 1641|       |
 1642|  2.73M|  if(cr_cbp_tmp==2)
 1643|   251k|    cr_cbp = 2;
 1644|       |
 1645|       |  
 1646|       |  //     IDCT.
 1647|       |  //     Horizontal.
 1648|  8.20M|  for (n2=0; n2 < img->mb_cr_size_y && !lossless_qpprime; n2 += BLOCK_SIZE)
 1649|  5.46M|  {
 1650|  16.4M|    for (n1=0; n1 < img->mb_cr_size_x; n1 += BLOCK_SIZE)
 1651|  10.9M|    {
 1652|  54.6M|      for (j=0; j < BLOCK_SIZE; j++)
 1653|  43.7M|      {
 1654|   218M|        for (i=0; i < BLOCK_SIZE; i++)
 1655|   174M|        {
 1656|   174M|          m5[i]=img->m7[n1+i][n2+j];
 1657|   174M|        }
 1658|  43.7M|        m6[0]=(m5[0]+m5[2]);
 1659|  43.7M|        m6[1]=(m5[0]-m5[2]);
 1660|  43.7M|        m6[2]=(m5[1]>>1)-m5[3];
 1661|  43.7M|        m6[3]=m5[1]+(m5[3]>>1);
 1662|       |
 1663|   131M|        for (i=0; i < 2; i++)
 1664|  87.4M|        {
 1665|  87.4M|          i1=3-i;
 1666|  87.4M|          img->m7[n1+i][n2+j]=m6[i]+m6[i1];
 1667|  87.4M|          img->m7[n1+i1][n2+j]=m6[i]-m6[i1];
 1668|  87.4M|        }
 1669|  43.7M|      }
 1670|       |
 1671|       |      //     Vertical.
 1672|  54.6M|      for (i=0; i < BLOCK_SIZE && !lossless_qpprime; i++)
 1673|  43.7M|      {
 1674|   218M|        for (j=0; j < BLOCK_SIZE; j++)
 1675|   174M|        {
 1676|   174M|          m5[j]=img->m7[n1+i][n2+j];
 1677|   174M|        }
 1678|  43.7M|        m6[0]=(m5[0]+m5[2]);
 1679|  43.7M|        m6[1]=(m5[0]-m5[2]);
 1680|  43.7M|        m6[2]=(m5[1]>>1)-m5[3];
 1681|  43.7M|        m6[3]=m5[1]+(m5[3]>>1);
 1682|       |
 1683|   131M|        for (j=0; j < 2; j++)
 1684|  87.4M|        {
 1685|  87.4M|          j2=3-j;
 1686|       |          // Residue Color Transform
 1687|  87.4M|          if (!img->residue_transform_flag)
 1688|  87.4M|          {
 1689|  87.4M|            img->m7[n1+i][n2+j] =min(img->max_imgpel_value_uv,max(0,(m6[j]+m6[j2]+((long)img->mpr[n1+i][n2+j] <<DQ_BITS)+DQ_ROUND)>>DQ_BITS));
 1690|  87.4M|            img->m7[n1+i][n2+j2]=min(img->max_imgpel_value_uv,max(0,(m6[j]-m6[j2]+((long)img->mpr[n1+i][n2+j2]<<DQ_BITS)+DQ_ROUND)>>DQ_BITS));
 1691|  87.4M|          } 
 1692|      0|          else 
 1693|      0|          {
 1694|      0|            if(lossless_qpprime)
 1695|      0|            {
 1696|      0|               img->m7[n1+i][n2+j] =m6[j]+m6[j2];
 1697|      0|               img->m7[n1+i][n2+j2]=m6[j]-m6[j2];
 1698|      0|            }
 1699|      0|            else
 1700|      0|            {
 1701|      0|              img->m7[n1+i][n2+j] =(m6[j]+m6[j2]+DQ_ROUND)>>DQ_BITS;
 1702|      0|              img->m7[n1+i][n2+j2]=(m6[j]-m6[j2]+DQ_ROUND)>>DQ_BITS;
 1703|      0|            }
 1704|      0|          }
 1705|  87.4M|        }
 1706|  43.7M|      }
 1707|  10.9M|    }
 1708|  5.46M|  }
 1709|       |
 1710|       |  //  Decoded block moved to memory
 1711|  2.73M|  if (!img->residue_transform_flag)
 1712|  24.6M|  for (j=0; j < img->mb_cr_size_y; j++)
 1713|  21.8M|  {
 1714|   196M|    for (i=0; i < img->mb_cr_size_x; i++)
 1715|   174M|    {
 1716|   174M|      if(lossless_qpprime)
 1717|      0|        enc_picture->imgUV[uv][img->pix_c_y+j][img->pix_c_x+i]= img->m7[i][j]+img->mpr[i][j];
 1718|   174M|      else
 1719|   174M|        enc_picture->imgUV[uv][img->pix_c_y+j][img->pix_c_x+i]= img->m7[i][j];
 1720|   174M|    }
 1721|  21.8M|  }
 1722|       |
 1723|  2.73M|  return cr_cbp;
 1724|  2.73M|}
 1725|       |
 1726|       |
 1727|       |// Residue Color Transform
 1728|       |int dct_chroma4x4(int uv, int b8, int b4)
 1729|      0|{
 1730|      0|  int sign(int a,int b);
 1731|       |
 1732|      0|  int i,j,i1,j1,ilev,m5[4],m6[4],coeff_ctr;
 1733|      0|  int level,scan_pos,run;
 1734|      0|  int nonzeroAC;
 1735|      0|  Macroblock *currMB = &img->mb_data[img->current_mb_nr];
 1736|      0|  int   intra = IS_INTRA (currMB);
 1737|       |
 1738|      0|  int qp_per,qp_rem,q_bits;
 1739|      0|  int qp_c;
 1740|       |
 1741|      0|  int*  ACLevel = img->cofAC[b8][b4][0];
 1742|      0|  int*  ACRun   = img->cofAC[b8][b4][1];
 1743|       |
 1744|      0|  Boolean lossless_qpprime = ((img->qp + img->bitdepth_luma_qp_scale)==0 && img->lossless_qpprime_flag==1);
 1745|       |
 1746|      0|  qp_c      = currMB->qp + img->chroma_qp_offset[uv];
 1747|      0|  qp_c      = (qp_c < 0)? qp_c : QP_SCALE_CR[qp_c - MIN_QP];
 1748|       |
 1749|      0|  qp_per    = (qp_c + img->bitdepth_chroma_qp_scale)/6;              
 1750|      0|  qp_rem    = (qp_c + img->bitdepth_chroma_qp_scale)%6;              
 1751|      0|  q_bits    = Q_BITS+qp_per;
 1752|       |
 1753|       |  //  Horizontal transform
 1754|      0|  if(!lossless_qpprime)
 1755|      0|  for (j=0; j < BLOCK_SIZE; j++)
 1756|      0|  {
 1757|      0|    for (i=0; i < 2; i++)
 1758|      0|    {
 1759|      0|      i1=3-i;
 1760|      0|      m5[i]=img->m7[i][j]+img->m7[i1][j];
 1761|      0|      m5[i1]=img->m7[i][j]-img->m7[i1][j];
 1762|      0|    }
 1763|      0|    img->m7[0][j]=(m5[0]+m5[1]);
 1764|      0|    img->m7[2][j]=(m5[0]-m5[1]);
 1765|      0|    img->m7[1][j]=m5[3]*2+m5[2];
 1766|      0|    img->m7[3][j]=m5[3]-m5[2]*2;
 1767|      0|  }
 1768|       |
 1769|       |  //  Vertical transform
 1770|      0|  if(!lossless_qpprime)
 1771|      0|  for (i=0; i < BLOCK_SIZE; i++)
 1772|      0|  {
 1773|      0|    for (j=0; j < 2; j++)
 1774|      0|    {
 1775|      0|      j1=3-j;
 1776|      0|      m5[j]=img->m7[i][j]+img->m7[i][j1];
 1777|      0|      m5[j1]=img->m7[i][j]-img->m7[i][j1];
 1778|      0|    }
 1779|      0|    img->m7[i][0]=(m5[0]+m5[1]);
 1780|      0|    img->m7[i][2]=(m5[0]-m5[1]);
 1781|      0|    img->m7[i][1]=m5[3]*2+m5[2];
 1782|      0|    img->m7[i][3]=m5[3]-m5[2]*2;
 1783|      0|  }
 1784|       |
 1785|       |  // Quant
 1786|       |
 1787|      0|  nonzeroAC=FALSE;
 1788|       |
 1789|      0|  run=-1;
 1790|      0|  scan_pos=0;
 1791|       |
 1792|      0|  if(lossless_qpprime)
 1793|      0|    level = abs(img->m7[0][0]);
 1794|      0|  else if(intra == 1)    
 1795|      0|    level =(abs(img->m7[0][0]) * LevelScale4x4Chroma_Intra[uv][qp_rem][0][0] + LevelOffset4x4Chroma_Intra[uv][qp_per][0][0]) >> q_bits;
 1796|      0|  else
 1797|      0|    level =(abs(img->m7[0][0]) * LevelScale4x4Chroma_Inter[uv][qp_rem][0][0] + LevelOffset4x4Chroma_Inter[uv][qp_per][0][0]) >> q_bits;
 1798|       |
 1799|      0|  b8 -= 4*(uv+1);
 1800|      0|  dc_level_temp[uv][2*(b8%2)+(b4%2)][2*(b8/2)+(b4/2)] = sign(level, img->m7[0][0]);
 1801|       |
 1802|       |  /* Inverse Quantization */
 1803|      0|  if(lossless_qpprime)
 1804|      0|  {
 1805|      0|    img->m7[0][0] = sign( level, img->m7[0][0]);
 1806|      0|  }
 1807|      0|  else
 1808|      0|  {
 1809|      0|    if(qp_per<4)
 1810|      0|    {
 1811|      0|      if(intra == 1)
 1812|      0|        img->m7[0][0] = sign( ((level*InvLevelScale4x4Chroma_Intra[uv][qp_rem][0][0]+(1<<(3-qp_per)))>>(4-qp_per)), img->m7[0][0]);
 1813|      0|      else
 1814|      0|        img->m7[0][0] = sign( ((level*InvLevelScale4x4Chroma_Inter[uv][qp_rem][0][0]+(1<<(3-qp_per)))>>(4-qp_per)), img->m7[0][0]);
 1815|      0|    }
 1816|      0|    else
 1817|      0|    {
 1818|      0|      if(intra == 1)
 1819|      0|        img->m7[0][0] = sign( ((level*InvLevelScale4x4Chroma_Intra[uv][qp_rem][0][0])<<(qp_per-4)), img->m7[0][0]);
 1820|      0|      else
 1821|      0|        img->m7[0][0] = sign( ((level*InvLevelScale4x4Chroma_Inter[uv][qp_rem][0][0])<<(qp_per-4)), img->m7[0][0]);
 1822|      0|    }
 1823|      0|  }
 1824|       |
 1825|      0|  for (coeff_ctr=1;coeff_ctr < 16;coeff_ctr++)
 1826|      0|  {
 1827|      0|    i=SNGL_SCAN[coeff_ctr][0];
 1828|      0|    j=SNGL_SCAN[coeff_ctr][1];
 1829|       |
 1830|      0|    run++;
 1831|      0|    ilev=0;
 1832|       |
 1833|      0|    if(lossless_qpprime)
 1834|      0|      level = abs (img->m7[i][j]);
 1835|      0|    else if(intra == 1)      
 1836|      0|      level = (abs(img->m7[i][j])*LevelScale4x4Chroma_Intra[uv][qp_rem][i][j]+LevelOffset4x4Chroma_Intra[uv][qp_per][i][j])>>q_bits;
 1837|      0|    else
 1838|      0|      level = (abs(img->m7[i][j])*LevelScale4x4Chroma_Inter[uv][qp_rem][i][j]+LevelOffset4x4Chroma_Inter[uv][qp_per][i][j])>>q_bits;
 1839|       |    
 1840|      0|    if (level != 0)
 1841|      0|    {
 1842|      0|      if(i||j) nonzeroAC=TRUE;
 1843|       |      
 1844|      0|      ACLevel[scan_pos] = sign(level,img->m7[i][j]);
 1845|      0|      ACRun  [scan_pos] = run;
 1846|      0|      ++scan_pos;
 1847|      0|      run=-1;                     // reset zero level counter
 1848|       |      
 1849|      0|      level=sign(level, img->m7[i][j]);
 1850|      0|      if(lossless_qpprime)
 1851|      0|      {
 1852|      0|        ilev=level;
 1853|      0|      }
 1854|      0|      else if(qp_per<4)
 1855|      0|      {
 1856|      0|        if(intra == 1)
 1857|      0|          ilev=(level*InvLevelScale4x4Chroma_Intra[uv][qp_rem][i][j]+(1<<(3-qp_per)))>>(4-qp_per);
 1858|      0|        else
 1859|      0|          ilev=(level*InvLevelScale4x4Chroma_Inter[uv][qp_rem][i][j]+(1<<(3-qp_per)))>>(4-qp_per);
 1860|      0|      }
 1861|      0|      else
 1862|      0|      {
 1863|      0|        if(intra == 1)
 1864|      0|          ilev=(level*InvLevelScale4x4Chroma_Intra[uv][qp_rem][i][j])<<(qp_per-4);
 1865|      0|        else
 1866|      0|          ilev=(level*InvLevelScale4x4Chroma_Inter[uv][qp_rem][i][j])<<(qp_per-4);
 1867|      0|      }
 1868|      0|    }
 1869|      0|    if(!lossless_qpprime)
 1870|      0|      img->m7[i][j]=ilev;
 1871|      0|  }
 1872|      0|  ACLevel[scan_pos] = 0;
 1873|       |
 1874|       |  
 1875|       |  //     IDCT.
 1876|       |  //     horizontal
 1877|      0|  if(!lossless_qpprime)
 1878|      0|  for (j=0; j < BLOCK_SIZE; j++)
 1879|      0|  {
 1880|      0|    for (i=0; i < BLOCK_SIZE; i++)
 1881|      0|    {
 1882|      0|      m5[i]=img->m7[i][j];
 1883|      0|    }
 1884|      0|    m6[0]=(m5[0]+m5[2]);
 1885|      0|    m6[1]=(m5[0]-m5[2]);
 1886|      0|    m6[2]=(m5[1]>>1)-m5[3];
 1887|      0|    m6[3]=m5[1]+(m5[3]>>1);
 1888|       |
 1889|      0|    for (i=0; i < 2; i++)
 1890|      0|    {
 1891|      0|      i1=3-i;
 1892|      0|      img->m7[i][j]=m6[i]+m6[i1];
 1893|      0|      img->m7[i1][j]=m6[i]-m6[i1];
 1894|      0|    }
 1895|      0|  }
 1896|       |
 1897|       |  //  vertical
 1898|      0|  if(!lossless_qpprime)
 1899|      0|  for (i=0; i < BLOCK_SIZE; i++)
 1900|      0|  {
 1901|      0|    for (j=0; j < BLOCK_SIZE; j++)
 1902|      0|    {
 1903|      0|      m5[j]=img->m7[i][j];
 1904|      0|    }
 1905|      0|    m6[0]=(m5[0]+m5[2]);
 1906|      0|    m6[1]=(m5[0]-m5[2]);
 1907|      0|    m6[2]=(m5[1]>>1)-m5[3];
 1908|      0|    m6[3]=m5[1]+(m5[3]>>1);
 1909|       |
 1910|      0|    for (j=0; j < 2; j++)
 1911|      0|    {
 1912|      0|      j1=3-j;
 1913|      0|      img->m7[i][j] =(m6[j]+m6[j1]+DQ_ROUND)>>DQ_BITS;
 1914|      0|      img->m7[i][j1]=(m6[j]-m6[j1]+DQ_ROUND)>>DQ_BITS;
 1915|      0|    }
 1916|      0|  }
 1917|       |
 1918|      0|  return nonzeroAC;
 1919|      0|}
 1920|       |
 1921|       |// Residue Color Transform
 1922|       |int dct_chroma_DC(int uv, int cr_cbp)
 1923|      0|{
 1924|      0|  int run, scan_pos, coeff_ctr, level, i, j;
 1925|      0|  int*  DCLevel = img->cofDC[uv+1][0];
 1926|      0|  int*  DCRun   = img->cofDC[uv+1][1];
 1927|       |
 1928|      0|  run=-1;
 1929|      0|  scan_pos=0;
 1930|       |
 1931|      0|  for (coeff_ctr=0; coeff_ctr < 16; coeff_ctr++)
 1932|      0|  {
 1933|      0|    i=SNGL_SCAN[coeff_ctr][0];
 1934|      0|    j=SNGL_SCAN[coeff_ctr][1];
 1935|       |
 1936|      0|    run++;
 1937|       |
 1938|      0|    level = abs(dc_level[uv][i][j]);
 1939|       |
 1940|      0|    if (level  != 0)
 1941|      0|    {
 1942|      0|      cr_cbp=max(1,cr_cbp);
 1943|      0|      DCLevel[scan_pos] = sign(level ,dc_level[uv][i][j]);
 1944|      0|      DCRun  [scan_pos] = run;
 1945|      0|      scan_pos++;
 1946|      0|      run=-1;
 1947|      0|    }
 1948|      0|  }
 1949|      0|  DCLevel[scan_pos] = 0;
 1950|       |
 1951|      0|  return cr_cbp;
 1952|      0|}
 1953|       |
 1954|       |
 1955|       |/*!
 1956|       | ************************************************************************
 1957|       | * \brief
 1958|       | *    The routine performs transform,quantization,inverse transform, adds the diff.
 1959|       | *    to the prediction and writes the result to the decoded luma frame. Includes the
 1960|       | *    RD constrained quantization also.
 1961|       | *
 1962|       | * \par Input:
 1963|       | *    block_x,block_y: Block position inside a macro block (0,4,8,12).
 1964|       | *
 1965|       | * \par Output:
 1966|       | *    nonzero: 0 if no levels are nonzero.  1 if there are nonzero levels.              \n
 1967|       | *    coeff_cost: Counter for nonzero coefficients, used to discard expensive levels.
 1968|       | *
 1969|       | *
 1970|       | ************************************************************************
 1971|       | */
 1972|       |int dct_luma_sp(int block_x,int block_y,int *coeff_cost)
 1973|      0|{
 1974|      0|  int sign(int a,int b);
 1975|       |
 1976|      0|  int i,j,i1,j1,ilev,m5[4],m6[4],coeff_ctr;
 1977|      0|  int qp_const,level,scan_pos,run;
 1978|      0|  int nonzero;
 1979|       |
 1980|      0|  int predicted_block[BLOCK_SIZE][BLOCK_SIZE],c_err,qp_const2;
 1981|      0|  int qp_per,qp_rem,q_bits;
 1982|      0|  int qp_per_sp,qp_rem_sp,q_bits_sp;
 1983|       |
 1984|      0|  int   pos_x   = block_x/BLOCK_SIZE;
 1985|      0|  int   pos_y   = block_y/BLOCK_SIZE;
 1986|      0|  int   b8      = 2*(pos_y/2) + (pos_x/2);
 1987|      0|  int   b4      = 2*(pos_y%2) + (pos_x%2);
 1988|      0|  int*  ACLevel = img->cofAC[b8][b4][0];
 1989|      0|  int*  ACRun   = img->cofAC[b8][b4][1];
 1990|      0|  Macroblock *currMB = &img->mb_data[img->current_mb_nr];
 1991|       |
 1992|       |  // For encoding optimization
 1993|      0|  int c_err1, c_err2, level1, level2;
 1994|      0|  double D_dis1, D_dis2;
 1995|      0|  int len, info;
 1996|      0|  double lambda_mode   = 0.85 * pow (2, (currMB->qp - SHIFT_QP)/3.0) * 4; 
 1997|       |
 1998|      0|  qp_per    = (currMB->qp-MIN_QP)/6;
 1999|      0|  qp_rem    = (currMB->qp-MIN_QP)%6;
 2000|      0|  q_bits    = Q_BITS+qp_per;
 2001|      0|  qp_per_sp    = (currMB->qpsp-MIN_QP)/6;
 2002|      0|  qp_rem_sp    = (currMB->qpsp-MIN_QP)%6;
 2003|      0|  q_bits_sp    = Q_BITS+qp_per_sp;
 2004|       |
 2005|      0|  qp_const=(1<<q_bits)/6;    // inter
 2006|      0|  qp_const2=(1<<q_bits_sp)/2;  //sp_pred
 2007|       |
 2008|       |  //  Horizontal transform
 2009|      0|  for (j=0; j< BLOCK_SIZE; j++)
 2010|      0|    for (i=0; i< BLOCK_SIZE; i++)
 2011|      0|    {
 2012|      0|      img->m7[i][j]+=img->mpr[i+block_x][j+block_y];
 2013|      0|      predicted_block[i][j]=img->mpr[i+block_x][j+block_y];
 2014|      0|    }
 2015|       |
 2016|      0|  for (j=0; j < BLOCK_SIZE; j++)
 2017|      0|  {
 2018|      0|    for (i=0; i < 2; i++)
 2019|      0|    {
 2020|      0|      i1=3-i;
 2021|      0|      m5[i]=img->m7[i][j]+img->m7[i1][j];
 2022|      0|      m5[i1]=img->m7[i][j]-img->m7[i1][j];
 2023|      0|    }
 2024|      0|    img->m7[0][j]=(m5[0]+m5[1]);
 2025|      0|    img->m7[2][j]=(m5[0]-m5[1]);
 2026|      0|    img->m7[1][j]=m5[3]*2+m5[2];
 2027|      0|    img->m7[3][j]=m5[3]-m5[2]*2;
 2028|      0|  }
 2029|       |
 2030|       |  //  Vertical transform
 2031|       |
 2032|      0|  for (i=0; i < BLOCK_SIZE; i++)
 2033|      0|  {
 2034|      0|    for (j=0; j < 2; j++)
 2035|      0|    {
 2036|      0|      j1=3-j;
 2037|      0|      m5[j]=img->m7[i][j]+img->m7[i][j1];
 2038|      0|      m5[j1]=img->m7[i][j]-img->m7[i][j1];
 2039|      0|    }
 2040|      0|    img->m7[i][0]=(m5[0]+m5[1]);
 2041|      0|    img->m7[i][2]=(m5[0]-m5[1]);
 2042|      0|    img->m7[i][1]=m5[3]*2+m5[2];
 2043|      0|    img->m7[i][3]=m5[3]-m5[2]*2;
 2044|      0|  }
 2045|       |
 2046|      0|  for (j=0; j < BLOCK_SIZE; j++)
 2047|      0|  {
 2048|      0|    for (i=0; i < 2; i++)
 2049|      0|    {
 2050|      0|      i1=3-i;
 2051|      0|      m5[i]=predicted_block[i][j]+predicted_block[i1][j];
 2052|      0|      m5[i1]=predicted_block[i][j]-predicted_block[i1][j];
 2053|      0|    }
 2054|      0|    predicted_block[0][j]=(m5[0]+m5[1]);
 2055|      0|    predicted_block[2][j]=(m5[0]-m5[1]);
 2056|      0|    predicted_block[1][j]=m5[3]*2+m5[2];
 2057|      0|    predicted_block[3][j]=m5[3]-m5[2]*2;
 2058|      0|  }
 2059|       |
 2060|       |  //  Vertical transform
 2061|       |
 2062|      0|  for (i=0; i < BLOCK_SIZE; i++)
 2063|      0|  {
 2064|      0|    for (j=0; j < 2; j++)
 2065|      0|    {
 2066|      0|      j1=3-j;
 2067|      0|      m5[j]=predicted_block[i][j]+predicted_block[i][j1];
 2068|      0|      m5[j1]=predicted_block[i][j]-predicted_block[i][j1];
 2069|      0|    }
 2070|      0|    predicted_block[i][0]=(m5[0]+m5[1]);
 2071|      0|    predicted_block[i][2]=(m5[0]-m5[1]);
 2072|      0|    predicted_block[i][1]=m5[3]*2+m5[2];
 2073|      0|    predicted_block[i][3]=m5[3]-m5[2]*2;
 2074|      0|  }
 2075|       |
 2076|       |  // Quant
 2077|      0|  nonzero=FALSE;
 2078|       |
 2079|      0|  run=-1;
 2080|      0|  scan_pos=0;
 2081|       |  
 2082|      0|  for (coeff_ctr=0;coeff_ctr < 16;coeff_ctr++)     // 8 times if double scan, 16 normal scan
 2083|      0|  {
 2084|       |
 2085|      0|    if (img->field_picture || ( mb_adaptive && img->field_mode )) 
 2086|      0|    {  // Alternate scan for field coding
 2087|      0|        i=FIELD_SCAN[coeff_ctr][0];
 2088|      0|        j=FIELD_SCAN[coeff_ctr][1];
 2089|      0|    }
 2090|      0|    else 
 2091|      0|    {
 2092|      0|        i=SNGL_SCAN[coeff_ctr][0];
 2093|      0|        j=SNGL_SCAN[coeff_ctr][1];
 2094|      0|    }
 2095|       |    
 2096|      0|    run++;
 2097|      0|    ilev=0;
 2098|       |    
 2099|       |    // decide prediction
 2100|       |    
 2101|       |    // case 1
 2102|      0|    level1 = (abs (predicted_block[i][j]) * quant_coef[qp_rem_sp][i][j] + qp_const2) >> q_bits_sp; 
 2103|      0|    level1 = (level1 << q_bits_sp) / quant_coef[qp_rem_sp][i][j];                 
 2104|      0|    c_err1 = img->m7[i][j]-sign(level1, predicted_block[i][j]);                   
 2105|      0|    level1 = (abs (c_err1) * quant_coef[qp_rem][i][j] + qp_const) >> q_bits;
 2106|       |    
 2107|       |    // case 2
 2108|      0|    c_err2=img->m7[i][j]-predicted_block[i][j];
 2109|      0|    level2 = (abs (c_err2) * quant_coef[qp_rem][i][j] + qp_const) >> q_bits;
 2110|       |    
 2111|       |    // select prediction
 2112|      0|    if ((level1 != level2) && (level1 != 0) && (level2 != 0))
 2113|      0|    {
 2114|      0|      D_dis1 = img->m7[i][j] - ((sign(level1,c_err1)*dequant_coef[qp_rem][i][j]*A[i][j]<< qp_per) >>6) - predicted_block[i][j]; 
 2115|      0|      levrun_linfo_inter(level1, run, &len, &info);
 2116|      0|      D_dis1 = D_dis1*D_dis1 + lambda_mode * len;
 2117|       |      
 2118|      0|      D_dis2 = img->m7[i][j] - ((sign(level2,c_err2)*dequant_coef[qp_rem][i][j]*A[i][j]<< qp_per) >>6) - predicted_block[i][j]; 
 2119|      0|      levrun_linfo_inter(level2, run, &len, &info);
 2120|      0|      D_dis2 = D_dis2 * D_dis2 + lambda_mode * len;
 2121|       |      
 2122|      0|      if (D_dis1 == D_dis2)
 2123|      0|        level = (abs(level1) < abs(level2)) ? level1 : level2;
 2124|      0|      else
 2125|      0|      {
 2126|      0|        if (D_dis1 < D_dis2)
 2127|      0|          level = level1;
 2128|      0|        else
 2129|      0|          level = level2;
 2130|      0|      }
 2131|      0|      c_err = (level == level1) ? c_err1 : c_err2;
 2132|      0|    }
 2133|      0|    else if (level1 == level2)
 2134|      0|    {
 2135|      0|      level = level1;
 2136|      0|      c_err = c_err1;
 2137|      0|    }
 2138|      0|    else
 2139|      0|    {
 2140|      0|      level = (level1 == 0) ? level1 : level2;
 2141|      0|      c_err = (level1 == 0) ? c_err1 : c_err2;
 2142|      0|    }
 2143|       |    
 2144|      0|    if (level != 0)
 2145|      0|    {
 2146|      0|      nonzero=TRUE;
 2147|      0|      if (level > 1)
 2148|      0|        *coeff_cost += MAX_VALUE;                // set high cost, shall not be discarded
 2149|      0|      else
 2150|      0|        *coeff_cost += COEFF_COST[input->disthres][run];
 2151|      0|      ACLevel[scan_pos] = sign(level,c_err);
 2152|      0|      ACRun  [scan_pos] = run;
 2153|      0|      ++scan_pos;
 2154|      0|      run=-1;                     // reset zero level counter
 2155|      0|      ilev=((sign(level,c_err)*dequant_coef[qp_rem][i][j]*A[i][j]<< qp_per) >>6);
 2156|      0|    }
 2157|      0|    ilev+=predicted_block[i][j] ; 
 2158|      0|    img->m7[i][j] = sign((abs(ilev) * quant_coef[qp_rem_sp][i][j] + qp_const2)>> q_bits_sp, ilev) * dequant_coef[qp_rem_sp][i][j] << qp_per_sp;
 2159|      0|  }
 2160|      0|  ACLevel[scan_pos] = 0;
 2161|       |  
 2162|       |    
 2163|       |  //     IDCT.
 2164|       |  //     horizontal
 2165|       |
 2166|      0|  for (j=0; j < BLOCK_SIZE; j++)
 2167|      0|  {
 2168|      0|    for (i=0; i < BLOCK_SIZE; i++)
 2169|      0|    {
 2170|      0|      m5[i]=img->m7[i][j];
 2171|      0|    }
 2172|      0|    m6[0]=(m5[0]+m5[2]);
 2173|      0|    m6[1]=(m5[0]-m5[2]);
 2174|      0|    m6[2]=(m5[1]>>1)-m5[3];
 2175|      0|    m6[3]=m5[1]+(m5[3]>>1);
 2176|       |
 2177|      0|    for (i=0; i < 2; i++)
 2178|      0|    {
 2179|      0|      i1=3-i;
 2180|      0|      img->m7[i][j]=m6[i]+m6[i1];
 2181|      0|      img->m7[i1][j]=m6[i]-m6[i1];
 2182|      0|    }
 2183|      0|  }
 2184|       |
 2185|       |  //  vertical
 2186|       |
 2187|      0|  for (i=0; i < BLOCK_SIZE; i++)
 2188|      0|  {
 2189|      0|    for (j=0; j < BLOCK_SIZE; j++)
 2190|      0|    {
 2191|      0|      m5[j]=img->m7[i][j];
 2192|      0|    }
 2193|      0|    m6[0]=(m5[0]+m5[2]);
 2194|      0|    m6[1]=(m5[0]-m5[2]);
 2195|      0|    m6[2]=(m5[1]>>1)-m5[3];
 2196|      0|    m6[3]=m5[1]+(m5[3]>>1);
 2197|       |
 2198|      0|    for (j=0; j < 2; j++)
 2199|      0|    {
 2200|      0|      j1=3-j;
 2201|      0|      img->m7[i][j] =min(img->max_imgpel_value,max(0,(m6[j]+m6[j1]+DQ_ROUND)>>DQ_BITS));
 2202|      0|      img->m7[i][j1]=min(img->max_imgpel_value,max(0,(m6[j]-m6[j1]+DQ_ROUND)>>DQ_BITS));
 2203|      0|    }
 2204|      0|  }
 2205|       |
 2206|       |  //  Decoded block moved to frame memory
 2207|       |
 2208|      0|  for (j=0; j < BLOCK_SIZE; j++)
 2209|      0|  for (i=0; i < BLOCK_SIZE; i++)
 2210|      0|    enc_picture->imgY[img->pix_y+block_y+j][img->pix_x+block_x+i]=img->m7[i][j];
 2211|       |
 2212|      0|  return nonzero;
 2213|      0|}
 2214|       |
 2215|       |/*!
 2216|       | ************************************************************************
 2217|       | * \brief
 2218|       | *    Transform,quantization,inverse transform for chroma.
 2219|       | *    The main reason why this is done in a separate routine is the
 2220|       | *    additional 2x2 transform of DC-coeffs. This routine is called
 2221|       | *    ones for each of the chroma components.
 2222|       | *
 2223|       | * \par Input:
 2224|       | *    uv    : Make difference between the U and V chroma component               \n
 2225|       | *    cr_cbp: chroma coded block pattern
 2226|       | *
 2227|       | * \par Output:
 2228|       | *    cr_cbp: Updated chroma coded block pattern.
 2229|       | ************************************************************************
 2230|       | */
 2231|       |int dct_chroma_sp(int uv,int cr_cbp)
 2232|      0|{
 2233|      0|  int i,j,i1,j2,ilev,n2,n1,j1,mb_y,coeff_ctr,qp_const,c_err,level ,scan_pos,run;
 2234|      0|  int m1[BLOCK_SIZE],m5[BLOCK_SIZE],m6[BLOCK_SIZE];
 2235|      0|  int coeff_cost;
 2236|      0|  int cr_cbp_tmp;
 2237|      0|  int predicted_chroma_block[MB_BLOCK_SIZE/2][MB_BLOCK_SIZE/2],qp_const2,mp1[BLOCK_SIZE];
 2238|      0|  Macroblock *currMB = &img->mb_data[img->current_mb_nr];
 2239|       |
 2240|      0|  int qp_per,qp_rem,q_bits;
 2241|      0|  int qp_per_sp,qp_rem_sp,q_bits_sp;
 2242|       |
 2243|      0|  int   b4;
 2244|      0|  int*  DCLevel = img->cofDC[uv+1][0];
 2245|      0|  int*  DCRun   = img->cofDC[uv+1][1];
 2246|      0|  int*  ACLevel;
 2247|      0|  int*  ACRun;
 2248|       |
 2249|      0|  int c_err1, c_err2, level1, level2;
 2250|      0|  int len, info;
 2251|      0|  double D_dis1, D_dis2;
 2252|      0|  double lambda_mode   = 0.85 * pow (2, (currMB->qp -SHIFT_QP)/3.0) * 4; 
 2253|       |
 2254|       |
 2255|      0|  int qpChroma=Clip3(0, 51, currMB->qp + active_pps->chroma_qp_index_offset);
 2256|      0|  int qpChromaSP=Clip3(0, 51, currMB->qpsp + active_pps->chroma_qp_index_offset);
 2257|       |
 2258|      0|  qp_per    = ((qpChroma<0?qpChroma:QP_SCALE_CR[qpChroma])-MIN_QP)/6;
 2259|      0|  qp_rem    = ((qpChroma<0?qpChroma:QP_SCALE_CR[qpChroma])-MIN_QP)%6;
 2260|      0|  q_bits    = Q_BITS+qp_per;
 2261|      0|  qp_const=(1<<q_bits)/6;    // inter
 2262|      0|  qp_per_sp    = ((qpChromaSP<0?currMB->qpsp:QP_SCALE_CR[qpChromaSP])-MIN_QP)/6;
 2263|      0|  qp_rem_sp    = ((qpChromaSP<0?currMB->qpsp:QP_SCALE_CR[qpChromaSP])-MIN_QP)%6;
 2264|      0|  q_bits_sp    = Q_BITS+qp_per_sp;
 2265|      0|  qp_const2=(1<<q_bits_sp)/2;  //sp_pred
 2266|       |
 2267|       |
 2268|      0|  for (j=0; j < MB_BLOCK_SIZE/2; j++)
 2269|      0|    for (i=0; i < MB_BLOCK_SIZE/2; i++)
 2270|      0|    {
 2271|      0|      img->m7[i][j]+=img->mpr[i][j];
 2272|      0|      predicted_chroma_block[i][j]=img->mpr[i][j];
 2273|      0|    }
 2274|       |
 2275|      0|  for (n2=0; n2 <= BLOCK_SIZE; n2 += BLOCK_SIZE)
 2276|      0|  {
 2277|      0|    for (n1=0; n1 <= BLOCK_SIZE; n1 += BLOCK_SIZE)
 2278|      0|    {
 2279|       |
 2280|       |      //  Horizontal transform.
 2281|      0|      for (j=0; j < BLOCK_SIZE; j++)
 2282|      0|      {
 2283|      0|        mb_y=n2+j;
 2284|      0|        for (i=0; i < 2; i++)
 2285|      0|        {
 2286|      0|          i1=3-i;
 2287|      0|          m5[i]=img->m7[i+n1][mb_y]+img->m7[i1+n1][mb_y];
 2288|      0|          m5[i1]=img->m7[i+n1][mb_y]-img->m7[i1+n1][mb_y];
 2289|      0|        }
 2290|      0|        img->m7[n1][mb_y]  =(m5[0]+m5[1]);
 2291|      0|        img->m7[n1+2][mb_y]=(m5[0]-m5[1]);
 2292|      0|        img->m7[n1+1][mb_y]=m5[3]*2+m5[2];
 2293|      0|        img->m7[n1+3][mb_y]=m5[3]-m5[2]*2;
 2294|      0|      }
 2295|       |
 2296|       |      //  Vertical transform.
 2297|       |
 2298|      0|      for (i=0; i < BLOCK_SIZE; i++)
 2299|      0|      {
 2300|      0|        j1=n1+i;
 2301|      0|        for (j=0; j < 2; j++)
 2302|      0|        {
 2303|      0|          j2=3-j;
 2304|      0|          m5[j]=img->m7[j1][n2+j]+img->m7[j1][n2+j2];
 2305|      0|          m5[j2]=img->m7[j1][n2+j]-img->m7[j1][n2+j2];
 2306|      0|        }
 2307|      0|        img->m7[j1][n2+0]=(m5[0]+m5[1]);
 2308|      0|        img->m7[j1][n2+2]=(m5[0]-m5[1]);
 2309|      0|        img->m7[j1][n2+1]=m5[3]*2+m5[2];
 2310|      0|        img->m7[j1][n2+3]=m5[3]-m5[2]*2;
 2311|      0|      }
 2312|      0|    }
 2313|      0|  }
 2314|      0|  for (n2=0; n2 <= BLOCK_SIZE; n2 += BLOCK_SIZE)
 2315|      0|  {
 2316|      0|    for (n1=0; n1 <= BLOCK_SIZE; n1 += BLOCK_SIZE)
 2317|      0|    {
 2318|       |
 2319|       |      //  Horizontal transform.
 2320|      0|      for (j=0; j < BLOCK_SIZE; j++)
 2321|      0|      {
 2322|      0|        mb_y=n2+j;
 2323|      0|        for (i=0; i < 2; i++)
 2324|      0|        {
 2325|      0|          i1=3-i;
 2326|      0|          m5[i]=predicted_chroma_block[i+n1][mb_y]+predicted_chroma_block[i1+n1][mb_y];
 2327|      0|          m5[i1]=predicted_chroma_block[i+n1][mb_y]-predicted_chroma_block[i1+n1][mb_y];
 2328|      0|        }
 2329|      0|        predicted_chroma_block[n1][mb_y]  =(m5[0]+m5[1]);
 2330|      0|        predicted_chroma_block[n1+2][mb_y]=(m5[0]-m5[1]);
 2331|      0|        predicted_chroma_block[n1+1][mb_y]=m5[3]*2+m5[2];
 2332|      0|        predicted_chroma_block[n1+3][mb_y]=m5[3]-m5[2]*2;
 2333|      0|      }
 2334|       |
 2335|       |      //  Vertical transform.
 2336|       |
 2337|      0|      for (i=0; i < BLOCK_SIZE; i++)
 2338|      0|      {
 2339|      0|        j1=n1+i;
 2340|      0|        for (j=0; j < 2; j++)
 2341|      0|        {
 2342|      0|          j2=3-j;
 2343|      0|          m5[j]=predicted_chroma_block[j1][n2+j]+predicted_chroma_block[j1][n2+j2];
 2344|      0|          m5[j2]=predicted_chroma_block[j1][n2+j]-predicted_chroma_block[j1][n2+j2];
 2345|      0|        }
 2346|      0|        predicted_chroma_block[j1][n2+0]=(m5[0]+m5[1]);
 2347|      0|        predicted_chroma_block[j1][n2+2]=(m5[0]-m5[1]);
 2348|      0|        predicted_chroma_block[j1][n2+1]=m5[3]*2+m5[2];
 2349|      0|        predicted_chroma_block[j1][n2+3]=m5[3]-m5[2]*2;
 2350|      0|      }
 2351|      0|    }
 2352|      0|  }
 2353|       |
 2354|       |  //     2X2 transform of DC coeffs.
 2355|      0|  m1[0]=(img->m7[0][0]+img->m7[4][0]+img->m7[0][4]+img->m7[4][4]);
 2356|      0|  m1[1]=(img->m7[0][0]-img->m7[4][0]+img->m7[0][4]-img->m7[4][4]);
 2357|      0|  m1[2]=(img->m7[0][0]+img->m7[4][0]-img->m7[0][4]-img->m7[4][4]);
 2358|      0|  m1[3]=(img->m7[0][0]-img->m7[4][0]-img->m7[0][4]+img->m7[4][4]);
 2359|       |
 2360|       |  //     2X2 transform of DC coeffs.
 2361|      0|  mp1[0]=(predicted_chroma_block[0][0]+predicted_chroma_block[4][0]+predicted_chroma_block[0][4]+predicted_chroma_block[4][4]);
 2362|      0|  mp1[1]=(predicted_chroma_block[0][0]-predicted_chroma_block[4][0]+predicted_chroma_block[0][4]-predicted_chroma_block[4][4]);
 2363|      0|  mp1[2]=(predicted_chroma_block[0][0]+predicted_chroma_block[4][0]-predicted_chroma_block[0][4]-predicted_chroma_block[4][4]);
 2364|      0|  mp1[3]=(predicted_chroma_block[0][0]-predicted_chroma_block[4][0]-predicted_chroma_block[0][4]+predicted_chroma_block[4][4]);
 2365|       |
 2366|      0|  run=-1;
 2367|      0|  scan_pos=0;
 2368|       |
 2369|      0|  for (coeff_ctr=0; coeff_ctr < 4; coeff_ctr++)
 2370|      0|  {
 2371|      0|    run++;
 2372|      0|    ilev=0;
 2373|       |
 2374|       |  // case 1
 2375|      0|    c_err1 = (abs (mp1[coeff_ctr]) * quant_coef[qp_rem_sp][0][0] + 2 * qp_const2) >> (q_bits_sp + 1);
 2376|      0|    c_err1 = (c_err1 << (q_bits_sp + 1)) / quant_coef[qp_rem_sp][0][0];
 2377|      0|    c_err1 = m1[coeff_ctr] - sign(c_err1, mp1[coeff_ctr]);
 2378|      0|    level1 = (abs(c_err1) * quant_coef[qp_rem][0][0] + 2 * qp_const) >> (q_bits+1);
 2379|       |
 2380|       |  // case 2
 2381|      0|    c_err2 = m1[coeff_ctr] - mp1[coeff_ctr];
 2382|      0|    level2 = (abs(c_err2) * quant_coef[qp_rem][0][0] + 2 * qp_const) >> (q_bits+1);
 2383|       |
 2384|      0|    if (level1 != level2 && level1 != 0 && level2 != 0)
 2385|      0|    {
 2386|      0|      D_dis1 = m1[coeff_ctr] - ((sign(level1,c_err1)*dequant_coef[qp_rem][0][0]*A[0][0]<< qp_per) >>5)- mp1[coeff_ctr];
 2387|      0|      levrun_linfo_c2x2(level1, run, &len, &info);
 2388|      0|      D_dis1 = D_dis1 * D_dis1 + lambda_mode * len;
 2389|       |      
 2390|      0|      D_dis2 = m1[coeff_ctr] - ((sign(level2,c_err2)*dequant_coef[qp_rem][0][0]*A[0][0]<< qp_per) >>5)- mp1[coeff_ctr];
 2391|      0|      levrun_linfo_c2x2(level2, run, &len, &info);
 2392|      0|      D_dis2 = D_dis2 * D_dis2 + lambda_mode * len;
 2393|       |      
 2394|      0|      if (D_dis1 == D_dis2)
 2395|      0|        level = (abs(level1) < abs(level2)) ? level1 : level2;
 2396|      0|      else
 2397|      0|      {
 2398|      0|        if (D_dis1 < D_dis2)
 2399|      0|          level = level1;
 2400|      0|        else
 2401|      0|          level = level2;
 2402|      0|      }
 2403|      0|      c_err = (level == level1) ? c_err1 : c_err2;
 2404|      0|    }
 2405|      0|    else if (level1 == level2)
 2406|      0|    {
 2407|      0|      level = level1;
 2408|      0|      c_err = c_err1;
 2409|      0|    }
 2410|      0|    else
 2411|      0|    {
 2412|      0|      level = (level1 == 0) ? level1 : level2;
 2413|      0|      c_err = (level1 == 0) ? c_err1 : c_err2;
 2414|      0|    }
 2415|       |    
 2416|      0|    if (input->symbol_mode == UVLC && img->qp < 4) 
 2417|      0|    {
 2418|      0|      if (level > CAVLC_LEVEL_LIMIT) 
 2419|      0|      {
 2420|      0|        level = CAVLC_LEVEL_LIMIT;
 2421|      0|      }
 2422|      0|    }
 2423|       |
 2424|      0|    if (level  != 0)
 2425|      0|    {
 2426|      0|      currMB->cbp_blk |= 0xf0000 << (uv << 2) ;  // if one of the 2x2-DC levels is != 0 the coded-bit
 2427|      0|      cr_cbp=max(1,cr_cbp);
 2428|      0|      DCLevel[scan_pos] = sign(level ,c_err);
 2429|      0|      DCRun  [scan_pos] = run;
 2430|      0|      scan_pos++;
 2431|      0|      run=-1;
 2432|      0|      ilev=((sign(level,c_err)*dequant_coef[qp_rem][0][0]*A[0][0]<< qp_per) >>5);
 2433|      0|    }
 2434|      0|    ilev+= mp1[coeff_ctr];
 2435|      0|    m1[coeff_ctr]=sign((abs(ilev)  * quant_coef[qp_rem_sp][0][0] + 2 * qp_const2) >> (q_bits_sp+1), ilev) * dequant_coef[qp_rem_sp][0][0] << qp_per_sp;
 2436|      0|  }
 2437|      0|  DCLevel[scan_pos] = 0;
 2438|       |
 2439|       |  //  Invers transform of 2x2 DC levels
 2440|       |
 2441|      0|  img->m7[0][0]=(m1[0]+m1[1]+m1[2]+m1[3])/2;
 2442|      0|  img->m7[4][0]=(m1[0]-m1[1]+m1[2]-m1[3])/2;
 2443|      0|  img->m7[0][4]=(m1[0]+m1[1]-m1[2]-m1[3])/2;
 2444|      0|  img->m7[4][4]=(m1[0]-m1[1]-m1[2]+m1[3])/2;
 2445|       |
 2446|       |  //     Quant of chroma AC-coeffs.
 2447|      0|  coeff_cost=0;
 2448|      0|  cr_cbp_tmp=0;
 2449|       |
 2450|      0|  for (n2=0; n2 <= BLOCK_SIZE; n2 += BLOCK_SIZE)
 2451|      0|  {
 2452|      0|    for (n1=0; n1 <= BLOCK_SIZE; n1 += BLOCK_SIZE)
 2453|      0|    {
 2454|      0|      b4      = 2*(n2/4) + (n1/4);
 2455|      0|      ACLevel = img->cofAC[uv+4][b4][0];
 2456|      0|      ACRun   = img->cofAC[uv+4][b4][1];
 2457|       |
 2458|      0|      run      = -1;
 2459|      0|      scan_pos =  0;
 2460|       |
 2461|      0|      for (coeff_ctr=1; coeff_ctr < 16; coeff_ctr++)// start change rd_quant
 2462|      0|      {
 2463|       |
 2464|      0|        if (img->field_picture || ( mb_adaptive && img->field_mode )) 
 2465|      0|        {  // Alternate scan for field coding
 2466|      0|          i=FIELD_SCAN[coeff_ctr][0];
 2467|      0|          j=FIELD_SCAN[coeff_ctr][1];
 2468|      0|        }
 2469|      0|        else 
 2470|      0|        {
 2471|      0|          i=SNGL_SCAN[coeff_ctr][0];
 2472|      0|          j=SNGL_SCAN[coeff_ctr][1];
 2473|      0|        }
 2474|      0|        ++run;
 2475|      0|        ilev=0;
 2476|       |
 2477|       |    // quantization on prediction
 2478|      0|    c_err1 = (abs(predicted_chroma_block[n1+i][n2+j]) * quant_coef[qp_rem_sp][i][j] + qp_const2) >> q_bits_sp;
 2479|      0|    c_err1 = (c_err1 << q_bits_sp) / quant_coef[qp_rem_sp][i][j];
 2480|      0|    c_err1 = img->m7[n1+i][n2+j] - sign(c_err1, predicted_chroma_block[n1+i][n2+j]);
 2481|      0|    level1 = (abs(c_err1) * quant_coef[qp_rem][i][j] + qp_const) >> q_bits;
 2482|       |
 2483|       |    // no quantization on prediction
 2484|      0|    c_err2 = img->m7[n1+i][n2+j] - predicted_chroma_block[n1+i][n2+j];
 2485|      0|    level2 = (abs(c_err2) * quant_coef[qp_rem][i][j] + qp_const) >> q_bits;
 2486|       |
 2487|      0|    if (level1 != level2 && level1 != 0 && level2 != 0)
 2488|      0|    {
 2489|      0|      D_dis1 = img->m7[n1+i][n2+j] - ((sign(level1,c_err1)*dequant_coef[qp_rem][i][j]*A[i][j]<< qp_per) >>6) - predicted_chroma_block[n1+i][n2+j]; 
 2490|       |
 2491|      0|      levrun_linfo_inter(level1, run, &len, &info);
 2492|      0|      D_dis1 = D_dis1 * D_dis1 + lambda_mode * len;
 2493|       |
 2494|      0|      D_dis2 = img->m7[n1+i][n2+j] - ((sign(level2,c_err2)*dequant_coef[qp_rem][i][j]*A[i][j]<< qp_per) >>6) - predicted_chroma_block[n1+i][n2+j]; 
 2495|      0|      levrun_linfo_inter(level2, run, &len, &info);
 2496|      0|      D_dis2 = D_dis2 * D_dis2 + lambda_mode * len;
 2497|       |      
 2498|      0|      if (D_dis1 == D_dis2)
 2499|      0|        level = (abs(level1) < abs(level2)) ? level1 : level2;
 2500|      0|      else
 2501|      0|      {
 2502|      0|        if (D_dis1 < D_dis2)
 2503|      0|          level = level1;
 2504|      0|        else
 2505|      0|          level = level2;
 2506|      0|      }
 2507|      0|      c_err = (level == level1) ? c_err1 : c_err2;
 2508|      0|    }
 2509|      0|    else if (level1 == level2)
 2510|      0|    {
 2511|      0|      level = level1;
 2512|      0|      c_err = c_err1;
 2513|      0|    }
 2514|      0|    else
 2515|      0|    {
 2516|      0|      level = (level1 == 0) ? level1 : level2;
 2517|      0|      c_err = (level1 == 0) ? c_err1 : c_err2;
 2518|      0|    }
 2519|       |
 2520|      0|        if (level  != 0)
 2521|      0|        {
 2522|      0|          currMB->cbp_blk |=  1 << (16 + (uv << 2) + ((n2 >> 1) + (n1 >> 2))) ;
 2523|      0|          if (level > 1)
 2524|      0|            coeff_cost += MAX_VALUE;                // set high cost, shall not be discarded
 2525|      0|          else
 2526|      0|            coeff_cost += COEFF_COST[input->disthres][run];
 2527|       |
 2528|      0|          cr_cbp_tmp=2;
 2529|      0|          ACLevel[scan_pos] = sign(level,c_err);
 2530|      0|          ACRun  [scan_pos] = run;
 2531|      0|          ++scan_pos;
 2532|      0|          run=-1;
 2533|      0|          ilev=((sign(level,c_err)*dequant_coef[qp_rem][i][j]*A[i][j]<< qp_per) >>6);
 2534|      0|        }
 2535|      0|        ilev+=predicted_chroma_block[n1+i][n2+j];
 2536|      0|        img->m7[n1+i][n2+j] = sign((abs(ilev) * quant_coef[qp_rem_sp][i][j] + qp_const2) >> q_bits_sp,ilev) * dequant_coef[qp_rem_sp][i][j] << qp_per_sp;
 2537|      0|      }
 2538|      0|      ACLevel[scan_pos] = 0;
 2539|      0|    }
 2540|      0|  }
 2541|       |
 2542|       |  // * reset chroma coeffs
 2543|       |
 2544|      0|  if(cr_cbp_tmp==2)
 2545|      0|      cr_cbp=2;
 2546|       |  //     IDCT.
 2547|       |
 2548|       |      //     Horizontal.
 2549|      0|  for (n2=0; n2 <= BLOCK_SIZE; n2 += BLOCK_SIZE)
 2550|      0|  {
 2551|      0|    for (n1=0; n1 <= BLOCK_SIZE; n1 += BLOCK_SIZE)
 2552|      0|    {
 2553|      0|      for (j=0; j < BLOCK_SIZE; j++)
 2554|      0|      {
 2555|      0|        for (i=0; i < BLOCK_SIZE; i++)
 2556|      0|        {
 2557|      0|          m5[i]=img->m7[n1+i][n2+j];
 2558|      0|        }
 2559|      0|        m6[0]=(m5[0]+m5[2]);
 2560|      0|        m6[1]=(m5[0]-m5[2]);
 2561|      0|        m6[2]=(m5[1]>>1)-m5[3];
 2562|      0|        m6[3]=m5[1]+(m5[3]>>1);
 2563|       |
 2564|      0|        for (i=0; i < 2; i++)
 2565|      0|        {
 2566|      0|          i1=3-i;
 2567|      0|          img->m7[n1+i][n2+j]=m6[i]+m6[i1];
 2568|      0|          img->m7[n1+i1][n2+j]=m6[i]-m6[i1];
 2569|      0|        }
 2570|      0|      }
 2571|       |
 2572|       |      //     Vertical.
 2573|      0|      for (i=0; i < BLOCK_SIZE; i++)
 2574|      0|      {
 2575|      0|        for (j=0; j < BLOCK_SIZE; j++)
 2576|      0|        {
 2577|      0|          m5[j]=img->m7[n1+i][n2+j];
 2578|      0|        }
 2579|      0|        m6[0]=(m5[0]+m5[2]);
 2580|      0|        m6[1]=(m5[0]-m5[2]);
 2581|      0|        m6[2]=(m5[1]>>1)-m5[3];
 2582|      0|        m6[3]=m5[1]+(m5[3]>>1);
 2583|       |
 2584|      0|        for (j=0; j < 2; j++)
 2585|      0|        {
 2586|      0|          j2=3-j;
 2587|      0|          img->m7[n1+i][n2+j] =min(img->max_imgpel_value_uv,max(0,(m6[j]+m6[j2]+DQ_ROUND)>>DQ_BITS));
 2588|      0|          img->m7[n1+i][n2+j2]=min(img->max_imgpel_value_uv,max(0,(m6[j]-m6[j2]+DQ_ROUND)>>DQ_BITS));
 2589|      0|        }
 2590|      0|      }
 2591|      0|    }
 2592|      0|  }
 2593|       |
 2594|       |  //  Decoded block moved to memory
 2595|      0|  for (j=0; j < BLOCK_SIZE*2; j++)
 2596|      0|    for (i=0; i < BLOCK_SIZE*2; i++)
 2597|      0|    {
 2598|      0|      enc_picture->imgUV[uv][img->pix_c_y+j][img->pix_c_x+i]= img->m7[i][j];
 2599|      0|    }
 2600|       |
 2601|      0|  return cr_cbp;
 2602|      0|}
 2603|       |
 2604|       |/*!
 2605|       | ************************************************************************
 2606|       | * \brief
 2607|       | *    The routine performs transform,quantization,inverse transform, adds the diff.
 2608|       | *    to the prediction and writes the result to the decoded luma frame. Includes the
 2609|       | *    RD constrained quantization also.
 2610|       | *
 2611|       | * \par Input:
 2612|       | *    block_x,block_y: Block position inside a macro block (0,4,8,12).
 2613|       | *
 2614|       | * \par Output:
 2615|       | *    nonzero: 0 if no levels are nonzero.  1 if there are nonzero levels.            \n
 2616|       | *    coeff_cost: Counter for nonzero coefficients, used to discard expencive levels.
 2617|       | ************************************************************************
 2618|       | */
 2619|       |void copyblock_sp(int block_x,int block_y)
 2620|      0|{
 2621|      0|  int sign(int a,int b);
 2622|       |
 2623|      0|  int i,j,i1,j1,m5[4],m6[4];
 2624|       |
 2625|      0|  Macroblock *currMB = &img->mb_data[img->current_mb_nr];
 2626|       |
 2627|      0|  int predicted_block[BLOCK_SIZE][BLOCK_SIZE];
 2628|      0|  int qp_per = (currMB->qpsp-MIN_QP)/6;
 2629|      0|  int qp_rem = (currMB->qpsp-MIN_QP)%6;
 2630|      0|  int q_bits    = Q_BITS+qp_per;
 2631|      0|  int qp_const2=(1<<q_bits)/2;  //sp_pred
 2632|       |
 2633|       |  //  Horizontal transform
 2634|      0|  for (j=0; j< BLOCK_SIZE; j++)
 2635|      0|    for (i=0; i< BLOCK_SIZE; i++)
 2636|      0|    {
 2637|      0|      predicted_block[i][j]=img->mpr[i+block_x][j+block_y];
 2638|      0|    }
 2639|       |
 2640|      0|  for (j=0; j < BLOCK_SIZE; j++)
 2641|      0|  {
 2642|      0|    for (i=0; i < 2; i++)
 2643|      0|    {
 2644|      0|      i1=3-i;
 2645|      0|      m5[i]=predicted_block[i][j]+predicted_block[i1][j];
 2646|      0|      m5[i1]=predicted_block[i][j]-predicted_block[i1][j];
 2647|      0|    }
 2648|      0|    predicted_block[0][j]=(m5[0]+m5[1]);
 2649|      0|    predicted_block[2][j]=(m5[0]-m5[1]);
 2650|      0|    predicted_block[1][j]=m5[3]*2+m5[2];
 2651|      0|    predicted_block[3][j]=m5[3]-m5[2]*2;
 2652|      0|  }
 2653|       |
 2654|       |  //  Vertival transform
 2655|       |
 2656|      0|  for (i=0; i < BLOCK_SIZE; i++)
 2657|      0|  {
 2658|      0|    for (j=0; j < 2; j++)
 2659|      0|    {
 2660|      0|      j1=3-j;
 2661|      0|      m5[j]=predicted_block[i][j]+predicted_block[i][j1];
 2662|      0|      m5[j1]=predicted_block[i][j]-predicted_block[i][j1];
 2663|      0|    }
 2664|      0|    predicted_block[i][0]=(m5[0]+m5[1]);
 2665|      0|    predicted_block[i][2]=(m5[0]-m5[1]);
 2666|      0|    predicted_block[i][1]=m5[3]*2+m5[2];
 2667|      0|    predicted_block[i][3]=m5[3]-m5[2]*2;
 2668|      0|  }
 2669|       |
 2670|       |  // Quant
 2671|      0|  for (j=0;j < BLOCK_SIZE; j++)
 2672|      0|    for (i=0; i < BLOCK_SIZE; i++)
 2673|      0|       img->m7[i][j]=sign((abs(predicted_block[i][j])* quant_coef[qp_rem][i][j]+qp_const2)>> q_bits,predicted_block[i][j])*dequant_coef[qp_rem][i][j]<<qp_per;
 2674|       |
 2675|       |  //     IDCT.
 2676|       |  //     horizontal
 2677|       |
 2678|      0|  for (j=0;j<BLOCK_SIZE;j++)
 2679|      0|  {
 2680|      0|    for (i=0;i<BLOCK_SIZE;i++)
 2681|      0|    {
 2682|      0|      m5[i]=img->m7[i][j];
 2683|      0|    }
 2684|      0|    m6[0]=(m5[0]+m5[2]);
 2685|      0|    m6[1]=(m5[0]-m5[2]);
 2686|      0|    m6[2]=(m5[1]>>1)-m5[3];
 2687|      0|    m6[3]=m5[1]+(m5[3]>>1);
 2688|       |
 2689|      0|    for (i=0;i<2;i++)
 2690|      0|    {
 2691|      0|      i1=3-i;
 2692|      0|      img->m7[i][j]=m6[i]+m6[i1];
 2693|      0|      img->m7[i1][j]=m6[i]-m6[i1];
 2694|      0|    }
 2695|      0|  }
 2696|       |  // vertical
 2697|      0|  for (i=0;i<BLOCK_SIZE;i++)
 2698|      0|  {
 2699|      0|    for (j=0;j<BLOCK_SIZE;j++)
 2700|      0|      m5[j]=img->m7[i][j];
 2701|       |
 2702|      0|    m6[0]=(m5[0]+m5[2]);
 2703|      0|    m6[1]=(m5[0]-m5[2]);
 2704|      0|    m6[2]=(m5[1]>>1)-m5[3];
 2705|      0|    m6[3]=m5[1]+(m5[3]>>1);
 2706|       |
 2707|      0|    for (j=0;j<2;j++)
 2708|      0|    {
 2709|      0|      j1=3-j;
 2710|      0|      img->m7[i][j] =min(img->max_imgpel_value,max(0,(m6[j]+m6[j1]+DQ_ROUND)>>DQ_BITS));
 2711|      0|      img->m7[i][j1]=min(img->max_imgpel_value,max(0,(m6[j]-m6[j1]+DQ_ROUND)>>DQ_BITS));
 2712|      0|    }
 2713|      0|  }
 2714|       |
 2715|       |  //  Decoded block moved to frame memory
 2716|       |
 2717|      0|  for (j=0; j < BLOCK_SIZE; j++)
 2718|      0|    for (i=0; i < BLOCK_SIZE; i++)
 2719|      0|      enc_picture->imgY[img->pix_y+block_y+j][img->pix_x+block_x+i]=img->m7[i][j];
 2720|      0|}

/home/xzp/speccpu2006-v1.0.1/benchspec/CPU2006/464.h264ref/run/build_base_ql_riscv_llvm17.0000/cabac.c:
    1|       |
    2|       |/*!
    3|       | *************************************************************************************
    4|       | * \file cabac.c
    5|       | *
    6|       | * \brief
    7|       | *    CABAC entropy coding routines
    8|       | *
    9|       | * \author
   10|       | *    Main contributors (see contributors.h for copyright, address and affiliation details)
   11|       | *    - Detlev Marpe                    <marpe@hhi.de>
   12|       | **************************************************************************************
   13|       | */
   14|       |
   15|       |#include <stdlib.h>
   16|       |#include <assert.h>
   17|       |
   18|       |#include "global.h"
   19|       |
   20|       |#include "cabac.h"
   21|       |#include "image.h"
   22|       |#include "mb_access.h"
   23|       |
   24|       |int last_dquant = 0;
   25|       |
   26|       |/***********************************************************************
   27|       | * L O C A L L Y   D E F I N E D   F U N C T I O N   P R O T O T Y P E S
   28|       | ***********************************************************************
   29|       | */
   30|       |
   31|       |
   32|       |void unary_bin_encode(EncodingEnvironmentPtr eep_frame,
   33|       |                      unsigned int symbol,
   34|       |                      BiContextTypePtr ctx,
   35|       |                      int ctx_offset);
   36|       |
   37|       |void unary_bin_max_encode(EncodingEnvironmentPtr eep_frame,
   38|       |                          unsigned int symbol,
   39|       |                          BiContextTypePtr ctx,
   40|       |                          int ctx_offset,
   41|       |                          unsigned int max_symbol);
   42|       |
   43|       |void unary_exp_golomb_level_encode( EncodingEnvironmentPtr eep_dp,
   44|       |                                   unsigned int symbol,
   45|       |                                   BiContextTypePtr ctx);
   46|       |
   47|       |void unary_exp_golomb_mv_encode(EncodingEnvironmentPtr eep_dp,
   48|       |                                unsigned int symbol,
   49|       |                                BiContextTypePtr ctx,
   50|       |                                unsigned int max_bin);
   51|       |
   52|       |
   53|       |void cabac_new_slice()
   54|    171|{
   55|    171|  last_dquant=0;
   56|    171|}
   57|       |
   58|       |
   59|       |/*!
   60|       | ************************************************************************
   61|       | * \brief
   62|       | *    Check for available neighbouring blocks
   63|       | *    and set pointers in current macroblock
   64|       | ************************************************************************
   65|       | */
   66|       |void CheckAvailabilityOfNeighborsCABAC()
   67|  1.56M|{
   68|  1.56M|  Macroblock *currMB = &img->mb_data[img->current_mb_nr];
   69|  1.56M|  PixelPos up, left;
   70|       |  
   71|  1.56M|  getNeighbour(img->current_mb_nr, -1,  0, 1, &left);
   72|  1.56M|  getNeighbour(img->current_mb_nr,  0, -1, 1, &up);
   73|       |  
   74|  1.56M|  if (up.available)
   75|  1.50M|    currMB->mb_available_up = &img->mb_data[up.mb_addr];
   76|  58.0k|  else
   77|  58.0k|    currMB->mb_available_up = NULL;
   78|       |  
   79|  1.56M|  if (left.available)
   80|  1.52M|    currMB->mb_available_left = &img->mb_data[left.mb_addr];
   81|  36.2k|  else
   82|  36.2k|    currMB->mb_available_left = NULL;
   83|  1.56M|}
   84|       |
   85|       |/*!
   86|       | ************************************************************************
   87|       | * \brief
   88|       | *    Allocation of contexts models for the motion info
   89|       | *    used for arithmetic encoding
   90|       | ************************************************************************
   91|       | */
   92|       |MotionInfoContexts* create_contexts_MotionInfo(void)
   93|    178|{
   94|    178|  MotionInfoContexts* enco_ctx;
   95|       |
   96|    178|  enco_ctx = (MotionInfoContexts*) calloc(1, sizeof(MotionInfoContexts) );
   97|    178|  if( enco_ctx == NULL )
   98|      0|    no_mem_exit("create_contexts_MotionInfo: enco_ctx");
   99|       |
  100|    178|  return enco_ctx;
  101|    178|}
  102|       |
  103|       |
  104|       |/*!
  105|       | ************************************************************************
  106|       | * \brief
  107|       | *    Allocates of contexts models for the texture info
  108|       | *    used for arithmetic encoding
  109|       | ************************************************************************
  110|       | */
  111|       |TextureInfoContexts* create_contexts_TextureInfo(void)
  112|    178|{
  113|    178|  TextureInfoContexts*  enco_ctx;
  114|       |
  115|    178|  enco_ctx = (TextureInfoContexts*) calloc(1, sizeof(TextureInfoContexts) );
  116|    178|  if( enco_ctx == NULL )
  117|      0|    no_mem_exit("create_contexts_TextureInfo: enco_ctx");
  118|       |
  119|    178|  return enco_ctx;
  120|    178|}
  121|       |
  122|       |
  123|       |
  124|       |
  125|       |/*!
  126|       | ************************************************************************
  127|       | * \brief
  128|       | *    Frees the memory of the contexts models
  129|       | *    used for arithmetic encoding of the motion info.
  130|       | ************************************************************************
  131|       | */
  132|       |void delete_contexts_MotionInfo(MotionInfoContexts *enco_ctx)
  133|    178|{
  134|    178|  if( enco_ctx == NULL )
  135|      0|    return;
  136|       |
  137|    178|  free( enco_ctx );
  138|       |
  139|    178|  return;
  140|    178|}
  141|       |
  142|       |/*!
  143|       | ************************************************************************
  144|       | * \brief
  145|       | *    Frees the memory of the contexts models
  146|       | *    used for arithmetic encoding of the texture info.
  147|       | ************************************************************************
  148|       | */
  149|       |void delete_contexts_TextureInfo(TextureInfoContexts *enco_ctx)
  150|    178|{
  151|    178|  if( enco_ctx == NULL )
  152|      0|    return;
  153|       |
  154|    178|  free( enco_ctx );
  155|       |
  156|    178|  return;
  157|    178|}
  158|       |
  159|       |
  160|       |/*!
  161|       | **************************************************************************
  162|       | * \brief
  163|       | *    generates arithmetic code and passes the code to the buffer
  164|       | **************************************************************************
  165|       | */
  166|       |int writeSyntaxElement_CABAC(SyntaxElement *se, DataPartition *this_dataPart)
  167|   179M|{
  168|   179M|  int curr_len;
  169|   179M|  EncodingEnvironmentPtr eep_dp = &(this_dataPart->ee_cabac);
  170|       |
  171|   179M|  curr_len = arienco_bits_written(eep_dp);
  172|       |
  173|       |  // perform the actual coding by calling the appropriate method
  174|   179M|  se->writing(se, eep_dp);
  175|       |
  176|   179M|  if(se->type != SE_HEADER)
  177|   179M|    this_dataPart->bitstream->write_flag = 1;
  178|       |
  179|   179M|  return (se->len = (arienco_bits_written(eep_dp) - curr_len));
  180|   179M|}
  181|       |
  182|       |/*!
  183|       | ***************************************************************************
  184|       | * \brief
  185|       | *    This function is used to arithmetically encode the field
  186|       | *    mode info of a given MB  in the case of mb-based frame/field decision
  187|       | ***************************************************************************
  188|       | */
  189|       |void writeFieldModeInfo_CABAC(SyntaxElement *se, EncodingEnvironmentPtr eep_dp)
  190|      0|{
  191|      0|  int a,b,act_ctx;
  192|      0|  MotionInfoContexts *ctx         = (img->currentSlice)->mot_ctx;
  193|      0|  Macroblock         *currMB      = &img->mb_data[img->current_mb_nr];
  194|      0|  int                mb_field = se->value1;
  195|       |  
  196|      0|  if (currMB->mbAvailA)
  197|      0|    a = img->mb_data[currMB->mbAddrA].mb_field;
  198|      0|  else
  199|      0|    a = 0;
  200|      0|  if (currMB->mbAvailB)
  201|      0|    b = img->mb_data[currMB->mbAddrB].mb_field;
  202|      0|  else
  203|      0|    b=0;
  204|       |
  205|      0|  act_ctx = a + b;
  206|       |
  207|      0|  if (mb_field==0) // frame
  208|      0|    biari_encode_symbol(eep_dp, 0,&ctx->mb_aff_contexts[act_ctx]);
  209|      0|  else
  210|      0|    biari_encode_symbol(eep_dp, 1,&ctx->mb_aff_contexts[act_ctx]);
  211|       |  
  212|      0|  se->context = act_ctx;
  213|       |  
  214|      0|  return;
  215|      0|}
  216|       |
  217|       |/*!
  218|       |***************************************************************************
  219|       |* \brief
  220|       |*    This function is used to arithmetically encode the mb_skip_flag.
  221|       |***************************************************************************
  222|       |*/
  223|       |void writeMB_skip_flagInfo_CABAC(SyntaxElement *se, EncodingEnvironmentPtr eep_dp)
  224|  1.45M|{
  225|  1.45M|  int a,b,act_ctx;
  226|  1.45M|  int bframe   = (img->type==B_SLICE);
  227|  1.45M|  MotionInfoContexts *ctx         = (img->currentSlice)->mot_ctx;
  228|  1.45M|  Macroblock         *currMB      = &img->mb_data[img->current_mb_nr];
  229|  1.45M|  int                curr_mb_type = se->value1;
  230|       |  
  231|  1.45M|  if (bframe)
  232|   954k|  {
  233|   954k|    if (currMB->mb_available_up == NULL)
  234|  34.4k|      b = 0;
  235|   919k|    else
  236|   919k|      b = (currMB->mb_available_up->skip_flag==0 ? 0 : 1);
  237|   954k|    if (currMB->mb_available_left == NULL)
  238|  21.5k|      a = 0;
  239|   932k|    else
  240|   932k|      a = (currMB->mb_available_left->skip_flag==0 ? 0 : 1);
  241|       |    
  242|   954k|    act_ctx = 7 + a + b;
  243|       |
  244|   954k|    if (se->value1==0 && se->value2==0) // DIRECT mode, no coefficients
  245|   194k|      biari_encode_symbol (eep_dp, 1, &ctx->mb_type_contexts[2][act_ctx]);
  246|   760k|    else
  247|   760k|      biari_encode_symbol (eep_dp, 0, &ctx->mb_type_contexts[2][act_ctx]);   
  248|       |
  249|   954k|    currMB->skip_flag = (se->value1==0 && se->value2==0)?0:1;
  250|   954k|  }
  251|   498k|  else
  252|   498k|  {
  253|   498k|    if (currMB->mb_available_up == NULL)
  254|  18.1k|      b = 0;
  255|   480k|    else
  256|   480k|      b = (( (currMB->mb_available_up)->skip_flag != 0) ? 1 : 0 );
  257|   498k|    if (currMB->mb_available_left == NULL)
  258|  11.2k|      a = 0;
  259|   487k|    else
  260|   487k|      a = (( (currMB->mb_available_left)->skip_flag != 0) ? 1 : 0 );
  261|       |
  262|   498k|    act_ctx = a + b;
  263|       |
  264|   498k|    if (curr_mb_type==0) // SKIP
  265|  53.7k|      biari_encode_symbol(eep_dp, 1,&ctx->mb_type_contexts[1][act_ctx]);
  266|   445k|    else
  267|   445k|      biari_encode_symbol(eep_dp, 0,&ctx->mb_type_contexts[1][act_ctx]);
  268|       |
  269|   498k|    currMB->skip_flag = (curr_mb_type==0)?0:1;
  270|   498k|  }
  271|  1.45M|  se->context = act_ctx;
  272|       |
  273|  1.45M|  return;
  274|  1.45M|}
  275|       |
  276|       |/*!
  277|       |***************************************************************************
  278|       |* \brief
  279|       |*    This function is used to arithmetically encode the macroblock
  280|       |*    intra_pred_size flag info of a given MB.
  281|       |***************************************************************************
  282|       |*/
  283|       |
  284|       |void writeMB_transform_size_CABAC(SyntaxElement *se, EncodingEnvironmentPtr eep_dp)
  285|      0|{
  286|      0|  int a, b;
  287|      0|  int act_ctx = 0;
  288|      0|  int act_sym;
  289|       |  
  290|      0|  MotionInfoContexts *ctx         = (img->currentSlice)->mot_ctx;
  291|      0|  Macroblock         *currMB      = &img->mb_data[img->current_mb_nr];
  292|       |  
  293|       |  
  294|      0|  if (currMB->mb_available_up == NULL)
  295|      0|    b = 0;
  296|      0|  else 
  297|      0|    b = currMB->mb_available_up->luma_transform_size_8x8_flag;
  298|       |  
  299|      0|  if (currMB->mb_available_left == NULL)
  300|      0|    a = 0;
  301|      0|  else 
  302|      0|    a = currMB->mb_available_left->luma_transform_size_8x8_flag;
  303|       |    
  304|      0|  act_ctx     = a + b;
  305|      0|  act_sym     = currMB->luma_transform_size_8x8_flag;
  306|      0|  se->context = act_ctx; // store context
  307|      0|  if(act_sym == 0)          // 4x4
  308|      0|    biari_encode_symbol(eep_dp, 0, ctx->transform_size_contexts + act_ctx );
  309|      0|  else                      // 8x8
  310|      0|    biari_encode_symbol(eep_dp, 1, ctx->transform_size_contexts + act_ctx );
  311|       |  
  312|      0|}
  313|       |
  314|       |/*!
  315|       | ***************************************************************************
  316|       | * \brief
  317|       | *    This function is used to arithmetically encode the macroblock
  318|       | *    type info of a given MB.
  319|       | ***************************************************************************
  320|       | */
  321|       |
  322|       |void writeMB_typeInfo_CABAC(SyntaxElement *se, EncodingEnvironmentPtr eep_dp)
  323|  1.36M|{
  324|  1.36M|  int a, b;
  325|  1.36M|  int act_ctx = 0;
  326|  1.36M|  int act_sym;
  327|  1.36M|  int csym;
  328|  1.36M|  int bframe   = (img->type==B_SLICE);
  329|  1.36M|  int mode_sym = 0;
  330|  1.36M|  int mode16x16;
  331|       |
  332|       |
  333|  1.36M|  MotionInfoContexts *ctx         = (img->currentSlice)->mot_ctx;
  334|  1.36M|  Macroblock         *currMB      = &img->mb_data[img->current_mb_nr];
  335|  1.36M|  int                curr_mb_type = se->value1;
  336|       |
  337|  1.36M|  if(img->type == I_SLICE)  // INTRA-frame
  338|   161k|  {
  339|   161k|    if (currMB->mb_available_up == NULL)
  340|  4.58k|      b = 0;
  341|   156k|    else 
  342|   156k|      b = ((currMB->mb_available_up->mb_type != I4MB &&  currMB->mb_available_up->mb_type != I8MB) ? 1 : 0 );
  343|       |
  344|   161k|    if (currMB->mb_available_left == NULL)
  345|  2.84k|      a = 0;
  346|   158k|    else 
  347|   158k|      a = ((currMB->mb_available_left->mb_type != I4MB &&  currMB->mb_available_left->mb_type != I8MB) ? 1 : 0 );
  348|       |    
  349|   161k|    act_ctx     = a + b;
  350|   161k|    act_sym     = curr_mb_type;
  351|   161k|    se->context = act_ctx; // store context
  352|       |
  353|   161k|    if (act_sym==0) // 4x4 Intra
  354|  75.4k|    {
  355|  75.4k|      biari_encode_symbol(eep_dp, 0, ctx->mb_type_contexts[0] + act_ctx );
  356|  75.4k|    }
  357|  85.6k|    else if( act_sym == 25 ) // PCM-MODE
  358|      0|    {
  359|      0|      biari_encode_symbol(eep_dp, 1, ctx->mb_type_contexts[0] + act_ctx );
  360|       |
  361|      0|      biari_encode_symbol_final(eep_dp, 1);
  362|      0|    }
  363|  85.6k|    else // 16x16 Intra
  364|  85.6k|    {
  365|  85.6k|      biari_encode_symbol(eep_dp, 1, ctx->mb_type_contexts[0] + act_ctx );
  366|       |
  367|  85.6k|      biari_encode_symbol_final(eep_dp, 0);
  368|       |
  369|  85.6k|      mode_sym = act_sym-1; // Values in the range of 0...23
  370|  85.6k|      act_ctx  = 4;
  371|  85.6k|      act_sym  = mode_sym/12;
  372|  85.6k|      biari_encode_symbol(eep_dp, (unsigned char) act_sym, ctx->mb_type_contexts[0] + act_ctx ); // coding of AC/no AC
  373|  85.6k|      mode_sym = mode_sym % 12;
  374|  85.6k|      act_sym  = mode_sym / 4; // coding of cbp: 0,1,2
  375|  85.6k|      act_ctx  = 5;
  376|  85.6k|      if (act_sym==0)
  377|  32.6k|      {
  378|  32.6k|        biari_encode_symbol(eep_dp, 0, ctx->mb_type_contexts[0] + act_ctx );
  379|  32.6k|      }
  380|  52.9k|      else
  381|  52.9k|      {
  382|  52.9k|        biari_encode_symbol(eep_dp, 1, ctx->mb_type_contexts[0] + act_ctx );
  383|  52.9k|        act_ctx=6;
  384|  52.9k|        if (act_sym==1)
  385|  39.1k|        {
  386|  39.1k|          biari_encode_symbol(eep_dp, 0, ctx->mb_type_contexts[0] + act_ctx );
  387|  39.1k|        }
  388|  13.8k|        else
  389|  13.8k|        {
  390|  13.8k|          biari_encode_symbol(eep_dp, 1, ctx->mb_type_contexts[0] + act_ctx );
  391|  13.8k|        }
  392|  52.9k|      }
  393|  85.6k|      mode_sym = mode_sym % 4; // coding of I pred-mode: 0,1,2,3
  394|  85.6k|      act_sym  = mode_sym/2;
  395|  85.6k|      act_ctx  = 7;
  396|  85.6k|      biari_encode_symbol(eep_dp, (unsigned char) act_sym, ctx->mb_type_contexts[0] + act_ctx );
  397|  85.6k|      act_ctx  = 8;
  398|  85.6k|      act_sym  = mode_sym%2;
  399|  85.6k|      biari_encode_symbol(eep_dp, (unsigned char) act_sym, ctx->mb_type_contexts[0] + act_ctx );
  400|  85.6k|    }
  401|   161k|  }
  402|  1.20M|  else // INTER
  403|  1.20M|  {
  404|       |    
  405|  1.20M|    if (bframe)
  406|   760k|    {
  407|   760k|      if (currMB->mb_available_up == NULL)
  408|  27.5k|        b = 0;
  409|   732k|      else
  410|   732k|        b = (( currMB->mb_available_up->mb_type != 0) ? 1 : 0 );
  411|   760k|      if (currMB->mb_available_left == NULL)
  412|  17.5k|        a = 0;
  413|   742k|      else
  414|   742k|        a = (( currMB->mb_available_left->mb_type != 0) ? 1 : 0 );
  415|   760k|      act_ctx = a + b;
  416|   760k|      se->context = act_ctx; // store context
  417|   760k|    }
  418|  1.20M|    act_sym = curr_mb_type;
  419|       |
  420|  1.20M|    if (act_sym>=(mode16x16=(bframe?24:7)))
  421|   356k|    {
  422|   356k|      mode_sym = act_sym-mode16x16;
  423|   356k|      act_sym  = mode16x16; // 16x16 mode info
  424|   356k|    }
  425|       |
  426|       |
  427|       |
  428|  1.20M|    if (!bframe)
  429|   445k|    {
  430|   445k|      switch (act_sym)
  431|   445k|      {
  432|      0|      case 0:
  433|      0|        break;
  434|  43.0k|      case 1:
  435|  43.0k|        biari_encode_symbol (eep_dp, 0, &ctx->mb_type_contexts[1][4]);
  436|  43.0k|        biari_encode_symbol (eep_dp, 0, &ctx->mb_type_contexts[1][5]);
  437|  43.0k|        biari_encode_symbol (eep_dp, 0, &ctx->mb_type_contexts[1][6]);
  438|  43.0k|        break;
  439|  38.8k|      case 2:
  440|  38.8k|        biari_encode_symbol (eep_dp, 0, &ctx->mb_type_contexts[1][4]);
  441|  38.8k|        biari_encode_symbol (eep_dp, 1, &ctx->mb_type_contexts[1][5]);
  442|  38.8k|        biari_encode_symbol (eep_dp, 1, &ctx->mb_type_contexts[1][7]);
  443|  38.8k|        break;
  444|  37.4k|      case 3:
  445|  37.4k|        biari_encode_symbol (eep_dp, 0, &ctx->mb_type_contexts[1][4]);
  446|  37.4k|        biari_encode_symbol (eep_dp, 1, &ctx->mb_type_contexts[1][5]);
  447|  37.4k|        biari_encode_symbol (eep_dp, 0, &ctx->mb_type_contexts[1][7]);
  448|  37.4k|        break;
  449|  37.9k|      case 4:
  450|  37.9k|      case 5:
  451|  37.9k|        biari_encode_symbol (eep_dp, 0, &ctx->mb_type_contexts[1][4]);
  452|  37.9k|        biari_encode_symbol (eep_dp, 0, &ctx->mb_type_contexts[1][5]);
  453|  37.9k|        biari_encode_symbol (eep_dp, 1, &ctx->mb_type_contexts[1][6]);
  454|  37.9k|        break;
  455|   140k|      case 6:
  456|   140k|        biari_encode_symbol (eep_dp, 1, &ctx->mb_type_contexts[1][4]);
  457|   140k|        biari_encode_symbol (eep_dp, 0, &ctx->mb_type_contexts[1][7]);
  458|   140k|        break;
  459|   147k|      case 7:
  460|   147k|        biari_encode_symbol (eep_dp, 1, &ctx->mb_type_contexts[1][4]);
  461|   147k|        biari_encode_symbol (eep_dp, 1, &ctx->mb_type_contexts[1][7]);
  462|   147k|        break;
  463|      0|      default:
  464|      0|        printf ("Unsupported MB-MODE in writeMB_typeInfo_CABAC!\n");
  465|      0|        exit (1);
  466|   445k|      }
  467|   445k|    }
  468|   760k|    else //===== B-FRAMES =====
  469|   760k|    {
  470|   760k|      if (act_sym==0)
  471|  7.08k|      {
  472|  7.08k|        biari_encode_symbol (eep_dp, 0, &ctx->mb_type_contexts[2][act_ctx]);
  473|  7.08k|      }
  474|   753k|      else if (act_sym<=2)
  475|   116k|      {
  476|   116k|        biari_encode_symbol (eep_dp, 1, &ctx->mb_type_contexts[2][act_ctx]);
  477|   116k|        biari_encode_symbol (eep_dp, 0, &ctx->mb_type_contexts[2][4]);
  478|   116k|        csym=act_sym-1;
  479|   116k|        if (csym) biari_encode_symbol (eep_dp, 1, &ctx->mb_type_contexts[2][6]);
  480|  58.1k|        else      biari_encode_symbol (eep_dp, 0, &ctx->mb_type_contexts[2][6]);
  481|   116k|      }
  482|   636k|      else if (act_sym<=10)
  483|   156k|      {
  484|   156k|        biari_encode_symbol (eep_dp, 1, &ctx->mb_type_contexts[2][act_ctx]);
  485|   156k|        biari_encode_symbol (eep_dp, 1, &ctx->mb_type_contexts[2][4]);
  486|   156k|        biari_encode_symbol (eep_dp, 0, &ctx->mb_type_contexts[2][5]);
  487|   156k|        csym=(((act_sym-3)>>2)&0x01);
  488|   156k|        if (csym) biari_encode_symbol (eep_dp, 1, &ctx->mb_type_contexts[2][6]);
  489|   114k|        else      biari_encode_symbol (eep_dp, 0, &ctx->mb_type_contexts[2][6]);
  490|   156k|        csym=(((act_sym-3)>>1)&0x01);
  491|   156k|        if (csym) biari_encode_symbol (eep_dp, 1, &ctx->mb_type_contexts[2][6]);
  492|   102k|        else      biari_encode_symbol (eep_dp, 0, &ctx->mb_type_contexts[2][6]);
  493|   156k|        csym=((act_sym-3)&0x01);
  494|   156k|        if (csym) biari_encode_symbol (eep_dp, 1, &ctx->mb_type_contexts[2][6]);
  495|   102k|        else      biari_encode_symbol (eep_dp, 0, &ctx->mb_type_contexts[2][6]);
  496|   156k|      }
  497|   480k|      else if (act_sym==11 || act_sym==22)
  498|  59.6k|      {
  499|  59.6k|        biari_encode_symbol (eep_dp, 1, &ctx->mb_type_contexts[2][act_ctx]);
  500|  59.6k|        biari_encode_symbol (eep_dp, 1, &ctx->mb_type_contexts[2][4]);
  501|  59.6k|        biari_encode_symbol (eep_dp, 1, &ctx->mb_type_contexts[2][5]);
  502|  59.6k|        biari_encode_symbol (eep_dp, 1, &ctx->mb_type_contexts[2][6]);
  503|  59.6k|        biari_encode_symbol (eep_dp, 1, &ctx->mb_type_contexts[2][6]);
  504|  59.6k|        if (act_sym==11)  biari_encode_symbol (eep_dp, 0, &ctx->mb_type_contexts[2][6]);
  505|  54.7k|        else              biari_encode_symbol (eep_dp, 1, &ctx->mb_type_contexts[2][6]);
  506|  59.6k|      }
  507|   421k|      else
  508|   421k|      {
  509|   421k|        if (act_sym > 22) act_sym--;
  510|   421k|        biari_encode_symbol (eep_dp, 1, &ctx->mb_type_contexts[2][act_ctx]);
  511|   421k|        biari_encode_symbol (eep_dp, 1, &ctx->mb_type_contexts[2][4]);
  512|   421k|        biari_encode_symbol (eep_dp, 1, &ctx->mb_type_contexts[2][5]);
  513|   421k|        csym=(((act_sym-12)>>3)&0x01);
  514|   421k|        if (csym) biari_encode_symbol (eep_dp, 1, &ctx->mb_type_contexts[2][6]);
  515|  2.89k|        else      biari_encode_symbol (eep_dp, 0, &ctx->mb_type_contexts[2][6]);
  516|   421k|        csym=(((act_sym-12)>>2)&0x01);
  517|   421k|        if (csym) biari_encode_symbol (eep_dp, 1, &ctx->mb_type_contexts[2][6]);
  518|   419k|        else      biari_encode_symbol (eep_dp, 0, &ctx->mb_type_contexts[2][6]);
  519|   421k|        csym=(((act_sym-12)>>1)&0x01);
  520|   421k|        if (csym) biari_encode_symbol (eep_dp, 1, &ctx->mb_type_contexts[2][6]);
  521|  1.61k|        else      biari_encode_symbol (eep_dp, 0, &ctx->mb_type_contexts[2][6]);
  522|   421k|        csym=((act_sym-12)&0x01);
  523|   421k|        if (csym) biari_encode_symbol (eep_dp, 1, &ctx->mb_type_contexts[2][6]); 
  524|   210k|        else      biari_encode_symbol (eep_dp, 0, &ctx->mb_type_contexts[2][6]);
  525|   421k|        if (act_sym >=22) act_sym++;
  526|   421k|      }
  527|   760k|    }
  528|       |
  529|  1.20M|    if(act_sym==mode16x16) // additional info for 16x16 Intra-mode
  530|   356k|    {
  531|   356k|      if( mode_sym==25 )
  532|      0|      {
  533|      0|        biari_encode_symbol_final(eep_dp, 1 );
  534|      0|        return;
  535|      0|      }
  536|   356k|      biari_encode_symbol_final(eep_dp, 0 );
  537|       |
  538|   356k|      act_ctx = 8;
  539|   356k|      act_sym = mode_sym/12;
  540|   356k|      biari_encode_symbol(eep_dp, (unsigned char) act_sym, ctx->mb_type_contexts[1] + act_ctx ); // coding of AC/no AC
  541|   356k|      mode_sym = mode_sym % 12;
  542|       |
  543|   356k|      act_sym = mode_sym / 4; // coding of cbp: 0,1,2
  544|   356k|      act_ctx = 9;
  545|   356k|      if (act_sym==0)
  546|   205k|      {
  547|   205k|        biari_encode_symbol(eep_dp, 0, ctx->mb_type_contexts[1] + act_ctx );
  548|   205k|      }
  549|   150k|      else
  550|   150k|      {
  551|   150k|        biari_encode_symbol(eep_dp, 1, ctx->mb_type_contexts[1] + act_ctx );
  552|   150k|        if (act_sym==1)
  553|  99.5k|        {
  554|  99.5k|          biari_encode_symbol(eep_dp, 0, ctx->mb_type_contexts[1] + act_ctx );
  555|  99.5k|        }
  556|  50.9k|        else
  557|  50.9k|        {
  558|  50.9k|          biari_encode_symbol(eep_dp, 1, ctx->mb_type_contexts[1] + act_ctx );
  559|  50.9k|        }
  560|   150k|      }
  561|       |
  562|   356k|      mode_sym = mode_sym % 4; // coding of I pred-mode: 0,1,2,3
  563|   356k|      act_ctx  = 10;
  564|   356k|      act_sym  = mode_sym/2;
  565|   356k|      biari_encode_symbol(eep_dp, (unsigned char) act_sym, ctx->mb_type_contexts[1] + act_ctx );
  566|   356k|      act_sym  = mode_sym%2;
  567|   356k|      biari_encode_symbol(eep_dp, (unsigned char) act_sym, ctx->mb_type_contexts[1] + act_ctx );
  568|   356k|    }
  569|  1.20M|  }
  570|  1.36M|}
  571|       |
  572|       |
  573|       |/*!
  574|       | ***************************************************************************
  575|       | * \brief
  576|       | *    This function is used to arithmetically encode the 8x8 block
  577|       | *    type info
  578|       | ***************************************************************************
  579|       | */
  580|       |void writeB8_typeInfo_CABAC(SyntaxElement *se, EncodingEnvironmentPtr eep_dp)
  581|  2.04M|{
  582|  2.04M|  int act_ctx;
  583|  2.04M|  int act_sym, csym;
  584|  2.04M|  int bframe=(img->type==B_SLICE);
  585|       |
  586|  2.04M|  MotionInfoContexts *ctx    = (img->currentSlice)->mot_ctx;
  587|       |
  588|  2.04M|  act_sym = se->value1;
  589|  2.04M|  act_ctx = 0;
  590|       |
  591|  2.04M|  if (!bframe)  
  592|   735k|  {
  593|   735k|    switch (act_sym)
  594|   735k|    {
  595|   281k|    case 0:
  596|   281k|      biari_encode_symbol (eep_dp, 1, &ctx->b8_type_contexts[0][1]);
  597|   281k|      break;
  598|   155k|    case 1:
  599|   155k|      biari_encode_symbol (eep_dp, 0, &ctx->b8_type_contexts[0][1]);
  600|   155k|      biari_encode_symbol (eep_dp, 0, &ctx->b8_type_contexts[0][3]);
  601|   155k|      break;
  602|   151k|    case 2:
  603|   151k|      biari_encode_symbol (eep_dp, 0, &ctx->b8_type_contexts[0][1]);
  604|   151k|      biari_encode_symbol (eep_dp, 1, &ctx->b8_type_contexts[0][3]);
  605|   151k|      biari_encode_symbol (eep_dp, 1, &ctx->b8_type_contexts[0][4]);
  606|   151k|      break;
  607|   146k|    case 3:
  608|   146k|      biari_encode_symbol (eep_dp, 0, &ctx->b8_type_contexts[0][1]);
  609|   146k|      biari_encode_symbol (eep_dp, 1, &ctx->b8_type_contexts[0][3]);
  610|   146k|      biari_encode_symbol (eep_dp, 0, &ctx->b8_type_contexts[0][4]);
  611|   146k|      break;
  612|   735k|    }
  613|   735k|  }
  614|  1.30M|  else //===== B-FRAME =====
  615|  1.30M|  {
  616|  1.30M|    if (act_sym==0)
  617|   416k|    {
  618|   416k|      biari_encode_symbol (eep_dp, 0, &ctx->b8_type_contexts[1][0]);
  619|   416k|      return;
  620|   416k|    }
  621|   890k|    else
  622|   890k|    {
  623|   890k|      biari_encode_symbol (eep_dp, 1, &ctx->b8_type_contexts[1][0]);
  624|   890k|      act_sym--;
  625|   890k|    }
  626|   890k|    if (act_sym<2)
  627|   233k|    {
  628|   233k|      biari_encode_symbol (eep_dp, 0, &ctx->b8_type_contexts[1][1]);
  629|   233k|      if (act_sym==0)   biari_encode_symbol (eep_dp, 0, &ctx->b8_type_contexts[1][3]);
  630|   133k|      else              biari_encode_symbol (eep_dp, 1, &ctx->b8_type_contexts[1][3]);
  631|   233k|    }
  632|   657k|    else if (act_sym<6)
  633|   313k|    {
  634|   313k|      biari_encode_symbol (eep_dp, 1, &ctx->b8_type_contexts[1][1]);
  635|   313k|      biari_encode_symbol (eep_dp, 0, &ctx->b8_type_contexts[1][2]);
  636|   313k|      csym=(((act_sym-2)>>1)&0x01);
  637|   313k|      if (csym) biari_encode_symbol (eep_dp, 1, &ctx->b8_type_contexts[1][3]);
  638|  94.9k|      else      biari_encode_symbol (eep_dp, 0, &ctx->b8_type_contexts[1][3]);
  639|   313k|      csym=((act_sym-2)&0x01);
  640|   313k|      if (csym) biari_encode_symbol (eep_dp, 1, &ctx->b8_type_contexts[1][3]);
  641|  95.6k|      else      biari_encode_symbol (eep_dp, 0, &ctx->b8_type_contexts[1][3]);
  642|   313k|    }
  643|   344k|    else
  644|   344k|    {
  645|   344k|      biari_encode_symbol (eep_dp, 1, &ctx->b8_type_contexts[1][1]);
  646|   344k|      biari_encode_symbol (eep_dp, 1, &ctx->b8_type_contexts[1][2]);
  647|   344k|      csym=(((act_sym-6)>>2)&0x01);
  648|   344k|      if (csym)
  649|   125k|      {
  650|   125k|        biari_encode_symbol (eep_dp, 1, &ctx->b8_type_contexts[1][3]);
  651|   125k|        csym=((act_sym-6)&0x01);
  652|   125k|        if (csym) biari_encode_symbol (eep_dp, 1, &ctx->b8_type_contexts[1][3]);
  653|   124k|        else      biari_encode_symbol (eep_dp, 0, &ctx->b8_type_contexts[1][3]);
  654|   125k|      }
  655|   218k|      else
  656|   218k|      {
  657|   218k|        biari_encode_symbol (eep_dp, 0, &ctx->b8_type_contexts[1][3]);
  658|   218k|        csym=(((act_sym-6)>>1)&0x01);
  659|   218k|        if (csym) biari_encode_symbol (eep_dp, 1, &ctx->b8_type_contexts[1][3]);
  660|   124k|        else      biari_encode_symbol (eep_dp, 0, &ctx->b8_type_contexts[1][3]);
  661|   218k|        csym=((act_sym-6)&0x01);
  662|   218k|        if (csym) biari_encode_symbol (eep_dp, 1, &ctx->b8_type_contexts[1][3]);
  663|   125k|        else      biari_encode_symbol (eep_dp, 0, &ctx->b8_type_contexts[1][3]);
  664|   218k|      }
  665|   344k|    }
  666|   890k|  }
  667|  2.04M|}
  668|       |
  669|       |
  670|       |/*!
  671|       | ****************************************************************************
  672|       | * \brief
  673|       | *    This function is used to arithmetically encode a pair of
  674|       | *    intra prediction modes of a given MB.
  675|       | ****************************************************************************
  676|       | */
  677|       |void writeIntraPredMode_CABAC(SyntaxElement *se, EncodingEnvironmentPtr eep_dp)
  678|  66.9M|{
  679|  66.9M|  TextureInfoContexts *ctx = img->currentSlice->tex_ctx;
  680|       |
  681|       |  // use_most_probable_mode
  682|  66.9M|  if (se->value1 == -1)
  683|  12.9M|    biari_encode_symbol(eep_dp, 1, ctx->ipr_contexts);
  684|  53.9M|  else
  685|  53.9M|  {
  686|  53.9M|    biari_encode_symbol(eep_dp, 0, ctx->ipr_contexts);
  687|       |        
  688|       |    // remaining_mode_selector
  689|  53.9M|    biari_encode_symbol(eep_dp,(signed short)( se->value1 & 0x1    ), ctx->ipr_contexts+1);
  690|  53.9M|    biari_encode_symbol(eep_dp,(signed short)((se->value1 & 0x2)>>1), ctx->ipr_contexts+1);
  691|  53.9M|    biari_encode_symbol(eep_dp,(signed short)((se->value1 & 0x4)>>2), ctx->ipr_contexts+1);
  692|  53.9M|  }
  693|  66.9M|}
  694|       |/*!
  695|       | ****************************************************************************
  696|       | * \brief
  697|       | *    This function is used to arithmetically encode the reference
  698|       | *    parameter of a given MB.
  699|       | ****************************************************************************
  700|       | */
  701|       |void writeRefFrame_CABAC(SyntaxElement *se, EncodingEnvironmentPtr eep_dp)
  702|  1.51M|{
  703|  1.51M|  MotionInfoContexts  *ctx    = img->currentSlice->mot_ctx;
  704|  1.51M|  Macroblock          *currMB = &img->mb_data[img->current_mb_nr];
  705|  1.51M|  int                 addctx  = 0;
  706|       |
  707|  1.51M|  int   a, b;
  708|  1.51M|  int   act_ctx;
  709|  1.51M|  int   act_sym;
  710|  1.51M|  short** refframe_array = enc_picture->ref_idx[se->value2];
  711|       |
  712|  1.51M|  int bslice = (img->type==B_SLICE);
  713|       |
  714|  1.51M|  int   b8a, b8b;
  715|       |
  716|  1.51M|  PixelPos block_a, block_b;
  717|       |  
  718|  1.51M|  getLuma4x4Neighbour(img->current_mb_nr, img->subblock_x, img->subblock_y, -1,  0, &block_a);
  719|  1.51M|  getLuma4x4Neighbour(img->current_mb_nr, img->subblock_x, img->subblock_y,  0, -1, &block_b);
  720|       |
  721|  1.51M|  b8a=((block_a.x/2)%2)+2*((block_a.y/2)%2);
  722|  1.51M|  b8b=((block_b.x/2)%2)+2*((block_b.y/2)%2);
  723|       |
  724|       |  
  725|  1.51M|  if (!block_b.available)
  726|  41.9k|    b=0;
  727|  1.47M|  else if (IS_DIRECT(&img->mb_data[block_b.mb_addr]) || (img->mb_data[block_b.mb_addr].b8mode[b8b]==0 && bslice))
  728|   496k|    b=0;
  729|   974k|  else
  730|   974k|  {
  731|   974k|    if (img->MbaffFrameFlag && (currMB->mb_field == 0) && (img->mb_data[block_b.mb_addr].mb_field == 1))
  732|      0|      b = (refframe_array[block_b.pos_x][block_b.pos_y] > 1 ? 1 : 0);
  733|   974k|    else
  734|   974k|      b = (refframe_array[block_b.pos_x][block_b.pos_y] > 0 ? 1 : 0);
  735|   974k|  }
  736|       |
  737|  1.51M|  if (!block_a.available)
  738|  27.9k|    a=0;
  739|  1.48M|  else if (IS_DIRECT(&img->mb_data[block_a.mb_addr]) || (img->mb_data[block_a.mb_addr].b8mode[b8a]==0 && bslice))
  740|   492k|    a=0;
  741|   993k|  else 
  742|   993k|  {
  743|   993k|    if (img->MbaffFrameFlag && (currMB->mb_field == 0) && (img->mb_data[block_a.mb_addr].mb_field == 1))
  744|      0|      a = (refframe_array[block_a.pos_x][block_a.pos_y] > 1 ? 1 : 0);
  745|   993k|    else
  746|   993k|      a = (refframe_array[block_a.pos_x][block_a.pos_y] > 0 ? 1 : 0);
  747|   993k|  }
  748|       |
  749|  1.51M|  act_ctx     = a + 2*b; 
  750|  1.51M|  se->context = act_ctx; // store context
  751|  1.51M|  act_sym     = se->value1;
  752|       |
  753|  1.51M|  if (act_sym==0)
  754|  1.31M|  {
  755|  1.31M|    biari_encode_symbol(eep_dp, 0, ctx->ref_no_contexts[addctx] + act_ctx );
  756|  1.31M|  }
  757|   194k|  else
  758|   194k|  {
  759|   194k|    biari_encode_symbol(eep_dp, 1, ctx->ref_no_contexts[addctx] + act_ctx);
  760|   194k|    act_sym--;
  761|   194k|    act_ctx=4;
  762|   194k|    unary_bin_encode(eep_dp, act_sym,ctx->ref_no_contexts[addctx]+act_ctx,1);
  763|   194k|  }
  764|  1.51M|}
  765|       |
  766|       |/*!
  767|       | ****************************************************************************
  768|       | * \brief
  769|       | *    This function is used to arithmetically encode the coded
  770|       | *    block pattern of a given delta quant.
  771|       | ****************************************************************************
  772|       | */
  773|       |void writeDquant_CABAC(SyntaxElement *se, EncodingEnvironmentPtr eep_dp)
  774|   795k|{
  775|   795k|  MotionInfoContexts *ctx = img->currentSlice->mot_ctx;
  776|       |
  777|   795k|  int act_ctx;
  778|   795k|  int act_sym;
  779|   795k|  int dquant = se->value1;
  780|   795k|  int sign=0;
  781|       |
  782|   795k|  Macroblock     *currMB       = &img->mb_data[img->current_mb_nr];
  783|       |
  784|   795k|  last_dquant=currMB->prev_delta_qp;
  785|       |
  786|   795k|  if (dquant <= 0)
  787|   795k|    sign = 1;
  788|   795k|  act_sym = abs(dquant) << 1;
  789|       |
  790|   795k|  act_sym += sign;
  791|   795k|  act_sym --;
  792|       |
  793|   795k|  act_ctx = ( (last_dquant != 0) ? 1 : 0);
  794|       |
  795|   795k|  if (act_sym==0)
  796|   795k|  {
  797|   795k|    biari_encode_symbol(eep_dp, 0, ctx->delta_qp_contexts + act_ctx );
  798|   795k|  }
  799|      0|  else
  800|      0|  {
  801|      0|    biari_encode_symbol(eep_dp, 1, ctx->delta_qp_contexts + act_ctx);
  802|      0|    act_ctx=2;
  803|      0|    act_sym--;
  804|      0|    unary_bin_encode(eep_dp, act_sym,ctx->delta_qp_contexts+act_ctx,1);
  805|      0|  }
  806|   795k|}
  807|       |
  808|       |/*!
  809|       | ****************************************************************************
  810|       | * \brief
  811|       | *    This function is used to arithmetically encode the motion
  812|       | *    vector data of a B-frame MB.
  813|       | ****************************************************************************
  814|       | */
  815|       |void writeMVD_CABAC(SyntaxElement *se, EncodingEnvironmentPtr eep_dp)
  816|  8.23M|{
  817|  8.23M|  int i = img->subblock_x;
  818|  8.23M|  int j = img->subblock_y;
  819|  8.23M|  int a, b;
  820|  8.23M|  int act_ctx;
  821|  8.23M|  int act_sym;
  822|  8.23M|  int mv_pred_res;
  823|  8.23M|  int mv_local_err;
  824|  8.23M|  int mv_sign;
  825|  8.23M|  int list_idx = se->value2 & 0x01;
  826|  8.23M|  int k = (se->value2>>1); // MVD component
  827|       |
  828|  8.23M|  PixelPos block_a, block_b;
  829|       |
  830|  8.23M|  MotionInfoContexts  *ctx    = img->currentSlice->mot_ctx;
  831|  8.23M|  Macroblock          *currMB = &img->mb_data[img->current_mb_nr];
  832|       |
  833|  8.23M|  getLuma4x4Neighbour(img->current_mb_nr, i, j, -1,  0, &block_a);
  834|  8.23M|  getLuma4x4Neighbour(img->current_mb_nr, i, j,  0, -1, &block_b);
  835|       |
  836|  8.23M|  if (block_b.available)
  837|  8.05M|  {
  838|  8.05M|    b = absm(img->mb_data[block_b.mb_addr].mvd[list_idx][block_b.y][block_b.x][k]);
  839|  8.05M|    if (img->MbaffFrameFlag && (k==1)) 
  840|      0|    {
  841|      0|      if ((currMB->mb_field==0) && (img->mb_data[block_b.mb_addr].mb_field==1))
  842|      0|        b *= 2;
  843|      0|      else if ((currMB->mb_field==1) && (img->mb_data[block_b.mb_addr].mb_field==0))
  844|      0|        b /= 2;
  845|      0|    }
  846|  8.05M|  }
  847|   176k|  else
  848|   176k|    b=0;
  849|       |          
  850|  8.23M|  if (block_a.available)
  851|  8.12M|  {
  852|  8.12M|    a = absm(img->mb_data[block_a.mb_addr].mvd[list_idx][block_a.y][block_a.x][k]);
  853|  8.12M|    if (img->MbaffFrameFlag && (k==1)) 
  854|      0|    {
  855|      0|      if ((currMB->mb_field==0) && (img->mb_data[block_a.mb_addr].mb_field==1))
  856|      0|        a *= 2;
  857|      0|      else if ((currMB->mb_field==1) && (img->mb_data[block_a.mb_addr].mb_field==0))
  858|      0|        a /= 2;
  859|      0|    }
  860|  8.12M|  }
  861|   109k|  else
  862|   109k|    a = 0;
  863|       |
  864|  8.23M|  if ((mv_local_err=a+b)<3)
  865|  7.40M|    act_ctx = 5*k;
  866|   827k|  else
  867|   827k|  {
  868|   827k|    if (mv_local_err>32)
  869|   205k|      act_ctx=5*k+3;
  870|   622k|    else
  871|   622k|      act_ctx=5*k+2;
  872|   827k|  }
  873|  8.23M|  mv_pred_res = se->value1;
  874|  8.23M|  se->context = act_ctx;
  875|       |
  876|  8.23M|  act_sym = absm(mv_pred_res);
  877|       |
  878|  8.23M|  if (act_sym == 0)
  879|  7.54M|    biari_encode_symbol(eep_dp, 0, &ctx->mv_res_contexts[0][act_ctx] );
  880|   684k|  else
  881|   684k|  {
  882|   684k|    biari_encode_symbol(eep_dp, 1, &ctx->mv_res_contexts[0][act_ctx] );
  883|   684k|    act_sym--;
  884|   684k|    act_ctx=5*k;
  885|   684k|    unary_exp_golomb_mv_encode(eep_dp,act_sym,ctx->mv_res_contexts[1]+act_ctx,3);
  886|   684k|    mv_sign = (mv_pred_res<0) ? 1: 0;
  887|   684k|    biari_encode_symbol_eq_prob(eep_dp, (unsigned char) mv_sign);
  888|   684k|  }
  889|  8.23M|}
  890|       |
  891|       |
  892|       |/*!
  893|       | ****************************************************************************
  894|       | * \brief
  895|       | *    This function is used to arithmetically encode the chroma
  896|       | *    intra prediction mode of an 8x8 block
  897|       | ****************************************************************************
  898|       | */
  899|       |void writeCIPredMode_CABAC(SyntaxElement *se, EncodingEnvironmentPtr eep_dp)
  900|   867k|{
  901|   867k|  TextureInfoContexts *ctx     = img->currentSlice->tex_ctx;
  902|   867k|  Macroblock          *currMB  = &img->mb_data[img->current_mb_nr];
  903|   867k|  int                 act_ctx,a,b;
  904|   867k|  int                 act_sym  = se->value1;
  905|       |
  906|   867k|  if (currMB->mb_available_up == NULL) b = 0;
  907|   844k|  else  b = ( ((currMB->mb_available_up)->c_ipred_mode != 0) ? 1 : 0);
  908|       |
  909|   867k|  if (currMB->mb_available_left == NULL) a = 0;
  910|   852k|  else  a = ( ((currMB->mb_available_left)->c_ipred_mode != 0) ? 1 : 0);
  911|       |
  912|   867k|  act_ctx = a+b;
  913|       |
  914|   867k|  if (act_sym==0) biari_encode_symbol(eep_dp, 0, ctx->cipr_contexts + act_ctx );
  915|   642k|  else
  916|   642k|  {
  917|   642k|    biari_encode_symbol(eep_dp, 1, ctx->cipr_contexts + act_ctx );
  918|   642k|    unary_bin_max_encode(eep_dp,(unsigned int) (act_sym-1),ctx->cipr_contexts+3,0,2);
  919|   642k|  }
  920|   867k|}
  921|       |
  922|       |
  923|       |/*!
  924|       | ****************************************************************************
  925|       | * \brief
  926|       | *    This function is used to arithmetically encode the coded
  927|       | *    block pattern of an 8x8 block
  928|       | ****************************************************************************
  929|       | */
  930|       |void writeCBP_BIT_CABAC (int b8, int bit, int cbp, Macroblock* currMB, int inter, EncodingEnvironmentPtr eep_dp)
  931|  5.37M|{
  932|  5.37M|  PixelPos block_a;
  933|  5.37M|  int a, b;
  934|       |  
  935|  5.37M|  int mb_x=(b8%2)<<1;
  936|  5.37M|  int mb_y=(b8/2)<<1;
  937|       |
  938|  5.37M|  if (mb_y == 0)
  939|  2.68M|  {
  940|  2.68M|    if (currMB->mb_available_up == NULL)
  941|   114k|      b = 0;
  942|  2.57M|    else
  943|  2.57M|    {
  944|  2.57M|      if((currMB->mb_available_up)->mb_type==IPCM)
  945|      0|        b=0;
  946|  2.57M|      else
  947|  2.57M|        b = (( ((currMB->mb_available_up)->cbp & (1<<(2+mb_x/2))) == 0) ? 1 : 0);   //VG-ADD
  948|  2.57M|    }
  949|       |    
  950|  2.68M|  }
  951|  2.68M|  else
  952|  2.68M|    b = ( ((cbp & (1<<(mb_x/2))) == 0) ? 1: 0);
  953|       |  
  954|  5.37M|  if (mb_x == 0)
  955|  2.68M|  {
  956|  2.68M|    getLuma4x4Neighbour(img->current_mb_nr, mb_x, mb_y, -1, 0, &block_a);
  957|  2.68M|    if (block_a.available)
  958|  2.61M|    {
  959|  2.61M|      {
  960|  2.61M|        if(img->mb_data[block_a.mb_addr].mb_type==IPCM)
  961|      0|          a=0;
  962|  2.61M|        else
  963|  2.61M|          a = (( (img->mb_data[block_a.mb_addr].cbp & (1<<(2*(block_a.y/2)+1))) == 0) ? 1 : 0); //VG-ADD
  964|  2.61M|      }
  965|       |      
  966|  2.61M|    }
  967|  72.0k|    else
  968|  72.0k|      a=0;
  969|  2.68M|  }
  970|  2.68M|  else
  971|  2.68M|    a = ( ((cbp & (1<<mb_y)) == 0) ? 1: 0);
  972|       |  
  973|       |  //===== WRITE BIT =====
  974|  5.37M|  biari_encode_symbol (eep_dp, (unsigned char) bit,
  975|  5.37M|    img->currentSlice->tex_ctx->cbp_contexts[0] + a+2*b);
  976|  5.37M|}
  977|       |
  978|       |/*!
  979|       |****************************************************************************
  980|       |* \brief
  981|       |*    This function is used to arithmetically encode the coded
  982|       |*    block pattern of a macroblock
  983|       |****************************************************************************
  984|       |*/
  985|       |void writeCBP_CABAC(SyntaxElement *se, EncodingEnvironmentPtr eep_dp)
  986|   924k|{
  987|   924k|  TextureInfoContexts *ctx = img->currentSlice->tex_ctx;
  988|   924k|  Macroblock *currMB = &img->mb_data[img->current_mb_nr];
  989|       |  
  990|   924k|  int a, b;
  991|   924k|  int curr_cbp_ctx, curr_cbp_idx;
  992|   924k|  int cbp = se->value1; // symbol to encode
  993|   924k|  int cbp_bit;
  994|   924k|  int b8;
  995|       |  
  996|  4.62M|  for (b8=0; b8<4; b8++)
  997|  3.69M|  {
  998|  3.69M|    curr_cbp_idx = (currMB->b8mode[b8] == IBLOCK ? 0 : 1);
  999|  3.69M|    writeCBP_BIT_CABAC (b8, cbp&(1<<b8), cbp, currMB, curr_cbp_idx, eep_dp);
 1000|  3.69M|  }
 1001|       |
 1002|   924k|  if (img->yuv_format != YUV400)
 1003|   924k|  {
 1004|       |    // coding of chroma part
 1005|   924k|    b = 0;
 1006|   924k|    if (currMB->mb_available_up != NULL)
 1007|   888k|    {
 1008|   888k|      if((currMB->mb_available_up)->mb_type==IPCM)
 1009|      0|        b=1;
 1010|   888k|      else
 1011|   888k|        b = ((currMB->mb_available_up)->cbp > 15) ? 1 : 0;
 1012|   888k|    }
 1013|       |    
 1014|       |    
 1015|   924k|    a = 0;
 1016|   924k|    if (currMB->mb_available_left != NULL)
 1017|   901k|    {
 1018|   901k|      if((currMB->mb_available_left)->mb_type==IPCM)
 1019|      0|        a=1;
 1020|   901k|      else
 1021|   901k|        a = ((currMB->mb_available_left)->cbp > 15) ? 1 : 0;
 1022|   901k|    }
 1023|       |    
 1024|   924k|    curr_cbp_ctx = a+2*b;
 1025|   924k|    cbp_bit = (cbp > 15 ) ? 1 : 0;
 1026|   924k|    biari_encode_symbol(eep_dp, (unsigned char) cbp_bit, ctx->cbp_contexts[1] + curr_cbp_ctx );
 1027|       |    
 1028|   924k|    if (cbp > 15)
 1029|   234k|    {
 1030|   234k|      b = 0;
 1031|   234k|      if (currMB->mb_available_up != NULL)
 1032|   229k|      {
 1033|   229k|        if((currMB->mb_available_up)->mb_type==IPCM)
 1034|      0|          b=1;
 1035|   229k|        else
 1036|   229k|          if ((currMB->mb_available_up)->cbp > 15)
 1037|  38.0k|            b = (( ((currMB->mb_available_up)->cbp >> 4) == 2) ? 1 : 0);
 1038|   229k|      }
 1039|       |      
 1040|       |      
 1041|   234k|      a = 0;
 1042|   234k|      if (currMB->mb_available_left != NULL)
 1043|   227k|      {
 1044|   227k|        if((currMB->mb_available_left)->mb_type==IPCM)
 1045|      0|          a=1;
 1046|   227k|        else
 1047|   227k|          if ((currMB->mb_available_left)->cbp > 15)
 1048|  45.1k|            a = (( ((currMB->mb_available_left)->cbp >> 4) == 2) ? 1 : 0);
 1049|   227k|      }
 1050|       |      
 1051|   234k|      curr_cbp_ctx = a+2*b;
 1052|   234k|      cbp_bit = ((cbp>>4) == 2) ? 1 : 0;
 1053|   234k|      biari_encode_symbol(eep_dp, (unsigned char) cbp_bit, ctx->cbp_contexts[2] + curr_cbp_ctx );
 1054|   234k|    }
 1055|   924k|  }
 1056|   924k|}
 1057|       |
 1058|       |static const int maxpos       [] = {16, 15, 64, 32, 32, 16,  4, 15,  8, 16};
 1059|       |static const int c1isdc       [] = { 1,  0,  1,  1,  1,  1,  1,  0,  1,  1};
 1060|       |
 1061|       |static const int type2ctx_bcbp[] = { 0,  1,  2,  2,  3,  4,  5,  6,  5,  5}; // 7
 1062|       |static const int type2ctx_map [] = { 0,  1,  2,  3,  4,  5,  6,  7,  6,  6}; // 8
 1063|       |static const int type2ctx_last[] = { 0,  1,  2,  3,  4,  5,  6,  7,  6,  6}; // 8
 1064|       |static const int type2ctx_one [] = { 0,  1,  2,  3,  3,  4,  5,  6,  5,  5}; // 7
 1065|       |static const int type2ctx_abs [] = { 0,  1,  2,  3,  3,  4,  5,  6,  5,  5}; // 7
 1066|       |static const int max_c2       [] = { 4,  4,  4,  4,  4,  4,  3,  4,  3,  3}; // 9
 1067|       |
 1068|       |
 1069|       |
 1070|       |/*!
 1071|       | ****************************************************************************
 1072|       | * \brief
 1073|       | *    Write CBP4-BIT
 1074|       | ****************************************************************************
 1075|       | */
 1076|       |void write_and_store_CBP_block_bit (Macroblock* currMB, EncodingEnvironmentPtr eep_dp, int type, int cbp_bit)
 1077|  66.4M|{
 1078|   132M|#define BIT_SET(x,n)  ((int)(((x)&(1<<(n)))>>(n)))
 1079|       |
 1080|  66.4M|  int y_ac        = (type==LUMA_16AC || type==LUMA_8x8 || type==LUMA_8x4 || type==LUMA_4x8 || type==LUMA_4x4);
 1081|  66.4M|  int y_dc        = (type==LUMA_16DC);
 1082|  66.4M|  int u_ac        = (type==CHROMA_AC && !img->is_v_block);
 1083|  66.4M|  int v_ac        = (type==CHROMA_AC &&  img->is_v_block);
 1084|  66.4M|  int chroma_dc   = (type==CHROMA_DC || type==CHROMA_DC_2x4 || type==CHROMA_DC_4x4);
 1085|  66.4M|  int u_dc        = (chroma_dc && !img->is_v_block);
 1086|  66.4M|  int v_dc        = (chroma_dc &&  img->is_v_block);
 1087|  66.4M|  int j           = (y_ac || u_ac || v_ac ? img->subblock_y : 0);
 1088|  66.4M|  int i           = (y_ac || u_ac || v_ac ? img->subblock_x : 0);
 1089|  66.4M|  int bit         = (y_dc ? 0 : y_ac ? 1 : u_dc ? 17 : v_dc ? 18 : u_ac ? 19 : 23);
 1090|  66.4M|  int default_bit = (img->is_intra_block ? 1 : 0);
 1091|  66.4M|  int upper_bit   = default_bit;
 1092|  66.4M|  int left_bit    = default_bit;
 1093|  66.4M|  int ctx;
 1094|       |
 1095|  66.4M|  int bit_pos_a   = 0;
 1096|  66.4M|  int bit_pos_b   = 0;
 1097|       |
 1098|  66.4M|  PixelPos block_a, block_b;
 1099|  66.4M|  if (y_ac || y_dc)
 1100|  64.4M|  {
 1101|  64.4M|    getLuma4x4Neighbour(img->current_mb_nr, i, j, -1,  0, &block_a);
 1102|  64.4M|    getLuma4x4Neighbour(img->current_mb_nr, i, j,  0, -1, &block_b);
 1103|  64.4M|    if (y_ac)
 1104|  63.9M|    {
 1105|  63.9M|      if (block_a.available)
 1106|  63.8M|        bit_pos_a = 4*block_a.y + block_a.x;
 1107|  63.9M|      if (block_b.available)
 1108|  63.8M|        bit_pos_b = 4*block_b.y + block_b.x;
 1109|  63.9M|    }
 1110|  64.4M|  }
 1111|  1.99M|  else
 1112|  1.99M|  {
 1113|  1.99M|    getChroma4x4Neighbour(img->current_mb_nr, i, j, -1,  0, &block_a);
 1114|  1.99M|    getChroma4x4Neighbour(img->current_mb_nr, i, j,  0, -1, &block_b);
 1115|  1.99M|    if (u_ac||v_ac)
 1116|  1.11M|    {
 1117|  1.11M|      if (block_a.available)
 1118|  1.10M|        bit_pos_a = 2*block_a.y + block_a.x;
 1119|  1.11M|      if (block_b.available)
 1120|  1.11M|        bit_pos_b = 2*block_b.y + block_b.x;
 1121|  1.11M|    }
 1122|  1.99M|  }
 1123|       |
 1124|  66.4M|  bit         = (y_dc ? 0 : y_ac ? 1+4*j+i : u_dc ? 17 : v_dc ? 18 : u_ac ? 19+2*j+i : 23+2*j+i);
 1125|       |  //--- set bits for current block ---
 1126|  66.4M|  if (cbp_bit)
 1127|  15.4M|  {
 1128|  15.4M|    if (type==LUMA_8x8)
 1129|      0|    {
 1130|      0|      currMB->cbp_bits   |= (1<< bit   );
 1131|      0|      currMB->cbp_bits   |= (1<<(bit+1));
 1132|      0|      currMB->cbp_bits   |= (1<<(bit+4));
 1133|      0|      currMB->cbp_bits   |= (1<<(bit+5));
 1134|      0|    }
 1135|  15.4M|    else if (type==LUMA_8x4)
 1136|      0|    {
 1137|      0|      currMB->cbp_bits   |= (1<< bit   );
 1138|      0|      currMB->cbp_bits   |= (1<<(bit+1));
 1139|      0|    }
 1140|  15.4M|    else if (type==LUMA_4x8)
 1141|      0|    {
 1142|      0|      currMB->cbp_bits   |= (1<< bit   );
 1143|      0|      currMB->cbp_bits   |= (1<<(bit+4));
 1144|      0|    }
 1145|  15.4M|    else
 1146|  15.4M|    {
 1147|  15.4M|      currMB->cbp_bits   |= (1<<bit);
 1148|  15.4M|    }
 1149|  15.4M|  }
 1150|       |
 1151|  66.4M|  bit         = (y_dc ? 0 : y_ac ? 1 : u_dc ? 17 : v_dc ? 18 : u_ac ? 19 : 23);
 1152|  66.4M|  if (type!=LUMA_8x8)
 1153|  66.4M|  {
 1154|  66.4M|    if (block_b.available)
 1155|  66.2M|    {
 1156|  66.2M|      if(img->mb_data[block_b.mb_addr].mb_type==IPCM)
 1157|      0|        upper_bit=1;
 1158|  66.2M|      else
 1159|  66.2M|        upper_bit = BIT_SET(img->mb_data[block_b.mb_addr].cbp_bits,bit+bit_pos_b);
 1160|  66.2M|    }
 1161|       |
 1162|       |    
 1163|  66.4M|    if (block_a.available)
 1164|  66.2M|    {
 1165|  66.2M|      if(img->mb_data[block_a.mb_addr].mb_type==IPCM)
 1166|      0|        left_bit=1;
 1167|  66.2M|      else
 1168|  66.2M|        left_bit = BIT_SET(img->mb_data[block_a.mb_addr].cbp_bits,bit+bit_pos_a);
 1169|  66.2M|    }
 1170|       |
 1171|  66.4M|    ctx = 2*upper_bit+left_bit;
 1172|       |
 1173|       |    //===== encode symbol =====
 1174|  66.4M|    biari_encode_symbol (eep_dp, (short)cbp_bit, img->currentSlice->tex_ctx->bcbp_contexts[type2ctx_bcbp[type]]+ctx);
 1175|  66.4M|  }
 1176|  66.4M|}
 1177|       |
 1178|       |
 1179|       |
 1180|       |
 1181|       |//===== position -> ctx for MAP =====
 1182|       |//--- zig-zag scan ----
 1183|       |static const int  pos2ctx_map8x8 [] = { 0,  1,  2,  3,  4,  5,  5,  4,  4,  3,  3,  4,  4,  4,  5,  5,
 1184|       |                                        4,  4,  4,  4,  3,  3,  6,  7,  7,  7,  8,  9, 10,  9,  8,  7,
 1185|       |                                        7,  6, 11, 12, 13, 11,  6,  7,  8,  9, 14, 10,  9,  8,  6, 11,
 1186|       |                                       12, 13, 11,  6,  9, 14, 10,  9, 11, 12, 13, 11 ,14, 10, 12, 14}; // 15 CTX
 1187|       |static const int  pos2ctx_map8x4 [] = { 0,  1,  2,  3,  4,  5,  7,  8,  9, 10, 11,  9,  8,  6,  7,  8,
 1188|       |                                        9, 10, 11,  9,  8,  6, 12,  8,  9, 10, 11,  9, 13, 13, 14, 14}; // 15 CTX
 1189|       |static const int  pos2ctx_map4x4 [] = { 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 14}; // 15 CTX
 1190|       |static const int  pos2ctx_map2x4c[] = { 0,  0,  1,  1,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2}; // 15 CTX
 1191|       |static const int  pos2ctx_map4x4c[] = { 0,  0,  0,  0,  1,  1,  1,  1,  2,  2,  2,  2,  2,  2,  2,  2}; // 15 CTX
 1192|       |static const int* pos2ctx_map    [] = {pos2ctx_map4x4, pos2ctx_map4x4, pos2ctx_map8x8, pos2ctx_map8x4,
 1193|       |                                       pos2ctx_map8x4, pos2ctx_map4x4, pos2ctx_map4x4, pos2ctx_map4x4,
 1194|       |                                       pos2ctx_map2x4c, pos2ctx_map4x4c};
 1195|       |
 1196|       |//--- interlace scan ----
 1197|       |//Taken from ABT
 1198|       |static const int  pos2ctx_map8x8i[] = { 0,  1,  1,  2,  2,  3,  3,  4,  5,  6,  7,  7,  7,  8,  4,  5,
 1199|       |                                        6,  9, 10, 10,  8, 11, 12, 11,  9,  9, 10, 10,  8, 11, 12, 11,
 1200|       |                                        9,  9, 10, 10,  8, 11, 12, 11,  9,  9, 10, 10,  8, 13, 13,  9,
 1201|       |                                        9, 10, 10,  8, 13, 13,  9,  9, 10, 10, 14, 14, 14, 14, 14, 14}; // 15 CTX
 1202|       |
 1203|       |static const int  pos2ctx_map8x4i[] = { 0,  1,  2,  3,  4,  5,  6,  3,  4,  5,  6,  3,  4,  7,  6,  8,
 1204|       |                                        9,  7,  6,  8,  9, 10, 11, 12, 12, 10, 11, 13, 13, 14, 14, 14}; // 15 CTX
 1205|       |static const int  pos2ctx_map4x8i[] = { 0,  1,  1,  1,  2,  3,  3,  4,  4,  4,  5,  6,  2,  7,  7,  8,
 1206|       |                                        8,  8,  5,  6,  9, 10, 10, 11, 11, 11, 12, 13, 13, 14, 14, 14}; // 15 CTX
 1207|       |static const int* pos2ctx_map_int[] = {pos2ctx_map4x4, pos2ctx_map4x4, pos2ctx_map8x8i,pos2ctx_map8x4i,
 1208|       |                                       pos2ctx_map4x8i,pos2ctx_map4x4, pos2ctx_map4x4, pos2ctx_map4x4,
 1209|       |                                       pos2ctx_map2x4c, pos2ctx_map4x4c};
 1210|       |
 1211|       |
 1212|       |//===== position -> ctx for LAST =====
 1213|       |static const int  pos2ctx_last8x8 [] = { 0,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
 1214|       |                                         2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,
 1215|       |                                         3,  3,  3,  3,  3,  3,  3,  3,  4,  4,  4,  4,  4,  4,  4,  4,
 1216|       |                                         5,  5,  5,  5,  6,  6,  6,  6,  7,  7,  7,  7,  8,  8,  8,  8}; //  9 CTX
 1217|       |static const int  pos2ctx_last8x4 [] = { 0,  1,  1,  1,  1,  1,  1,  1,  2,  2,  2,  2,  2,  2,  2,  2,
 1218|       |                                         3,  3,  3,  3,  4,  4,  4,  4,  5,  5,  6,  6,  7,  7,  8,  8}; //  9 CTX
 1219|       |static const int  pos2ctx_last4x4 [] = { 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15}; // 15 CTX
 1220|       |static const int  pos2ctx_last2x4c[] = { 0,  0,  1,  1,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2}; // 15 CTX
 1221|       |static const int  pos2ctx_last4x4c[] = { 0,  0,  0,  0,  1,  1,  1,  1,  2,  2,  2,  2,  2,  2,  2,  2}; // 15 CTX
 1222|       |static const int* pos2ctx_last    [] = {pos2ctx_last4x4, pos2ctx_last4x4, pos2ctx_last8x8, pos2ctx_last8x4,
 1223|       |                                        pos2ctx_last8x4, pos2ctx_last4x4, pos2ctx_last4x4, pos2ctx_last4x4,
 1224|       |                                        pos2ctx_last2x4c, pos2ctx_last4x4c};
 1225|       |
 1226|       |
 1227|       |
 1228|       |
 1229|       |/*!
 1230|       |****************************************************************************
 1231|       |* \brief
 1232|       |*    Write Significance MAP
 1233|       |****************************************************************************
 1234|       |*/
 1235|       |void write_significance_map (Macroblock* currMB, EncodingEnvironmentPtr eep_dp, int type, int coeff[], int coeff_ctr)
 1236|  15.4M|{
 1237|  15.4M|  short k, sig, last;
 1238|  15.4M|  int   k0      = 0;
 1239|  15.4M|  int   k1      = maxpos[type]-1;
 1240|       |  
 1241|  15.4M|  int               fld       = ( img->structure!=FRAME || currMB->mb_field );
 1242|  15.4M|  BiContextTypePtr  map_ctx   = ( fld ? img->currentSlice->tex_ctx-> fld_map_contexts[type2ctx_map [type]]
 1243|  15.4M|    : img->currentSlice->tex_ctx->     map_contexts[type2ctx_map [type]] );
 1244|  15.4M|  BiContextTypePtr  last_ctx  = ( fld ? img->currentSlice->tex_ctx->fld_last_contexts[type2ctx_last[type]]
 1245|  15.4M|    : img->currentSlice->tex_ctx->    last_contexts[type2ctx_last[type]] );
 1246|       |  
 1247|  15.4M|  if (!c1isdc[type])
 1248|   860k|  {
 1249|   860k|    k0++; k1++; coeff--;
 1250|   860k|  }
 1251|       |
 1252|  45.2M|  for (k=k0; k<k1; k++) // if last coeff is reached, it has to be significant
 1253|  44.9M|  {
 1254|  44.9M|    sig   = (coeff[k]!=0 ? 1 : 0);
 1255|       |
 1256|  44.9M|    if (img->structure!=FRAME || currMB->mb_field)
 1257|      0|      biari_encode_symbol  (eep_dp, sig,  map_ctx+pos2ctx_map_int [type][k]);
 1258|  44.9M|    else
 1259|  44.9M|       biari_encode_symbol  (eep_dp, sig,  map_ctx+pos2ctx_map     [type][k]);
 1260|  44.9M|    if (sig)
 1261|  28.8M|    {
 1262|  28.8M|      last = (--coeff_ctr==0 ? 1 : 0);
 1263|       |
 1264|  28.8M|      biari_encode_symbol(eep_dp, last, last_ctx+pos2ctx_last[type][k]);
 1265|  28.8M|      if (last)
 1266|  15.2M|      {
 1267|  15.2M|        return;
 1268|  15.2M|      }
 1269|  28.8M|    }
 1270|  44.9M|  }
 1271|  15.4M|}
 1272|       |
 1273|       |
 1274|       |/*!
 1275|       | ****************************************************************************
 1276|       | * \brief
 1277|       | *    Write Levels
 1278|       | ****************************************************************************
 1279|       | */
 1280|       |void write_significant_coefficients (Macroblock* currMB, EncodingEnvironmentPtr eep_dp, int type, int coeff[])
 1281|  15.4M|{
 1282|  15.4M|  int   i;
 1283|  15.4M|  int   absLevel;
 1284|  15.4M|  int   ctx;
 1285|  15.4M|  short sign;
 1286|  15.4M|  short greater_one;
 1287|  15.4M|  int   c1 = 1;
 1288|  15.4M|  int   c2 = 0;
 1289|       |  
 1290|   254M|  for (i=maxpos[type]-1; i>=0; i--)
 1291|   238M|  {
 1292|   238M|    if (coeff[i]!=0)
 1293|  29.0M|    {
 1294|  29.0M|      if (coeff[i]>0) {absLevel =  coeff[i];  sign = 0;}
 1295|  14.0M|      else            {absLevel = -coeff[i];  sign = 1;}
 1296|       |
 1297|  29.0M|      greater_one = (absLevel>1 ? 1 : 0);
 1298|       |
 1299|       |      //--- if coefficient is one ---
 1300|  29.0M|      ctx = min(c1,4);    
 1301|  29.0M|      biari_encode_symbol (eep_dp, greater_one, img->currentSlice->tex_ctx->one_contexts[type2ctx_one[type]] + ctx);
 1302|       |
 1303|  29.0M|      if (greater_one)
 1304|  9.18M|      {
 1305|  9.18M|        ctx = min(c2, max_c2[type]);
 1306|  9.18M|        unary_exp_golomb_level_encode(eep_dp, absLevel-2, img->currentSlice->tex_ctx->abs_contexts[type2ctx_abs[type]] + ctx);
 1307|  9.18M|        c1 = 0;
 1308|  9.18M|        c2++;
 1309|  9.18M|      }
 1310|  19.9M|      else if (c1)
 1311|  18.1M|      {
 1312|  18.1M|        c1++;
 1313|  18.1M|      }
 1314|  29.0M|      biari_encode_symbol_eq_prob (eep_dp, sign);
 1315|  29.0M|    }
 1316|   238M|  }
 1317|  15.4M|}
 1318|       |
 1319|       |
 1320|       |
 1321|       |/*!
 1322|       | ****************************************************************************
 1323|       | * \brief
 1324|       | *    Write Block-Transform Coefficients
 1325|       | ****************************************************************************
 1326|       | */
 1327|       |void writeRunLevel_CABAC (SyntaxElement *se, EncodingEnvironmentPtr eep_dp)
 1328|  95.5M|{
 1329|  95.5M|  static int  coeff[64];
 1330|  95.5M|  static int  coeff_ctr = 0;
 1331|  95.5M|  static int  pos       = 0;
 1332|       |
 1333|  95.5M|  Macroblock* currMB    = &img->mb_data[img->current_mb_nr];
 1334|  95.5M|  int         i;
 1335|       |
 1336|       |  //--- accumulate run-level information ---
 1337|  95.5M|  if (se->value1 != 0)
 1338|  29.0M|  {
 1339|  45.2M|    for (i=0; i<se->value2; i++) coeff[pos++] = 0; coeff[pos++] = se->value1; coeff_ctr++;
 1340|  29.0M|    return;
 1341|  29.0M|  }
 1342|  66.4M|  else
 1343|  66.4M|  {
 1344|  4.27G|    for (; pos<64; pos++) coeff[pos] = 0;//xxzp 使用memset函数  //提升2% //1/9 看到这
 1345|  66.4M|  }
 1346|       |
 1347|  66.4M|  assert(pos < 65);
 1348|       |  
 1349|       |  //===== encode CBP-BIT =====
 1350|  66.4M|  write_and_store_CBP_block_bit     (currMB, eep_dp, se->context, coeff_ctr>0?1:0);
 1351|       |
 1352|  66.4M|  if (coeff_ctr>0)
 1353|  15.4M|  {
 1354|       |    //===== encode significance map =====
 1355|  15.4M|    write_significance_map          (currMB, eep_dp, se->context, coeff, coeff_ctr);
 1356|       |
 1357|       |    //===== encode significant coefficients =====
 1358|  15.4M|    write_significant_coefficients  (currMB, eep_dp, se->context, coeff);
 1359|  15.4M|  }
 1360|       |
 1361|       |  //--- reset counters ---
 1362|  66.4M|  pos = coeff_ctr = 0;
 1363|  66.4M|}
 1364|       |
 1365|       |
 1366|       |
 1367|       |
 1368|       |/*!
 1369|       | ************************************************************************
 1370|       | * \brief
 1371|       | *    Unary binarization and encoding of a symbol by using
 1372|       | *    one or two distinct models for the first two and all
 1373|       | *    remaining bins
 1374|       |*
 1375|       |************************************************************************/
 1376|       |void unary_bin_encode(EncodingEnvironmentPtr eep_dp,
 1377|       |                      unsigned int symbol,
 1378|       |                      BiContextTypePtr ctx,
 1379|       |                      int ctx_offset)
 1380|   194k|{
 1381|   194k|  unsigned int l;
 1382|   194k|  BiContextTypePtr ictx;
 1383|       |
 1384|   194k|  if (symbol==0)
 1385|   105k|  {
 1386|   105k|    biari_encode_symbol(eep_dp, 0, ctx );
 1387|   105k|    return;
 1388|   105k|  }
 1389|  88.7k|  else
 1390|  88.7k|  {
 1391|  88.7k|    biari_encode_symbol(eep_dp, 1, ctx );
 1392|  88.7k|    l=symbol;
 1393|  88.7k|    ictx=ctx+ctx_offset;
 1394|   151k|    while ((--l)>0)
 1395|  62.8k|      biari_encode_symbol(eep_dp, 1, ictx);
 1396|  88.7k|    biari_encode_symbol(eep_dp, 0, ictx);
 1397|  88.7k|  }
 1398|  88.7k|  return;
 1399|   194k|}
 1400|       |
 1401|       |/*!
 1402|       | ************************************************************************
 1403|       | * \brief
 1404|       | *    Unary binarization and encoding of a symbol by using
 1405|       | *    one or two distinct models for the first two and all
 1406|       | *    remaining bins; no terminating "0" for max_symbol
 1407|       | *    (finite symbol alphabet)
 1408|       | ************************************************************************
 1409|       | */
 1410|       |void unary_bin_max_encode(EncodingEnvironmentPtr eep_dp,
 1411|       |                          unsigned int symbol,
 1412|       |                          BiContextTypePtr ctx,
 1413|       |                          int ctx_offset,
 1414|       |                          unsigned int max_symbol)
 1415|   642k|{
 1416|   642k|  unsigned int l;
 1417|   642k|  BiContextTypePtr ictx;
 1418|       |
 1419|   642k|  if (symbol==0)
 1420|   228k|  {
 1421|   228k|    biari_encode_symbol(eep_dp, 0, ctx );
 1422|   228k|    return;
 1423|   228k|  }
 1424|   414k|  else
 1425|   414k|  {
 1426|   414k|    biari_encode_symbol(eep_dp, 1, ctx );
 1427|   414k|    l=symbol;
 1428|   414k|    ictx=ctx+ctx_offset;
 1429|   618k|    while ((--l)>0)
 1430|   204k|      biari_encode_symbol(eep_dp, 1, ictx);
 1431|   414k|    if (symbol<max_symbol)
 1432|   209k|        biari_encode_symbol(eep_dp, 0, ictx);
 1433|   414k|  }
 1434|   414k|  return;
 1435|   642k|}
 1436|       |
 1437|       |
 1438|       |
 1439|       |/*!
 1440|       | ************************************************************************
 1441|       | * \brief
 1442|       | *    Exp Golomb binarization and encoding
 1443|       | ************************************************************************
 1444|       | */
 1445|       |void exp_golomb_encode_eq_prob( EncodingEnvironmentPtr eep_dp,
 1446|       |                                unsigned int symbol,
 1447|       |                                int k) 
 1448|   524k|{
 1449|  1.22M|  while(1)
 1450|  1.22M|  {
 1451|  1.22M|    if (symbol >= (unsigned int)(1<<k))   
 1452|   702k|    {
 1453|   702k|      biari_encode_symbol_eq_prob(eep_dp, 1);   //first unary part
 1454|   702k|      symbol = symbol - (1<<k);
 1455|   702k|      k++;
 1456|   702k|    }
 1457|   524k|    else                  
 1458|   524k|    {
 1459|   524k|      biari_encode_symbol_eq_prob(eep_dp, 0);   //now terminated zero of unary part
 1460|  2.22M|      while (k--)                               //next binary part
 1461|  1.70M|        biari_encode_symbol_eq_prob(eep_dp, (unsigned char)((symbol>>k)&1)); 
 1462|   524k|      break;
 1463|   524k|    }
 1464|  1.22M|  }
 1465|       |
 1466|   524k|  return;
 1467|   524k|}
 1468|       |
 1469|       |/*!
 1470|       | ************************************************************************
 1471|       | * \brief
 1472|       | *    Exp-Golomb for Level Encoding
 1473|       |*
 1474|       |************************************************************************/
 1475|       |void unary_exp_golomb_level_encode( EncodingEnvironmentPtr eep_dp,
 1476|       |                                    unsigned int symbol,
 1477|       |                                    BiContextTypePtr ctx)
 1478|  9.18M|{
 1479|  9.18M|  unsigned int l,k;
 1480|  9.18M|  unsigned int exp_start = 13; // 15-2 : 0,1 level decision always sent
 1481|       |
 1482|  9.18M|  if (symbol==0)
 1483|  4.52M|  {
 1484|  4.52M|    biari_encode_symbol(eep_dp, 0, ctx );
 1485|  4.52M|    return;
 1486|  4.52M|  }
 1487|  4.66M|  else
 1488|  4.66M|  {
 1489|  4.66M|    biari_encode_symbol(eep_dp, 1, ctx );
 1490|  4.66M|    l=symbol;
 1491|  4.66M|    k=1;
 1492|  15.9M|    while (((--l)>0) && (++k <= exp_start))
 1493|  11.2M|      biari_encode_symbol(eep_dp, 1, ctx);
 1494|  4.66M|    if (symbol < exp_start) biari_encode_symbol(eep_dp, 0, ctx);
 1495|   190k|    else exp_golomb_encode_eq_prob(eep_dp,symbol-exp_start,0);
 1496|  4.66M|  }
 1497|  4.66M|  return;
 1498|  9.18M|}
 1499|       |
 1500|       |
 1501|       |
 1502|       |/*!
 1503|       | ************************************************************************
 1504|       | * \brief
 1505|       | *    Exp-Golomb for MV Encoding
 1506|       |*
 1507|       |************************************************************************/
 1508|       |void unary_exp_golomb_mv_encode(EncodingEnvironmentPtr eep_dp,
 1509|       |                                unsigned int symbol,
 1510|       |                                BiContextTypePtr ctx,
 1511|       |                                unsigned int max_bin)
 1512|   684k|{
 1513|   684k|  unsigned int l,k;
 1514|   684k|  unsigned int bin=1;
 1515|   684k|  BiContextTypePtr ictx=ctx;
 1516|   684k|  unsigned int exp_start = 8; // 9-1 : 0 mvd decision always sent
 1517|       |
 1518|   684k|  if (symbol==0)
 1519|   140k|  {
 1520|   140k|    biari_encode_symbol(eep_dp, 0, ictx );
 1521|   140k|    return;
 1522|   140k|  }
 1523|   544k|  else
 1524|   544k|  {
 1525|   544k|    biari_encode_symbol(eep_dp, 1, ictx );
 1526|   544k|    l=symbol;
 1527|   544k|    k=1;
 1528|   544k|    ictx++;
 1529|  3.35M|    while (((--l)>0) && (++k <= exp_start))
 1530|  2.80M|    {
 1531|  2.80M|      biari_encode_symbol(eep_dp, 1, ictx  );
 1532|  2.80M|      if ((++bin)==2) ictx++;
 1533|  2.80M|      if (bin==max_bin) ictx++;
 1534|  2.80M|    }
 1535|   544k|    if (symbol < exp_start) biari_encode_symbol(eep_dp, 0, ictx);
 1536|   333k|    else exp_golomb_encode_eq_prob(eep_dp,symbol-exp_start,3);
 1537|   544k|  }
 1538|   544k|  return;
 1539|   684k|}
 1540|       |

/home/xzp/speccpu2006-v1.0.1/benchspec/CPU2006/464.h264ref/run/build_base_ql_riscv_llvm17.0000/configfile.c:
    1|       |
    2|       |/*!
    3|       | ***********************************************************************
    4|       | * \file
    5|       | *    configfile.c
    6|       | * \brief
    7|       | *    Configuration handling.
    8|       | * \author
    9|       | *  Main contributors (see contributors.h for copyright, address and affiliation details)
   10|       | *    - Stephan Wenger           <stewe@cs.tu-berlin.de>
   11|       | * \note
   12|       | *    In the future this module should hide the Parameters and offer only
   13|       | *    Functions for their access.  Modules which make frequent use of some parameters
   14|       | *    (e.g. picture size in macroblocks) are free to buffer them on local variables.
   15|       | *    This will not only avoid global variable and make the code more readable, but also
   16|       | *    speed it up.  It will also greatly facilitate future enhancements such as the
   17|       | *    handling of different picture sizes in the same sequence.                         \n
   18|       | *                                                                                      \n
   19|       | *    For now, everything is just copied to the inp_par structure (gulp)
   20|       | *
   21|       | **************************************************************************************
   22|       | * \par Configuration File Format
   23|       | **************************************************************************************
   24|       | * Format is line oriented, maximum of one parameter per line                           \n
   25|       | *                                                                                      \n
   26|       | * Lines have the following format:                                                     \n
   27|       | * \<ParameterName\> = \<ParameterValue\> # Comments \\n                                    \n
   28|       | * Whitespace is space and \\t
   29|       | * \par
   30|       | * \<ParameterName\> are the predefined names for Parameters and are case sensitive.
   31|       | *   See configfile.h for the definition of those names and their mapping to
   32|       | *   configinput->values.
   33|       | * \par
   34|       | * \<ParameterValue\> are either integers [0..9]* or strings.
   35|       | *   Integers must fit into the wordlengths, signed values are generally assumed.
   36|       | *   Strings containing no whitespace characters can be used directly.  Strings containing
   37|       | *   whitespace characters are to be inclosed in double quotes ("string with whitespace")
   38|       | *   The double quote character is forbidden (may want to implement something smarter here).
   39|       | * \par
   40|       | * Any Parameters whose ParameterName is undefined lead to the termination of the program
   41|       | * with an error message.
   42|       | *
   43|       | * \par Known bug/Shortcoming:
   44|       | *    zero-length strings (i.e. to signal an non-existing file
   45|       | *    have to be coded as "".
   46|       | *
   47|       | * \par Rules for using command files
   48|       | *                                                                                      \n
   49|       | * All Parameters are initially taken from DEFAULTCONFIGFILENAME, defined in configfile.h.
   50|       | * If an -f \<config\> parameter is present in the command line then this file is used to
   51|       | * update the defaults of DEFAULTCONFIGFILENAME.  There can be more than one -f parameters
   52|       | * present.  If -p <ParameterName = ParameterValue> parameters are present then these
   53|       | * override the default and the additional config file's settings, and are themselves
   54|       | * overridden by future -p parameters.  There must be whitespace between -f and -p commands
   55|       | * and their respective parameters
   56|       | ***********************************************************************
   57|       | */
   58|       |
   59|       |#define INCLUDED_BY_CONFIGFILE_C
   60|       |
   61|       |#include <stdlib.h>
   62|       |#include <string.h>
   63|       |#include <assert.h>
   64|       |
   65|       |#if defined WIN32
   66|       |  #include <io.h>
   67|       |#else
   68|       |  #include <unistd.h>
   69|       |#endif
   70|       |#include <fcntl.h>
   71|       |#include <sys/stat.h>
   72|       |
   73|       |#include "global.h"
   74|       |#include "configfile.h"
   75|       |
   76|       |#include "fmo.h"
   77|       |
   78|       |#if defined(SPEC_CPU)
   79|       |InputParameters configinput;
   80|       |#endif 
   81|       |
   82|       |       char *GetConfigFileContent (char *Filename);
   83|       |static void ParseContent (char *buf, int bufsize);
   84|       |static int ParameterNameToMapIndex (char *s);
   85|       |static int InitEncoderParams();
   86|       |static int TestEncoderParams(int bitdepth_qp_scale);
   87|       |static int DisplayEncoderParams();
   88|       |static void PatchInp ();
   89|       |static void ProfileCheck();
   90|       |static void LevelCheck();
   91|       |
   92|       |
   93|       |#define MAX_ITEMS_TO_PARSE  10000
   94|       |
   95|       |
   96|       |/*!
   97|       | ***********************************************************************
   98|       | * \brief
   99|       | *   print help message and exit
  100|       | ***********************************************************************
  101|       | */
  102|       |void JMHelpExit ()
  103|      0|{
  104|      0|  fprintf( stderr, "\n   lencod [-h] [-p defenc.cfg] {[-f curenc1.cfg]...[-f curencN.cfg]}"
  105|      0|    " {[-p EncParam1=EncValue1]..[-p EncParamM=EncValueM]}\n\n"    
  106|      0|    "## Parameters\n\n"
  107|       |
  108|      0|    "## Options\n"
  109|      0|    "   -h :  prints function usage\n"
  110|      0|    "   -d :  use <defenc.cfg> as default file for parameter initializations.\n"
  111|      0|    "         If not used then file defaults to encoder.cfg in local directory.\n"
  112|      0|    "   -f :  read <curencM.cfg> for reseting selected encoder parameters.\n"
  113|      0|    "         Multiple files could be used that set different parameters\n"
  114|      0|    "   -p :  Set parameter <EncParamM> to <EncValueM>.\n"
  115|      0|    "         See default encoder.cfg file for description of all parameters.\n\n"
  116|       |    
  117|      0|    "## Supported video file formats\n"
  118|      0|    "   RAW:  .yuv -> YUV 4:2:0\n\n"
  119|       |    
  120|      0|    "## Examples of usage:\n"
  121|      0|    "   lencod\n"
  122|      0|    "   lencod  -h\n"
  123|      0|    "   lencod  -d default.cfg\n"
  124|      0|    "   lencod  -f curenc1.cfg\n"
  125|      0|    "   lencod  -f curenc1.cfg -p InputFile=\"e:\\data\\container_qcif_30.yuv\" -p SourceWidth=176 -p SourceHeight=144\n"  
  126|      0|    "   lencod  -f curenc1.cfg -p FramesToBeEncoded=30 -p QPISlice=28 -p QPPSlice=28 -p QPBSlice=30\n");
  127|       |
  128|      0|  exit(-1);
  129|      0|}
  130|       |
  131|       |/*!
  132|       | ***********************************************************************
  133|       | * \brief
  134|       | *    Parse the command line parameters and read the config files.
  135|       | * \param ac
  136|       | *    number of command line parameters
  137|       | * \param av
  138|       | *    command line parameters
  139|       | ***********************************************************************
  140|       | */
  141|       |void Configure (int ac, char *av[])
  142|      1|{
  143|      1|  char *content;
  144|      1|  int CLcount, ContentLen, NumberParams;
  145|      1|  char *filename=DEFAULTCONFIGFILENAME;
  146|       |
  147|      1|  memset (&configinput, 0, sizeof (InputParameters));
  148|       |  //Set default parameters.
  149|      1|  printf ("Setting Default Parameters...\n");
  150|      1|  InitEncoderParams();
  151|       |
  152|       |  // Process default config file
  153|      1|  CLcount = 1;
  154|       |
  155|      1|  if (ac==2)
  156|      0|  {
  157|      0|    if (0 == strncmp (av[1], "-h", 2))
  158|      0|    {
  159|      0|      JMHelpExit();
  160|      0|    }
  161|      0|  }
  162|       |
  163|      1|  if (ac>=3)
  164|      1|  {
  165|      1|    if (0 == strncmp (av[1], "-d", 2))
  166|      1|    {
  167|      1|      filename=av[2];
  168|      1|      CLcount = 3;
  169|      1|    }
  170|      1|    if (0 == strncmp (av[1], "-h", 2))
  171|      0|    {
  172|      0|      JMHelpExit();
  173|      0|    }
  174|      1|  }
  175|      1|  printf ("Parsing Configfile %s", filename);
  176|      1|  content = GetConfigFileContent (filename);
  177|      1|  if (NULL==content)
  178|      0|    error (errortext, 300);
  179|      1|  ParseContent (content, strlen(content));
  180|      1|  printf ("\n");
  181|      1|  free (content);
  182|       |
  183|       |  // Parse the command line
  184|       |
  185|      1|  while (CLcount < ac)
  186|      0|  {
  187|      0|    if (0 == strncmp (av[CLcount], "-h", 2))
  188|      0|    {
  189|      0|      JMHelpExit();
  190|      0|    }
  191|       |    
  192|      0|    if (0 == strncmp (av[CLcount], "-f", 2))  // A file parameter?
  193|      0|    {
  194|      0|      content = GetConfigFileContent (av[CLcount+1]);
  195|      0|      if (NULL==content)
  196|      0|        error (errortext, 300);
  197|      0|      printf ("Parsing Configfile %s", av[CLcount+1]);
  198|      0|      ParseContent (content, strlen (content));
  199|      0|      printf ("\n");
  200|      0|      free (content);
  201|      0|      CLcount += 2;
  202|      0|    } else
  203|      0|    {
  204|      0|      if (0 == strncmp (av[CLcount], "-p", 2))  // A config change?
  205|      0|      {
  206|       |        // Collect all data until next parameter (starting with -<x> (x is any character)),
  207|       |        // put it into content, and parse content.
  208|       |
  209|      0|        CLcount++;
  210|      0|        ContentLen = 0;
  211|      0|        NumberParams = CLcount;
  212|       |
  213|       |        // determine the necessary size for content
  214|      0|        while (NumberParams < ac && av[NumberParams][0] != '-')
  215|      0|          ContentLen += strlen (av[NumberParams++]);        // Space for all the strings
  216|      0|        ContentLen += 1000;                     // Additional 1000 bytes for spaces and \0s
  217|       |
  218|       |
  219|      0|        if ((content = malloc (ContentLen))==NULL) no_mem_exit("Configure: content");;
  220|      0|        content[0] = '\0';
  221|       |
  222|       |        // concatenate all parameters identified before
  223|       |
  224|      0|        while (CLcount < NumberParams)
  225|      0|        {
  226|      0|          char *source = &av[CLcount][0];
  227|      0|          char *destin = &content[strlen (content)];
  228|       |
  229|      0|          while (*source != '\0')
  230|      0|          {
  231|      0|            if (*source == '=')  // The Parser expects whitespace before and after '='
  232|      0|            {
  233|      0|              *destin++=' '; *destin++='='; *destin++=' ';  // Hence make sure we add it
  234|      0|            } else
  235|      0|              *destin++=*source;
  236|      0|            source++;
  237|      0|          }
  238|      0|          *destin = '\0';
  239|      0|          CLcount++;
  240|      0|        }
  241|      0|        printf ("Parsing command line string '%s'", content);
  242|      0|        ParseContent (content, strlen(content));
  243|      0|        free (content);
  244|      0|        printf ("\n");
  245|      0|      }
  246|      0|      else
  247|      0|      {
  248|      0|        snprintf (errortext, ET_SIZE, "Error in command line, ac %d, around string '%s', missing -f or -p parameters?", CLcount, av[CLcount]);
  249|      0|        error (errortext, 300);
  250|      0|      }
  251|      0|    }
  252|      0|  }
  253|      1|  printf ("\n");
  254|      1|  PatchInp();
  255|      1|  if (input->DisplayEncParams)
  256|      0|    DisplayEncoderParams();
  257|      1|}
  258|       |
  259|       |/*!
  260|       | ***********************************************************************
  261|       | * \brief
  262|       | *    allocates memory buf, opens file Filename in f, reads contents into
  263|       | *    buf and returns buf
  264|       | * \param Filename
  265|       | *    name of config file
  266|       | * \return
  267|       | *    if successfull, content of config file
  268|       | *    NULL in case of error. Error message will be set in errortext
  269|       | ***********************************************************************
  270|       | */
  271|       |char *GetConfigFileContent (char *Filename)
  272|      1|{
  273|      1|  long FileSize;
  274|      1|  FILE *f;
  275|      1|  char *buf;
  276|       |
  277|      1|  if (NULL == (f = fopen (Filename, "r")))
  278|      0|  {
  279|      0|      snprintf (errortext, ET_SIZE, "Cannot open configuration file %s.", Filename);
  280|      0|      return NULL;
  281|      0|  }
  282|       |
  283|      1|  if (0 != fseek (f, 0, SEEK_END))
  284|      0|  {
  285|      0|    snprintf (errortext, ET_SIZE, "Cannot fseek in configuration file %s.", Filename);
  286|      0|    return NULL;
  287|      0|  }
  288|       |
  289|      1|  FileSize = ftell (f);
  290|      1|  if (FileSize < 0 || FileSize > 60000)
  291|      0|  {
  292|      0|    snprintf (errortext, ET_SIZE, "Unreasonable Filesize %ld reported by ftell for configuration file %s.", FileSize, Filename);
  293|      0|    return NULL;
  294|      0|  }
  295|      1|  if (0 != fseek (f, 0, SEEK_SET))
  296|      0|  {
  297|      0|    snprintf (errortext, ET_SIZE, "Cannot fseek in configuration file %s.", Filename);
  298|      0|    return NULL;
  299|      0|  }
  300|       |
  301|      1|  if ((buf = malloc (FileSize + 1))==NULL) no_mem_exit("GetConfigFileContent: buf");
  302|       |
  303|       |  // Note that ftell() gives us the file size as the file system sees it.  The actual file size,
  304|       |  // as reported by fread() below will be often smaller due to CR/LF to CR conversion and/or
  305|       |  // control characters after the dos EOF marker in the file.
  306|       |
  307|      1|  FileSize = fread (buf, 1, FileSize, f);
  308|      1|  buf[FileSize] = '\0';
  309|       |
  310|       |
  311|      1|  fclose (f);
  312|      1|  return buf;
  313|      1|}
  314|       |
  315|       |
  316|       |/*!
  317|       | ***********************************************************************
  318|       | * \brief
  319|       | *    Parses the character array buf and writes global variable input, which is defined in
  320|       | *    configfile.h.  This hack will continue to be necessary to facilitate the addition of
  321|       | *    new parameters through the Map[] mechanism (Need compiler-generated addresses in map[]).
  322|       | * \param buf
  323|       | *    buffer to be parsed
  324|       | * \param bufsize
  325|       | *    buffer size of buffer
  326|       | ***********************************************************************
  327|       | */
  328|       |void ParseContent (char *buf, int bufsize)
  329|      1|{
  330|       |
  331|      1|  char *items[MAX_ITEMS_TO_PARSE];
  332|      1|  int MapIdx;
  333|      1|  int item = 0;
  334|      1|  int InString = 0, InItem = 0;
  335|      1|  char *p = buf;
  336|      1|  char *bufend = &buf[bufsize];
  337|      1|  int IntContent;
  338|      1|  double DoubleContent;
  339|      1|  int i;
  340|       |
  341|       |// Stage one: Generate an argc/argv-type list in items[], without comments and whitespace.
  342|       |// This is context insensitive and could be done most easily with lex(1).
  343|       |
  344|  5.94k|  while (p < bufend)
  345|  5.94k|  {
  346|  5.94k|    switch (*p)
  347|  5.94k|    {
  348|      0|      case 13:
  349|      0|        p++;
  350|      0|        break;
  351|    218|      case '#':                 // Found comment
  352|    218|        *p = '\0';              // Replace '#' with '\0' in case of comment immediately following integer or string
  353|  8.73k|        while (*p != '\n' && p < bufend)  // Skip till EOL or EOF, whichever comes first
  354|  8.51k|          p++;
  355|    218|        InString = 0;
  356|    218|        InItem = 0;
  357|    218|        break;
  358|    253|      case '\n':
  359|    253|        InItem = 0;
  360|    253|        InString = 0;
  361|    253|        *p++='\0';
  362|    253|        break;
  363|  3.58k|      case ' ':
  364|  3.59k|      case '\t':              // Skip whitespace, leave state unchanged
  365|  3.59k|        if (InString)
  366|      0|          p++;
  367|  3.59k|        else
  368|  3.59k|        {                     // Terminate non-strings once whitespace is found
  369|  3.59k|          *p++ = '\0';
  370|  3.59k|          InItem = 0;
  371|  3.59k|        }
  372|  3.59k|        break;
  373|       |
  374|     16|      case '"':               // Begin/End of String
  375|     16|        *p++ = '\0';
  376|     16|        if (!InString)
  377|      8|        {
  378|      8|          items[item++] = p;
  379|      8|          InItem = ~InItem;
  380|      8|        }
  381|      8|        else
  382|      8|          InItem = 0;
  383|     16|        InString = ~InString; // Toggle
  384|     16|        break;
  385|       |
  386|  1.86k|      default:
  387|  1.86k|        if (!InItem)
  388|    295|        {
  389|    295|          items[item++] = p;
  390|    295|          InItem = ~InItem;
  391|    295|        }
  392|  1.86k|        p++;
  393|  5.94k|    }
  394|  5.94k|  }
  395|       |
  396|      1|  item--;
  397|       |
  398|    102|  for (i=0; i<item; i+= 3)
  399|    101|  {
  400|    101|    if (0 > (MapIdx = ParameterNameToMapIndex (items[i])))
  401|      0|    {
  402|      0|      snprintf (errortext, ET_SIZE, " Parsing error in config file: Parameter Name '%s' not recognized.", items[i]);
  403|      0|      error (errortext, 300);
  404|      0|    }
  405|    101|    if (strcmp ("=", items[i+1]))
  406|      0|    {
  407|      0|      snprintf (errortext, ET_SIZE, " Parsing error in config file: '=' expected as the second token in each line.");
  408|      0|      error (errortext, 300);
  409|      0|    }
  410|       |
  411|       |    // Now interpret the Value, context sensitive...
  412|       |
  413|    101|    switch (Map[MapIdx].Type)
  414|    101|    {
  415|     92|      case 0:           // Numerical
  416|     92|        if (1 != sscanf (items[i+2], "%d", &IntContent))
  417|      0|        {
  418|      0|          snprintf (errortext, ET_SIZE, " Parsing error: Expected numerical value for Parameter of %s, found '%s'.", items[i], items[i+2]);
  419|      0|          error (errortext, 300);
  420|      0|        }
  421|     92|        * (int *) (Map[MapIdx].Place) = IntContent;
  422|     92|        printf (".");
  423|     92|        break;
  424|      8|      case 1:
  425|      8|        strncpy ((char *) Map[MapIdx].Place, items [i+2], FILE_NAME_SIZE);
  426|      8|        printf (".");
  427|      8|        break;
  428|      1|      case 2:           // Numerical double
  429|      1|        if (1 != sscanf (items[i+2], "%lf", &DoubleContent))
  430|      0|        {
  431|      0|          snprintf (errortext, ET_SIZE, " Parsing error: Expected numerical value for Parameter of %s, found '%s'.", items[i], items[i+2]);
  432|      0|          error (errortext, 300);
  433|      0|        }
  434|      1|        * (double *) (Map[MapIdx].Place) = DoubleContent;
  435|      1|        printf (".");
  436|      1|        break;
  437|      0|      default:
  438|      0|        assert ("Unknown value type in the map definition of configfile.h");
  439|    101|    }
  440|    101|  }
  441|      1|  memcpy (input, &configinput, sizeof (InputParameters));
  442|      1|}
  443|       |
  444|       |/*!
  445|       | ***********************************************************************
  446|       | * \brief
  447|       | *    Returns the index number from Map[] for a given parameter name.
  448|       | * \param s
  449|       | *    parameter name string
  450|       | * \return
  451|       | *    the index number if the string is a valid parameter name,         \n
  452|       | *    -1 for error
  453|       | ***********************************************************************
  454|       | */
  455|       |static int ParameterNameToMapIndex (char *s)
  456|    101|{
  457|    101|  int i = 0;
  458|       |
  459|  6.06k|  while (Map[i].TokenName != NULL)
  460|  6.06k|    if (0==strcmp (Map[i].TokenName, s))
  461|    101|      return i;
  462|  5.96k|    else
  463|  5.96k|      i++;
  464|      0|  return -1;
  465|    101|};
  466|       |
  467|       |/*!
  468|       | ***********************************************************************
  469|       | * \brief
  470|       | *    Sets initial values for encoding parameters.
  471|       | * \return
  472|       | *    -1 for error
  473|       | ***********************************************************************
  474|       | */
  475|       |static int InitEncoderParams()
  476|      1|{
  477|      1|  int i = 0;
  478|       |
  479|    151|  while (Map[i].TokenName != NULL)
  480|    150|  {
  481|    150|    if (Map[i].Type == 0)
  482|    133|        * (int *) (Map[i].Place) = (int) Map[i].Default;
  483|     17|    else if (Map[i].Type == 2)
  484|      7|    * (double *) (Map[i].Place) = Map[i].Default;
  485|    150|      i++;
  486|    150|  }
  487|      1|  return -1;
  488|      1|};
  489|       |
  490|       |/*!
  491|       | ***********************************************************************
  492|       | * \brief
  493|       | *    Validates encoding parameters.
  494|       | * \return
  495|       | *    -1 for error
  496|       | ***********************************************************************
  497|       | */
  498|       |static int TestEncoderParams(int bitdepth_qp_scale)
  499|      1|{
  500|      1|  int i = 0;
  501|       |
  502|    151|  while (Map[i].TokenName != NULL)
  503|    150|  {
  504|    150|    if (Map[i].param_limits == 1)
  505|     95|    {
  506|     95|      if (Map[i].Type == 0)
  507|     94|      {
  508|     94|        if ( * (int *) (Map[i].Place) < (int) Map[i].min_limit || * (int *) (Map[i].Place) > (int) Map[i].max_limit )
  509|      0|        {
  510|      0|          snprintf(errortext, ET_SIZE, "Error in input parameter %s. Check configuration file. Value should be in [%d, %d] range.", Map[i].TokenName, (int) Map[i].min_limit,(int)Map[i].max_limit );
  511|      0|          error (errortext, 400);
  512|      0|        }
  513|       |        
  514|     94|      }
  515|      1|      else if (Map[i].Type == 2)
  516|      1|      {
  517|      1|        if ( * (double *) (Map[i].Place) < Map[i].min_limit || * (double *) (Map[i].Place) > Map[i].max_limit )
  518|      0|        {
  519|      0|          snprintf(errortext, ET_SIZE, "Error in input parameter %s. Check configuration file. Value should be in [%.2f, %.2f] range.", Map[i].TokenName,Map[i].min_limit ,Map[i].max_limit );
  520|      0|          error (errortext, 400);
  521|      0|        }        
  522|      1|      }            
  523|     95|    }
  524|     55|    else if (Map[i].param_limits == 2)
  525|     33|    {
  526|     33|      if (Map[i].Type == 0)
  527|     27|      {
  528|     27|        if ( * (int *) (Map[i].Place) < (int) Map[i].min_limit )
  529|      0|        {
  530|      0|          snprintf(errortext, ET_SIZE, "Error in input parameter %s. Check configuration file. Value should not be smaller than %d.", Map[i].TokenName, (int) Map[i].min_limit);
  531|      0|          error (errortext, 400);
  532|      0|        }
  533|       |        
  534|     27|      }
  535|      6|      else if (Map[i].Type == 2)
  536|      6|      {
  537|      6|        if ( * (double *) (Map[i].Place) < Map[i].min_limit )
  538|      0|        {
  539|      0|          snprintf(errortext, ET_SIZE, "Error in input parameter %s. Check configuration file. Value should not be smaller than %2.f.", Map[i].TokenName,Map[i].min_limit);
  540|      0|          error (errortext, 400);
  541|      0|        }        
  542|      6|      }
  543|     33|    }
  544|     22|    else if (Map[i].param_limits == 3) // Only used for QPs
  545|      9|    {
  546|      9|      if (Map[i].Type == 0)
  547|      9|      {
  548|      9|        if ( * (int *) (Map[i].Place) < (int) (Map[i].min_limit - bitdepth_qp_scale) || * (int *) (Map[i].Place) > (int) Map[i].max_limit )
  549|      0|        {
  550|      0|          snprintf(errortext, ET_SIZE, "Error in input parameter %s. Check configuration file. Value should be in [%d, %d] range.", Map[i].TokenName, (int) (Map[i].min_limit - bitdepth_qp_scale),(int)Map[i].max_limit );
  551|      0|          error (errortext, 400);
  552|      0|        }
  553|       |        
  554|      9|      }
  555|      9|    }
  556|       | 
  557|    150|    i++;
  558|    150|  }
  559|      1|  return -1;
  560|      1|};
  561|       |
  562|       |
  563|       |
  564|       |/*!
  565|       | ***********************************************************************
  566|       | * \brief
  567|       | *    Outputs encoding parameters.
  568|       | * \return
  569|       | *    -1 for error
  570|       | ***********************************************************************
  571|       | */
  572|       |static int DisplayEncoderParams()
  573|      0|{
  574|      0|  int i = 0;
  575|       |
  576|      0|  printf("******************************************************\n");
  577|      0|  printf("*               Encoder Parameters                   *\n");
  578|      0|  printf("******************************************************\n");
  579|      0|  while (Map[i].TokenName != NULL)
  580|      0|  {
  581|      0|    if (Map[i].Type == 0)
  582|      0|      printf("Parameter %s = %d\n",Map[i].TokenName,* (int *) (Map[i].Place));
  583|      0|    else if (Map[i].Type == 1)
  584|      0|      printf("Parameter %s = ""%s""\n",Map[i].TokenName,(char *)  (Map[i].Place));
  585|      0|    else if (Map[i].Type == 2)
  586|      0|      printf("Parameter %s = %.2f\n",Map[i].TokenName,* (double *) (Map[i].Place));
  587|      0|      i++;
  588|      0|  }
  589|      0|  printf("******************************************************\n");
  590|      0|  return -1;
  591|      0|};
  592|       |
  593|       |/*!
  594|       | ************************************************************************
  595|       | * \brief
  596|       | *    calculate Ceil(Log2(uiVal))
  597|       | ************************************************************************
  598|       | */
  599|       |unsigned CeilLog2( unsigned uiVal)
  600|      2|{
  601|      2|  unsigned uiTmp = uiVal-1;
  602|      2|  unsigned uiRet = 0;
  603|       |
  604|     20|  while( uiTmp != 0 )
  605|     18|  {
  606|     18|    uiTmp >>= 1;
  607|     18|    uiRet++;
  608|     18|  }
  609|      2|  return uiRet;
  610|      2|}
  611|       |
  612|       |
  613|       |/*!
  614|       | ***********************************************************************
  615|       | * \brief
  616|       | *    Checks the input parameters for consistency.
  617|       | ***********************************************************************
  618|       | */
  619|       |static void PatchInp ()
  620|      1|{
  621|      1|  int bitdepth_qp_scale = 6*(input->BitDepthLuma - 8);
  622|       |  
  623|       |  // These variables are added for FMO
  624|      1|  FILE * sgfile=NULL;
  625|      1|  int i;
  626|      1|  int frame_mb_only;
  627|      1|  int mb_width, mb_height, mapunit_height;
  628|       |
  629|       |//  input->BitDepthChroma = input->BitDepthLuma;
  630|      1|  input->LowPassForIntra8x8 = 1;                    //low pass is always used
  631|       |
  632|      1|  TestEncoderParams(bitdepth_qp_scale);
  633|       |
  634|      1|  if (input->FrameRate == 0.0)
  635|      0|    input->FrameRate = INIT_FRAME_RATE;
  636|       |
  637|       |  // Set block sizes
  638|       |
  639|      1|    input->blc_size[0][0]=16;
  640|      1|    input->blc_size[0][1]=16;
  641|       |
  642|      1|    input->blc_size[1][0]=16;
  643|      1|    input->blc_size[1][1]=16;
  644|       |
  645|      1|    input->blc_size[2][0]=16;
  646|      1|    input->blc_size[2][1]= 8;
  647|       |
  648|      1|    input->blc_size[3][0]= 8;
  649|      1|    input->blc_size[3][1]=16;
  650|       |
  651|      1|    input->blc_size[4][0]= 8;
  652|      1|    input->blc_size[4][1]= 8;
  653|       |
  654|      1|    input->blc_size[5][0]= 8;
  655|      1|    input->blc_size[5][1]= 4;
  656|       |
  657|      1|    input->blc_size[6][0]= 4;
  658|      1|    input->blc_size[6][1]= 8;
  659|       |
  660|      1|    input->blc_size[7][0]= 4;
  661|      1|    input->blc_size[7][1]= 4;
  662|       |
  663|       |
  664|      1|    input->part_size[0][0] = 4;
  665|      1|    input->part_size[0][1] = 4;
  666|      1|    input->part_size[1][0] = 4;
  667|      1|    input->part_size[1][1] = 4;
  668|      1|    input->part_size[2][0] = 4;
  669|      1|    input->part_size[2][1] = 2;
  670|      1|    input->part_size[3][0] = 2;
  671|      1|    input->part_size[3][1] = 4;
  672|      1|    input->part_size[4][0] = 2;
  673|      1|    input->part_size[4][1] = 2;
  674|      1|    input->part_size[5][0] = 2;
  675|      1|    input->part_size[5][1] = 1;
  676|      1|    input->part_size[6][0] = 1;
  677|      1|    input->part_size[6][1] = 2;
  678|      1|    input->part_size[7][0] = 1;
  679|      1|    input->part_size[7][1] = 1;
  680|       |
  681|       |
  682|       |  // set proper log2_max_frame_num_minus4.
  683|      1|  {
  684|      1|    int storedBplus1 = (input->BRefPictures ) ? input->successive_Bframe + 1: 1;
  685|       |
  686|       |//    log2_max_frame_num_minus4 = max( (int)(CeilLog2(input->no_frames * storedBplus1))-4, 0);
  687|      1|    if (input->Log2MaxFrameNum < 4)
  688|      0|      log2_max_frame_num_minus4 = max( (int)(CeilLog2(input->no_frames *storedBplus1 ))-4, 0);
  689|      1|    else 
  690|      1|      log2_max_frame_num_minus4 = input->Log2MaxFrameNum - 4;
  691|       |  
  692|      1|  }
  693|       |
  694|      1|  log2_max_pic_order_cnt_lsb_minus4 = max( (int)(CeilLog2( 2*input->no_frames * (input->jumpd + 1))) -4, 0);
  695|       |
  696|       |  // B picture consistency check
  697|      1|  if(input->successive_Bframe > input->jumpd)
  698|      0|  {
  699|      0|    snprintf(errortext, ET_SIZE, "Number of B-frames %d can not exceed the number of frames skipped", input->successive_Bframe);
  700|      0|    error (errortext, 400);
  701|      0|  }
  702|       |
  703|       |  // Direct Mode consistency check
  704|      1|  if(input->successive_Bframe && input->direct_spatial_mv_pred_flag != DIR_SPATIAL && input->direct_spatial_mv_pred_flag != DIR_TEMPORAL)
  705|      0|  {
  706|      0|    snprintf(errortext, ET_SIZE, "Unsupported direct mode=%d, use TEMPORAL=0 or SPATIAL=1", input->direct_spatial_mv_pred_flag);
  707|      0|    error (errortext, 400);
  708|      0|  }
  709|       |
  710|      1|  if (input->PicInterlace>0 || input->MbInterlace>0)
  711|      0|  {
  712|      0|    if (input->directInferenceFlag==0)
  713|      0|      printf("\nDirectInferenceFlag set to 1 due to interlace coding.");
  714|      0|    input->directInferenceFlag=1;
  715|      0|  }
  716|       |
  717|      1|  if (input->PicInterlace>0)
  718|      0|  {
  719|      0|    if (input->IntraBottom!=0 && input->IntraBottom!=1)
  720|      0|    {
  721|      0|      snprintf(errortext, ET_SIZE, "Incorrect value %d for IntraBottom. Use 0 (disable) or 1 (enable).", input->IntraBottom);
  722|      0|      error (errortext, 400);
  723|      0|    }
  724|      0|  } 
  725|       |  // Cabac/UVLC consistency check
  726|      1|  if (input->symbol_mode != UVLC && input->symbol_mode != CABAC)
  727|      0|  {
  728|      0|    snprintf (errortext, ET_SIZE, "Unsupported symbol mode=%d, use UVLC=0 or CABAC=1",input->symbol_mode);
  729|      0|    error (errortext, 400);
  730|      0|  }
  731|       |
  732|       |  // Open Files
  733|      1|  if ((p_in=open(input->infile, OPENFLAGS_READ))==-1)
  734|      0|  {
  735|      0|    snprintf(errortext, ET_SIZE, "Input file %s does not exist",input->infile);
  736|      0|    error (errortext, 500);
  737|      0|  }
  738|       |
  739|      1|  if (strlen (input->ReconFile) > 0 && (p_dec=open(input->ReconFile, OPENFLAGS_WRITE, OPEN_PERMISSIONS))==-1)
  740|      0|  {
  741|      0|    snprintf(errortext, ET_SIZE, "Error open file %s", input->ReconFile);
  742|      0|    error (errortext, 500);
  743|      0|  }
  744|       |
  745|      1|  if (strlen (input->TraceFile) > 0 && (p_trace=fopen(input->TraceFile,"w"))==NULL)
  746|      0|  {
  747|      0|    snprintf(errortext, ET_SIZE, "Error open file %s", input->TraceFile);
  748|      0|    error (errortext, 500);
  749|      0|  }
  750|       |
  751|       |
  752|       |  // consistency check size information
  753|       |  /*
  754|       |  if (input->img_height % 16 != 0 || input->img_width % 16 != 0)
  755|       |  {
  756|       |    snprintf(errortext, ET_SIZE, "Unsupported image format x=%d,y=%d, must be a multiple of 16",input->img_width,input->img_height);
  757|       |    error (errortext, 400);
  758|       |  }
  759|       |
  760|       |  if (input->PicInterlace || input->MbInterlace)
  761|       |  {
  762|       |    if (input->img_height % 32 != 0 )
  763|       |    { 
  764|       |      snprintf(errortext, ET_SIZE, "Unsupported image format y=%d, must be a multiple of 32 for adaptive frame/field",input->img_height);
  765|       |      error (errortext, 400);
  766|       |    }
  767|       |  }
  768|       | */
  769|      1|  if (input->img_width % 16 != 0)
  770|      0|  {
  771|      0|    img->auto_crop_right = 16-(input->img_width % 16);
  772|      0|  }
  773|      1|  else
  774|      1|  {
  775|      1|    img->auto_crop_right=0;
  776|      1|  }
  777|      1|  if (input->PicInterlace || input->MbInterlace)
  778|      0|  {
  779|      0|    if (input->img_height % 2 != 0)
  780|      0|    {
  781|      0|      error ("even number of lines required for interlaced coding", 500);
  782|      0|    }
  783|      0|    if (input->img_height % 32 != 0)
  784|      0|    {
  785|      0|      img->auto_crop_bottom = 32-(input->img_height % 32);
  786|      0|    }
  787|      0|    else
  788|      0|    {
  789|      0|      img->auto_crop_bottom=0;
  790|      0|    }
  791|      0|  }
  792|      1|  else
  793|      1|  {
  794|      1|    if (input->img_height % 16 != 0)
  795|      0|    {
  796|      0|      img->auto_crop_bottom = 16-(input->img_height % 16);
  797|      0|    }
  798|      1|    else
  799|      1|    {
  800|      1|      img->auto_crop_bottom=0;
  801|      1|    }
  802|      1|  }
  803|      1|  if (img->auto_crop_bottom || img->auto_crop_right)
  804|      0|  {
  805|      0|    printf ("Warning: Automatical cropping activated: Coded frame Size: %dx%d\n", input->img_width+img->auto_crop_right, input->img_height+img->auto_crop_bottom);
  806|      0|  }
  807|       |
  808|       |  /*
  809|       |  // add check for MAXSLICEGROUPIDS
  810|       |  if(input->num_slice_groups_minus1>=MAXSLICEGROUPIDS)
  811|       |  {
  812|       |    snprintf(errortext, ET_SIZE, "num_slice_groups_minus1 exceeds MAXSLICEGROUPIDS");
  813|       |    error (errortext, 500);
  814|       |  }
  815|       |  */
  816|       |
  817|       |  // Following codes are to read slice group configuration from SliceGroupConfigFileName for slice group type 0,2 or 6
  818|      1|  if( (input->num_slice_groups_minus1!=0)&&
  819|      1|    ((input->slice_group_map_type == 0) || (input->slice_group_map_type == 2) || (input->slice_group_map_type == 6)) )
  820|      0|  { 
  821|      0|    if (strlen (input->SliceGroupConfigFileName) > 0 && (sgfile=fopen(input->SliceGroupConfigFileName,"r"))==NULL)
  822|      0|    {
  823|      0|      snprintf(errortext, ET_SIZE, "Error open file %s", input->SliceGroupConfigFileName);
  824|      0|      error (errortext, 500);
  825|      0|    }
  826|      0|    else
  827|      0|    {
  828|      0|      if (input->slice_group_map_type == 0) 
  829|      0|      {
  830|      0|        input->run_length_minus1=(int *)malloc(sizeof(int)*(input->num_slice_groups_minus1+1));
  831|      0|        if (NULL==input->run_length_minus1) 
  832|      0|          no_mem_exit("PatchInp: input->run_length_minus1");
  833|       |        
  834|       |        // each line contains one 'run_length_minus1' value
  835|      0|        for(i=0;i<=input->num_slice_groups_minus1;i++)
  836|      0|        {
  837|      0|          fscanf(sgfile,"%d",(input->run_length_minus1+i));
  838|      0|          fscanf(sgfile,"%*[^\n]");
  839|       |          
  840|      0|        }
  841|      0|      }
  842|      0|      else if (input->slice_group_map_type == 2)
  843|      0|      {
  844|      0|        input->top_left=(int *)malloc(sizeof(int)*input->num_slice_groups_minus1);
  845|      0|        input->bottom_right=(int *)malloc(sizeof(int)*input->num_slice_groups_minus1);
  846|      0|        if (NULL==input->top_left) 
  847|      0|          no_mem_exit("PatchInp: input->top_left");
  848|      0|        if (NULL==input->bottom_right) 
  849|      0|          no_mem_exit("PatchInp: input->bottom_right");
  850|       |        
  851|       |        // every two lines contain 'top_left' and 'bottom_right' value
  852|      0|        for(i=0;i<input->num_slice_groups_minus1;i++)
  853|      0|        {
  854|      0|          fscanf(sgfile,"%d",(input->top_left+i));
  855|      0|          fscanf(sgfile,"%*[^\n]");
  856|      0|          fscanf(sgfile,"%d",(input->bottom_right+i));
  857|      0|          fscanf(sgfile,"%*[^\n]");
  858|      0|        }
  859|       |        
  860|      0|      }
  861|      0|      else if (input->slice_group_map_type == 6)
  862|      0|      {
  863|      0|        int tmp;
  864|       |
  865|      0|        frame_mb_only = !(input->PicInterlace || input->MbInterlace);
  866|      0|        mb_width= (input->img_width+img->auto_crop_right)/16;
  867|      0|        mb_height= (input->img_height+img->auto_crop_bottom)/16;
  868|      0|        mapunit_height=mb_height/(2-frame_mb_only);
  869|       |        
  870|      0|        input->slice_group_id=(byte * ) malloc(sizeof(byte)*mapunit_height*mb_width);
  871|      0|        if (NULL==input->slice_group_id) 
  872|      0|          no_mem_exit("PatchInp: input->slice_group_id");
  873|       |        
  874|       |        // each line contains slice_group_id for one Macroblock
  875|      0|        for (i=0;i<mapunit_height*mb_width;i++)
  876|      0|        {
  877|      0|          fscanf(sgfile,"%d", &tmp);
  878|      0|          input->slice_group_id[i]= (byte) tmp;
  879|      0|          if ( *(input->slice_group_id+i) > input->num_slice_groups_minus1 )
  880|      0|          {
  881|      0|            snprintf(errortext, ET_SIZE, "Error read slice group information from file %s", input->SliceGroupConfigFileName);
  882|      0|            error (errortext, 500);
  883|      0|          }
  884|      0|          fscanf(sgfile,"%*[^\n]");
  885|      0|        }
  886|      0|      }
  887|      0|      fclose(sgfile);
  888|       |      
  889|      0|    }
  890|      0|  }
  891|       |  
  892|       |  
  893|      1|  if (input->PyramidRefReorder && input->PyramidCoding && (input->PicInterlace || input->MbInterlace))
  894|      0|  {
  895|      0|    snprintf(errortext, ET_SIZE, "PyramidRefReorder Not supported with Interlace encoding methods\n");
  896|      0|    error (errortext, 400);
  897|      0|  }
  898|       |
  899|      1|  if (input->PocMemoryManagement && input->PyramidCoding && (input->PicInterlace || input->MbInterlace))
  900|      0|  {
  901|      0|    snprintf(errortext, ET_SIZE, "PocMemoryManagement not supported with Interlace encoding methods\n");
  902|      0|    error (errortext, 400);
  903|      0|  }
  904|       |
  905|       |
  906|       |  // frame/field consistency check
  907|      1|  if (input->PicInterlace != FRAME_CODING && input->PicInterlace != ADAPTIVE_CODING && input->PicInterlace != FIELD_CODING)
  908|      0|  {
  909|      0|    snprintf (errortext, ET_SIZE, "Unsupported PicInterlace=%d, use frame based coding=0 or field based coding=1 or adaptive=2",input->PicInterlace);
  910|      0|    error (errortext, 400);
  911|      0|  }
  912|       |
  913|       |  // frame/field consistency check
  914|      1|  if (input->MbInterlace != FRAME_CODING && input->MbInterlace != ADAPTIVE_CODING && input->MbInterlace != FIELD_CODING)
  915|      0|  {
  916|      0|    snprintf (errortext, ET_SIZE, "Unsupported MbInterlace=%d, use frame based coding=0 or field based coding=1 or adaptive=2",input->MbInterlace);
  917|      0|    error (errortext, 400);
  918|      0|  }
  919|       |   
  920|       | 
  921|      1|  if ((!input->rdopt)&&(input->MbInterlace))
  922|      0|  {
  923|      0|    snprintf(errortext, ET_SIZE, "MB AFF is not compatible with non-rd-optimized coding.");
  924|      0|    error (errortext, 500);
  925|      0|  }
  926|       |
  927|      1|  if (input->rdopt>1)
  928|      0|  {
  929|      0|    snprintf(errortext, ET_SIZE, "RDOptimization=2 mode has been deactivated do to diverging of real and simulated decoders.");
  930|      0|    error (errortext, 500);
  931|      0|  }
  932|       |
  933|       |  // Tian Dong: May 31, 2002
  934|       |  // The number of frames in one sub-seq in enhanced layer should not exceed
  935|       |  // the number of reference frame number.
  936|      1|  if ( input->NumFramesInELSubSeq >= input->num_ref_frames || input->NumFramesInELSubSeq < 0 )
  937|      0|  {
  938|      0|    snprintf(errortext, ET_SIZE, "NumFramesInELSubSeq (%d) is out of range [0,%d).", input->NumFramesInELSubSeq, input->num_ref_frames);
  939|      0|    error (errortext, 500);
  940|      0|  }
  941|       |  // Tian Dong: Enhanced GOP is not supported in bitstream mode. September, 2002
  942|      1|  if ( input->NumFramesInELSubSeq > 0 && input->of_mode == PAR_OF_ANNEXB )
  943|      0|  {
  944|      0|    snprintf(errortext, ET_SIZE, "Enhanced GOP is not supported in bitstream mode and RTP mode yet.");
  945|      0|    error (errortext, 500);
  946|      0|  }
  947|       |  // Tian Dong (Sept 2002)
  948|       |  // The AFF is not compatible with spare picture for the time being.
  949|      1|  if ((input->PicInterlace || input->MbInterlace) && input->SparePictureOption == TRUE)
  950|      0|  {
  951|      0|    snprintf(errortext, ET_SIZE, "AFF is not compatible with spare picture.");
  952|      0|    error (errortext, 500);
  953|      0|  }
  954|       |
  955|       |  // Only the RTP mode is compatible with spare picture for the time being.
  956|      1|  if (input->of_mode != PAR_OF_RTP && input->SparePictureOption == TRUE)
  957|      0|  {
  958|      0|    snprintf(errortext, ET_SIZE, "Only RTP output mode is compatible with spare picture features.");
  959|      0|    error (errortext, 500);
  960|      0|  }
  961|       |
  962|      1|  if( (input->WeightedPrediction > 0 || input->WeightedBiprediction > 0) && (input->MbInterlace))
  963|      0|  {
  964|      0|    printf("Weighted prediction coding is not supported for MB AFF currently.");
  965|      0|    error (errortext, 500);
  966|      0|  }
  967|      1|  if ( input->NumFramesInELSubSeq > 0 && input->WeightedPrediction > 0)
  968|      0|  {
  969|      0|    snprintf(errortext, ET_SIZE, "Enhanced GOP is not supported in weighted prediction coding mode yet.");
  970|      0|    error (errortext, 500);
  971|      0|  }
  972|       |
  973|       |  //! the number of slice groups is forced to be 1 for slice group type 3-5
  974|      1|  if(input->num_slice_groups_minus1 > 0)
  975|      0|  {
  976|      0|    if( (input->slice_group_map_type >= 3) && (input->slice_group_map_type<=5) ) 
  977|      0|      input->num_slice_groups_minus1 = 1;
  978|      0|  }
  979|       |  
  980|       |  // Rate control
  981|      1|  if(input->RCEnable)
  982|      0|  {
  983|      0|    if ( ((input->img_height+img->auto_crop_bottom)*(input->img_width+img->auto_crop_right)/256)%input->basicunit!=0)
  984|      0|    {
  985|      0|      snprintf(errortext, ET_SIZE, "Basic unit is not defined correctly.");
  986|      0|      error (errortext, 500);
  987|      0|    }
  988|      0|  }
  989|       |
  990|      1|  if ((input->successive_Bframe)&&(input->BRefPictures)&&(input->idr_enable)&&(input->intra_period)&&(input->pic_order_cnt_type!=0))
  991|      0|  {
  992|      0|    error("Stored B pictures combined with IDR pictures only supported in Picture Order Count type 0\n",-1000);
  993|      0|  }
  994|       |  
  995|      1|  if( !input->direct_spatial_mv_pred_flag && input->num_ref_frames<2 && input->successive_Bframe >0)
  996|      0|    error("temporal direct needs at least 2 ref frames\n",-1000);
  997|       |
  998|       |  // frext
  999|      1|  if(input->AllowTransform8x8 && input->sp_periodicity /*SP-frames*/)
 1000|      0|  {
 1001|      0|    snprintf(errortext, ET_SIZE, "\nThe new 8x8 mode is not implemented for sp-frames.");
 1002|      0|    error (errortext, 500);
 1003|      0|  }
 1004|       |
 1005|      1|  if(input->AllowTransform8x8 && (input->ProfileIDC<FREXT_HP || input->ProfileIDC>FREXT_Hi444))
 1006|      0|  {
 1007|      0|    snprintf(errortext, ET_SIZE, "\nAllowTransform8x8 may be used only with ProfileIDC %d to %d.", FREXT_HP, FREXT_Hi444);
 1008|      0|    error (errortext, 500);
 1009|      0|  }
 1010|      1|  if(input->ScalingMatrixPresentFlag && (input->ProfileIDC<FREXT_HP || input->ProfileIDC>FREXT_Hi444))
 1011|      0|  {
 1012|      0|    snprintf(errortext, ET_SIZE, "\nScalingMatrixPresentFlag may be used only with ProfileIDC %d to %d.", FREXT_HP, FREXT_Hi444);
 1013|      0|    error (errortext, 500);
 1014|      0|  }
 1015|       |
 1016|      1|  if(input->yuv_format==YUV422 && input->ProfileIDC < FREXT_Hi422)
 1017|      0|  {
 1018|      0|    snprintf(errortext, ET_SIZE, "\nFRExt Profile(YUV Format) Error!\nYUV422 can be used only with ProfileIDC %d or %d\n",FREXT_Hi422, FREXT_Hi444);
 1019|      0|    error (errortext, 500);
 1020|      0|  }
 1021|      1|  if(input->yuv_format==YUV444 && input->ProfileIDC < FREXT_Hi444)
 1022|      0|  {
 1023|      0|    snprintf(errortext, ET_SIZE, "\nFRExt Profile(YUV Format) Error!\nYUV444 can be used only with ProfileIDC %d.\n",FREXT_Hi444);
 1024|      0|    error (errortext, 500);
 1025|      0|  }
 1026|       |  
 1027|       |  // Residue Color Transform
 1028|      1|  if(input->yuv_format!=YUV444 && input->residue_transform_flag)
 1029|      0|  {
 1030|      0|    snprintf(errortext, ET_SIZE, "\nResidue color transform is supported only in YUV444.");
 1031|      0|    error (errortext, 500);
 1032|      0|  }
 1033|       |
 1034|      1|  ProfileCheck();
 1035|      1|  LevelCheck();
 1036|      1|}
 1037|       |
 1038|       |void PatchInputNoFrames()
 1039|      1|{
 1040|       |  // Tian Dong: May 31, 2002
 1041|       |  // If the frames are grouped into two layers, "FramesToBeEncoded" in the config file
 1042|       |  // will give the number of frames which are in the base layer. Here we let input->no_frames
 1043|       |  // be the total frame numbers.
 1044|      1|  input->no_frames = 1+ (input->no_frames-1) * (input->NumFramesInELSubSeq+1);
 1045|      1|  if ( input->NumFrameIn2ndIGOP )
 1046|      0|    input->NumFrameIn2ndIGOP = 1+(input->NumFrameIn2ndIGOP-1) * (input->NumFramesInELSubSeq+1);
 1047|      1|  FirstFrameIn2ndIGOP = input->no_frames;
 1048|      1|}
 1049|       |
 1050|       |static void ProfileCheck()
 1051|      1|{
 1052|      1|  if((input->ProfileIDC != 66 ) &&
 1053|      1|     (input->ProfileIDC != 77 ) && 
 1054|      1|     (input->ProfileIDC != 88 ) && 
 1055|      1|     (input->ProfileIDC != FREXT_HP    ) && 
 1056|      1|     (input->ProfileIDC != FREXT_Hi10P ) && 
 1057|      1|     (input->ProfileIDC != FREXT_Hi422 ) && 
 1058|      1|     (input->ProfileIDC != FREXT_Hi444 ))
 1059|      0|  {
 1060|      0|    snprintf(errortext, ET_SIZE, "Profile must be baseline(66)/main(77)/extended(88) or FRExt (%d to %d).", FREXT_HP,FREXT_Hi444);
 1061|      0|    error (errortext, 500);
 1062|      0|  }
 1063|       |  // baseline
 1064|      1|  if (input->ProfileIDC == 66 )
 1065|      0|  {
 1066|      0|    if (input->successive_Bframe)
 1067|      0|    {
 1068|      0|      snprintf(errortext, ET_SIZE, "B pictures are not allowed in baseline.");
 1069|      0|      error (errortext, 500);
 1070|      0|    }
 1071|      0|    if (input->sp_periodicity)
 1072|      0|    {
 1073|      0|      snprintf(errortext, ET_SIZE, "SP pictures are not allowed in baseline.");
 1074|      0|      error (errortext, 500);
 1075|      0|    }
 1076|      0|    if (input->partition_mode)
 1077|      0|    {
 1078|      0|      snprintf(errortext, ET_SIZE, "Data partitioning is not allowed in baseline.");
 1079|      0|      error (errortext, 500);
 1080|      0|    }
 1081|      0|    if (input->WeightedPrediction)
 1082|      0|    {
 1083|      0|      snprintf(errortext, ET_SIZE, "Weighted prediction is not allowed in baseline.");
 1084|      0|      error (errortext, 500);
 1085|      0|    }
 1086|      0|    if (input->WeightedBiprediction)
 1087|      0|    {
 1088|      0|      snprintf(errortext, ET_SIZE, "Weighted prediction is not allowed in baseline.");
 1089|      0|      error (errortext, 500);
 1090|      0|    }
 1091|      0|    if (input->symbol_mode == CABAC)
 1092|      0|    {
 1093|      0|      snprintf(errortext, ET_SIZE, "CABAC is not allowed in baseline.");
 1094|      0|      error (errortext, 500);
 1095|      0|    }
 1096|      0|  }
 1097|       |
 1098|       |  // main
 1099|      1|  if (input->ProfileIDC == 77 )
 1100|      1|  {
 1101|      1|    if (input->sp_periodicity)
 1102|      0|    {
 1103|      0|      snprintf(errortext, ET_SIZE, "SP pictures are not allowed in main.");
 1104|      0|      error (errortext, 500);
 1105|      0|    }
 1106|      1|    if (input->partition_mode)
 1107|      0|    {
 1108|      0|      snprintf(errortext, ET_SIZE, "Data partitioning is not allowed in main.");
 1109|      0|      error (errortext, 500);
 1110|      0|    }
 1111|      1|    if (input->num_slice_groups_minus1)
 1112|      0|    {
 1113|      0|      snprintf(errortext, ET_SIZE, "num_slice_groups_minus1>0 (FMO) is not allowed in main.");
 1114|      0|      error (errortext, 500);
 1115|      0|    }
 1116|      1|    if (input->redundant_slice_flag)
 1117|      0|    {
 1118|      0|      snprintf(errortext, ET_SIZE, "Redundant pictures are not allowed in main.");
 1119|      0|      error (errortext, 500);
 1120|      0|    }
 1121|      1|  }
 1122|       |
 1123|       |  // extended
 1124|      1|  if (input->ProfileIDC == 88 )
 1125|      0|  {
 1126|      0|    if (!input->directInferenceFlag)
 1127|      0|    {
 1128|      0|      snprintf(errortext, ET_SIZE, "direct_8x8_inference flag must be equal to 1 in extended.");
 1129|      0|      error (errortext, 500);
 1130|      0|    }
 1131|       |
 1132|      0|    if (input->symbol_mode == CABAC)
 1133|      0|    {
 1134|      0|      snprintf(errortext, ET_SIZE, "CABAC is not allowed in extended.");
 1135|      0|      error (errortext, 500);
 1136|      0|    }
 1137|      0|  }
 1138|      1|}
 1139|       |
 1140|       |static void LevelCheck()
 1141|      1|{
 1142|      1|  return;
 1143|      1|}
 1144|       |

/home/xzp/speccpu2006-v1.0.1/benchspec/CPU2006/464.h264ref/run/build_base_ql_riscv_llvm17.0000/configfile.h:
    1|       |
    2|       |/*!
    3|       | ***********************************************************************
    4|       | *  \file
    5|       | *     configfile.h
    6|       | *  \brief
    7|       | *     Prototypes for configfile.c and definitions of used structures.
    8|       | ***********************************************************************
    9|       | */
   10|       |
   11|       |#include "fmo.h"
   12|       |
   13|       |#ifndef _CONFIGFILE_H_
   14|       |#define _CONFIGFILE_H_
   15|       |
   16|      1|#define DEFAULTCONFIGFILENAME "encoder.cfg"
   17|       |
   18|       |#define PROFILE_IDC     88
   19|       |#define LEVEL_IDC       21
   20|       |
   21|       |
   22|       |typedef struct {
   23|       |  char *TokenName;
   24|       |  void *Place;
   25|       |  int Type;
   26|       |  double Default;
   27|       |  int param_limits; //! 0: no limits, 1: both min and max, 2: only min (i.e. no negatives), 3: specialcase for QPs since min needs bitdepth_qp_scale
   28|       |  double min_limit;
   29|       |  double max_limit;
   30|       |} Mapping;
   31|       |
   32|       |
   33|       |
   34|       |#if defined(SPEC_CPU)
   35|       |extern InputParameters configinput;
   36|       |#else
   37|       |InputParameters configinput;
   38|       |#endif
   39|       |
   40|       |
   41|       |#ifdef INCLUDED_BY_CONFIGFILE_C
   42|       |
   43|       |Mapping Map[] = {
   44|       |    {"ProfileIDC",               &configinput.ProfileIDC,                   0,   (double) PROFILE_IDC,      0,  0.0,              0.0              },
   45|       |    {"LevelIDC",                 &configinput.LevelIDC,                     0,   (double) LEVEL_IDC,        0,  0.0,              0.0              },
   46|       |    {"FrameRate",                &configinput.FrameRate,                    2,   (double) INIT_FRAME_RATE,  1,  0.0,            100.0              },
   47|       |    {"IDRIntraEnable",           &configinput.idr_enable,                   0,   0.0,                       1,  0.0,              1.0              },
   48|       |    {"StartFrame",               &configinput.start_frame,                  0,   0.0,                       2,  0.0,              0.0              },
   49|       |    {"IntraPeriod",              &configinput.intra_period,                 0,   0.0,                       2,  0.0,              0.0              },
   50|       |    {"FramesToBeEncoded",        &configinput.no_frames,                    0,   1.0,                       2,  1.0,              0.0              },
   51|       |    {"QPISlice",                 &configinput.qp0,                          0,   24.0,                      3,  (double) MIN_QP,  (double) MAX_QP  },
   52|       |    {"QPPSlice",                 &configinput.qpN,                          0,   24.0,                      3,  (double) MIN_QP,  (double) MAX_QP  },
   53|       |    {"QPBSlice",                 &configinput.qpB,                          0,   24.0,                      3,  (double) MIN_QP,  (double) MAX_QP  },
   54|       |    {"FrameSkip",                &configinput.jumpd,                        0,   0.0,                       2,  0.0,              0.0              },
   55|       |    {"UseHadamard",              &configinput.hadamard,                     0,   0.0,                       1,  0.0,              1.0              },
   56|       |    {"UseHadamardQpelOnly",      &configinput.hadamardqpel,                 0,   0.0,                       1,  0.0,              1.0              },
   57|       |    {"SearchRange",              &configinput.search_range,                 0,   16.0,                      2,  0.0,              0.0              },
   58|       |    {"NumberReferenceFrames",    &configinput.num_ref_frames,               0,   1.0,                       1,  1.0,             16.0              },
   59|       |    {"PList0References",         &configinput.P_List0_refs,                 0,   0.0,                       1,  0.0,             16.0              },
   60|       |    {"BList0References",         &configinput.B_List0_refs,                 0,   0.0,                       1,  0.0,             16.0              },
   61|       |    {"BList1References",         &configinput.B_List1_refs,                 0,   1.0,                       1,  0.0,             16.0              },
   62|       |    {"Log2MaxFrameNum",          &configinput.Log2MaxFrameNum,              0,   0.0,                       2,  0.0,              0.0              },
   63|       |    {"GenerateMultiplePPS",      &configinput.GenerateMultiplePPS,          0,   0.0,                       1,  0.0,              1.0              },
   64|       |    {"ResendPPS",                &configinput.ResendPPS,                    0,   0.0,                       1,  0.0,              1.0              },
   65|       |    {"SourceWidth",              &configinput.img_width,                    0,   176.0,                     2, 16.0,              0.0              },
   66|       |    {"SourceHeight",             &configinput.img_height,                   0,   144.0,                     2, 16.0,              0.0              },
   67|       |    {"MbLineIntraUpdate",        &configinput.intra_upd,                    0,   0.0,                       1,  0.0,              1.0              },
   68|       |    {"SliceMode",                &configinput.slice_mode,                   0,   0.0,                       1,  0.0,              3.0              },
   69|       |    {"SliceArgument",            &configinput.slice_argument,               0,   0.0,                       2,  1.0,              1.0              },
   70|       |    {"UseConstrainedIntraPred",  &configinput.UseConstrainedIntraPred,      0,   0.0,                       1,  0.0,              1.0              },
   71|       |    {"InputFile",                &configinput.infile,                       1,   0.0,                       0,  0.0,              0.0              },
   72|       |    {"InputHeaderLength",        &configinput.infile_header,                0,   0.0,                       2,  0.0,              1.0              },
   73|       |    {"OutputFile",               &configinput.outfile,                      1,   0.0,                       0,  0.0,              0.0              },
   74|       |    {"ReconFile",                &configinput.ReconFile,                    1,   0.0,                       0,  0.0,              0.0              },
   75|       |    {"TraceFile",                &configinput.TraceFile,                    1,   0.0,                       0,  0.0,              0.0              },
   76|       |    {"NumberBFrames",            &configinput.successive_Bframe,            0,   0.0,                       2,  0.0,              0.0              },
   77|       |    {"BRefPicQPOffset",          &configinput.qpBRSOffset,                  0,   0.0,                       0,-51.0,             51.0              },
   78|       |    {"DirectModeType",           &configinput.direct_spatial_mv_pred_flag,  0,   0.0,                       1,  0.0,              1.0              },
   79|       |    {"DirectInferenceFlag",      &configinput.directInferenceFlag,          0,   0.0,                       1,  0.0,              1.0              },
   80|       |    {"SPPicturePeriodicity",     &configinput.sp_periodicity,               0,   0.0,                       2,  0.0,              0.0              },
   81|       |    {"QPSPSlice",                &configinput.qpsp,                         0,   24.0,                      3,  (double) MIN_QP,  (double) MAX_QP  },
   82|       |    {"QPSP2Slice",               &configinput.qpsp_pred,                    0,   24.0,                      3,  (double) MIN_QP,  (double) MAX_QP  },
   83|       |    {"SymbolMode",               &configinput.symbol_mode,                  0,   0.0,                       1,  (double) UVLC,    (double) CABAC   },
   84|       |    {"OutFileMode",              &configinput.of_mode,                      0,   0.0,                       1,  0.0,              1.0              },
   85|       |    {"PartitionMode",            &configinput.partition_mode,               0,   0.0,                       1,  0.0,              1.0              },
   86|       |    {"InterSearch16x16",         &configinput.InterSearch16x16,             0,   0.0,                       1,  0.0,              1.0              },
   87|       |    {"InterSearch16x8",          &configinput.InterSearch16x8 ,             0,   0.0,                       1,  0.0,              1.0              },
   88|       |    {"InterSearch8x16",          &configinput.InterSearch8x16,              0,   0.0,                       1,  0.0,              1.0              },
   89|       |    {"InterSearch8x8",           &configinput.InterSearch8x8 ,              0,   0.0,                       1,  0.0,              1.0              },
   90|       |    {"InterSearch8x4",           &configinput.InterSearch8x4,               0,   0.0,                       1,  0.0,              1.0              },
   91|       |    {"InterSearch4x8",           &configinput.InterSearch4x8,               0,   0.0,                       1,  0.0,              1.0              },
   92|       |    {"InterSearch4x4",           &configinput.InterSearch4x4,               0,   0.0,                       1,  0.0,              1.0              },
   93|       |    {"IntraDisableInterOnly",    &configinput.IntraDisableInterOnly,        0,   0.0,                       1,  0.0,              1.0              },
   94|       |    {"Intra4x4ParDisable",       &configinput.Intra4x4ParDisable,           0,   0.0,                       1,  0.0,              1.0              },
   95|       |    {"Intra4x4DiagDisable",      &configinput.Intra4x4DiagDisable,          0,   0.0,                       1,  0.0,              1.0              },
   96|       |    {"Intra4x4DirDisable",       &configinput.Intra4x4DirDisable,           0,   0.0,                       1,  0.0,              1.0              },
   97|       |    {"Intra16x16ParDisable",     &configinput.Intra16x16ParDisable,         0,   0.0,                       1,  0.0,              1.0              },
   98|       |    {"Intra16x16PlaneDisable",   &configinput.Intra16x16PlaneDisable,       0,   0.0,                       1,  0.0,              1.0              },
   99|       |    {"ChromaIntraDisable",       &configinput.ChromaIntraDisable,           0,   0.0,                       1,  0.0,              1.0              },
  100|       |
  101|       |#ifdef _FULL_SEARCH_RANGE_
  102|       |    {"RestrictSearchRange",      &configinput.full_search,                  0,   0.0,                       1,  0.0,              2.0              },
  103|       |#endif
  104|       |#ifdef _ADAPT_LAST_GROUP_
  105|       |    {"LastFrameNumber",          &configinput.last_frame,                   0,   0.0,                       2,  0.0,              0.0              },
  106|       |#endif
  107|       |#ifdef _CHANGE_QP_
  108|       |    {"ChangeQPI",                &configinput.qp02,                         0,   24.0,                      3,  (double) MIN_QP,  (double) MAX_QP  },
  109|       |    {"ChangeQPP",                &configinput.qpN2,                         0,   24.0,                      3,  (double) MIN_QP,  (double) MAX_QP  },
  110|       |    {"ChangeQPB",                &configinput.qpB2,                         0,   24.0,                      3,  (double) MIN_QP,  (double) MAX_QP  },
  111|       |    {"ChangeQPBSRefOffset",      &configinput.qpBRS2Offset,                 0,   0.0,                       1,-51.0,             51.0              },
  112|       |    {"ChangeQPStart",            &configinput.qp2start,                     0,   0.0,                       2,  0.0,              0.0              },
  113|       |#endif
  114|       |    {"RDOptimization",           &configinput.rdopt,                        0,   0.0,                       1,  0.0,              1.0              },
  115|       |    {"DisableThresholding",      &configinput.disthres,                     0,   0.0,                       1,  0.0,              1.0              },
  116|       |    {"DisableBSkipRDO",          &configinput.nobskip,                      0,   0.0,                       1,  0.0,              1.0              },
  117|       |    {"LossRateA",                &configinput.LossRateA,                    0,   0.0,                       2,  0.0,              0.0              },
  118|       |    {"LossRateB",                &configinput.LossRateB,                    0,   0.0,                       2,  0.0,              0.0              },
  119|       |    {"LossRateC",                &configinput.LossRateC,                    0,   0.0,                       2,  0.0,              0.0              },
  120|       |    {"NumberOfDecoders",         &configinput.NoOfDecoders,                 0,   0.0,                       2,  0.0,              0.0              },
  121|       |    {"RestrictRefFrames",        &configinput.RestrictRef ,                 0,   0.0,                       1,  0.0,              1.0              },
  122|       |#ifdef _LEAKYBUCKET_
  123|       |    {"NumberofLeakyBuckets",     &configinput.NumberLeakyBuckets,           0,   2.0,                       1,  2.0,              255.0            },
  124|       |    {"LeakyBucketRateFile",      &configinput.LeakyBucketRateFile,          1,   0.0,                       0,  0.0,              0.0              },
  125|       |    {"LeakyBucketParamFile",     &configinput.LeakyBucketParamFile,         1,   0.0,                       0,  0.0,              0.0              },
  126|       |#endif
  127|       |    {"PicInterlace",             &configinput.PicInterlace,                 0,   0.0,                       1,  0.0,              2.0              },
  128|       |    {"MbInterlace",              &configinput.MbInterlace,                  0,   0.0,                       1,  0.0,              2.0              },
  129|       |
  130|       |    {"IntraBottom",              &configinput.IntraBottom,                  0,   0.0,                       1,  0.0,              1.0              },
  131|       |
  132|       |    {"NumberFramesInEnhancementLayerSubSequence", &configinput.NumFramesInELSubSeq, 0,   0.0,               2,  0.0,              0.0              },
  133|       |    {"NumberOfFrameInSecondIGOP",&configinput.NumFrameIn2ndIGOP,            0,   0.0,                       2,  0.0,              0.0              },
  134|       |    {"RandomIntraMBRefresh",     &configinput.RandomIntraMBRefresh,         0,   0.0,                       2,  0.0,              0.0              },
  135|       |		
  136|       |		
  137|       |    {"WeightedPrediction",       &configinput.WeightedPrediction,           0,   0.0,                       1,  0.0,              1.0              },
  138|       |    {"WeightedBiprediction",     &configinput.WeightedBiprediction,         0,   0.0,                       1,  0.0,              2.0              },
  139|       |    {"UseWeightedReferenceME",   &configinput.UseWeightedReferenceME,       0,   0.0,                       1,  0.0,              1.0              },
  140|       |    {"RDPictureDecision",        &configinput.RDPictureDecision,            0,   0.0,                       1,  0.0,              1.0              },
  141|       |    {"RDPictureIntra",           &configinput.RDPictureIntra,               0,   0.0,                       1,  0.0,              1.0              },    
  142|       |    {"RDPSliceWeightOnly",       &configinput.RDPSliceWeightOnly,           0,   1.0,                       1,  0.0,              1.0              },    
  143|       |    {"RDBSliceWeightOnly",       &configinput.RDBSliceWeightOnly,           0,   0.0,                       1,  0.0,              1.0              },    
  144|       |
  145|       |    {"SkipIntraInInterSlices",   &configinput.SkipIntraInInterSlices,       0,   0.0,                       1,  0.0,              1.0              },    
  146|       |    {"BReferencePictures",       &configinput.BRefPictures,                 0,   0.0,                       1,  0.0,              1.0              },
  147|       |    {"PyramidCoding",            &configinput.PyramidCoding,                0,   0.0,                       1,  0.0,              3.0              },
  148|       |    {"ExplicitPyramidFormat",    &configinput.ExplicitPyramidFormat,        1,   0.0,                       0,  0.0,              0.0              },
  149|       |    {"PyramidRefReorder",        &configinput.PyramidRefReorder,            0,   0.0,                       1,  0.0,              1.0              },
  150|       |    {"PocMemoryManagement",      &configinput.PocMemoryManagement,          0,   0.0,                       1,  0.0,              1.0              },
  151|       |#if BI_PREDICTION
  152|       |    {"BiPredMotionEstimation",   &configinput.BiPredMotionEstimation,       0,   0.0,                       1,  0.0,              1.0              },
  153|       |    {"BiPredMERefinements",      &configinput.BiPredMERefinements,          0,   0.0,                       1,  0.0,              5.0              },
  154|       |    {"BiPredMESearchRange",      &configinput.BiPredMESearchRange,          0,   8.0,                       2,  0.0,              0.0              },
  155|       |    {"BiPredMESubPel",           &configinput.BiPredMESubPel,               0,   1.0,                       1,  0.0,              2.0              },
  156|       |#endif
  157|       |
  158|       |    {"LoopFilterParametersFlag", &configinput.LFSendParameters,             0,   0.0,                       1,  0.0,              1.0              },
  159|       |    {"LoopFilterDisable",        &configinput.LFDisableIdc,                 0,   0.0,                       1,  0.0,              2.0              },
  160|       |    {"LoopFilterAlphaC0Offset",  &configinput.LFAlphaC0Offset,              0,   0.0,                       1, -6.0,              6.0              },
  161|       |    {"LoopFilterBetaOffset",     &configinput.LFBetaOffset,                 0,   0.0,                       1, -6.0,              6.0              },
  162|       |    {"SparePictureOption",       &configinput.SparePictureOption,           0,   0.0,                       1,  0.0,              1.0              },
  163|       |    {"SparePictureDetectionThr", &configinput.SPDetectionThreshold,         0,   0.0,                       2,  0.0,              0.0              },
  164|       |    {"SparePicturePercentageThr",&configinput.SPPercentageThreshold,        0,   0.0,                       2,  0.0,            100.0              },
  165|       |
  166|       |    {"num_slice_groups_minus1",  &configinput.num_slice_groups_minus1,      0,   0.0,                       1,  0.0,  (double)MAXSLICEGROUPIDS - 1 },
  167|       |    {"slice_group_map_type",     &configinput.slice_group_map_type,         0,   0.0,                       1,  0.0,              6.0              },               
  168|       |    {"slice_group_change_direction_flag", &configinput.slice_group_change_direction_flag, 0,   0.0,         1,  0.0,              2.0              },
  169|       |    {"slice_group_change_rate_minus1",    &configinput.slice_group_change_rate_minus1,    0,   0.0,         2,  0.0,              1.0              },
  170|       |    {"SliceGroupConfigFileName", &configinput.SliceGroupConfigFileName,     1,   0.0,                       0,  0.0,              0.0              },
  171|       |		
  172|       |
  173|       |    {"UseRedundantSlice",        &configinput.redundant_slice_flag,         0,   0.0,                       1,  0.0,              1.0              },
  174|       |    {"PicOrderCntType",          &configinput.pic_order_cnt_type,           0,   0.0,                       1,  0.0,              2.0              },
  175|       |
  176|       |    {"ContextInitMethod",        &configinput.context_init_method,          0,   0.0,                       1,  0.0,              1.0              },
  177|       |    {"FixedModelNumber",         &configinput.model_number,                 0,   0.0,                       1,  0.0,              2.0              },
  178|       |
  179|       |    {"Transform8x8Mode",         &configinput.AllowTransform8x8,            0,   0.0,                       1,  0.0,              2.0              },
  180|       |    {"ReportFrameStats",         &configinput.ReportFrameStats,             0,   0.0,                       1,  0.0,              1.0              },
  181|       |    {"DisplayEncParams",         &configinput.DisplayEncParams,             0,   0.0,                       1,  0.0,              1.0              },
  182|       |    // Rate Control
  183|       |    {"RateControlEnable",        &configinput.RCEnable,                     0,   0.0,                       1,  0.0,              1.0              },
  184|       |    {"Bitrate",                  &configinput.bit_rate,                     0,   0.0,                       2,  0.0,              0.0              },
  185|       |    {"InitialQP",                &configinput.SeinitialQP,                  0,   0.0,                       3,  (double) MIN_QP,  (double) MAX_QP  },
  186|       |    {"BasicUnit",                &configinput.basicunit,                    0,   0.0,                       2,  0.0,              0.0              },
  187|       |    {"ChannelType",              &configinput.channel_type,                 0,   0.0,                       1,  0.0,              1.0              },
  188|       |
  189|       |    // Q_Matrix
  190|       |    {"QmatrixFile",              &configinput.QmatrixFile,                  1,   0.0,                       0,  0.0,              0.0              },
  191|       |    {"ScalingMatrixPresentFlag", &configinput.ScalingMatrixPresentFlag,     0,   0.0,                       1,  0.0,              3.0              },
  192|       |    {"ScalingListPresentFlag0",  &configinput.ScalingListPresentFlag[0],    0,   0.0,                       1,  0.0,              3.0              },
  193|       |    {"ScalingListPresentFlag1",  &configinput.ScalingListPresentFlag[1],    0,   0.0,                       1,  0.0,              3.0              },
  194|       |    {"ScalingListPresentFlag2",  &configinput.ScalingListPresentFlag[2],    0,   0.0,                       1,  0.0,              3.0              },
  195|       |    {"ScalingListPresentFlag3",  &configinput.ScalingListPresentFlag[3],    0,   0.0,                       1,  0.0,              3.0              },
  196|       |    {"ScalingListPresentFlag4",  &configinput.ScalingListPresentFlag[4],    0,   0.0,                       1,  0.0,              3.0              },
  197|       |    {"ScalingListPresentFlag5",  &configinput.ScalingListPresentFlag[5],    0,   0.0,                       1,  0.0,              3.0              },
  198|       |    {"ScalingListPresentFlag6",  &configinput.ScalingListPresentFlag[6],    0,   0.0,                       1,  0.0,              3.0              },
  199|       |    {"ScalingListPresentFlag7",  &configinput.ScalingListPresentFlag[7],    0,   0.0,                       1,  0.0,              3.0              },
  200|       |
  201|       |    // Fast ME enable
  202|       |    {"UseFME",                   &configinput.FMEnable,                     0,   0.0,                       1,  0.0,              1.0              },
  203|       |
  204|       |    {"ChromaQPOffset",           &configinput.chroma_qp_index_offset,       0,   0.0,                       1,-51.0,             51.0              },
  205|       |
  206|       |    // Fidelity Range Extensions
  207|       |    {"BitDepthLuma",             &configinput.BitDepthLuma,                 0,   8.0,                       1,  8.0,             12.0              },
  208|       |    {"BitDepthChroma",           &configinput.BitDepthChroma,               0,   8.0,                       1,  8.0,             12.0              },
  209|       |    {"YUVFormat",                &configinput.yuv_format,                   0,   1.0,                       1,  0.0,              3.0              },
  210|       |    {"RGBInput",                 &configinput.rgb_input_flag,               0,   0.0,                       1,  0.0,              1.0              },
  211|       |    {"CbQPOffset",               &configinput.cb_qp_index_offset,           0,   0.0,                       1,-51.0,             51.0              },
  212|       |    {"CrQPOffset",               &configinput.cr_qp_index_offset,           0,   0.0,                       1,-51.0,             51.0              },
  213|       |   
  214|       |    // Lossless Coding
  215|       |    {"QPPrimeYZeroTransformBypassFlag", &configinput.lossless_qpprime_y_zero_flag,      0,   0.0,           1,  0.0,              1.0              },
  216|       |
  217|       |    // Residue Color Transform
  218|       |    {"ResidueTransformFlag",     &configinput.residue_transform_flag ,      0,   0.0,                       1,  0.0,              1.0              },
  219|       |
  220|       |    // Explicit Lambda Usage
  221|       |    {"UseExplicitLambdaParams",  &configinput.UseExplicitLambdaParams,      0,   0.0,                       1,  0.0,              3.0              },
  222|       |    {"LambdaWeightPslice",       &configinput.LambdaWeight[0],              2,   0.68,                      2,  0.0,              0.0              },
  223|       |    {"LambdaWeightBslice",       &configinput.LambdaWeight[1],              2,   2.00,                      2,  0.0,              0.0              },
  224|       |    {"LambdaWeightIslice",       &configinput.LambdaWeight[2],              2,   0.65,                      2,  0.0,              0.0              },
  225|       |    {"LambdaWeightSPslice",      &configinput.LambdaWeight[3],              2,   1.50,                      2,  0.0,              0.0              },
  226|       |    {"LambdaWeightSIslice",      &configinput.LambdaWeight[4],              2,   0.65,                      2,  0.0,              0.0              },
  227|       |    {"LambdaWeightRefBslice",    &configinput.LambdaWeight[5],              2,   1.50,                      2,  0.0,              0.0              },
  228|       |    
  229|       |    {"QOffsetMatrixFile",        &configinput.QOffsetMatrixFile,            1,   0.0,                       0,  0.0,              0.0              },
  230|       |    {"OffsetMatrixPresentFlag",  &configinput.OffsetMatrixPresentFlag,      0,   0.0,                       1,  0.0,              3.0              },
  231|       |
  232|       |    {NULL,                       NULL,                                     -1,   0.0,                       0,  0.0,              0.0              }
  233|       |};
  234|       |
  235|       |#endif
  236|       |
  237|       |#ifndef INCLUDED_BY_CONFIGFILE_C
  238|       |extern Mapping Map[];
  239|       |#endif
  240|       |
  241|       |
  242|       |void Configure (int ac, char *av[]);
  243|       |void PatchInputNoFrames();
  244|       |
  245|       |#endif
  246|       |

/home/xzp/speccpu2006-v1.0.1/benchspec/CPU2006/464.h264ref/run/build_base_ql_riscv_llvm17.0000/context_ini.c:
    1|       |
    2|       |/*!
    3|       | *************************************************************************************
    4|       | * \file context_ini.c
    5|       | *
    6|       | * \brief
    7|       | *    CABAC context initializations
    8|       | *
    9|       | * \author
   10|       | *    Main contributors (see contributors.h for copyright, address and affiliation details)
   11|       | *    - Detlev Marpe                    <marpe@hhi.de>
   12|       | *    - Heiko Schwarz                   <hschwarz@hhi.de>
   13|       | **************************************************************************************
   14|       | */
   15|       |
   16|       |#define CONTEXT_INI_C
   17|       |
   18|       |#include <stdlib.h>
   19|       |#include <math.h>
   20|       |
   21|       |#include "global.h"
   22|       |
   23|       |#include "ctx_tables.h"
   24|       |#include "cabac.h"
   25|       |
   26|     29|#define DEFAULT_CTX_MODEL   0
   27|       |#define RELIABLE_COUNT      32.0
   28|     51|#define FRAME_TYPES         4
   29|    142|#define FIXED               0
   30|       |
   31|       |
   32|       |int                     num_mb_per_slice;
   33|       |int                     number_of_slices;
   34|       |int***                  initialized;
   35|       |int***                  model_number;
   36|       |
   37|       |
   38|       |double entropy    [128];
   39|       |double probability[128] =
   40|       |{
   41|       |  0.000000, 0.000000, 0.000000, 0.000000,    0.000000, 0.000000, 0.000000, 0.000000,
   42|       |  0.000000, 0.000000, 0.000000, 0.000000,    0.000000, 0.000000, 0.000000, 0.000000,
   43|       |  0.000000, 0.000000, 0.000000, 0.000000,    0.000000, 0.000000, 0.000000, 0.000000,
   44|       |  0.000000, 0.000000, 0.000000, 0.000000,    0.000000, 0.000000, 0.000000, 0.000000,
   45|       |  0.000000, 0.000000, 0.000000, 0.000000,    0.000000, 0.000000, 0.000000, 0.000000,
   46|       |  0.000000, 0.000000, 0.000000, 0.000000,    0.000000, 0.000000, 0.000000, 0.000000,
   47|       |  0.000000, 0.000000, 0.000000, 0.000000,    0.000000, 0.000000, 0.000000, 0.000000,
   48|       |  0.000000, 0.000000, 0.000000, 0.000000,    0.000000, 0.000000, 0.000000, 0.000000,
   49|       |  //--------------------------------------------------------------------------------
   50|       |  0.500000, 0.474609, 0.450507, 0.427629,    0.405912, 0.385299, 0.365732, 0.347159,
   51|       |  0.329530, 0.312795, 0.296911, 0.281833,    0.267520, 0.253935, 0.241039, 0.228799,
   52|       |  0.217180, 0.206151, 0.195682, 0.185744,    0.176312, 0.167358, 0.158859, 0.150792,
   53|       |  0.143134, 0.135866, 0.128966, 0.122417,    0.116200, 0.110299, 0.104698, 0.099381,
   54|       |  0.094334, 0.089543, 0.084996, 0.080680,    0.076583, 0.072694, 0.069002, 0.065498,
   55|       |  0.062172, 0.059014, 0.056018, 0.053173,    0.050473, 0.047909, 0.045476, 0.043167,
   56|       |  0.040975, 0.038894, 0.036919, 0.035044,    0.033264, 0.031575, 0.029972, 0.028450,
   57|       |  0.027005, 0.025633, 0.024332, 0.023096,    0.021923, 0.020810, 0.019753, 0.018750
   58|       |};
   59|       |
   60|       |
   61|       |
   62|       |void create_context_memory ()
   63|      1|{
   64|      1|  int i, j, k;
   65|      1|  int num_mb    = img->FrameSizeInMbs; // number of macroblocks for frame
   66|       | 
   67|      1|  num_mb_per_slice  = (input->slice_mode==1 ? input->slice_argument : num_mb);
   68|      1|  number_of_slices  = (num_mb + num_mb_per_slice - 1) / num_mb_per_slice;
   69|       |
   70|      1|  if ((initialized  = (int***) malloc (3 * sizeof(int**))) == NULL)
   71|      0|  {
   72|      0|    no_mem_exit ("create_context_memory: initialized");
   73|      0|  }
   74|      1|  if ((model_number = (int***) malloc (3 * sizeof(int**))) == NULL)
   75|      0|  {
   76|      0|    no_mem_exit ("create_context_memory: model_number");
   77|      0|  }
   78|       |
   79|      4|  for (k=0; k<3; k++)
   80|      3|  {
   81|      3|    if ((initialized[k] = (int**) malloc (FRAME_TYPES * sizeof(int*))) == NULL)
   82|      0|    {
   83|      0|      no_mem_exit ("create_context_memory: initialized");
   84|      0|    }
   85|      3|    if ((model_number[k]= (int**) malloc (FRAME_TYPES * sizeof(int*))) == NULL)
   86|      0|    {
   87|      0|      no_mem_exit ("create_context_memory: model_number");
   88|      0|    }
   89|       |
   90|     15|    for (i=0; i<FRAME_TYPES; i++)
   91|     12|    {
   92|     12|      if ((initialized[k][i] = (int*) malloc (number_of_slices * sizeof(int))) == NULL)
   93|      0|      {
   94|      0|        no_mem_exit ("create_context_memory: initialized");
   95|      0|      }
   96|     12|      if ((model_number[k][i]= (int*) malloc (number_of_slices * sizeof(int))) == NULL)
   97|      0|      {
   98|      0|        no_mem_exit ("create_context_memory: model_number");
   99|      0|      }
  100|     12|    }
  101|      3|  }
  102|       |
  103|       |  //===== set all context sets as "uninitialized" =====
  104|      4|  for (k=0; k<3; k++)
  105|      3|  {
  106|     15|    for (i=0; i<FRAME_TYPES; i++)
  107|     12|    {
  108|     24|      for (j=0; j<number_of_slices; j++)
  109|     12|      {
  110|     12|        initialized[k][i][j] = 0;
  111|     12|      }
  112|     12|    }
  113|      3|  }
  114|       |
  115|       |  //----- init tables -----
  116|     65|  for( k=0; k<64; k++ )
  117|     64|  {
  118|     64|    probability[k] = 1.0 - probability[127-k];
  119|     64|    entropy    [k] = log10(probability[    k])/log10(2.0);
  120|     64|    entropy[127-k] = log10(probability[127-k])/log10(2.0);
  121|     64|  }
  122|      1|}
  123|       |
  124|       |
  125|       |
  126|       |
  127|       |void free_context_memory ()
  128|      1|{
  129|      1|  int i, k;
  130|       |
  131|      4|  for (k=0; k<3; k++)
  132|      3|  {
  133|     15|    for (i=0; i<FRAME_TYPES; i++)
  134|     12|    {
  135|     12|      free (initialized [k][i]);
  136|     12|      free (model_number[k][i]);
  137|     12|    }
  138|      3|    free (initialized [k]);
  139|      3|    free (model_number[k]);
  140|      3|  }
  141|      1|  free (initialized);
  142|      1|  free (model_number);
  143|      1|}
  144|       |
  145|       |
  146|       |
  147|       |
  148|       |
  149|       |
  150|  2.05k|#define BIARI_CTX_INIT2(ii,jj,ctx,tab,num) \
  151|  2.05k|{ \
  152|  16.0k|  for (i=0; i<ii; i++) \
  153|   156k|  for (j=0; j<jj; j++) \
  154|   142k|  { \
  155|   142k|    if      (img->type==I_SLICE)  biari_init_context (&(ctx[i][j]), &(tab ## _I[num][i][j][0])); \
  156|   142k|    else                            biari_init_context (&(ctx[i][j]), &(tab ## _P[num][i][j][0])); \
  157|   142k|  } \
  158|  2.05k|}
  159|    855|#define BIARI_CTX_INIT1(jj,ctx,tab,num) \
  160|    855|{ \
  161|  3.76k|  for (j=0; j<jj; j++) \
  162|  2.90k|  { \
  163|  2.90k|    if      (img->type==I_SLICE)  biari_init_context (&(ctx[j]), &(tab ## _I[num][0][j][0])); \
  164|  2.90k|    else                            biari_init_context (&(ctx[j]), &(tab ## _P[num][0][j][0])); \
  165|  2.90k|  } \
  166|    855|}
  167|       |
  168|       |
  169|       |
  170|       |void SetCtxModelNumber ()
  171|    171|{
  172|    171|  int frame_field = img->field_picture;
  173|    171|  int img_type    = img->type;
  174|    171|  int ctx_number  = img->currentSlice->start_mb_nr / num_mb_per_slice;
  175|       |
  176|    171|  if(img->type==I_SLICE)
  177|     29|  {
  178|     29|    img->model_number=DEFAULT_CTX_MODEL;
  179|     29|    return;
  180|     29|  }
  181|    142|  if(input->context_init_method==FIXED)
  182|    142|  {
  183|    142|    img->model_number=input->model_number;
  184|    142|    return;
  185|    142|  }
  186|       |
  187|      0|  if (initialized [frame_field][img_type][ctx_number])
  188|      0|  {
  189|      0|    img->model_number = model_number[frame_field][img_type][ctx_number];
  190|      0|  }
  191|      0|  else if (ctx_number && initialized[frame_field][img_type][ctx_number-1])
  192|      0|  {
  193|      0|    img->model_number = model_number[frame_field][img_type][ctx_number-1];
  194|      0|  }
  195|      0|  else
  196|      0|  {
  197|      0|    img->model_number = DEFAULT_CTX_MODEL;
  198|      0|  }
  199|      0|}
  200|       |
  201|       |
  202|       |
  203|       |void init_contexts ()
  204|    171|{
  205|    171|  MotionInfoContexts*  mc = img->currentSlice->mot_ctx;
  206|    171|  TextureInfoContexts* tc = img->currentSlice->tex_ctx;
  207|    171|  int i, j;
  208|       |
  209|       |  //--- motion coding contexts ---
  210|    171|  BIARI_CTX_INIT2 (3, NUM_MB_TYPE_CTX,   mc->mb_type_contexts,     INIT_MB_TYPE,    img->model_number);
  211|    171|  BIARI_CTX_INIT2 (2, NUM_B8_TYPE_CTX,   mc->b8_type_contexts,     INIT_B8_TYPE,    img->model_number);
  212|    171|  BIARI_CTX_INIT2 (2, NUM_MV_RES_CTX,    mc->mv_res_contexts,      INIT_MV_RES,     img->model_number);
  213|    171|  BIARI_CTX_INIT2 (2, NUM_REF_NO_CTX,    mc->ref_no_contexts,      INIT_REF_NO,     img->model_number);
  214|    171|  BIARI_CTX_INIT1 (   NUM_DELTA_QP_CTX,  mc->delta_qp_contexts,    INIT_DELTA_QP,   img->model_number);
  215|    171|  BIARI_CTX_INIT1 (   NUM_MB_AFF_CTX,    mc->mb_aff_contexts,      INIT_MB_AFF,     img->model_number);
  216|    171|  BIARI_CTX_INIT1 (   NUM_TRANSFORM_SIZE_CTX,  mc->transform_size_contexts,    INIT_TRANSFORM_SIZE,   img->model_number);
  217|       |  
  218|       |  //--- texture coding contexts ---
  219|    171|  BIARI_CTX_INIT1 (                 NUM_IPR_CTX,  tc->ipr_contexts,     INIT_IPR,       img->model_number);
  220|    171|  BIARI_CTX_INIT1 (                 NUM_CIPR_CTX, tc->cipr_contexts,    INIT_CIPR,      img->model_number);
  221|    171|  BIARI_CTX_INIT2 (3,               NUM_CBP_CTX,  tc->cbp_contexts,     INIT_CBP,       img->model_number);
  222|    171|  BIARI_CTX_INIT2 (NUM_BLOCK_TYPES, NUM_BCBP_CTX, tc->bcbp_contexts,    INIT_BCBP,      img->model_number);
  223|    171|  BIARI_CTX_INIT2 (NUM_BLOCK_TYPES, NUM_MAP_CTX,  tc->map_contexts,     INIT_MAP,       img->model_number);
  224|    171|  BIARI_CTX_INIT2 (NUM_BLOCK_TYPES, NUM_LAST_CTX, tc->last_contexts,    INIT_LAST,      img->model_number);
  225|    171|  BIARI_CTX_INIT2 (NUM_BLOCK_TYPES, NUM_ONE_CTX,  tc->one_contexts,     INIT_ONE,       img->model_number);
  226|    171|  BIARI_CTX_INIT2 (NUM_BLOCK_TYPES, NUM_ABS_CTX,  tc->abs_contexts,     INIT_ABS,       img->model_number);
  227|    171|  BIARI_CTX_INIT2 (NUM_BLOCK_TYPES, NUM_MAP_CTX,  tc->fld_map_contexts, INIT_FLD_MAP,   img->model_number);
  228|    171|  BIARI_CTX_INIT2 (NUM_BLOCK_TYPES, NUM_LAST_CTX, tc->fld_last_contexts,INIT_FLD_LAST,  img->model_number);
  229|    171|}
  230|       |
  231|       |
  232|       |
  233|       |
  234|       |
  235|       |double XRate (BiContextTypePtr ctx, const int* model)
  236|      0|{
  237|      0|  int     ctx_state, mod_state;
  238|      0|  double  weight, xr = 0.0;
  239|      0|  int     qp = max(0,img->qp);
  240|       |
  241|      0|  weight    = min (1.0, (double)ctx->count/(double)RELIABLE_COUNT);
  242|       |
  243|      0|  mod_state = ((model[0]*qp)>>4)+model[1];
  244|      0|  mod_state = min (max (0, mod_state), 127);
  245|      0|  ctx_state = (ctx->MPS ? 64+ctx->state : 63-ctx->state);
  246|       |
  247|      0|  xr -= weight * probability[    ctx_state] * entropy[    mod_state];
  248|      0|  xr -= weight * probability[127-ctx_state] * entropy[127-mod_state];
  249|       |
  250|      0|  return xr;
  251|      0|}
  252|       |
  253|      0|#define ADD_XRATE2(ii,jj,ctx,tab,num) \
  254|      0|{ \
  255|      0|  for (i=0; i<ii; i++) \
  256|      0|  for (j=0; j<jj; j++) \
  257|      0|  { \
  258|      0|    if      (img->type==I_SLICE)  xr += XRate (&(ctx[i][j]), &(tab ## _I[num][i][j][0])); \
  259|      0|    else                            xr += XRate (&(ctx[i][j]), &(tab ## _P[num][i][j][0])); \
  260|      0|  } \
  261|      0|}
  262|      0|#define ADD_XRATE1(jj,ctx,tab,num) \
  263|      0|{ \
  264|      0|  for (j=0; j<jj; j++) \
  265|      0|  { \
  266|      0|    if      (img->type==I_SLICE)  xr += XRate (&(ctx[j]), &(tab ## _I[num][0][j][0])); \
  267|      0|    else                            xr += XRate (&(ctx[j]), &(tab ## _P[num][0][j][0])); \
  268|      0|  } \
  269|      0|}
  270|       |
  271|       |
  272|       |void GetCtxModelNumber (int* mnumber, MotionInfoContexts* mc, TextureInfoContexts* tc)
  273|      0|{
  274|      0|  int     model, j, i;
  275|      0|  int     num_models = (img->type==I_SLICE ? NUM_CTX_MODELS_I : NUM_CTX_MODELS_P);
  276|      0|  double  xr, min_xr = 1e30;
  277|       |
  278|      0|  for (model=0; model<num_models; model++)
  279|      0|  {
  280|      0|    xr = 0.0;
  281|       |    //--- motion coding contexts ---
  282|      0|    ADD_XRATE2 (3, NUM_MB_TYPE_CTX,   mc->mb_type_contexts,     INIT_MB_TYPE,   model);
  283|      0|    ADD_XRATE2 (2, NUM_B8_TYPE_CTX,   mc->b8_type_contexts,     INIT_B8_TYPE,   model);
  284|      0|    ADD_XRATE2 (2, NUM_MV_RES_CTX,    mc->mv_res_contexts,      INIT_MV_RES,    model);
  285|      0|    ADD_XRATE2 (2, NUM_REF_NO_CTX,    mc->ref_no_contexts,      INIT_REF_NO,    model);
  286|      0|    ADD_XRATE1 (   NUM_DELTA_QP_CTX,  mc->delta_qp_contexts,    INIT_DELTA_QP,  model);
  287|      0|    ADD_XRATE1 (   NUM_MB_AFF_CTX,    mc->mb_aff_contexts,      INIT_MB_AFF,    model);
  288|      0|    ADD_XRATE1 (   NUM_TRANSFORM_SIZE_CTX,  mc->transform_size_contexts, INIT_TRANSFORM_SIZE,  model);
  289|       |
  290|       |    //--- texture coding contexts ---
  291|      0|    ADD_XRATE1 (                  NUM_IPR_CTX,  tc->ipr_contexts,       INIT_IPR,       model);
  292|      0|    ADD_XRATE1 (                  NUM_CIPR_CTX, tc->cipr_contexts,      INIT_CIPR,      model);
  293|      0|    ADD_XRATE2 (3,                NUM_CBP_CTX,  tc->cbp_contexts,       INIT_CBP,       model);
  294|      0|    ADD_XRATE2 (NUM_BLOCK_TYPES,  NUM_BCBP_CTX, tc->bcbp_contexts,      INIT_BCBP,      model);
  295|      0|    ADD_XRATE2 (NUM_BLOCK_TYPES,  NUM_MAP_CTX,  tc->map_contexts,       INIT_MAP,       model);
  296|      0|    ADD_XRATE2 (NUM_BLOCK_TYPES,  NUM_LAST_CTX, tc->last_contexts,      INIT_LAST,      model);
  297|      0|    ADD_XRATE2 (NUM_BLOCK_TYPES,  NUM_ONE_CTX,  tc->one_contexts,       INIT_ONE,       model);
  298|      0|    ADD_XRATE2 (NUM_BLOCK_TYPES,  NUM_ABS_CTX,  tc->abs_contexts,       INIT_ABS,       model);
  299|      0|    ADD_XRATE2 (NUM_BLOCK_TYPES,  NUM_MAP_CTX,  tc->fld_map_contexts,   INIT_FLD_MAP,   model);
  300|      0|    ADD_XRATE2 (NUM_BLOCK_TYPES,  NUM_LAST_CTX, tc->fld_last_contexts,  INIT_FLD_LAST,  model);
  301|       |
  302|      0|    if (xr<min_xr)
  303|      0|    {
  304|      0|      min_xr    = xr;
  305|      0|      *mnumber  = model;
  306|      0|    }
  307|      0|  }
  308|      0|}
  309|       |
  310|       |#undef ADD_XRATE2
  311|       |#undef ADD_XRATE1
  312|       |
  313|       |
  314|       |
  315|       |
  316|       |
  317|       |
  318|       |void store_contexts ()
  319|    171|{
  320|    171|  int frame_field = img->field_picture;
  321|    171|  int img_type    = img->type;
  322|    171|  int ctx_number  = img->currentSlice->start_mb_nr / num_mb_per_slice;
  323|       |
  324|    171|  if( input->context_init_method )
  325|      0|  {
  326|      0|    initialized [frame_field][img_type][ctx_number] = 1;
  327|      0|    GetCtxModelNumber (model_number[frame_field][img_type]+ctx_number, img->currentSlice->mot_ctx, img->currentSlice->tex_ctx);
  328|      0|  }
  329|    171|  else
  330|    171|  {
  331|       |    // do nothing
  332|    171|  }
  333|    171|}
  334|       |
  335|       |
  336|       |void update_field_frame_contexts (int field)
  337|      0|{
  338|      0|  int i, j;
  339|       |
  340|      0|  if (field)
  341|      0|  {
  342|       |    // set frame contexts
  343|      0|    for (j=0; j<FRAME_TYPES; j++)
  344|      0|    {
  345|      0|      for (i=0; i<number_of_slices; i++)
  346|      0|      {
  347|      0|        initialized [0][j][i] = initialized [1][j][i>>1];
  348|      0|        model_number[0][j][i] = model_number[1][j][i>>1];
  349|      0|      }
  350|      0|    }
  351|      0|  }
  352|      0|  else
  353|      0|  {
  354|       |    // set field contexts
  355|      0|    for (j=0; j<FRAME_TYPES; j++)
  356|      0|    {
  357|      0|      for (i=0; i<((number_of_slices+1)>>1); i++)
  358|      0|      {
  359|      0|        initialized [1][j][i] = initialized [0][j][i<<1];
  360|      0|        model_number[1][j][i] = model_number[0][j][i<<1];
  361|      0|      }
  362|      0|    }
  363|      0|  }
  364|      0|}
  365|       |

/home/xzp/speccpu2006-v1.0.1/benchspec/CPU2006/464.h264ref/run/build_base_ql_riscv_llvm17.0000/ctx_tables.h:
    1|       |
    2|       |/*!
    3|       | *************************************************************************************
    4|       | * \file ctx_tables.h
    5|       | *
    6|       | * \brief
    7|       | *    CABAC context initialization tables
    8|       | *
    9|       | * \author
   10|       | *    Main contributors (see contributors.h for copyright, address and affiliation details)
   11|       | *    - Detlev Marpe                    <marpe@hhi.de>
   12|       | *    - Heiko Schwarz                   <hschwarz@hhi.de>
   13|       | **************************************************************************************
   14|       | */
   15|       |
   16|       |#define CTX_UNUSED          {0,64}
   17|       |#define CTX_UNDEF           {0,63}
   18|       |
   19|       |#ifdef CONTEXT_INI_C
   20|       |
   21|       |
   22|      0|#define NUM_CTX_MODELS_I     1
   23|      0|#define NUM_CTX_MODELS_P     3
   24|       |
   25|       |
   26|       |static const int INIT_MB_TYPE_I[1][3][11][2] =
   27|       |{
   28|       |  //----- model 0 -----
   29|       |  {
   30|       |    { {  20, -15} , {   2,  54} , {   3,  74} ,  CTX_UNUSED , { -28, 127} , { -23, 104} , {  -6,  53} , {  -1,  54} , {   7,  51} ,  CTX_UNUSED ,  CTX_UNUSED },
   31|       |    { {  20, -15} , {   2,  54} , {   3,  74} , {  20, -15} , {   2,  54} , {   3,  74} , { -28, 127} , { -23, 104} , {  -6,  53} , {  -1,  54} , {   7,  51} }, // SI (unused at the moment)
   32|       |    {  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED }
   33|       |  }
   34|       |};
   35|       |static const int INIT_MB_TYPE_P[3][3][11][2] =
   36|       |{
   37|       |  //----- model 0 -----
   38|       |  {
   39|       |    {  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED },
   40|       |  { {  23,  33} , {  23,   2} , {  21,   0} ,  CTX_UNUSED , {   1,   9} , {   0,  49} , { -37, 118} , {   5,  57} , { -13,  78} , { -11,  65} , {   1,  62} },
   41|       |  { {  26,  67} , {  16,  90} , {   9, 104} ,  CTX_UNUSED , { -46, 127} , { -20, 104} , {   1,  67} , {  18,  64} , {   9,  43} , {  29,   0} ,  CTX_UNUSED }
   42|       |  },
   43|       |  //----- model 1 -----
   44|       |  {
   45|       |    {  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED },
   46|       |    { {  22,  25} , {  34,   0} , {  16,   0} ,  CTX_UNUSED , {  -2,   9} , {   4,  41} , { -29, 118} , {   2,  65} , {  -6,  71} , { -13,  79} , {   5,  52} },
   47|       |    { {  57,   2} , {  41,  36} , {  26,  69} ,  CTX_UNUSED , { -45, 127} , { -15, 101} , {  -4,  76} , {  26,  34} , {  19,  22} , {  40,   0} ,  CTX_UNUSED }
   48|       |  },
   49|       |  //----- model 2 -----
   50|       |  {
   51|       |    {  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED },
   52|       |    { {  29,  16} , {  25,   0} , {  14,   0} ,  CTX_UNUSED , { -10,  51} , {  -3,  62} , { -27,  99} , {  26,  16} , {  -4,  85} , { -24, 102} , {   5,  57} },
   53|       |  { {  54,   0} , {  37,  42} , {  12,  97} ,  CTX_UNUSED , { -32, 127} , { -22, 117} , {  -2,  74} , {  20,  40} , {  20,  10} , {  29,   0} ,  CTX_UNUSED }
   54|       |  }
   55|       |};
   56|       |
   57|       |
   58|       |
   59|       |
   60|       |
   61|       |static const int INIT_B8_TYPE_I[1][2][9][2] =
   62|       |{
   63|       |  //----- model 0 -----
   64|       |  {
   65|       |    {  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED },
   66|       |    {  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED }
   67|       |  }
   68|       |};
   69|       |static const int INIT_B8_TYPE_P[3][2][9][2] =
   70|       |{
   71|       |  //----- model 0 -----
   72|       |  {
   73|       |    {  CTX_UNUSED , {  12,  49} ,  CTX_UNUSED , {  -4,  73} , {  17,  50} ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED },
   74|       |    { {  -6,  86} , { -17,  95} , {  -6,  61} , {   9,  45} ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED }
   75|       |  },
   76|       |  //----- model 1 -----
   77|       |  {
   78|       |    {  CTX_UNUSED , {   9,  50} ,  CTX_UNUSED , {  -3,  70} , {  10,  54} ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED },
   79|       |    { {   6,  69} , { -13,  90} , {   0,  52} , {   8,  43} ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED }
   80|       |  },
   81|       |  //----- model 2 -----
   82|       |  {
   83|       |    {  CTX_UNUSED , {   6,  57} ,  CTX_UNUSED , { -17,  73} , {  14,  57} ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED },
   84|       |    { {  -6,  93} , { -14,  88} , {  -6,  44} , {   4,  55} ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED }
   85|       |  }
   86|       |};
   87|       |
   88|       |
   89|       |
   90|       |
   91|       |
   92|       |static const int INIT_MV_RES_I[1][2][10][2] =
   93|       |{
   94|       |  //----- model 0 -----
   95|       |  {
   96|       |    {  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED },
   97|       |    {  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED }
   98|       |  }
   99|       |};
  100|       |static const int INIT_MV_RES_P[3][2][10][2] =
  101|       |{
  102|       |  //----- model 0 -----
  103|       |  {
  104|       |    { {  -3,  69} ,  CTX_UNUSED , {  -6,  81} , { -11,  96} ,  CTX_UNUSED , {   0,  58} ,  CTX_UNUSED , {  -3,  76} , { -10,  94} ,  CTX_UNUSED },
  105|       |    { {   6,  55} , {   7,  67} , {  -5,  86} , {   2,  88} ,  CTX_UNUSED , {   5,  54} , {   4,  69} , {  -3,  81} , {   0,  88} ,  CTX_UNUSED }
  106|       |  },
  107|       |  //----- model 1 -----
  108|       |  {
  109|       |    { {  -2,  69} ,  CTX_UNUSED , {  -5,  82} , { -10,  96} ,  CTX_UNUSED , {   1,  56} ,  CTX_UNUSED , {  -3,  74} , {  -6,  85} ,  CTX_UNUSED },
  110|       |    { {   2,  59} , {   2,  75} , {  -3,  87} , {  -3, 100} ,  CTX_UNUSED , {   0,  59} , {  -3,  81} , {  -7,  86} , {  -5,  95} ,  CTX_UNUSED }
  111|       |  },
  112|       |  //----- model 2 -----
  113|       |  {
  114|       |    { { -11,  89} ,  CTX_UNUSED , { -15, 103} , { -21, 116} ,  CTX_UNUSED , {   1,  63} ,  CTX_UNUSED , {  -5,  85} , { -13, 106} ,  CTX_UNUSED },
  115|       |    { {  19,  57} , {  20,  58} , {   4,  84} , {   6,  96} ,  CTX_UNUSED , {   5,  63} , {   6,  75} , {  -3,  90} , {  -1, 101} ,  CTX_UNUSED }
  116|       |  }
  117|       |};
  118|       |
  119|       |
  120|       |
  121|       |
  122|       |
  123|       |static const int INIT_REF_NO_I[1][2][6][2] =
  124|       |{
  125|       |  //----- model 0 -----
  126|       |  {
  127|       |    {  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED },
  128|       |    {  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED }
  129|       |  }
  130|       |};
  131|       |static const int INIT_REF_NO_P[3][2][6][2] =
  132|       |{
  133|       |  //----- model 0 -----
  134|       |  {
  135|       |    { {  -7,  67} , {  -5,  74} , {  -4,  74} , {  -5,  80} , {  -7,  72} , {   1,  58} },
  136|       |    {  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED }
  137|       |  },
  138|       |  //----- model 1 -----
  139|       |  {
  140|       |    { {  -1,  66} , {  -1,  77} , {   1,  70} , {  -2,  86} , {  -5,  72} , {   0,  61} },
  141|       |    {  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED }
  142|       |  },
  143|       |  //----- model 2 -----
  144|       |  {
  145|       |    { {   3,  55} , {  -4,  79} , {  -2,  75} , { -12,  97} , {  -7,  50} , {   1,  60} },
  146|       |    {  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED }
  147|       |  }
  148|       |};
  149|       |
  150|       |
  151|       |static const int INIT_TRANSFORM_SIZE_I[1][1][3][2]=
  152|       |{
  153|       |  //----- model 0 -----
  154|       |  {
  155|       |    {  {  31,  21} , {  31,  31} , {  25,  50} },
  156|       |//    { {   0,  41} , {   0,  63} , {   0,  63} },
  157|       |  }
  158|       |};
  159|       |
  160|       |static const int INIT_TRANSFORM_SIZE_P[3][1][3][2]=
  161|       |{
  162|       |  //----- model 0 -----
  163|       |  {
  164|       |    {  {  12,  40} , {  11,  51} , {  14,  59} },
  165|       |//    { {   0,  41} , {   0,  63} , {   0,  63} },
  166|       |  },
  167|       |  //----- model 1 -----
  168|       |  {
  169|       |    {  {  25,  32} , {  21,  49} , {  21,  54} },
  170|       |//    { {   0,  41} , {   0,  63} , {   0,  63} },
  171|       |  },
  172|       |  //----- model 2 -----
  173|       |  {
  174|       |    {  {  21,  33} , {  19,  50} , {  17,  61} },
  175|       |//    { {   0,  41} , {   0,  63} , {   0,  63} },
  176|       |  }
  177|       |};
  178|       |
  179|       |static const int INIT_DELTA_QP_I[1][1][4][2]=
  180|       |{
  181|       |  //----- model 0 -----
  182|       |  {
  183|       |    { {   0,  41} , {   0,  63} , {   0,  63} , {   0,  63} },
  184|       |  }
  185|       |};
  186|       |static const int INIT_DELTA_QP_P[3][1][4][2]=
  187|       |{
  188|       |  //----- model 0 -----
  189|       |  {
  190|       |    { {   0,  41} , {   0,  63} , {   0,  63} , {   0,  63} },
  191|       |  },
  192|       |  //----- model 1 -----
  193|       |  {
  194|       |    { {   0,  41} , {   0,  63} , {   0,  63} , {   0,  63} },
  195|       |  },
  196|       |  //----- model 2 -----
  197|       |  {
  198|       |    { {   0,  41} , {   0,  63} , {   0,  63} , {   0,  63} },
  199|       |  }
  200|       |};
  201|       |
  202|       |
  203|       |
  204|       |
  205|       |
  206|       |static const int INIT_MB_AFF_I[1][1][4][2] =
  207|       |{
  208|       |  //----- model 0 -----
  209|       |  {
  210|       |    { {   0,  11} , {   1,  55} , {   0,  69} ,  CTX_UNUSED }
  211|       |  }
  212|       |};
  213|       |static const int INIT_MB_AFF_P[3][1][4][2] =
  214|       |{
  215|       |  //----- model 0 -----
  216|       |  {
  217|       |    { {   0,  45} , {  -4,  78} , {  -3,  96} ,  CTX_UNUSED }
  218|       |  },
  219|       |  //----- model 1 -----
  220|       |  {
  221|       |    { {  13,  15} , {   7,  51} , {   2,  80} ,  CTX_UNUSED }
  222|       |  },
  223|       |  //----- model 2 -----
  224|       |  {
  225|       |    { {   7,  34} , {  -9,  88} , { -20, 127} ,  CTX_UNUSED }
  226|       |  }
  227|       |};
  228|       |
  229|       |
  230|       |
  231|       |
  232|       |
  233|       |static const int INIT_IPR_I[1][1][2][2] =
  234|       |{
  235|       |  //----- model 0 -----
  236|       |  {
  237|       |    { { 13,  41} , {   3,  62} }
  238|       |  }
  239|       |};
  240|       |static const int INIT_IPR_P[3][1][2][2] =
  241|       |{
  242|       |  //----- model 0 -----
  243|       |  {
  244|       |    { { 13,  41} , {   3,  62} }
  245|       |  },
  246|       |  //----- model 1 -----
  247|       |  {
  248|       |    { { 13,  41} , {   3,  62} }
  249|       |  },
  250|       |  //----- model 2 -----
  251|       |  {
  252|       |    { { 13,  41} , {   3,  62} }
  253|       |  }
  254|       |};
  255|       |
  256|       |
  257|       |
  258|       |
  259|       |
  260|       |static const int INIT_CIPR_I[1][1][4][2] =
  261|       |{
  262|       |  //----- model 0 -----
  263|       |  {
  264|       |    { {  -9,  83} , {   4,  86} , {   0,  97} , {  -7,  72} }
  265|       |  }
  266|       |};
  267|       |static const int INIT_CIPR_P[3][1][4][2] =
  268|       |{
  269|       |  //----- model 0 -----
  270|       |  {
  271|       |    { {  -9,  83} , {   4,  86} , {   0,  97} , {  -7,  72} }
  272|       |  },
  273|       |  //----- model 1 -----
  274|       |  {
  275|       |    { {  -9,  83} , {   4,  86} , {   0,  97} , {  -7,  72} }
  276|       |  },
  277|       |  //----- model 2 -----
  278|       |  {
  279|       |    { {  -9,  83} , {   4,  86} , {   0,  97} , {  -7,  72} }
  280|       |  }
  281|       |};
  282|       |
  283|       |
  284|       |
  285|       |
  286|       |
  287|       |
  288|       |static const int INIT_CBP_I[1][3][4][2] =
  289|       |{
  290|       |  //----- model 0 -----
  291|       |  {
  292|       |    { { -17, 127} , { -13, 102} , {   0,  82} , {  -7,  74} },
  293|       |    { { -21, 107} , { -27, 127} , { -31, 127} , { -24, 127} },
  294|       |    { { -18,  95} , { -27, 127} , { -21, 114} , { -30, 127} }
  295|       |  }
  296|       |};
  297|       |static const int INIT_CBP_P[3][3][4][2] =
  298|       |{
  299|       |  //----- model 0 -----
  300|       |  {
  301|       |    { { -27, 126} , { -28,  98} , { -25, 101} , { -23,  67} },
  302|       |    { { -28,  82} , { -20,  94} , { -16,  83} , { -22, 110} },
  303|       |    { { -21,  91} , { -18, 102} , { -13,  93} , { -29, 127} }
  304|       |  },
  305|       |  //----- model 1 -----
  306|       |  {
  307|       |    { { -39, 127} , { -18,  91} , { -17,  96} , { -26,  81} },
  308|       |    { { -35,  98} , { -24, 102} , { -23,  97} , { -27, 119} },
  309|       |    { { -24,  99} , { -21, 110} , { -18, 102} , { -36, 127} }
  310|       |  },
  311|       |  //----- model 2 -----
  312|       |  {
  313|       |    { { -36, 127} , { -17,  91} , { -14,  95} , { -25,  84} },
  314|       |    { { -25,  86} , { -12,  89} , { -17,  91} , { -31, 127} },
  315|       |    { { -14,  76} , { -18, 103} , { -13,  90} , { -37, 127} }
  316|       |  }
  317|       |};
  318|       |
  319|       |
  320|       |
  321|       |
  322|       |
  323|       |static const int INIT_BCBP_I[1][8][4][2] =
  324|       |{
  325|       |  //----- model 0 -----
  326|       |  {
  327|       |    { { -17, 123} , { -12, 115} , { -16, 122} , { -11, 115} },
  328|       |    { { -12,  63} , {  -2,  68} , { -15,  84} , { -13, 104} },
  329|       |    {  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED },
  330|       |    {  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED },
  331|       |    { {  -3,  70} , {  -8,  93} , { -10,  90} , { -30, 127} },
  332|       |    { {  -1,  74} , {  -6,  97} , {  -7,  91} , { -20, 127} },
  333|       |    { {  -4,  56} , {  -5,  82} , {  -7,  76} , { -22, 125} },
  334|       |    {  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED }
  335|       |  }
  336|       |};
  337|       |static const int INIT_BCBP_P[3][8][4][2] =
  338|       |{
  339|       |  //----- model 0 -----
  340|       |  {
  341|       |    { {  -7,  92} , {  -5,  89} , {  -7,  96} , { -13, 108} },
  342|       |    { {  -3,  46} , {  -1,  65} , {  -1,  57} , {  -9,  93} },
  343|       |    {  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED },
  344|       |    {  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED },
  345|       |    { {  -3,  74} , {  -9,  92} , {  -8,  87} , { -23, 126} },
  346|       |    { {   5,  54} , {   6,  60} , {   6,  59} , {   6,  69} },
  347|       |    { {  -1,  48} , {   0,  68} , {  -4,  69} , {  -8,  88} },
  348|       |    {  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED }
  349|       |  },
  350|       |  //----- model 1 -----
  351|       |  {
  352|       |    { {   0,  80} , {  -5,  89} , {  -7,  94} , {  -4,  92} },
  353|       |    { {   0,  39} , {   0,  65} , { -15,  84} , { -35, 127} },
  354|       |    {  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED },
  355|       |    {  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED },
  356|       |    { {  -2,  73} , { -12, 104} , {  -9,  91} , { -31, 127} },
  357|       |    { {   3,  55} , {   7,  56} , {   7,  55} , {   8,  61} },
  358|       |    { {  -3,  53} , {   0,  68} , {  -7,  74} , {  -9,  88} },
  359|       |    {  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED }
  360|       |  },
  361|       |  //----- model 2 -----
  362|       |  {
  363|       |    { {  11,  80} , {   5,  76} , {   2,  84} , {   5,  78} },
  364|       |    { {  -6,  55} , {   4,  61} , { -14,  83} , { -37, 127} },
  365|       |    {  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED },
  366|       |    {  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED },
  367|       |    { {  -5,  79} , { -11, 104} , { -11,  91} , { -30, 127} },
  368|       |    { {   0,  65} , {  -2,  79} , {   0,  72} , {  -4,  92} },
  369|       |    { {  -6,  56} , {   3,  68} , {  -8,  71} , { -13,  98} },
  370|       |    {  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED }
  371|       |  }
  372|       |};
  373|       |
  374|       |
  375|       |
  376|       |
  377|       |
  378|       |static const int INIT_MAP_I[1][8][15][2] =
  379|       |{
  380|       |  //----- model 0 -----
  381|       |  {
  382|       |    { {  -7,  93} , { -11,  87} , {  -3,  77} , {  -5,  71} , {  -4,  63} , {  -4,  68} , { -12,  84} , {  -7,  62} , {  -7,  65} , {   8,  61} , {   5,  56} , {  -2,  66} , {   1,  64} , {   0,  61} , {  -2,  78} },
  383|       |    {  CTX_UNUSED , {   1,  50} , {   7,  52} , {  10,  35} , {   0,  44} , {  11,  38} , {   1,  45} , {   0,  46} , {   5,  44} , {  31,  17} , {   1,  51} , {   7,  50} , {  28,  19} , {  16,  33} , {  14,  62} },
  384|       |    {  { -17, 120} , { -20, 112} , { -18, 114} , { -11,  85} , { -15,  92} , { -14,  89} , { -26,  71} , { -15,  81} , { -14,  80} , {   0,  68} , { -14,  70} , { -24,  56} , { -23,  68} , { -24,  50} , { -11,  74} },
  385|       |//    { {  -1,  73} , {  -7,  73} , {  -6,  76} , {  -7,  71} , {  -9,  72} , {  -5,  65} , { -14,  83} , {  -8,  72} , { -10,  75} , {  -5,  64} , {  -4,  59} , { -13,  79} , {  -9,  69} , {  -8,  66} , {   3,  55} },
  386|       |    {  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED },
  387|       |    {  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED },
  388|       |    { { -13, 108} , { -15, 100} , { -13, 101} , { -13,  91} , { -12,  94} , { -10,  88} , { -16,  84} , { -10,  86} , {  -7,  83} , { -13,  87} , { -19,  94} , {   1,  70} , {   0,  72} , {  -5,  74} , {  18,  59} },
  389|       |    { {  -8, 102} , { -15, 100} , {   0,  95} ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED },
  390|       |    {  CTX_UNUSED , {  -4,  75} , {   2,  72} , { -11,  75} , {  -3,  71} , {  15,  46} , { -13,  69} , {   0,  62} , {   0,  65} , {  21,  37} , { -15,  72} , {   9,  57} , {  16,  54} , {   0,  62} , {  12,  72} }
  391|       |  }
  392|       |};
  393|       |static const int INIT_MAP_P[3][8][15][2] =
  394|       |{
  395|       |  //----- model 0 -----
  396|       |  {
  397|       |    { {  -2,  85} , {  -6,  78} , {  -1,  75} , {  -7,  77} , {   2,  54} , {   5,  50} , {  -3,  68} , {   1,  50} , {   6,  42} , {  -4,  81} , {   1,  63} , {  -4,  70} , {   0,  67} , {   2,  57} , {  -2,  76} },
  398|       |    {  CTX_UNUSED , {  11,  35} , {   4,  64} , {   1,  61} , {  11,  35} , {  18,  25} , {  12,  24} , {  13,  29} , {  13,  36} , { -10,  93} , {  -7,  73} , {  -2,  73} , {  13,  46} , {   9,  49} , {  -7, 100} },
  399|       |    {  {  -4,  79} , {  -7,  71} , {  -5,  69} , {  -9,  70} , {  -8,  66} , { -10,  68} , { -19,  73} , { -12,  69} , { -16,  70} , { -15,  67} , { -20,  62} , { -19,  70} , { -16,  66} , { -22,  65} , { -20,  63} },
  400|       |//    { {  -4,  60} , {  -3,  49} , {  -2,  50} , {  -4,  49} , {  -5,  48} , {  -2,  46} , {  -7,  54} , {  -1,  45} , {  -4,  49} , {   4,  39} , {   0,  42} , {   2,  43} , {   0,  44} , {   5,  32} , {  15,  30}  },
  401|       |    {  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED },
  402|       |    {  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED },
  403|       |    { {   9,  53} , {   2,  53} , {   5,  53} , {  -2,  61} , {   0,  56} , {   0,  56} , { -13,  63} , {  -5,  60} , {  -1,  62} , {   4,  57} , {  -6,  69} , {   4,  57} , {  14,  39} , {   4,  51} , {  13,  68} },
  404|       |    { {   3,  64} , {   1,  61} , {   9,  63} ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED },
  405|       |    {  CTX_UNUSED , {   7,  50} , {  16,  39} , {   5,  44} , {   4,  52} , {  11,  48} , {  -5,  60} , {  -1,  59} , {   0,  59} , {  22,  33} , {   5,  44} , {  14,  43} , {  -1,  78} , {   0,  60} , {   9,  69} }
  406|       |  },
  407|       |  //----- model 1 -----
  408|       |  {
  409|       |    { { -13, 103} , { -13,  91} , {  -9,  89} , { -14,  92} , {  -8,  76} , { -12,  87} , { -23, 110} , { -24, 105} , { -10,  78} , { -20, 112} , { -17,  99} , { -78, 127} , { -70, 127} , { -50, 127} , { -46, 127} },
  410|       |    {  CTX_UNUSED , {  -4,  66} , {  -5,  78} , {  -4,  71} , {  -8,  72} , {   2,  59} , {  -1,  55} , {  -7,  70} , {  -6,  75} , {  -8,  89} , { -34, 119} , {  -3,  75} , {  32,  20} , {  30,  22} , { -44, 127} },
  411|       |    {  {  -5,  85} , {  -6,  81} , { -10,  77} , {  -7,  81} , { -17,  80} , { -18,  73} , {  -4,  74} , { -10,  83} , {  -9,  71} , {  -9,  67} , {  -1,  61} , {  -8,  66} , { -14,  66} , {   0,  59} , {   2,  59} },
  412|       |//    { {  -4,  60} , {  -3,  49} , {  -2,  50} , {  -4,  49} , {  -5,  48} , {  -2,  46} , {  -7,  54} , {  -1,  45} , {  -4,  49} , {   4,  39} , {   0,  42} , {   2,  43} , {   0,  44} , {   5,  32} , {  15,  30}  },
  413|       |    {  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED },
  414|       |    {  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED },
  415|       |    { {   0,  54} , {  -5,  61} , {   0,  58} , {  -1,  60} , {  -3,  61} , {  -8,  67} , { -25,  84} , { -14,  74} , {  -5,  65} , {   5,  52} , {   2,  57} , {   0,  61} , {  -9,  69} , { -11,  70} , {  18,  55} },
  416|       |    { {  -4,  71} , {   0,  58} , {   7,  61} ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED },
  417|       |    {  CTX_UNUSED , {   9,  41} , {  18,  25} , {   9,  32} , {   5,  43} , {   9,  47} , {   0,  44} , {   0,  51} , {   2,  46} , {  19,  38} , {  -4,  66} , {  15,  38} , {  12,  42} , {   9,  34} , {   0,  89} }
  418|       |  },
  419|       |  //----- model 2 -----
  420|       |  {
  421|       |    { {  -4,  86} , { -12,  88} , {  -5,  82} , {  -3,  72} , {  -4,  67} , {  -8,  72} , { -16,  89} , {  -9,  69} , {  -1,  59} , {   5,  66} , {   4,  57} , {  -4,  71} , {  -2,  71} , {   2,  58} , {  -1,  74} },
  422|       |    {  CTX_UNUSED , {  -4,  44} , {  -1,  69} , {   0,  62} , {  -7,  51} , {  -4,  47} , {  -6,  42} , {  -3,  41} , {  -6,  53} , {   8,  76} , {  -9,  78} , { -11,  83} , {   9,  52} , {   0,  67} , {  -5,  90} },
  423|       |    {  {  -3,  78} , {  -8,  74} , {  -9,  72} , { -10,  72} , { -18,  75} , { -12,  71} , { -11,  63} , {  -5,  70} , { -17,  75} , { -14,  72} , { -16,  67} , {  -8,  53} , { -14,  59} , {  -9,  52} , { -11,  68} },
  424|       |//    { {  -4,  60} , {  -3,  49} , {  -2,  50} , {  -4,  49} , {  -5,  48} , {  -2,  46} , {  -7,  54} , {  -1,  45} , {  -4,  49} , {   4,  39} , {   0,  42} , {   2,  43} , {   0,  44} , {   5,  32} , {  15,  30}  },
  425|       |    {  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED },
  426|       |    {  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED },
  427|       |    { {   1,  67} , { -15,  72} , {  -5,  75} , {  -8,  80} , { -21,  83} , { -21,  64} , { -13,  31} , { -25,  64} , { -29,  94} , {   9,  75} , {  17,  63} , {  -8,  74} , {  -5,  35} , {  -2,  27} , {  13,  91} },
  428|       |    { {   3,  65} , {  -7,  69} , {   8,  77} ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED },
  429|       |    {  CTX_UNUSED , { -10,  66} , {   3,  62} , {  -3,  68} , { -20,  81} , {   0,  30} , {   1,   7} , {  -3,  23} , { -21,  74} , {  16,  66} , { -23, 124} , {  17,  37} , {  44, -18} , {  50, -34} , { -22, 127} }
  430|       |  }
  431|       |};
  432|       |
  433|       |
  434|       |
  435|       |
  436|       |static const int INIT_LAST_I[1][8][15][2] =
  437|       |{
  438|       |  //----- model 0 -----
  439|       |  {
  440|       |    { {  24,   0} , {  15,   9} , {   8,  25} , {  13,  18} , {  15,   9} , {  13,  19} , {  10,  37} , {  12,  18} , {   6,  29} , {  20,  33} , {  15,  30} , {   4,  45} , {   1,  58} , {   0,  62} , {   7,  61} },
  441|       |    {  CTX_UNUSED , {  12,  38} , {  11,  45} , {  15,  39} , {  11,  42} , {  13,  44} , {  16,  45} , {  12,  41} , {  10,  49} , {  30,  34} , {  18,  42} , {  10,  55} , {  17,  51} , {  17,  46} , {   0,  89} },
  442|       |    {  {  23, -13} , {  26, -13} , {  40, -15} , {  49, -14} , {  44,   3} , {  45,   6} , {  44,  34} , {  33,  54} , {  19,  82} ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED },
  443|       |//    { {  12,  33} , {   5,  38} , {   9,  34} , {  18,  22} , {  19,  22} , {  23,  19} , {  26,  16} , {  14,  44} , {  40,  14} ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED },
  444|       |    {  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED },
  445|       |    {  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED },
  446|       |    { {  26, -19} , {  22, -17} , {  26, -17} , {  30, -25} , {  28, -20} , {  33, -23} , {  37, -27} , {  33, -23} , {  40, -28} , {  38, -17} , {  33, -11} , {  40, -15} , {  41,  -6} , {  38,   1} , {  41,  17} },
  447|       |    { {  30,  -6} , {  27,   3} , {  26,  22} ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED },
  448|       |    {  CTX_UNUSED , {  37, -16} , {  35,  -4} , {  38,  -8} , {  38,  -3} , {  37,   3} , {  38,   5} , {  42,   0} , {  35,  16} , {  39,  22} , {  14,  48} , {  27,  37} , {  21,  60} , {  12,  68} , {   2,  97} }
  449|       |  }
  450|       |};
  451|       |static const int INIT_LAST_P[3][8][15][2] =
  452|       |{
  453|       |  //----- model 0 -----
  454|       |  {
  455|       |    { {  11,  28} , {   2,  40} , {   3,  44} , {   0,  49} , {   0,  46} , {   2,  44} , {   2,  51} , {   0,  47} , {   4,  39} , {   2,  62} , {   6,  46} , {   0,  54} , {   3,  54} , {   2,  58} , {   4,  63} },
  456|       |    {  CTX_UNUSED , {   6,  51} , {   6,  57} , {   7,  53} , {   6,  52} , {   6,  55} , {  11,  45} , {  14,  36} , {   8,  53} , {  -1,  82} , {   7,  55} , {  -3,  78} , {  15,  46} , {  22,  31} , {  -1,  84} },
  457|       |    {  {   9,  -2} , {  26,  -9} , {  33,  -9} , {  39,  -7} , {  41,  -2} , {  45,   3} , {  49,   9} , {  45,  27} , {  36,  59} ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED },
  458|       |//    { {  17,  27} , {  23,  13} , {  24,  16} , {  22,  25} , {  23,  27} , {  23,  32} , {  17,  43} , {  17,  49} , {   2,  70} ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED },
  459|       |    {  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED },
  460|       |    {  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED },
  461|       |    { {  25,   7} , {  30,  -7} , {  28,   3} , {  28,   4} , {  32,   0} , {  34,  -1} , {  30,   6} , {  30,   6} , {  32,   9} , {  31,  19} , {  26,  27} , {  26,  30} , {  37,  20} , {  28,  34} , {  17,  70} },
  462|       |    { {   1,  67} , {   5,  59} , {   9,  67} ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED },
  463|       |    {  CTX_UNUSED , {  16,  30} , {  18,  32} , {  18,  35} , {  22,  29} , {  24,  31} , {  23,  38} , {  18,  43} , {  20,  41} , {  11,  63} , {   9,  59} , {   9,  64} , {  -1,  94} , {  -2,  89} , {  -9, 108} }
  464|       |  },
  465|       |  //----- model 1 -----
  466|       |  {
  467|       |    { {   4,  45} , {  10,  28} , {  10,  31} , {  33, -11} , {  52, -43} , {  18,  15} , {  28,   0} , {  35, -22} , {  38, -25} , {  34,   0} , {  39, -18} , {  32, -12} , { 102, -94} , {   0,   0} , {  56, -15} },
  468|       |    {  CTX_UNUSED , {  33,  -4} , {  29,  10} , {  37,  -5} , {  51, -29} , {  39,  -9} , {  52, -34} , {  69, -58} , {  67, -63} , {  44,  -5} , {  32,   7} , {  55, -29} , {  32,   1} , {   0,   0} , {  27,  36} },
  469|       |    {  {  17, -10} , {  32, -13} , {  42,  -9} , {  49,  -5} , {  53,   0} , {  64,   3} , {  68,  10} , {  66,  27} , {  47,  57} ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED },
  470|       |//    { {  17,  27} , {  23,  13} , {  24,  16} , {  22,  25} , {  23,  27} , {  23,  32} , {  17,  43} , {  17,  49} , {   2,  70} ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED },
  471|       |    {  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED },
  472|       |    {  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED },
  473|       |    { {  33, -25} , {  34, -30} , {  36, -28} , {  38, -28} , {  38, -27} , {  34, -18} , {  35, -16} , {  34, -14} , {  32,  -8} , {  37,  -6} , {  35,   0} , {  30,  10} , {  28,  18} , {  26,  25} , {  29,  41} },
  474|       |    { {   0,  75} , {   2,  72} , {   8,  77} ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED },
  475|       |    {  CTX_UNUSED , {  14,  35} , {  18,  31} , {  17,  35} , {  21,  30} , {  17,  45} , {  20,  42} , {  18,  45} , {  27,  26} , {  16,  54} , {   7,  66} , {  16,  56} , {  11,  73} , {  10,  67} , { -10, 116} }
  476|       |  },
  477|       |  //----- model 2 -----
  478|       |  {
  479|       |    { {   4,  39} , {   0,  42} , {   7,  34} , {  11,  29} , {   8,  31} , {   6,  37} , {   7,  42} , {   3,  40} , {   8,  33} , {  13,  43} , {  13,  36} , {   4,  47} , {   3,  55} , {   2,  58} , {   6,  60} },
  480|       |    {  CTX_UNUSED , {   8,  44} , {  11,  44} , {  14,  42} , {   7,  48} , {   4,  56} , {   4,  52} , {  13,  37} , {   9,  49} , {  19,  58} , {  10,  48} , {  12,  45} , {   0,  69} , {  20,  33} , {   8,  63} },
  481|       |    {  {   9,  -2} , {  30, -10} , {  31,  -4} , {  33,  -1} , {  33,   7} , {  31,  12} , {  37,  23} , {  31,  38} , {  20,  64} ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED },
  482|       |//    { {  17,  27} , {  23,  13} , {  24,  16} , {  22,  25} , {  23,  27} , {  23,  32} , {  17,  43} , {  17,  49} , {   2,  70} ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED },
  483|       |    {  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED },
  484|       |    {  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED },
  485|       |    { {  35, -18} , {  33, -25} , {  28,  -3} , {  24,  10} , {  27,   0} , {  34, -14} , {  52, -44} , {  39, -24} , {  19,  17} , {  31,  25} , {  36,  29} , {  24,  33} , {  34,  15} , {  30,  20} , {  22,  73} },
  486|       |    { {  20,  34} , {  19,  31} , {  27,  44} ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED },
  487|       |    {  CTX_UNUSED , {  19,  16} , {  15,  36} , {  15,  36} , {  21,  28} , {  25,  21} , {  30,  20} , {  31,  12} , {  27,  16} , {  24,  42} , {   0,  93} , {  14,  56} , {  15,  57} , {  26,  38} , { -24, 127} }
  488|       |  }
  489|       |};
  490|       |
  491|       |
  492|       |
  493|       |
  494|       |
  495|       |static const int INIT_ONE_I[1][8][5][2] =
  496|       |{
  497|       |  //----- model 0 -----
  498|       |  {
  499|       |    { {  -3,  71} , {  -6,  42} , {  -5,  50} , {  -3,  54} , {  -2,  62} },
  500|       |    { {  -5,  67} , {  -5,  27} , {  -3,  39} , {  -2,  44} , {   0,  46} },
  501|       |    {  {  -3,  75} , {  -1,  23} , {   1,  34} , {   1,  43} , {   0,  54} },
  502|       |//    { {  -9,  75} , {  -1,  44} , {  -2,  49} , {  -2,  51} , {  -1,  51} },
  503|       |    {  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED },
  504|       |    { { -12,  92} , { -15,  55} , { -10,  60} , {  -6,  62} , {  -4,  65} },
  505|       |    { { -11,  97} , { -20,  84} , { -11,  79} , {  -6,  73} , {  -4,  74} },
  506|       |    { {  -8,  78} , {  -5,  33} , {  -4,  48} , {  -2,  53} , {  -3,  62} },
  507|       |    {  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED }
  508|       |  }
  509|       |};
  510|       |static const int INIT_ONE_P[3][8][5][2] =
  511|       |{
  512|       |  //----- model 0 -----
  513|       |  {
  514|       |    { {  -6,  76} , {  -2,  44} , {   0,  45} , {   0,  52} , {  -3,  64} },
  515|       |    { {  -9,  77} , {   3,  24} , {   0,  42} , {   0,  48} , {   0,  55} },
  516|       |    {  {  -6,  66} , {  -7,  35} , {  -7,  42} , {  -8,  45} , {  -5,  48} },
  517|       |//    { {  -3,  58} , {  -1,  28} , {   0,  29} , {   2,  30} , {   1,  35} },
  518|       |    {  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED },
  519|       |    { {   1,  58} , {  -3,  29} , {  -1,  36} , {   1,  38} , {   2,  43} },
  520|       |    { {   0,  70} , {  -4,  29} , {   5,  31} , {   7,  42} , {   1,  59} },
  521|       |    { {   0,  58} , {   8,   5} , {  10,  14} , {  14,  18} , {  13,  27} },
  522|       |    {  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED }
  523|       |  },
  524|       |  //----- model 1 -----
  525|       |  {
  526|       |    { { -23, 112} , { -15,  71} , {  -7,  61} , {   0,  53} , {  -5,  66} },
  527|       |    { { -21, 101} , {  -3,  39} , {  -5,  53} , {  -7,  61} , { -11,  75} },
  528|       |    {  {  -5,  71} , {   0,  24} , {  -1,  36} , {  -2,  42} , {  -2,  52} },
  529|       |//    { {  -3,  58} , {  -1,  28} , {   0,  29} , {   2,  30} , {   1,  35} },
  530|       |    {  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED },
  531|       |    { { -11,  76} , { -10,  44} , { -10,  52} , { -10,  57} , {  -9,  58} },
  532|       |    { {   2,  66} , {  -9,  34} , {   1,  32} , {  11,  31} , {   5,  52} },
  533|       |    { {   3,  52} , {   7,   4} , {  10,   8} , {  17,   8} , {  16,  19} },
  534|       |    {  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED }
  535|       |  },
  536|       |  //----- model 2 -----
  537|       |  {
  538|       |    { { -24, 115} , { -22,  82} , {  -9,  62} , {   0,  53} , {   0,  59} },
  539|       |    { { -21, 100} , { -14,  57} , { -12,  67} , { -11,  71} , { -10,  77} },
  540|       |    {  {  -9,  71} , {  -7,  37} , {  -8,  44} , { -11,  49} , { -10,  56} },
  541|       |//    { {  -3,  58} , {  -1,  28} , {   0,  29} , {   2,  30} , {   1,  35} },
  542|       |    {  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED },
  543|       |    { { -10,  82} , {  -8,  48} , {  -8,  61} , {  -8,  66} , {  -7,  70} },
  544|       |    { {  -4,  79} , { -22,  69} , { -16,  75} , {  -2,  58} , {   1,  58} },
  545|       |    { { -13,  81} , {  -6,  38} , { -13,  62} , {  -6,  58} , {  -2,  59} },
  546|       |    {  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED }
  547|       |  }
  548|       |};
  549|       |
  550|       |
  551|       |
  552|       |
  553|       |
  554|       |static const int INIT_ABS_I[1][8][5][2] =
  555|       |{
  556|       |  //----- model 0 -----
  557|       |  {
  558|       |    { {   0,  58} , {   1,  63} , {  -2,  72} , {  -1,  74} , {  -9,  91} },
  559|       |    { { -16,  64} , {  -8,  68} , { -10,  78} , {  -6,  77} , { -10,  86} },
  560|       |    {  {  -2,  55} , {   0,  61} , {   1,  64} , {   0,  68} , {  -9,  92} },
  561|       |//    { {  -4,  56} , {  -1,  59} , {  -6,  71} , {  -8,  74} , { -11,  85} },
  562|       |    {  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED },
  563|       |    { { -12,  73} , {  -8,  76} , {  -7,  80} , {  -9,  88} , { -17, 110} },
  564|       |    { { -13,  86} , { -13,  96} , { -11,  97} , { -19, 117} ,  CTX_UNUSED },
  565|       |    { { -13,  71} , { -10,  79} , { -12,  86} , { -13,  90} , { -14,  97} },
  566|       |    {  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED }
  567|       |  }
  568|       |};
  569|       |static const int INIT_ABS_P[3][8][5][2] =
  570|       |{
  571|       |  //----- model 0 -----
  572|       |  {
  573|       |    { {  -2,  59} , {  -4,  70} , {  -4,  75} , {  -8,  82} , { -17, 102} },
  574|       |    { {  -6,  59} , {  -7,  71} , { -12,  83} , { -11,  87} , { -30, 119} },
  575|       |    {  { -12,  56} , {  -6,  60} , {  -5,  62} , {  -8,  66} , {  -8,  76} },
  576|       |//    { {  -7,  54} , {  -2,  58} , {  -4,  63} , {  -5,  66} , {   1,  64} },
  577|       |    {  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED },
  578|       |    { {  -6,  55} , {   0,  58} , {   0,  64} , {  -3,  74} , { -10,  90} },
  579|       |    { {  -2,  58} , {  -3,  72} , {  -3,  81} , { -11,  97} ,  CTX_UNUSED },
  580|       |    { {   2,  40} , {   0,  58} , {  -3,  70} , {  -6,  79} , {  -8,  85} },
  581|       |    {  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED }
  582|       |  },
  583|       |  //----- model 1 -----
  584|       |  {
  585|       |    { { -11,  77} , {  -9,  80} , {  -9,  84} , { -10,  87} , { -34, 127} },
  586|       |    { { -15,  77} , { -17,  91} , { -25, 107} , { -25, 111} , { -28, 122} },
  587|       |    {  {  -9,  57} , {  -6,  63} , {  -4,  65} , {  -4,  67} , {  -7,  82} },
  588|       |//    { {  -7,  54} , {  -2,  58} , {  -4,  63} , {  -5,  66} , {   1,  64} },
  589|       |    {  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED },
  590|       |    { { -16,  72} , {  -7,  69} , {  -4,  69} , {  -5,  74} , {  -9,  86} },
  591|       |    { {  -2,  55} , {  -2,  67} , {   0,  73} , {  -8,  89} ,  CTX_UNUSED },
  592|       |    { {   3,  37} , {  -1,  61} , {  -5,  73} , {  -1,  70} , {  -4,  78} },
  593|       |    {  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED }
  594|       |  },
  595|       |  //----- model 2 -----
  596|       |  {
  597|       |    { { -14,  85} , { -13,  89} , { -13,  94} , { -11,  92} , { -29, 127} },
  598|       |    { { -21,  85} , { -16,  88} , { -23, 104} , { -15,  98} , { -37, 127} },
  599|       |    {  { -12,  59} , {  -8,  63} , {  -9,  67} , {  -6,  68} , { -10,  79} },
  600|       |//    { {  -7,  54} , {  -2,  58} , {  -4,  63} , {  -5,  66} , {   1,  64} },
  601|       |    {  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED },
  602|       |    { { -14,  75} , { -10,  79} , {  -9,  83} , { -12,  92} , { -18, 108} },
  603|       |    { { -13,  78} , {  -9,  83} , {  -4,  81} , { -13,  99} ,  CTX_UNUSED },
  604|       |    { { -16,  73} , { -10,  76} , { -13,  86} , {  -9,  83} , { -10,  87} },
  605|       |    {  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED }
  606|       |  }
  607|       |};
  608|       |
  609|       |
  610|       |
  611|       |
  612|       |
  613|       |static const int INIT_FLD_MAP_I[1][8][15][2] =
  614|       |{
  615|       |  //----- model 0 -----
  616|       |  {
  617|       |    { {  -6,  93} , {  -6,  84} , {  -8,  79} , {   0,  66} , {  -1,  71} , {   0,  62} , {  -2,  60} , {  -2,  59} , {  -5,  75} , {  -3,  62} , {  -4,  58} , {  -9,  66} , {  -1,  79} , {   0,  71} , {   3,  68} },
  618|       |    {  CTX_UNUSED , {  10,  44} , {  -7,  62} , {  15,  36} , {  14,  40} , {  16,  27} , {  12,  29} , {   1,  44} , {  20,  36} , {  18,  32} , {   5,  42} , {   1,  48} , {  10,  62} , {  17,  46} , {   9,  64} },
  619|       |    {  { -14, 106} , { -13,  97} , { -15,  90} , { -12,  90} , { -18,  88} , { -10,  73} , {  -9,  79} , { -14,  86} , { -10,  73} , { -10,  70} , { -10,  69} , {  -5,  66} , {  -9,  64} , {  -5,  58} , {   2,  59} },
  620|       |//    { {  -1,  73} , {  -7,  73} , {  -6,  76} , {  -7,  71} , {  -9,  72} , {  -5,  65} , { -14,  83} , {  -8,  72} , { -10,  75} , {  -5,  64} , {  -4,  59} , { -13,  79} , {  -9,  69} , {  -8,  66} , {   3,  55} },
  621|       |    {  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED },
  622|       |    {  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED },
  623|       |    { { -12, 104} , { -11,  97} , { -16,  96} , {  -7,  88} , {  -8,  85} , {  -7,  85} , {  -9,  85} , { -13,  88} , {   4,  66} , {  -3,  77} , {  -3,  76} , {  -6,  76} , {  10,  58} , {  -1,  76} , {  -1,  83} },
  624|       |    { {  -7,  99} , { -14,  95} , {   2,  95} ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED },
  625|       |    {  CTX_UNUSED , {   0,  76} , {  -5,  74} , {   0,  70} , { -11,  75} , {   1,  68} , {   0,  65} , { -14,  73} , {   3,  62} , {   4,  62} , {  -1,  68} , { -13,  75} , {  11,  55} , {   5,  64} , {  12,  70} }
  626|       |  }
  627|       |};
  628|       |static const int INIT_FLD_MAP_P[3][8][15][2] =
  629|       |{
  630|       |  //----- model 0 -----
  631|       |  {
  632|       |    { { -13, 106} , { -16, 106} , { -10,  87} , { -21, 114} , { -18, 110} , { -14,  98} , { -22, 110} , { -21, 106} , { -18, 103} , { -21, 107} , { -23, 108} , { -26, 112} , { -10,  96} , { -12,  95} , {  -5,  91} },
  633|       |    {  CTX_UNUSED , {  -9,  93} , { -22,  94} , {  -5,  86} , {   9,  67} , {  -4,  80} , { -10,  85} , {  -1,  70} , {   7,  60} , {   9,  58} , {   5,  61} , {  12,  50} , {  15,  50} , {  18,  49} , {  17,  54} },
  634|       |    {  {  -5,  85} , {  -6,  81} , { -10,  77} , {  -7,  81} , { -17,  80} , { -18,  73} , {  -4,  74} , { -10,  83} , {  -9,  71} , {  -9,  67} , {  -1,  61} , {  -8,  66} , { -14,  66} , {   0,  59} , {   2,  59} },
  635|       |//    { {  -4,  60} , {  -3,  49} , {  -2,  50} , {  -4,  49} , {  -5,  48} , {  -2,  46} , {  -7,  54} , {  -1,  45} , {  -4,  49} , {   4,  39} , {   0,  42} , {   2,  43} , {   0,  44} , {   5,  32} , {  15,  30}  },
  636|       |    {  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED },
  637|       |    {  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED },
  638|       |    { {  10,  41} , {   7,  46} , {  -1,  51} , {   7,  49} , {   8,  52} , {   9,  41} , {   6,  47} , {   2,  55} , {  13,  41} , {  10,  44} , {   6,  50} , {   5,  53} , {  13,  49} , {   4,  63} , {   6,  64} },
  639|       |    { {  -2,  69} , {  -2,  59} , {   6,  70} ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED },
  640|       |    {  CTX_UNUSED , {  10,  44} , {   9,  31} , {  12,  43} , {   3,  53} , {  14,  34} , {  10,  38} , {  -3,  52} , {  13,  40} , {  17,  32} , {   7,  44} , {   7,  38} , {  13,  50} , {  10,  57} , {  26,  43} }
  641|       |  },
  642|       |  //----- model 1 -----
  643|       |  {
  644|       |    { { -21, 126} , { -23, 124} , { -20, 110} , { -26, 126} , { -25, 124} , { -17, 105} , { -27, 121} , { -27, 117} , { -17, 102} , { -26, 117} , { -27, 116} , { -33, 122} , { -10,  95} , { -14, 100} , {  -8,  95} },
  645|       |    {  CTX_UNUSED , { -17, 111} , { -28, 114} , {  -6,  89} , {  -2,  80} , {  -4,  82} , {  -9,  85} , {  -8,  81} , {  -1,  72} , {   5,  64} , {   1,  67} , {   9,  56} , {   0,  69} , {   1,  69} , {   7,  69} },
  646|       |    {  {  -3,  81} , {  -3,  76} , {  -7,  72} , {  -6,  78} , { -12,  72} , { -14,  68} , {  -3,  70} , {  -6,  76} , {  -5,  66} , {  -5,  62} , {   0,  57} , {  -4,  61} , {  -9,  60} , {   1,  54} , {   2,  58} },
  647|       |//    { {  -4,  60} , {  -3,  49} , {  -2,  50} , {  -4,  49} , {  -5,  48} , {  -2,  46} , {  -7,  54} , {  -1,  45} , {  -4,  49} , {   4,  39} , {   0,  42} , {   2,  43} , {   0,  44} , {   5,  32} , {  15,  30}  },
  648|       |    {  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED },
  649|       |    {  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED },
  650|       |    { {  -7,  69} , {  -6,  67} , { -16,  77} , {  -2,  64} , {   2,  61} , {  -6,  67} , {  -3,  64} , {   2,  57} , {  -3,  65} , {  -3,  66} , {   0,  62} , {   9,  51} , {  -1,  66} , {  -2,  71} , {  -2,  75} },
  651|       |    { {  -1,  70} , {  -9,  72} , {  14,  60} ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED },
  652|       |    {  CTX_UNUSED , {  16,  37} , {   0,  47} , {  18,  35} , {  11,  37} , {  12,  41} , {  10,  41} , {   2,  48} , {  12,  41} , {  13,  41} , {   0,  59} , {   3,  50} , {  19,  40} , {   3,  66} , {  18,  50} }
  653|       |  },
  654|       |  //----- model 2 -----
  655|       |  {
  656|       |    { { -22, 127} , { -25, 127} , { -25, 120} , { -27, 127} , { -19, 114} , { -23, 117} , { -25, 118} , { -26, 117} , { -24, 113} , { -28, 118} , { -31, 120} , { -37, 124} , { -10,  94} , { -15, 102} , { -10,  99} },
  657|       |    {  CTX_UNUSED , { -13, 106} , { -50, 127} , {  -5,  92} , {  17,  57} , {  -5,  86} , { -13,  94} , { -12,  91} , {  -2,  77} , {   0,  71} , {  -1,  73} , {   4,  64} , {  -7,  81} , {   5,  64} , {  15,  57} },
  658|       |    {  {  -3,  78} , {  -8,  74} , {  -9,  72} , { -10,  72} , { -18,  75} , { -12,  71} , { -11,  63} , {  -5,  70} , { -17,  75} , { -14,  72} , { -16,  67} , {  -8,  53} , { -14,  59} , {  -9,  52} , { -11,  68} },
  659|       |//    { {  -4,  60} , {  -3,  49} , {  -2,  50} , {  -4,  49} , {  -5,  48} , {  -2,  46} , {  -7,  54} , {  -1,  45} , {  -4,  49} , {   4,  39} , {   0,  42} , {   2,  43} , {   0,  44} , {   5,  32} , {  15,  30}  },
  660|       |    {  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED },
  661|       |    {  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED },
  662|       |    { {   1,  67} , {   0,  68} , { -10,  67} , {   1,  68} , {   0,  77} , {   2,  64} , {   0,  68} , {  -5,  78} , {   7,  55} , {   5,  59} , {   2,  65} , {  14,  54} , {  15,  44} , {   5,  60} , {   2,  70} },
  663|       |    { {  -2,  76} , { -18,  86} , {  12,  70} ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED },
  664|       |    {  CTX_UNUSED , {   5,  64} , { -12,  70} , {  11,  55} , {   5,  56} , {   0,  69} , {   2,  65} , {  -6,  74} , {   5,  54} , {   7,  54} , {  -6,  76} , { -11,  82} , {  -2,  77} , {  -2,  77} , {  25,  42} }
  665|       |  }
  666|       |};
  667|       |
  668|       |
  669|       |
  670|       |
  671|       |
  672|       |static const int INIT_FLD_LAST_I[1][8][15][2] =
  673|       |{
  674|       |  //----- model 0 -----
  675|       |  {
  676|       |    { {  15,   6} , {   6,  19} , {   7,  16} , {  12,  14} , {  18,  13} , {  13,  11} , {  13,  15} , {  15,  16} , {  12,  23} , {  13,  23} , {  15,  20} , {  14,  26} , {  14,  44} , {  17,  40} , {  17,  47} },
  677|       |    {  CTX_UNUSED , {  24,  17} , {  21,  21} , {  25,  22} , {  31,  27} , {  22,  29} , {  19,  35} , {  14,  50} , {  10,  57} , {   7,  63} , {  -2,  77} , {  -4,  82} , {  -3,  94} , {   9,  69} , { -12, 109} },
  678|       |    {  {  21, -10} , {  24, -11} , {  28,  -8} , {  28,  -1} , {  29,   3} , {  29,   9} , {  35,  20} , {  29,  36} , {  14,  67} ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED },
  679|       |//    { {  12,  33} , {   5,  38} , {   9,  34} , {  18,  22} , {  19,  22} , {  23,  19} , {  26,  16} , {  14,  44} , {  40,  14} ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED },
  680|       |    {  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED },
  681|       |    {  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED },
  682|       |    { {  36, -35} , {  36, -34} , {  32, -26} , {  37, -30} , {  44, -32} , {  34, -18} , {  34, -15} , {  40, -15} , {  33,  -7} , {  35,  -5} , {  33,   0} , {  38,   2} , {  33,  13} , {  23,  35} , {  13,  58} },
  683|       |    { {  29,  -3} , {  26,   0} , {  22,  30} ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED },
  684|       |    {  CTX_UNUSED , {  31,  -7} , {  35, -15} , {  34,  -3} , {  34,   3} , {  36,  -1} , {  34,   5} , {  32,  11} , {  35,   5} , {  34,  12} , {  39,  11} , {  30,  29} , {  34,  26} , {  29,  39} , {  19,  66} }
  685|       |  }
  686|       |};
  687|       |static const int INIT_FLD_LAST_P[3][8][15][2] =
  688|       |{
  689|       |  //----- model 0 -----
  690|       |  {
  691|       |    { {  14,  11} , {  11,  14} , {   9,  11} , {  18,  11} , {  21,   9} , {  23,  -2} , {  32, -15} , {  32, -15} , {  34, -21} , {  39, -23} , {  42, -33} , {  41, -31} , {  46, -28} , {  38, -12} , {  21,  29} },
  692|       |    {  CTX_UNUSED , {  45, -24} , {  53, -45} , {  48, -26} , {  65, -43} , {  43, -19} , {  39, -10} , {  30,   9} , {  18,  26} , {  20,  27} , {   0,  57} , { -14,  82} , {  -5,  75} , { -19,  97} , { -35, 125} },
  693|       |    {  {  21, -13} , {  33, -14} , {  39,  -7} , {  46,  -2} , {  51,   2} , {  60,   6} , {  61,  17} , {  55,  34} , {  42,  62} ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED },
  694|       |//    { {  17,  27} , {  23,  13} , {  24,  16} , {  22,  25} , {  23,  27} , {  23,  32} , {  17,  43} , {  17,  49} , {   2,  70} ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED },
  695|       |    {  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED },
  696|       |    {  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED },
  697|       |    { {  27,   0} , {  28,   0} , {  31,  -4} , {  27,   6} , {  34,   8} , {  30,  10} , {  24,  22} , {  33,  19} , {  22,  32} , {  26,  31} , {  21,  41} , {  26,  44} , {  23,  47} , {  16,  65} , {  14,  71} },
  698|       |    { {   8,  60} , {   6,  63} , {  17,  65} ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED },
  699|       |    {  CTX_UNUSED , {  21,  24} , {  23,  20} , {  26,  23} , {  27,  32} , {  28,  23} , {  28,  24} , {  23,  40} , {  24,  32} , {  28,  29} , {  23,  42} , {  19,  57} , {  22,  53} , {  22,  61} , {  11,  86} }
  700|       |  },
  701|       |  //----- model 1 -----
  702|       |  {
  703|       |    { {  19,  -6} , {  18,  -6} , {  14,   0} , {  26, -12} , {  31, -16} , {  33, -25} , {  33, -22} , {  37, -28} , {  39, -30} , {  42, -30} , {  47, -42} , {  45, -36} , {  49, -34} , {  41, -17} , {  32,   9} },
  704|       |    {  CTX_UNUSED , {  69, -71} , {  63, -63} , {  66, -64} , {  77, -74} , {  54, -39} , {  52, -35} , {  41, -10} , {  36,   0} , {  40,  -1} , {  30,  14} , {  28,  26} , {  23,  37} , {  12,  55} , {  11,  65} },
  705|       |    {  {  17, -10} , {  32, -13} , {  42,  -9} , {  49,  -5} , {  53,   0} , {  64,   3} , {  68,  10} , {  66,  27} , {  47,  57} ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED },
  706|       |//    { {  17,  27} , {  23,  13} , {  24,  16} , {  22,  25} , {  23,  27} , {  23,  32} , {  17,  43} , {  17,  49} , {   2,  70} ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED },
  707|       |    {  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED },
  708|       |    {  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED },
  709|       |    { {  37, -33} , {  39, -36} , {  40, -37} , {  38, -30} , {  46, -33} , {  42, -30} , {  40, -24} , {  49, -29} , {  38, -12} , {  40, -10} , {  38,  -3} , {  46,  -5} , {  31,  20} , {  29,  30} , {  25,  44} },
  710|       |    { {  12,  48} , {  11,  49} , {  26,  45} ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED },
  711|       |    {  CTX_UNUSED , {  22,  22} , {  23,  22} , {  27,  21} , {  33,  20} , {  26,  28} , {  30,  24} , {  27,  34} , {  18,  42} , {  25,  39} , {  18,  50} , {  12,  70} , {  21,  54} , {  14,  71} , {  11,  83} }
  712|       |  },
  713|       |  //----- model 2 -----
  714|       |  {
  715|       |    { {  17, -13} , {  16,  -9} , {  17, -12} , {  27, -21} , {  37, -30} , {  41, -40} , {  42, -41} , {  48, -47} , {  39, -32} , {  46, -40} , {  52, -51} , {  46, -41} , {  52, -39} , {  43, -19} , {  32,  11} },
  716|       |    {  CTX_UNUSED , {  61, -55} , {  56, -46} , {  62, -50} , {  81, -67} , {  45, -20} , {  35,  -2} , {  28,  15} , {  34,   1} , {  39,   1} , {  30,  17} , {  20,  38} , {  18,  45} , {  15,  54} , {   0,  79} },
  717|       |    {  {   9,  -2} , {  30, -10} , {  31,  -4} , {  33,  -1} , {  33,   7} , {  31,  12} , {  37,  23} , {  31,  38} , {  20,  64} ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED },
  718|       |//    { {  17,  27} , {  23,  13} , {  24,  16} , {  22,  25} , {  23,  27} , {  23,  32} , {  17,  43} , {  17,  49} , {   2,  70} ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED },
  719|       |    {  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED },
  720|       |    {  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED },
  721|       |    { {  36, -16} , {  37, -14} , {  37, -17} , {  32,   1} , {  34,  15} , {  29,  15} , {  24,  25} , {  34,  22} , {  31,  16} , {  35,  18} , {  31,  28} , {  33,  41} , {  36,  28} , {  27,  47} , {  21,  62} },
  722|       |    { {  18,  31} , {  19,  26} , {  36,  24} ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED ,  CTX_UNUSED },
  723|       |    {  CTX_UNUSED , {  24,  23} , {  27,  16} , {  24,  30} , {  31,  29} , {  22,  41} , {  22,  42} , {  16,  60} , {  15,  52} , {  14,  60} , {   3,  78} , { -16, 123} , {  21,  53} , {  22,  56} , {  25,  61} }
  724|       |  }
  725|       |};
  726|       |
  727|       |
  728|       |#endif
  729|       |

/home/xzp/speccpu2006-v1.0.1/benchspec/CPU2006/464.h264ref/run/build_base_ql_riscv_llvm17.0000/decoder.c:
    1|       |
    2|       |/*! 
    3|       | *************************************************************************************
    4|       | * \file decoder.c
    5|       | *
    6|       | * \brief
    7|       | *    Contains functions that implement the "decoders in the encoder" concept for the
    8|       | *    rate-distortion optimization with losses.
    9|       | * \date
   10|       | *    October 22nd, 2001
   11|       | *
   12|       | * \author
   13|       | *    Main contributors (see contributors.h for copyright, address and 
   14|       | *    affiliation details)
   15|       | *    - Dimitrios Kontopodis                    <dkonto@eikon.tum.de>
   16|       | *************************************************************************************
   17|       | */
   18|       |
   19|       |#include <stdlib.h>
   20|       |#include <memory.h>
   21|       |
   22|       |#include "global.h"
   23|       |#include "refbuf.h"
   24|       |#include "image.h"
   25|       |
   26|       |/*! 
   27|       | *************************************************************************************
   28|       | * \brief
   29|       | *    decodes one 8x8 partition
   30|       | *
   31|       | * \note
   32|       | *    Gives the expected value in the decoder of one 8x8 block. This is done based on the 
   33|       | *    stored reconstructed residue decs->resY[][], the reconstructed values imgY[][]
   34|       | *    and the motion vectors. The decoded 8x8 block is moved to decs->decY[][].
   35|       | *************************************************************************************
   36|       | */
   37|       |void decode_one_b8block (int decoder, int mbmode, int b8block, int b8mode, int b8ref)
   38|      0|{
   39|      0|  int i,j,block_y,block_x,bx,by;
   40|      0|  int ref_inx = (IMG_NUMBER-1)%img->num_ref_frames;
   41|       |
   42|      0|  int mv[2][BLOCK_MULTIPLE][BLOCK_MULTIPLE];
   43|      0|  int resY_tmp[MB_BLOCK_SIZE][MB_BLOCK_SIZE];
   44|       |
   45|      0|  int i0 = (b8block%2)<<3,   i1 = i0+8,   bx0 = i0>>2,   bx1 = bx0+2;
   46|      0|  int j0 = (b8block/2)<<3,   j1 = j0+8,   by0 = j0>>2,   by1 = by0+2;
   47|       |
   48|      0|  if (img->type==I_SLICE)
   49|      0|  {
   50|      0|    for(i=i0;i<i1;i++)
   51|      0|    for(j=j0;j<j1;j++)
   52|      0|    {
   53|      0|      decs->decY[decoder][img->pix_y+j][img->pix_x+i]=enc_picture->imgY[img->pix_y+j][img->pix_x+i];
   54|      0|    }
   55|      0|  }
   56|      0|  else
   57|      0|  {
   58|      0|    if (mbmode==0 && (img->type==P_SLICE || (img->type==B_SLICE && img->nal_reference_idc>0)))
   59|      0|    {
   60|      0|      for(i=i0;i<i1;i++)
   61|      0|      for(j=j0;j<j1;j++)
   62|      0|      {
   63|      0|        resY_tmp[j][i]=0;
   64|      0|      }
   65|      0|      for (by=by0; by<by1; by++)
   66|      0|      for (bx=bx0; bx<bx1; bx++)
   67|      0|      {
   68|      0|        mv[0][by][bx] = mv[1][by][bx] = 0;
   69|      0|      }
   70|      0|    }
   71|      0|    else
   72|      0|    {
   73|      0|      if (b8mode>=1 && b8mode<=7)
   74|      0|      {
   75|      0|        for (by=by0; by<by1; by++)
   76|      0|        for (bx=bx0; bx<bx1; bx++)
   77|      0|        {
   78|      0|          mv[0][by][bx] = img->all_mv[bx][by][LIST_0][b8ref][b8mode][0];
   79|      0|          mv[1][by][bx] = img->all_mv[bx][by][LIST_0][b8ref][b8mode][1];
   80|      0|        }
   81|      0|      }
   82|      0|      else
   83|      0|      {
   84|      0|        for (by=by0; by<by1; by++)
   85|      0|        for (bx=bx0; bx<bx1; bx++)
   86|      0|        {
   87|      0|          mv[0][by][bx] = mv[1][by][bx] = 0;
   88|      0|        }
   89|      0|      }
   90|       |          
   91|      0|      for(i=i0;i<i1;i++)
   92|      0|      for(j=j0;j<j1;j++)
   93|      0|      {
   94|      0|        resY_tmp[j][i]=decs->resY[j][i];
   95|      0|      }
   96|      0|    }
   97|       |
   98|       |    // Decode Luminance
   99|      0|    if ((b8mode>=1 && b8mode<=7) || (mbmode==0 && (img->type==P_SLICE || (img->type==B_SLICE && img->nal_reference_idc>0))))
  100|      0|    {
  101|      0|      for (by=by0; by<by1; by++)
  102|      0|      for (bx=bx0; bx<bx1; bx++)
  103|      0|      {
  104|      0|        block_x = img->block_x+bx;
  105|      0|        block_y = img->block_y+by;
  106|      0|        if (img->type == B_SLICE && enc_picture != enc_frame_picture)
  107|      0|          ref_inx = (IMG_NUMBER-b8ref-2)%img->num_ref_frames;
  108|       |
  109|      0|        Get_Reference_Block (decs->decref[decoder][ref_inx],
  110|      0|                             block_y, block_x,
  111|      0|                             mv[0][by][bx],
  112|      0|                             mv[1][by][bx],
  113|      0|                             decs->RefBlock);
  114|      0|        for (j=0; j<4; j++)
  115|      0|        for (i=0; i<4; i++)
  116|      0|        {
  117|       |          /*
  118|       |          if (decs->RefBlock[j][i] != UMVPelY_14 (mref[ref_inx],
  119|       |                                                  (block_y*4+j)*4+mv[1][by][bx],
  120|       |                                                  (block_x*4+i)*4+mv[0][by][bx]))
  121|       |          ref_inx = (img->number-ref-1)%img->num_ref_frames;
  122|       |          */
  123|      0|          decs->decY[decoder][block_y*4+j][block_x*4+i] = resY_tmp[by*4+j][bx*4+i] + decs->RefBlock[j][i];
  124|      0|        }
  125|      0|      }
  126|      0|    }
  127|      0|    else 
  128|      0|    {
  129|       |      // Intra Refresh - Assume no spatial prediction
  130|      0|      for(i=i0;i<i1;i++)
  131|      0|      for(j=j0;j<j1;j++)
  132|      0|      {
  133|      0|        decs->decY[decoder][img->pix_y+j][img->pix_x+i] = enc_picture->imgY[img->pix_y+j][img->pix_x+i];
  134|      0|      }
  135|      0|    }
  136|      0|  }
  137|      0|}
  138|       |
  139|       |
  140|       |/*! 
  141|       | *************************************************************************************
  142|       | * \brief
  143|       | *    decodes one macroblock
  144|       | *************************************************************************************
  145|       | */
  146|       |void decode_one_mb (int decoder, Macroblock* currMB)
  147|      0|{
  148|       |  /*
  149|       |  decode_one_b8block (decoder, currMB->mb_type, 0, currMB->b8mode[0], refFrArr[img->block_y+0][img->block_x+0]);
  150|       |  decode_one_b8block (decoder, currMB->mb_type, 1, currMB->b8mode[1], refFrArr[img->block_y+0][img->block_x+2]);
  151|       |  decode_one_b8block (decoder, currMB->mb_type, 2, currMB->b8mode[2], refFrArr[img->block_y+2][img->block_x+0]);
  152|       |  decode_one_b8block (decoder, currMB->mb_type, 3, currMB->b8mode[3], refFrArr[img->block_y+2][img->block_x+2]);
  153|       |  */
  154|      0|}
  155|       |
  156|       |/*! 
  157|       | *************************************************************************************
  158|       | * \brief
  159|       | *    Finds the reference MB given the decoded reference frame
  160|       | * \note
  161|       | *    This is based on the function UnifiedOneForthPix, only it is modified to
  162|       | *    be used at the "many decoders in the encoder" RD optimization. In this case
  163|       | *    we dont want to keep full upsampled reference frames for all decoders, so
  164|       | *    we just upsample when it is necessary.
  165|       | * \param imY
  166|       | *    The frame to be upsampled
  167|       | * \param block_y
  168|       | *    The row of the block, whose prediction we want to find
  169|       | * \param block_x
  170|       | *    The column of the block, whose prediction we want to track
  171|       | * \param mvhor
  172|       | *    Motion vector, horizontal part
  173|       | * \param mvver
  174|       | *    Motion vector, vertical part
  175|       | * \param out
  176|       | *    Output: The prediction for the block (block_y, block_x)
  177|       | *************************************************************************************
  178|       | */
  179|       |void Get_Reference_Block(imgpel **imY, 
  180|       |                         int block_y, 
  181|       |                         int block_x, 
  182|       |                         int mvhor, 
  183|       |                         int mvver, 
  184|       |                         imgpel **out)
  185|      0|{
  186|      0|  int i,j,y,x;
  187|       |
  188|      0|  y = block_y * BLOCK_SIZE * 4 + mvver;
  189|      0|  x = block_x * BLOCK_SIZE * 4 + mvhor;
  190|       |
  191|      0|  for (j=0; j<BLOCK_SIZE; j++)
  192|      0|    for (i=0; i<BLOCK_SIZE; i++)
  193|      0|      out[j][i] = Get_Reference_Pixel(imY, y+j*4, x+i*4);
  194|      0|}
  195|       |
  196|       |/*! 
  197|       | *************************************************************************************
  198|       | * \brief
  199|       | *    Finds a pixel (y,x) of the upsampled reference frame
  200|       | * \note
  201|       | *    This is based on the function UnifiedOneForthPix, only it is modified to
  202|       | *    be used at the "many decoders in the encoder" RD optimization. In this case
  203|       | *    we dont want to keep full upsampled reference frames for all decoders, so
  204|       | *    we just upsample when it is necessary.
  205|       | *************************************************************************************
  206|       | */
  207|       |byte Get_Reference_Pixel(imgpel **imY, int y_pos, int x_pos)
  208|      0|{
  209|       |
  210|      0|  int dx, x;
  211|      0|  int dy, y;
  212|      0|  int maxold_x,maxold_y;
  213|       |
  214|      0|  int result = 0, result1, result2;
  215|      0|  int pres_x;
  216|      0|  int pres_y; 
  217|       |
  218|      0|  int tmp_res[6];
  219|       |
  220|      0|  static const int COEF[6] = {
  221|      0|    1, -5, 20, 20, -5, 1
  222|      0|  };
  223|       |
  224|       |
  225|      0|  dx = x_pos&3;
  226|      0|  dy = y_pos&3;
  227|      0|  x_pos = (x_pos-dx)/4;
  228|      0|  y_pos = (y_pos-dy)/4;
  229|      0|  maxold_x = img->width-1;
  230|      0|  maxold_y = img->height-1;
  231|       |
  232|      0|  if (dx == 0 && dy == 0) { /* fullpel position */
  233|      0|    result = imY[max(0,min(maxold_y,y_pos))][max(0,min(maxold_x,x_pos))];
  234|      0|  }
  235|      0|  else { /* other positions */
  236|       |
  237|      0|    if (dy == 0) {
  238|       |
  239|      0|      pres_y = max(0,min(maxold_y,y_pos));
  240|      0|      for(x=-2;x<4;x++) {
  241|      0|        pres_x = max(0,min(maxold_x,x_pos+x));
  242|      0|        result += imY[pres_y][pres_x]*COEF[x+2];
  243|      0|      }
  244|       |
  245|      0|      result = max(0, min(img->max_imgpel_value, (result+16)/32));
  246|       |
  247|      0|      if (dx == 1) {
  248|      0|        result = (result + imY[pres_y][max(0,min(maxold_x,x_pos))])/2;
  249|      0|      }
  250|      0|      else if (dx == 3) {
  251|      0|        result = (result + imY[pres_y][max(0,min(maxold_x,x_pos+1))])/2;
  252|      0|      }
  253|      0|    }
  254|      0|    else if (dx == 0) {
  255|       |
  256|      0|      pres_x = max(0,min(maxold_x,x_pos));
  257|      0|      for(y=-2;y<4;y++) {
  258|      0|        pres_y = max(0,min(maxold_y,y_pos+y));
  259|      0|        result += imY[pres_y][pres_x]*COEF[y+2];
  260|      0|      }
  261|       |
  262|      0|      result = max(0, min(img->max_imgpel_value, (result+16)/32));
  263|       |
  264|      0|      if (dy == 1) {
  265|      0|        result = (result + imY[max(0,min(maxold_y,y_pos))][pres_x])/2;
  266|      0|      }
  267|      0|      else if (dy == 3) {
  268|      0|        result = (result + imY[max(0,min(maxold_y,y_pos+1))][pres_x])/2;
  269|      0|      }
  270|      0|    }
  271|      0|    else if (dx == 2) {
  272|       |
  273|      0|      for(y=-2;y<4;y++) {
  274|      0|        result = 0;
  275|      0|        pres_y = max(0,min(maxold_y,y_pos+y));
  276|      0|        for(x=-2;x<4;x++) {
  277|      0|          pres_x = max(0,min(maxold_x,x_pos+x));
  278|      0|          result += imY[pres_y][pres_x]*COEF[x+2];
  279|      0|        }
  280|      0|        tmp_res[y+2] = result;
  281|      0|      }
  282|       |
  283|      0|      result = 0;
  284|      0|      for(y=-2;y<4;y++) {
  285|      0|        result += tmp_res[y+2]*COEF[y+2];
  286|      0|      }
  287|       |
  288|      0|      result = max(0, min(img->max_imgpel_value, (result+512)/1024));
  289|       |
  290|      0|      if (dy == 1) {
  291|      0|        result = (result + max(0, min(img->max_imgpel_value, (tmp_res[2]+16)/32)))/2;
  292|      0|      }
  293|      0|      else if (dy == 3) {
  294|      0|        result = (result + max(0, min(img->max_imgpel_value, (tmp_res[3]+16)/32)))/2;
  295|      0|      }
  296|      0|    }
  297|      0|    else if (dy == 2) {
  298|       |
  299|      0|      for(x=-2;x<4;x++) {
  300|      0|        result = 0;
  301|      0|        pres_x = max(0,min(maxold_x,x_pos+x));
  302|      0|        for(y=-2;y<4;y++) {
  303|      0|          pres_y = max(0,min(maxold_y,y_pos+y));
  304|      0|          result += imY[pres_y][pres_x]*COEF[y+2];
  305|      0|        }
  306|      0|        tmp_res[x+2] = result;
  307|      0|      }
  308|       |
  309|      0|      result = 0;
  310|      0|      for(x=-2;x<4;x++) {
  311|      0|        result += tmp_res[x+2]*COEF[x+2];
  312|      0|      }
  313|       |
  314|      0|      result = max(0, min(img->max_imgpel_value, (result+512)/1024));
  315|       |
  316|      0|      if (dx == 1) {
  317|      0|        result = (result + max(0, min(img->max_imgpel_value, (tmp_res[2]+16)/32)))/2;
  318|      0|      }
  319|      0|      else {
  320|      0|        result = (result + max(0, min(img->max_imgpel_value, (tmp_res[3]+16)/32)))/2;
  321|      0|      }
  322|      0|    }
  323|      0|    else {
  324|       |
  325|      0|      result = 0;
  326|      0|      pres_y = dy == 1 ? y_pos : y_pos+1;
  327|      0|      pres_y = max(0,min(maxold_y,pres_y));
  328|       |
  329|      0|      for(x=-2;x<4;x++) {
  330|      0|        pres_x = max(0,min(maxold_x,x_pos+x));
  331|      0|        result += imY[pres_y][pres_x]*COEF[x+2];
  332|      0|      }
  333|       |
  334|      0|      result1 = max(0, min(img->max_imgpel_value, (result+16)/32));
  335|       |
  336|      0|      result = 0;
  337|      0|      pres_x = dx == 1 ? x_pos : x_pos+1;
  338|      0|      pres_x = max(0,min(maxold_x,pres_x));
  339|       |
  340|      0|      for(y=-2;y<4;y++) {
  341|      0|        pres_y = max(0,min(maxold_y,y_pos+y));
  342|      0|        result += imY[pres_y][pres_x]*COEF[y+2];
  343|      0|      }
  344|       |
  345|      0|      result2 = max(0, min(img->max_imgpel_value, (result+16)/32));
  346|      0|      result = (result1+result2)/2;
  347|      0|    }
  348|      0|  }
  349|       |
  350|      0|  return result;
  351|      0|}
  352|       |  
  353|       |/*! 
  354|       | *************************************************************************************
  355|       | * \brief
  356|       | *    Performs the simulation of the packet losses, calls the error concealment funcs
  357|       | *    and copies the decoded images to the reference frame buffers of the decoders 
  358|       | *
  359|       | *************************************************************************************
  360|       | */
  361|       |void UpdateDecoders()
  362|      0|{
  363|      0|  int k;
  364|      0|  for (k=0; k<input->NoOfDecoders; k++)
  365|      0|  {
  366|      0|    Build_Status_Map(decs->status_map); // simulates the packet losses
  367|      0|    Error_Concealment(decs->decY_best[k], decs->status_map, decs->decref[k]); // for the moment error concealment is just a "copy"
  368|       |    // Move decoded frames to reference buffers: (at the decoders this is done 
  369|       |    // without interpolation (upsampling) - upsampling is done while decoding
  370|      0|    DecOneForthPix(decs->decY_best[k], decs->decref[k]); 
  371|      0|  }
  372|      0|}
  373|       |/*! 
  374|       | *************************************************************************************
  375|       | * \brief
  376|       | *    Copies one (reconstructed) image to the respective reference frame buffer
  377|       | *
  378|       | * \note
  379|       | *    This is used at the "many decoders in the encoder"
  380|       | * \param dY
  381|       | *    The reconstructed image
  382|       | * \param dref
  383|       | *    The reference buffer
  384|       | *************************************************************************************
  385|       | */
  386|       |void DecOneForthPix(imgpel **dY, imgpel ***dref)
  387|      0|{
  388|      0|  int j, ref=IMG_NUMBER%img->buf_cycle;
  389|       |
  390|      0|  for (j=0; j<img->height; j++)
  391|      0|    memcpy(dref[ref][j], dY[j], img->width*sizeof(imgpel));
  392|      0|}
  393|       |
  394|       |/*! 
  395|       | *************************************************************************************
  396|       | * \brief
  397|       | *    Gives the prediction residue for a 8x8 block
  398|       | *************************************************************************************
  399|       | */
  400|       |void compute_residue_b8block (int b8block, int i16mode) // if not INTRA16x16 it has to be -1
  401|      0|{
  402|      0|  int i,j;
  403|      0|  int i0 = (b8block%2)<<3,   i1 = i0+8;
  404|      0|  int j0 = (b8block/2)<<3,   j1 = j0+8;
  405|       |
  406|      0|  if (i16mode>=0)
  407|      0|  {
  408|      0|    for (i=i0; i<i1; i++)
  409|      0|    for (j=j0; j<j1; j++)
  410|      0|    {
  411|      0|      decs->resY[j][i] = enc_picture->imgY[img->pix_y+j][img->pix_x+i] - img->mprr_2[i16mode][j][i];
  412|      0|    }
  413|      0|  }
  414|      0|  else
  415|      0|  {
  416|      0|    for (i=i0; i<i1; i++)
  417|      0|    for (j=j0; j<j1; j++)
  418|      0|    {
  419|      0|      decs->resY[j][i] = enc_picture->imgY[img->pix_y+j][img->pix_x+i] - img->mpr[i][j];
  420|      0|    }
  421|      0|  }
  422|      0|}
  423|       |
  424|       |/*! 
  425|       | *************************************************************************************
  426|       | * \brief
  427|       | *    Gives the prediction residue for a macroblock
  428|       | *************************************************************************************
  429|       | */
  430|       |void compute_residue_mb (int i16mode)
  431|      0|{
  432|      0|  compute_residue_b8block (0, i16mode);
  433|      0|  compute_residue_b8block (1, i16mode);
  434|      0|  compute_residue_b8block (2, i16mode);
  435|      0|  compute_residue_b8block (3, i16mode);
  436|      0|}
  437|       |
  438|       |
  439|       |/*! 
  440|       | *************************************************************************************
  441|       | * \brief
  442|       | *    Builds a random status map showing whether each MB is received or lost, based
  443|       | *    on the packet loss rate and the slice structure.
  444|       | *
  445|       | * \param s_map
  446|       | *    The status map to be filled
  447|       | *************************************************************************************
  448|       | */
  449|       |void Build_Status_Map(byte **s_map)
  450|      0|{
  451|      0|  int i,j,slice=-1,mb=0,jj,ii,packet_lost=0;
  452|       |
  453|      0|  jj = img->height/MB_BLOCK_SIZE;
  454|      0|  ii = img->width/MB_BLOCK_SIZE;
  455|       |  
  456|      0|  for (j=0 ; j<jj; j++)
  457|      0|  for (i=0 ; i<ii; i++)
  458|      0|  {
  459|      0|    if (!input->slice_mode || img->mb_data[mb].slice_nr != slice) /* new slice */
  460|      0|    {
  461|      0|      packet_lost=0;
  462|      0|      #if defined(SPEC_CPU)
  463|      0|      if ((spec_rand() * (double) RAND_MAX)/(double)RAND_MAX*100.0 < input->LossRateC)   packet_lost += 3;
  464|      0|      if ((spec_rand() * (double) RAND_MAX)/(double)RAND_MAX*100.0 < input->LossRateB)   packet_lost += 2;
  465|      0|      if ((spec_rand() * (double) RAND_MAX)/(double)RAND_MAX*100.0 < input->LossRateA)   packet_lost  = 1;
  466|       |      #else
  467|       |      if ((double)rand()/(double)RAND_MAX*100 < input->LossRateC)   packet_lost += 3;
  468|       |      if ((double)rand()/(double)RAND_MAX*100 < input->LossRateB)   packet_lost += 2;
  469|       |      if ((double)rand()/(double)RAND_MAX*100 < input->LossRateA)   packet_lost  = 1;
  470|       |      #endif
  471|      0|      slice++;
  472|      0|    }
  473|      0|    if (!packet_lost)
  474|      0|    {
  475|      0|      s_map[j][i]=0;  //! Packet OK
  476|      0|    }
  477|      0|    else
  478|      0|    {
  479|      0|      s_map[j][i]=packet_lost;
  480|      0|      if(input->partition_mode == 0)  s_map[j][i]=1;
  481|      0|    }
  482|      0|    mb++;
  483|      0|  }
  484|      0|}
  485|       |
  486|       |/*! 
  487|       | *************************************************************************************
  488|       | * \brief
  489|       | *    Performs some sort of error concealment for the areas that are lost according
  490|       | *    to the status_map
  491|       | *    
  492|       | * \param inY
  493|       | *    Error concealment is performed on this frame imY[][]
  494|       | * \param s_map
  495|       | *    The status map shows which areas are lost.
  496|       | * \param refY
  497|       | *    The set of reference frames - may be used for the error concealment.
  498|       | *************************************************************************************
  499|       | */
  500|       |void Error_Concealment(imgpel **inY, byte **s_map, imgpel ***refY)
  501|      0|{
  502|      0|  int mb_y, mb_x, mb_h, mb_w;
  503|      0|  mb_h = img->height/MB_BLOCK_SIZE;
  504|      0|  mb_w = img->width/MB_BLOCK_SIZE;
  505|       |  
  506|      0|  for (mb_y=0; mb_y < mb_h; mb_y++)
  507|      0|  for (mb_x=0; mb_x < mb_w; mb_x++)
  508|      0|  {
  509|      0|    if (s_map[mb_y][mb_x])   Conceal_Error(inY, mb_y, mb_x, refY, s_map);
  510|      0|  }
  511|      0|}
  512|       |
  513|       |/*! 
  514|       | *************************************************************************************
  515|       | * \brief
  516|       | *    Copies a certain MB (mb_y,mb_x) of the frame inY[][] from the previous frame.
  517|       | *    For the time there is no better EC...
  518|       | *************************************************************************************
  519|       | */
  520|       |void Conceal_Error(imgpel **inY, int mb_y, int mb_x, imgpel ***refY, byte **s_map)
  521|      0|{
  522|      0|  int i,j,block_x, block_y;
  523|      0|  int ref_inx = (IMG_NUMBER-1)%img->num_ref_frames;
  524|      0|  int pos_y = mb_y*MB_BLOCK_SIZE, pos_x = mb_x*MB_BLOCK_SIZE;
  525|      0|  int mv[2][BLOCK_MULTIPLE][BLOCK_MULTIPLE];
  526|      0|  int resY[MB_BLOCK_SIZE][MB_BLOCK_SIZE];
  527|      0|  int copy  = (decs->dec_mb_mode[mb_x][mb_y]==0 && (img->type==P_SLICE || (img->type==B_SLICE && img->nal_reference_idc>0)));
  528|      0|  int inter = (((decs->dec_mb_mode[mb_x][mb_y]>=1 && decs->dec_mb_mode[mb_x][mb_y]<=3) || decs->dec_mb_mode[mb_x][mb_y]==P8x8) && (img->type==P_SLICE || (img->type==B_SLICE && img->nal_reference_idc>0)));
  529|      0|  short ***tmp_mv = enc_picture->mv[LIST_0];
  530|       |  
  531|      0|  switch(s_map[mb_y][mb_x])
  532|      0|  {
  533|      0|  case 1: //! whole slice lost (at least partition A lost)
  534|      0|    if (img->type!=I_SLICE)
  535|      0|    {
  536|      0|      for (j=0;j<MB_BLOCK_SIZE;j++)
  537|      0|        for (i=0;i<MB_BLOCK_SIZE;i++)
  538|      0|          inY[pos_y+j][pos_x+i] = refY[ref_inx][pos_y+j][pos_x+i];
  539|      0|    }
  540|      0|    else
  541|      0|    {
  542|      0|      for (j=0;j<MB_BLOCK_SIZE;j++)
  543|      0|        for (i=0;i<MB_BLOCK_SIZE;i++)
  544|      0|          inY[pos_y+j][pos_x+i] = 127;
  545|      0|    }
  546|      0|    break;
  547|      0|  case 5: //! partition B and partition C lost
  548|       |    
  549|       |    //! Copy motion vectors 
  550|      0|    for (block_y=0; block_y<BLOCK_MULTIPLE; block_y++)
  551|      0|      for (block_x=0; block_x<BLOCK_MULTIPLE; block_x++)
  552|      0|        for (i=0;i<2;i++)
  553|      0|          mv[i][block_y][block_x]=tmp_mv[mb_x*BLOCK_SIZE+block_x+4][mb_y*BLOCK_SIZE+block_y][i];
  554|       |    
  555|       |    //! Residuum ist set to zero    
  556|      0|    for(i=0;i<MB_BLOCK_SIZE;i++)
  557|      0|      for(j=0;j<MB_BLOCK_SIZE;j++)
  558|      0|        resY[j][i]=0;
  559|       |    
  560|       |    //! not first frame
  561|      0|    if (img->type!=I_SLICE)
  562|      0|    {
  563|       |      //! if copy mb
  564|      0|      if (copy)
  565|      0|      {
  566|      0|        for (j=0;j<MB_BLOCK_SIZE;j++)
  567|      0|          for (i=0;i<MB_BLOCK_SIZE;i++)
  568|      0|            inY[pos_y+j][pos_x+i] = refY[ref_inx][pos_y+j][pos_x+i];
  569|      0|      }
  570|       |      //! if inter mb
  571|      0|      else if (inter)  
  572|      0|      {
  573|      0|        for (block_y = mb_y*BLOCK_SIZE ; block_y < (mb_y*BLOCK_SIZE + BLOCK_MULTIPLE) ; block_y++)
  574|      0|          for (block_x = mb_x*BLOCK_SIZE ; block_x < (mb_x*BLOCK_SIZE + BLOCK_MULTIPLE) ; block_x++)
  575|      0|          {
  576|      0|            Get_Reference_Block(refY[ref_inx],
  577|      0|                                block_y, block_x,
  578|      0|                                mv[0][block_y - mb_y*BLOCK_SIZE][block_x - mb_x*BLOCK_SIZE],
  579|      0|                                mv[1][block_y - mb_y*BLOCK_SIZE][block_x - mb_x*BLOCK_SIZE],
  580|      0|                                decs->RefBlock);
  581|      0|            for (j=0;j<BLOCK_SIZE;j++)
  582|      0|              for (i=0;i<BLOCK_SIZE;i++)
  583|      0|              {
  584|      0|                inY[block_y*BLOCK_SIZE + j][block_x*BLOCK_SIZE + i] = decs->RefBlock[j][i];
  585|      0|              }
  586|      0|          }
  587|      0|      }
  588|      0|      else //intra; up to now only copy mb, may integrate nokia EC 
  589|      0|      {
  590|      0|        for (j=0;j<MB_BLOCK_SIZE;j++)
  591|      0|          for (i=0;i<MB_BLOCK_SIZE;i++)
  592|      0|            inY[pos_y+j][pos_x+i] = refY[ref_inx][pos_y+j][pos_x+i];
  593|      0|      }
  594|      0|    }
  595|      0|    else //! first frame; up to now set value to grey, may integrate nokia EC 
  596|      0|    {
  597|      0|      for (j=0;j<MB_BLOCK_SIZE;j++)
  598|      0|        for (i=0;i<MB_BLOCK_SIZE;i++)
  599|      0|          inY[pos_y+j][pos_x+i] = 127;
  600|      0|    }
  601|      0|    break;
  602|      0|  case 3: //! Partition C lost
  603|      0|    if(img->type!=I_SLICE)
  604|      0|    {
  605|       |      //! Copy motion vectors 
  606|      0|      for (block_y=0; block_y<BLOCK_MULTIPLE; block_y++)
  607|      0|        for (block_x=0; block_x<BLOCK_MULTIPLE; block_x++)
  608|      0|          for (i=0;i<2;i++)
  609|      0|            mv[i][block_y][block_x]=tmp_mv[mb_x*BLOCK_SIZE+block_x+4][mb_y*BLOCK_SIZE+block_y][i];
  610|       |    
  611|       |      //! Residuum ist set to zero    
  612|      0|      for(i=0;i<MB_BLOCK_SIZE;i++)
  613|      0|        for(j=0;j<MB_BLOCK_SIZE;j++)
  614|      0|          resY[j][i]=0;
  615|       |
  616|       |      //! if copy mb
  617|      0|      if (copy)
  618|      0|      {
  619|      0|        for (j=0;j<MB_BLOCK_SIZE;j++)
  620|      0|          for (i=0;i<MB_BLOCK_SIZE;i++)
  621|      0|            inY[pos_y+j][pos_x+i] = refY[ref_inx][pos_y+j][pos_x+i];
  622|      0|      }
  623|       |      //! if inter mb
  624|      0|      else if (inter)  
  625|      0|      {
  626|      0|        for (block_y = mb_y*BLOCK_SIZE ; block_y < (mb_y*BLOCK_SIZE + BLOCK_MULTIPLE) ; block_y++)
  627|      0|          for (block_x = mb_x*BLOCK_SIZE ; block_x < (mb_x*BLOCK_SIZE + BLOCK_MULTIPLE) ; block_x++)
  628|      0|            {
  629|      0|              Get_Reference_Block(refY[ref_inx],
  630|      0|                                  block_y, block_x,
  631|      0|                                  mv[0][block_y - mb_y*BLOCK_SIZE][block_x - mb_x*BLOCK_SIZE],
  632|      0|                                  mv[1][block_y - mb_y*BLOCK_SIZE][block_x - mb_x*BLOCK_SIZE],
  633|      0|                                  decs->RefBlock);
  634|      0|              for (j=0;j<BLOCK_SIZE;j++)
  635|      0|                for (i=0;i<BLOCK_SIZE;i++)
  636|      0|                {
  637|      0|                  inY[block_y*BLOCK_SIZE + j][block_x*BLOCK_SIZE + i] = decs->RefBlock[j][i];
  638|      0|                }
  639|      0|            }
  640|      0|      }
  641|      0|    }
  642|      0|    break;
  643|      0|  case 2: //! Partition B lost
  644|      0|    if(img->type!=I_SLICE)
  645|      0|    {
  646|      0|      if(!inter)
  647|      0|      {
  648|      0|        for (j=0;j<MB_BLOCK_SIZE;j++)
  649|      0|          for (i=0;i<MB_BLOCK_SIZE;i++)
  650|      0|            inY[pos_y+j][pos_x+i] = refY[ref_inx][pos_y+j][pos_x+i];
  651|      0|      }
  652|      0|    }
  653|      0|    else //! first frame; up to now set value to grey, may integrate nokia EC 
  654|      0|    {
  655|      0|      for (j=0;j<MB_BLOCK_SIZE;j++)
  656|      0|        for (i=0;i<MB_BLOCK_SIZE;i++)
  657|      0|          inY[pos_y+j][pos_x+i] = 127;
  658|      0|    }
  659|      0|    break;
  660|      0|  } //! End Switch
  661|      0|}

/home/xzp/speccpu2006-v1.0.1/benchspec/CPU2006/464.h264ref/run/build_base_ql_riscv_llvm17.0000/defines.h:
    1|       |
    2|       |/*!
    3|       | **************************************************************************
    4|       | * \file defines.h
    5|       | *
    6|       | * \brief
    7|       | *    Headerfile containing some useful global definitions
    8|       | *
    9|       | * \author
   10|       | *    Detlev Marpe 
   11|       | *    Copyright (C) 2000 HEINRICH HERTZ INSTITUTE All Rights Reserved.
   12|       | *
   13|       | * \date
   14|       | *    21. March 2001
   15|       | **************************************************************************
   16|       | */
   17|       |
   18|       |
   19|       |#ifndef _DEFINES_H_
   20|       |#define _DEFINES_H_
   21|       |
   22|       |#if defined _DEBUG
   23|       |#define TRACE           0                   //!< 0:Trace off 1:Trace on
   24|       |#else
   25|       |#define TRACE           0                   //!< 0:Trace off 1:Trace on
   26|       |#endif
   27|       |
   28|       |#define BI_PREDICTION   1
   29|       |
   30|       |typedef unsigned char byte;    //!< byte type definition
   31|       |
   32|       |//FREXT Profile IDC definitions
   33|      6|#define FREXT_HP        100      //!< YUV 4:2:0/8 "High"
   34|      5|#define FREXT_Hi10P     110      //!< YUV 4:2:0/10 "High 10"
   35|      5|#define FREXT_Hi422     122      //!< YUV 4:2:2/10 "High 4:2:2"
   36|      6|#define FREXT_Hi444     144      //!< YUV 4:4:4/12 "High 4:4:4"
   37|       |
   38|  6.68M|#define YUV400 0
   39|  2.73M|#define YUV420 1
   40|  2.73M|#define YUV422 2
   41|      6|#define YUV444 3
   42|       |
   43|   488M|#define LIST_0 0
   44|   291M|#define LIST_1 1
   45|       |#define ZEROSNR 1
   46|       |// CAVLC
   47|      0|#define LUMA              0
   48|      0|#define LUMA_INTRA16x16DC 1
   49|      0|#define LUMA_INTRA16x16AC 2
   50|       |
   51|       |#define LEVEL_NUM      6
   52|       |#define TOTRUN_NUM    15
   53|      0|#define RUNBEFORE_NUM  7
   54|       |
   55|      0|#define CAVLC_LEVEL_LIMIT 2063
   56|       |
   57|       |
   58|       |//--- block types for CABAC
   59|  67.7M|#define LUMA_16DC       0
   60|   135M|#define LUMA_16AC       1
   61|   213M|#define LUMA_8x8        2
   62|   147M|#define LUMA_8x4        3
   63|   147M|#define LUMA_4x8        4
   64|   152M|#define LUMA_4x4        5
   65|   134M|#define CHROMA_DC       6
   66|   268M|#define CHROMA_AC       7
   67|   133M|#define CHROMA_DC_2x4   8
   68|  66.9M|#define CHROMA_DC_4x4   9
   69|       |#define NUM_BLOCK_TYPES 10
   70|       |
   71|       |
   72|       |#define _FAST_FULL_ME_
   73|       |
   74|       |#define _FULL_SEARCH_RANGE_
   75|       |#define _ADAPT_LAST_GROUP_
   76|       |#define _CHANGE_QP_
   77|       |#define _LEAKYBUCKET_
   78|       |
   79|       |// ---------------------------------------------------------------------------------
   80|       |// FLAGS and DEFINES for new chroma intra prediction, Dzung Hoang
   81|       |// Threshold values to zero out quantized transform coefficients.
   82|       |// Recommend that _CHROMA_COEFF_COST_ be low to improve chroma quality
   83|  7.38M|#define _LUMA_COEFF_COST_       4 //!< threshold for luma coeffs
   84|  5.46M|#define _CHROMA_COEFF_COST_     4 //!< threshold for chroma coeffs, used to be 7
   85|  1.14M|#define _LUMA_MB_COEFF_COST_    5 //!< threshold for luma coeffs of inter Macroblocks
   86|      0|#define _LUMA_8x8_COEFF_COST_   5 //!< threshold for luma coeffs of 8x8 Inter Partition
   87|       |
   88|  31.0G|#define IMG_PAD_SIZE    4   //!< Number of pixels padded around the reference frame (>=4)
   89|       |
   90|   186M|#define absm(A) ((A)<(0) ? (-(A)):(A)) //!< abs macro, faster than procedure
   91|  8.32M|#define MAX_VALUE       999999   //!< used for start value for some variables
   92|       |
   93|      0|#define INVALIDINDEX  (-135792468)
   94|       |
   95|       |#define Clip1(a)            ((a)>img->max_imgpel_value?img->max_imgpel_value:((a)<0?0:(a)))
   96|       |#define Clip1_Chr(a)        ((a)>img->max_imgpel_value_uv?img->max_imgpel_value_uv:((a)<0?0:(a)))
   97|  7.87M|#define Clip3(min,max,val) (((val)<(min))?(min):(((val)>(max))?(max):(val)))
   98|       |
   99|   137M|#define P8x8    8
  100|   114M|#define I4MB    9
  101|   105M|#define I16MB   10
  102|  20.6M|#define IBLOCK  11
  103|  1.42M|#define SI4MB   12
  104|  51.2M|#define I8MB    13
  105|   185M|#define IPCM    14
  106|  1.75M|#define MAXMODE 15
  107|       |
  108|       |
  109|  10.2G|#define  LAMBDA_ACCURACY_BITS         16
  110|  41.0M|#define  LAMBDA_FACTOR(lambda)        ((int)((double)(1<<LAMBDA_ACCURACY_BITS)*lambda+0.5))
  111|  10.1G|#define  WEIGHTED_COST(factor,bits)   (((factor)*(bits))>>LAMBDA_ACCURACY_BITS)
  112|  10.1G|#define  MV_COST(f,s,cx,cy,px,py)     (WEIGHTED_COST(f,mvbits[((cx)<<(s))-px]+mvbits[((cy)<<(s))-py]))
  113|       |//#define  REF_COST(f,ref)              (WEIGHTED_COST(f,refbits[(ref)]))
  114|       |
  115|  12.7M|#define  REF_COST(f,ref,list_offset) (WEIGHTED_COST(f,((listXsize[list_offset]<=1)? 0:refbits[(ref)])))
  116|       |
  117|  19.8M|#define IS_INTRA(MB)    ((MB)->mb_type==I4MB  || (MB)->mb_type==I16MB || (MB)->mb_type==I8MB)
  118|  3.52M|#define IS_NEWINTRA(MB) ((MB)->mb_type==I16MB)
  119|  2.05M|#define IS_OLDINTRA(MB) ((MB)->mb_type==I4MB)
  120|       |
  121|   795k|#define IS_INTER(MB)    ((MB)->mb_type!=I4MB  && (MB)->mb_type!=I16MB && (MB)->mb_type!=I8MB)
  122|  5.65M|#define IS_INTERMV(MB)  ((MB)->mb_type!=I4MB  && (MB)->mb_type!=I16MB && (MB)->mb_type!=I8MB  && (MB)->mb_type!=0)
  123|  10.1M|#define IS_DIRECT(MB)   ((MB)->mb_type==0     && (img->type==B_SLICE))
  124|       |#define IS_COPY(MB)     ((MB)->mb_type==0     && (img->type==P_SLICE||img ->type==SP_SLICE));
  125|  5.31M|#define IS_P8x8(MB)     ((MB)->mb_type==P8x8)
  126|       |
  127|       |// Quantization parameter range
  128|       |
  129|   151M|#define MIN_QP          0
  130|       |#define MAX_QP          51
  131|   109k|#define SHIFT_QP        12
  132|       |
  133|       |#define LOG2_MAX_FRAME_NUM_MINUS4   7           // POC200301 moved from defines.h
  134|       |#define LOG2_MAX_PIC_ORDER_CNT_LSB_MINUS4 7     // POC200301 newly added
  135|       |
  136|       |// Direct Mode types
  137|      0|#define DIR_TEMPORAL    0   //!< Temporal Direct Mode
  138|      2|#define DIR_SPATIAL     1    //!< Spatial Direct Mode
  139|       |
  140|      0|#define MAX_REFERENCE_PICTURES 15
  141|       |
  142|  9.46G|#define BLOCK_SIZE      4
  143|  1.59G|#define MB_BLOCK_SIZE   16
  144|       |
  145|  67.2M|#define NO_INTRA_PMODE  9        //!< #intra prediction modes
  146|       |//!< 4x4 intra prediction modes
  147|   215M|#define VERT_PRED             0
  148|   175M|#define HOR_PRED              1
  149|   177M|#define DC_PRED               2
  150|   147M|#define DIAG_DOWN_LEFT_PRED   3
  151|   106M|#define DIAG_DOWN_RIGHT_PRED  4
  152|   106M|#define VERT_RIGHT_PRED       5
  153|   106M|#define HOR_DOWN_PRED         6
  154|   207M|#define VERT_LEFT_PRED        7
  155|   134M|#define HOR_UP_PRED           8
  156|       |
  157|       |// 16x16 intra prediction modes
  158|   107M|#define VERT_PRED_16    0
  159|   107M|#define HOR_PRED_16     1
  160|   107M|#define DC_PRED_16      2
  161|   103M|#define PLANE_16        3
  162|       |
  163|       |// 8x8 chroma intra prediction modes
  164|  20.5M|#define DC_PRED_8       0
  165|  14.4M|#define HOR_PRED_8      1
  166|  14.1M|#define VERT_PRED_8     2
  167|  14.2M|#define PLANE_8         3
  168|       |
  169|      0|#define INIT_FRAME_RATE 30
  170|       |#define EOS             1         //!< End Of Sequence
  171|       |
  172|       |
  173|  52.4M|#define MVPRED_MEDIAN   0
  174|  10.7M|#define MVPRED_L        1
  175|  5.15M|#define MVPRED_U        2
  176|   422k|#define MVPRED_UR       3
  177|       |
  178|       |
  179|   512M|#define BLOCK_MULTIPLE      (MB_BLOCK_SIZE/BLOCK_SIZE)
  180|       |
  181|       |#define MAX_SYMBOLS_PER_MB  1200  //!< Maximum number of different syntax elements for one MB
  182|       |                                  // CAVLC needs more symbols per MB
  183|       |
  184|       |
  185|       |#define MAX_PART_NR     3 /*!< Maximum number of different data partitions.
  186|       |                               Some reasonable number which should reflect
  187|       |                               what is currently defined in the SE2Partition map (elements.h) */
  188|       |
  189|       |//Start code and Emulation Prevention need this to be defined in identical manner at encoder and decoder
  190|   350k|#define ZEROBYTES_SHORTSTARTCODE 2 //indicates the number of zero bytes in the short start-code prefix
  191|       |#define BIPRED_SIMPLE 1
  192|       |
  193|  76.9M|#define Q_BITS          15
  194|      0|#define DQ_BITS         6
  195|      0|#define DQ_ROUND        (1<<(DQ_BITS-1))
  196|       |
  197|      0|#define Q_BITS_8        16
  198|      0|#define DQ_BITS_8       6 
  199|      0|#define DQ_ROUND_8      (1<<(DQ_BITS_8-1))
  200|       |
  201|       |#endif
  202|       |

/home/xzp/speccpu2006-v1.0.1/benchspec/CPU2006/464.h264ref/run/build_base_ql_riscv_llvm17.0000/explicit_gop.c:
    1|       |
    2|       |/*!
    3|       | *************************************************************************************
    4|       | * \file explicit_gop.c
    5|       | *
    6|       | * \brief
    7|       | *    Code for explicit gop support and pyramidal coding.
    8|       | *
    9|       | * \author
   10|       | *    Main contributors (see contributors.h for copyright, address and affiliation details)
   11|       | *     - Alexis Michael Tourapis                     <alexismt@ieee.org> 
   12|       | *************************************************************************************
   13|       | */
   14|       |
   15|       |#include <stdlib.h>
   16|       |#include <ctype.h>
   17|       |#include <limits.h>
   18|       |#include "global.h"
   19|       |#include "contributors.h"
   20|       |#include "explicit_gop.h"
   21|       |#include "image.h"
   22|       |#include "nalucommon.h"
   23|       |#include "string.h"
   24|       |
   25|       |
   26|       |/*!
   27|       |************************************************************************
   28|       |* \brief
   29|       |*    Generation of Pyramid GOP
   30|       |************************************************************************
   31|       |*/
   32|       |void create_pyramid()
   33|      0|{
   34|      0|  int i, j;
   35|      0|  int centerB=input->successive_Bframe/2;
   36|       |
   37|      0|  if (input->PyramidCoding == 1)
   38|      0|  {
   39|      0|    for (i=0;i<input->successive_Bframe;i++)
   40|      0|    {
   41|      0|      if (i < centerB)
   42|      0|      {
   43|      0|        gop_structure[i].slice_type = B_SLICE;
   44|      0|        gop_structure[i].display_no = i * 2 + 1;
   45|      0|        gop_structure[i].pyramid_layer = 0;
   46|      0|        gop_structure[i].reference_idc = NALU_PRIORITY_HIGH;
   47|      0|      }
   48|      0|      else
   49|      0|      {
   50|      0|        gop_structure[i].slice_type = B_SLICE;
   51|      0|        gop_structure[i].display_no = (i - centerB) * 2;
   52|      0|        gop_structure[i].pyramid_layer = 1;
   53|      0|        gop_structure[i].reference_idc = NALU_PRIORITY_DISPOSABLE;
   54|       |
   55|      0|      }      
   56|      0|    }
   57|       |   
   58|      0|  }
   59|      0|  else
   60|      0|  {    
   61|      0|    int GOPlevels = 0;
   62|      0|    int Bframes = input->successive_Bframe;
   63|      0|    int *curGOPLevelfrm,*curGOPLeveldist ;
   64|      0|    int curlevel = GOPlevels ;
   65|      0|    int prvlevelrefs = input->successive_Bframe;
   66|      0|    int levelrefs = input->successive_Bframe;
   67|      0|    int i;
   68|       |
   69|      0|    while (Bframes > 2)
   70|      0|    {
   71|      0|      Bframes  /= 2;
   72|      0|      GOPlevels ++;
   73|      0|    }
   74|       |     
   75|      0|    curlevel = GOPlevels ;
   76|      0|    if (NULL == (curGOPLevelfrm = (int*)malloc((GOPlevels + 1)*sizeof(int)))) no_mem_exit("create_pyramid:curGOPLevelfrm");
   77|      0|    if (NULL == (curGOPLeveldist= (int*)malloc((GOPlevels + 1)*sizeof(int)))) no_mem_exit("create_pyramid:curGOPLeveldist");
   78|       |    
   79|      0|    for (i=0; i <input->successive_Bframe; i++)
   80|      0|    {
   81|      0|      gop_structure[i].display_no = 0;
   82|      0|      gop_structure[i].slice_type = B_SLICE;
   83|      0|    }
   84|       |
   85|      0|    while (levelrefs > 2)
   86|      0|    {
   87|      0|      levelrefs /= 2;
   88|      0|      curGOPLevelfrm[ curlevel ] = prvlevelrefs - levelrefs;
   89|      0|      curGOPLeveldist[ GOPlevels - curlevel ] = levelrefs+ (levelrefs )% 2;
   90|       |    
   91|      0|      prvlevelrefs =levelrefs ;
   92|      0|      curlevel --;
   93|      0|    }
   94|       |
   95|      0|    curGOPLevelfrm[ 0] = levelrefs;
   96|      0|    curGOPLeveldist[ GOPlevels] = levelrefs + (levelrefs )% 2;
   97|       |  
   98|       |        
   99|      0|    for (j=0; j<curGOPLevelfrm[0]; j++)
  100|      0|    {
  101|      0|      gop_pyramid(GOPlevels, (j+ 1) * curGOPLeveldist[ 0] - 1, curGOPLeveldist[ 0]-1, gop_structure);
  102|       |
  103|      0|    }
  104|       |
  105|       |	
  106|      0|    for (j=input->successive_Bframe; j>0; j--)
  107|      0|    {
  108|      0|      for (i=1; i<j; i++)
  109|      0|      {
  110|      0|        int tempnum;      
  111|       |
  112|      0|        if (gop_structure[i].pyramid_layer>gop_structure[i-1].pyramid_layer)
  113|      0|        {
  114|      0|          tempnum=gop_structure[i -1].display_no;
  115|      0|          gop_structure[i-1].display_no = gop_structure[i].display_no;
  116|      0|          gop_structure[i].display_no = tempnum;
  117|       |          
  118|      0|          tempnum=gop_structure[i-1].pyramid_layer;
  119|      0|          gop_structure[i-1].pyramid_layer = gop_structure[i].pyramid_layer;
  120|      0|          gop_structure[i].pyramid_layer = tempnum;
  121|       |
  122|      0|          tempnum=gop_structure[i -1].reference_idc;
  123|      0|          gop_structure[i-1].reference_idc = gop_structure[i].reference_idc;
  124|      0|          gop_structure[i].reference_idc = tempnum;
  125|       |
  126|      0|          tempnum=gop_structure[i -1].slice_type;
  127|      0|          gop_structure[i-1].slice_type = gop_structure[i].slice_type;
  128|      0|          gop_structure[i].slice_type = tempnum;
  129|       |
  130|      0|          tempnum=gop_structure[i -1].slice_qp;
  131|      0|          gop_structure[i-1].slice_qp = gop_structure[i].slice_qp;
  132|      0|          gop_structure[i].slice_qp = tempnum;
  133|       | 
  134|      0|          tempnum=gop_structure[i -1].pyramidPocDelta;
  135|      0|          gop_structure[i-1].pyramidPocDelta = gop_structure[i].pyramidPocDelta;
  136|      0|          gop_structure[i].pyramidPocDelta = tempnum;
  137|       |
  138|      0|        }
  139|       |
  140|      0|      }     
  141|      0|   }
  142|       |
  143|      0|  }
  144|      0|}
  145|       |
  146|       |
  147|       |/*!
  148|       |************************************************************************
  149|       |* \brief
  150|       |*    True Pyramid GOP generation 
  151|       |************************************************************************
  152|       |*/
  153|       |void gop_pyramid(int level, int frm_no, int frames, GOP_DATA *pyramid_structure)
  154|      0|{
  155|       |  
  156|      0|  if (level == 0 )
  157|      0|  {
  158|      0|    if (frm_no>=0 && frm_no<input->successive_Bframe && pyramid_structure[frm_no].display_no == 0)
  159|      0|    {
  160|      0|        pyramid_structure[frm_no].slice_type = B_SLICE;
  161|      0|        pyramid_structure[frm_no].display_no = frm_no;
  162|      0|        pyramid_structure[frm_no].pyramid_layer = 0;
  163|      0|        pyramid_structure[frm_no].reference_idc = NALU_PRIORITY_DISPOSABLE;
  164|      0|    }
  165|      0|  }
  166|      0|  else
  167|      0|  {
  168|      0|    if (frm_no>=0 && frm_no<input->successive_Bframe)
  169|      0|    {
  170|      0|      pyramid_structure[frm_no].slice_type = B_SLICE;
  171|      0|      pyramid_structure[frm_no].display_no = frm_no;
  172|      0|      pyramid_structure[frm_no].pyramid_layer = level;
  173|      0|      pyramid_structure[frm_no].reference_idc = NALU_PRIORITY_HIGH;
  174|      0|    }
  175|       |
  176|       |    
  177|      0|    gop_pyramid(level - 1, frm_no - (frames+1)/2,(frames+1)/2,pyramid_structure);
  178|      0|    gop_pyramid(level - 1, frm_no + (frames+1)/2,(frames+1)/2,pyramid_structure);
  179|      0|  }  
  180|      0|}
  181|       |
  182|       |
  183|       |/*!
  184|       |************************************************************************
  185|       |* \brief
  186|       |*    Initialization of GOP structure.
  187|       |*
  188|       |************************************************************************
  189|       |*/
  190|       |void init_gop_structure()
  191|      0|{
  192|      0|  int max_gopsize = input->PyramidCoding != 3 ? input->successive_Bframe  : input->jumpd;
  193|       |  
  194|      0|  gop_structure = calloc(max(10,max_gopsize), sizeof (GOP_DATA)); // +1 for reordering
  195|      0|  if (NULL==gop_structure) 
  196|      0|    no_mem_exit("init_gop_structure: gop_structure");
  197|      0|}
  198|       |
  199|       |
  200|       |/*!
  201|       |************************************************************************
  202|       |* \brief
  203|       |*    Clear GOP structure
  204|       |************************************************************************
  205|       |*/
  206|       |void clear_gop_structure()
  207|      0|{
  208|      0|  if (gop_structure)
  209|      0|    free(gop_structure);
  210|      0|}
  211|       |
  212|       |
  213|       |/*!
  214|       |************************************************************************
  215|       |* \brief
  216|       |*    Interpret GOP struct from input parameters
  217|       |************************************************************************
  218|       |*/
  219|       |void interpret_gop_structure()
  220|      0|{
  221|       |
  222|      0|  int nLength = strlen(input->ExplicitPyramidFormat);
  223|      0|  int i =0, k, qp, display_no;
  224|      0|  int slice_read =0, order_read = 0, stored_read = 0, qp_read =0;
  225|      0|  int coded_frame = 0;
  226|       |  
  227|       |   
  228|      0|  if (nLength > 0)
  229|      0|  {
  230|       |    
  231|      0|    for (i = 0; i < nLength ; i++)
  232|      0|    {    
  233|       |      //! First lets read slice type
  234|      0|      if (slice_read == 0)
  235|      0|      {
  236|      0|        switch (input->ExplicitPyramidFormat[i])
  237|      0|        {
  238|      0|        case 'P':
  239|      0|        case 'p':
  240|      0|          gop_structure[coded_frame].slice_type=P_SLICE;
  241|      0|          break;
  242|      0|        case 'B':
  243|      0|        case 'b':
  244|      0|          gop_structure[coded_frame].slice_type=B_SLICE;
  245|      0|          break;
  246|      0|        case 'I':
  247|      0|        case 'i':
  248|      0|          gop_structure[coded_frame].slice_type=I_SLICE;
  249|      0|          break;
  250|      0|        default:
  251|      0|          snprintf(errortext, ET_SIZE, "Slice Type invalid in ExplicitPyramidFormat param. Please check configuration file.");
  252|      0|          error (errortext, 400);
  253|      0|          break;
  254|      0|        }
  255|      0|        slice_read = 1;
  256|      0|      }
  257|      0|      else
  258|      0|      {
  259|       |        //! Next is Display Order
  260|      0|        if (order_read == 0)
  261|      0|        {
  262|      0|          if (isdigit((int)(*(input->ExplicitPyramidFormat+i))))
  263|      0|          {
  264|      0|            sscanf(input->ExplicitPyramidFormat+i,"%d",&display_no);
  265|      0|            gop_structure[coded_frame].display_no = display_no;
  266|      0|            order_read = 1;
  267|      0|            if (display_no<0 || display_no>=input->jumpd)
  268|      0|            {
  269|      0|              snprintf(errortext, ET_SIZE, "Invalid Frame Order value. Frame position needs to be in [0,%d] range.",input->jumpd-1);
  270|      0|              error (errortext, 400);          
  271|      0|            }
  272|      0|            for (k=0;k<coded_frame;k++)
  273|      0|            {
  274|      0|              if (gop_structure[k].display_no == display_no)
  275|      0|              {
  276|      0|                snprintf(errortext, ET_SIZE, "Frame Order value %d in frame %d already used for enhancement frame %d.",display_no,coded_frame,k);
  277|      0|                error (errortext, 400);          
  278|      0|              }
  279|      0|            }
  280|      0|          }
  281|      0|          else
  282|      0|          {
  283|      0|            snprintf(errortext, ET_SIZE, "Slice Type needs to be followed by Display Order. Please check configuration file.");
  284|      0|            error (errortext, 400);
  285|      0|          }
  286|      0|        }
  287|      0|        else if (order_read == 1)
  288|      0|        { 
  289|      0|          if (stored_read == 0 && !(isdigit((int)(*(input->ExplicitPyramidFormat+i)))))
  290|      0|          {
  291|      0|            switch (input->ExplicitPyramidFormat[i])
  292|      0|            {
  293|      0|            case 'E':
  294|      0|            case 'e':
  295|      0|              gop_structure[coded_frame].reference_idc = NALU_PRIORITY_DISPOSABLE;
  296|      0|              break;
  297|      0|            case 'R':
  298|      0|            case 'r':
  299|      0|              gop_structure[coded_frame].reference_idc= NALU_PRIORITY_HIGH;
  300|      0|              break;
  301|      0|            default:
  302|      0|              snprintf(errortext, ET_SIZE, "Reference_IDC invalid in ExplicitPyramidFormat param. Please check configuration file.");
  303|      0|              error (errortext, 400);
  304|      0|              break;
  305|      0|            }
  306|      0|            stored_read = 1;          
  307|      0|          }
  308|      0|          else if (stored_read == 1 && qp_read == 0)
  309|      0|          {
  310|      0|            if (isdigit((int)(*(input->ExplicitPyramidFormat+i))))
  311|      0|            {
  312|      0|              sscanf(input->ExplicitPyramidFormat+i,"%d",&qp);
  313|      0|              gop_structure[coded_frame].slice_qp= qp;
  314|      0|                qp_read = 1;
  315|      0|                if (qp<0 || qp>51)
  316|      0|                {
  317|      0|                  snprintf(errortext, ET_SIZE, "Invalid QP value. Please check configuration file.");
  318|      0|                  error (errortext, 400);          
  319|      0|                }
  320|      0|            }
  321|      0|            else
  322|      0|            {
  323|      0|              snprintf(errortext, ET_SIZE, "Reference_IDC needs to be followed by QP. Please check configuration file.");
  324|      0|              error (errortext, 400);
  325|      0|            }
  326|      0|          }
  327|      0|          else if (stored_read == 1 && qp_read == 1 && !(isdigit((int)(*(input->ExplicitPyramidFormat+i)))) && (i < nLength - 2))
  328|      0|          {
  329|      0|            stored_read =0;
  330|      0|            qp_read=0;
  331|      0|            order_read=0;
  332|      0|            slice_read=0;
  333|      0|            i--;
  334|      0|            coded_frame ++;
  335|      0|            if (coded_frame >= input->jumpd )
  336|      0|            {
  337|      0|              snprintf(errortext, ET_SIZE, "Total number of frames in Enhancement GOP need to be fewer or equal to FrameSkip parameter.");
  338|      0|              error (errortext, 400);
  339|      0|            }
  340|       |            
  341|      0|          }
  342|      0|        }
  343|       |        
  344|      0|      }      
  345|      0|    }
  346|      0|  }
  347|      0|  else
  348|      0|  {
  349|      0|    snprintf(errortext, ET_SIZE, "ExplicitPyramidFormat is empty. Please check configuration file.");
  350|      0|    error (errortext, 400);
  351|      0|  }
  352|       |
  353|      0|  input->successive_Bframe = coded_frame + 1;
  354|      0|}
  355|       |
  356|       |
  357|       |/*!
  358|       |************************************************************************
  359|       |* \brief
  360|       |*    Encode Enhancement Layer. 
  361|       |************************************************************************
  362|       |*/
  363|       |void encode_enhancement_layer()
  364|     86|{
  365|     86|    if ((input->successive_Bframe != 0) && (IMG_NUMBER > 0)) // B-frame(s) to encode
  366|     85|    {
  367|     85|      img->type = B_SLICE;            // set image type to B-frame
  368|       |      
  369|     85|      if (input->NumFramesInELSubSeq == 0) 
  370|     85|        img->layer = 0;
  371|      0|      else 
  372|      0|        img->layer = 1;
  373|       |      
  374|     85|      if (input->BRefPictures == 0 && input->PyramidCoding==0)
  375|     85|      {
  376|     85|        img->frame_num++;                 //increment frame_num once for B-frames
  377|     85|        img->frame_num %= (1 << (log2_max_frame_num_minus4 + 4));
  378|     85|      }
  379|     85|      img->nal_reference_idc = 0;     
  380|       |
  381|       |      //if (input->PyramidCoding == 3 || input->PyramidCoding == 1)
  382|     85|      if (input->PyramidCoding)
  383|      0|      {
  384|      0|        for(img->b_frame_to_code=1; img->b_frame_to_code<=input->successive_Bframe; img->b_frame_to_code++)
  385|      0|        {
  386|       |          
  387|      0|          img->nal_reference_idc = 0;     
  388|       |
  389|      0|          img->type = gop_structure[img->b_frame_to_code - 1].slice_type;
  390|       |
  391|      0|          if (gop_structure[img->b_frame_to_code - 1].reference_idc== NALU_PRIORITY_HIGH )            
  392|      0|          {
  393|      0|            img->nal_reference_idc = 1;
  394|      0|            img->frame_num++;                 //increment frame_num for each stored B slice
  395|      0|            img->frame_num %= (1 << (log2_max_frame_num_minus4 + 4));
  396|      0|          } 
  397|       |
  398|      0|          img->b_interval =
  399|      0|            ((double) (input->jumpd + 1) / (input->successive_Bframe + 1.0) );
  400|       |
  401|      0|          if (input->PyramidCoding == 3)
  402|      0|            img->b_interval = 1.0;
  403|       |          
  404|      0|          if(input->intra_period && input->idr_enable)
  405|      0|            img->toppoc = 2*(((IMG_NUMBER%input->intra_period)-1)*(input->jumpd+1) + (int)(img->b_interval * (double)(1 + gop_structure[img->b_frame_to_code - 1].display_no)));
  406|      0|          else
  407|      0|            img->toppoc = 2*((IMG_NUMBER-1)*(input->jumpd + 1) + (int)(img->b_interval * (double)(1 + gop_structure[img->b_frame_to_code -1].display_no)));
  408|       |
  409|      0|          if (img->b_frame_to_code == 1)
  410|      0|            img->delta_pic_order_cnt[0] = img->toppoc - 2*(start_tr_in_this_IGOP  + (IMG_NUMBER)*((input->jumpd+1)));
  411|      0|          else
  412|      0|            img->delta_pic_order_cnt[0] = img->toppoc - 2*(start_tr_in_this_IGOP  + (IMG_NUMBER-1)*((input->jumpd+1)) + (int) (2.0 *img->b_interval * (double) (1+ gop_structure[img->b_frame_to_code - 2].display_no)));
  413|       |
  414|      0|          if ((input->PicInterlace==FRAME_CODING)&&(input->MbInterlace==FRAME_CODING))
  415|      0|            img->bottompoc = img->toppoc;     //progressive
  416|      0|          else 
  417|      0|            img->bottompoc = img->toppoc+1;
  418|       |          
  419|      0|          img->framepoc = min (img->toppoc, img->bottompoc);
  420|       |          
  421|      0|          img->delta_pic_order_cnt[1]= 0;   // POC200301
  422|       |          
  423|      0|          encode_one_frame();  // encode one B-frame
  424|      0|          if (input->ReportFrameStats)
  425|      0|            report_frame_statistic();
  426|      0|        }
  427|      0|        img->b_frame_to_code = 0;
  428|      0|      }
  429|     85|      else 
  430|     85|      {      
  431|    170|        for(img->b_frame_to_code=1; img->b_frame_to_code<=input->successive_Bframe; img->b_frame_to_code++)
  432|     85|        {
  433|       |          
  434|     85|          img->nal_reference_idc = 0;     
  435|     85|          if (input->BRefPictures == 1 )
  436|      0|          {
  437|      0|            img->nal_reference_idc = 1;
  438|      0|            img->frame_num++;                 //increment frame_num once for B-frames
  439|      0|            img->frame_num %= (1 << (log2_max_frame_num_minus4 + 4));
  440|      0|          }
  441|       |
  442|     85|          img->b_interval =
  443|     85|            ((double) (input->jumpd + 1) / (input->successive_Bframe + 1.0) );
  444|       |
  445|     85|          if (input->PyramidCoding == 3)
  446|      0|            img->b_interval = 1.0;
  447|       |          
  448|     85|          if(input->intra_period && input->idr_enable)
  449|      0|            img->toppoc = 2*(((IMG_NUMBER% input->intra_period)-1)*(input->jumpd+1) + (int) (img->b_interval * (double)img->b_frame_to_code));
  450|     85|          else
  451|     85|            img->toppoc = 2*((IMG_NUMBER-1)*(input->jumpd+1) + (int) (img->b_interval * (double)img->b_frame_to_code));
  452|       |
  453|     85|          if ((input->PicInterlace==FRAME_CODING)&&(input->MbInterlace==FRAME_CODING))
  454|     85|            img->bottompoc = img->toppoc;     //progressive
  455|      0|          else 
  456|      0|            img->bottompoc = img->toppoc+1;
  457|       |          
  458|     85|          img->framepoc = min (img->toppoc, img->bottompoc);
  459|       |          
  460|       |          //the following is sent in the slice header
  461|     85|          if (!input->BRefPictures)
  462|     85|          {
  463|     85|            img->delta_pic_order_cnt[0]= 2*(img->b_frame_to_code-1);
  464|     85|          }
  465|      0|          else
  466|      0|          {
  467|      0|            img->delta_pic_order_cnt[0]= -2;
  468|      0|          }
  469|       |          
  470|     85|          img->delta_pic_order_cnt[1]= 0;   // POC200301
  471|       |          
  472|     85|          encode_one_frame();  // encode one B-frame
  473|     85|          if (input->ReportFrameStats)
  474|      0|            report_frame_statistic();
  475|     85|        }
  476|     85|      }
  477|     85|    }
  478|     86|    img->b_frame_to_code = 0;
  479|     86|}
  480|       |
  481|       |
  482|       |void poc_based_ref_management(int current_pic_num)
  483|      0|{
  484|      0|  unsigned i, pic_num = 0;
  485|       |
  486|      0|  int min_poc=INT_MAX;
  487|      0|  DecRefPicMarking_t *tmp_drpm,*tmp_drpm2;
  488|       |
  489|      0|  if (img->dec_ref_pic_marking_buffer!=NULL)
  490|      0|    return;
  491|       |
  492|      0|  if ((dpb.ref_frames_in_buffer+dpb.ltref_frames_in_buffer)==0)
  493|      0|    return;
  494|       |
  495|      0|  for (i=0; i<dpb.used_size;i++)
  496|      0|  {
  497|      0|    if (dpb.fs[i]->is_reference  && (!(dpb.fs[i]->is_long_term)) && dpb.fs[i]->poc < min_poc)
  498|      0|    {
  499|      0|      min_poc = dpb.fs[i]->frame->poc ;
  500|      0|      pic_num =  dpb.fs[i]->frame->pic_num;
  501|      0|    }
  502|      0|  }
  503|       |  
  504|      0|  if (NULL==(tmp_drpm=(DecRefPicMarking_t*)calloc (1,sizeof (DecRefPicMarking_t)))) no_mem_exit("poc_based_ref_management: tmp_drpm");
  505|      0|  tmp_drpm->Next=NULL;
  506|       |  
  507|      0|  tmp_drpm->memory_management_control_operation = 0;
  508|       |  
  509|      0|  if (NULL==(tmp_drpm2=(DecRefPicMarking_t*)calloc (1,sizeof (DecRefPicMarking_t)))) no_mem_exit("poc_based_ref_management: tmp_drpm2");
  510|      0|  tmp_drpm2->Next=tmp_drpm;
  511|       |  
  512|      0|  tmp_drpm2->memory_management_control_operation = 1;
  513|      0|  tmp_drpm2->difference_of_pic_nums_minus1 = current_pic_num - pic_num - 1;
  514|      0|  img->dec_ref_pic_marking_buffer = tmp_drpm2;
  515|       |
  516|      0|}

/home/xzp/speccpu2006-v1.0.1/benchspec/CPU2006/464.h264ref/run/build_base_ql_riscv_llvm17.0000/fast_me.c:
    1|       |
    2|       |/*!
    3|       | ************************************************************************
    4|       | *
    5|       | * \file fast_me.c
    6|       | *
    7|       | * \brief
    8|       | *   Fast integer pel motion estimation and fractional pel motion estimation
    9|       | *   algorithms are described in this file.
   10|       | *   1. get_mem_FME() and free_mem_FME() are functions for allocation and release
   11|       | *      of memories about motion estimation
   12|       | *   2. FME_BlockMotionSearch() is the function for fast integer pel motion 
   13|       | *      estimation and fractional pel motion estimation
   14|       | *   3. DefineThreshold() defined thresholds for early termination
   15|       | * \author 
   16|       | *    Main contributors: (see contributors.h for copyright, address and affiliation details)
   17|       | *    - Zhibo Chen         <chenzhibo@tsinghua.org.cn>
   18|       | *    - JianFeng Xu        <fenax@video.mdc.tsinghua.edu.cn>  
   19|       | * \date    
   20|       | *    2003.8
   21|       | ************************************************************************
   22|       | */
   23|       |
   24|       |#include <stdlib.h>
   25|       |#include <string.h>
   26|       |
   27|       |#include "global.h"
   28|       |
   29|       |#include "memalloc.h"
   30|       |#include "fast_me.h"
   31|       |#include "refbuf.h"
   32|       |
   33|       |#if defined(SPEC_CPU)
   34|       |int **McostState; //state for integer pel search
   35|       |
   36|       |int *****all_mincost;//store the MV and SAD information needed;
   37|       |int *****all_bwmincost;//store for backward prediction
   38|       |int pred_SAD_space,pred_SAD_time,pred_SAD_ref,pred_SAD_uplayer;//SAD prediction
   39|       |int FME_blocktype;  //blocktype for FME SetMotionVectorPredictor
   40|       |int pred_MV_time[2],pred_MV_ref[2],pred_MV_uplayer[2];//pred motion vector by space or temporal correlation,Median is provided
   41|       |
   42|       |//for early termination
   43|       |float Quantize_step;
   44|       |float  Bsize[8];
   45|       |int Thresh4x4;
   46|       |float AlphaSec[8];
   47|       |float AlphaThird[8];
   48|       |int  *flag_intra;
   49|       |int  flag_intra_SAD;
   50|       |
   51|       |byte **SearchState; //state for fractional pel search
   52|       |#endif /* SPEC_CPU */
   53|       |
   54|      0|#define Q_BITS          15
   55|       |
   56|       |extern  int*   byte_abs;
   57|       |extern  int*   mvbits;
   58|       |extern  int*   spiral_search_x;
   59|       |extern  int*   spiral_search_y;
   60|       |
   61|       |
   62|       |static pel_t (*PelY_14) (pel_t**, int, int, int, int);
   63|       |
   64|       |static const int quant_coef[6][4][4] = {
   65|       |  {{13107, 8066,13107, 8066},{ 8066, 5243, 8066, 5243},{13107, 8066,13107, 8066},{ 8066, 5243, 8066, 5243}},
   66|       |  {{11916, 7490,11916, 7490},{ 7490, 4660, 7490, 4660},{11916, 7490,11916, 7490},{ 7490, 4660, 7490, 4660}},
   67|       |  {{10082, 6554,10082, 6554},{ 6554, 4194, 6554, 4194},{10082, 6554,10082, 6554},{ 6554, 4194, 6554, 4194}},
   68|       |  {{ 9362, 5825, 9362, 5825},{ 5825, 3647, 5825, 3647},{ 9362, 5825, 9362, 5825},{ 5825, 3647, 5825, 3647}},
   69|       |  {{ 8192, 5243, 8192, 5243},{ 5243, 3355, 5243, 3355},{ 8192, 5243, 8192, 5243},{ 5243, 3355, 5243, 3355}},
   70|       |  {{ 7282, 4559, 7282, 4559},{ 4559, 2893, 4559, 2893},{ 7282, 4559, 7282, 4559},{ 4559, 2893, 4559, 2893}}
   71|       |};
   72|       |
   73|       |
   74|       |void DefineThreshold()
   75|      0|{
   76|      0|  AlphaSec[1] = 0.01f;
   77|      0|  AlphaSec[2] = 0.01f;
   78|      0|  AlphaSec[3] = 0.01f;
   79|      0|  AlphaSec[4] = 0.02f;
   80|      0|  AlphaSec[5] = 0.03f;
   81|      0|  AlphaSec[6] = 0.03f;
   82|      0|  AlphaSec[7] = 0.04f;
   83|       |
   84|      0|  AlphaThird[1] = 0.06f;
   85|      0|  AlphaThird[2] = 0.07f;
   86|      0|  AlphaThird[3] = 0.07f;
   87|      0|  AlphaThird[4] = 0.08f;
   88|      0|  AlphaThird[5] = 0.12f;
   89|      0|  AlphaThird[6] = 0.11f;
   90|      0|  AlphaThird[7] = 0.15f;
   91|       |
   92|      0|  DefineThresholdMB();
   93|      0|  return;
   94|      0|}
   95|       |
   96|       |void DefineThresholdMB()
   97|      0|{
   98|      0|  int gb_qp_per    = (input->qpN-MIN_QP)/6;
   99|      0|  int gb_qp_rem    = (input->qpN-MIN_QP)%6;
  100|       |  
  101|      0|  int gb_q_bits    = Q_BITS+gb_qp_per;
  102|      0|  int gb_qp_const,Thresh4x4;
  103|       |
  104|      0|  if (img->type == I_SLICE)
  105|      0|    gb_qp_const=(1<<gb_q_bits)/3;    // intra
  106|      0|  else
  107|      0|    gb_qp_const=(1<<gb_q_bits)/6;    // inter
  108|       |  
  109|      0|  Thresh4x4 =   ((1<<gb_q_bits) - gb_qp_const)/quant_coef[gb_qp_rem][0][0];
  110|      0|  Quantize_step = Thresh4x4/(4*5.61f);
  111|      0|  Bsize[7]=(16*16)*Quantize_step;
  112|       |
  113|      0|  Bsize[6]=Bsize[7]*4;
  114|      0|  Bsize[5]=Bsize[7]*4;
  115|      0|  Bsize[4]=Bsize[5]*4;
  116|      0|  Bsize[3]=Bsize[4]*4;
  117|      0|  Bsize[2]=Bsize[4]*4;
  118|      0|  Bsize[1]=Bsize[2]*4;
  119|      0|}
  120|       |
  121|       |/*!
  122|       | ************************************************************************
  123|       | * \brief
  124|       | *    Dynamic memory allocation of all infomation needed for Fast ME
  125|       | * \par Input:
  126|       | * \return Number of allocated bytes
  127|       | * \date 
  128|       | *    2003/3
  129|       | ************************************************************************
  130|       | */
  131|       |
  132|       |int get_mem_mincost (int****** mv)
  133|      0|{
  134|      0|  int i, j, k, l;
  135|       |
  136|      0|  if ((*mv = (int*****)calloc(img->width/4,sizeof(int****))) == NULL)
  137|      0|    no_mem_exit ("get_mem_mv: mv");
  138|      0|  for (i=0; i<img->width/4; i++)
  139|      0|  {
  140|      0|    if (((*mv)[i] = (int****)calloc(img->height/4,sizeof(int***))) == NULL)
  141|      0|      no_mem_exit ("get_mem_mv: mv");
  142|      0|    for (j=0; j<img->height/4; j++)
  143|      0|    {
  144|      0|      if (((*mv)[i][j] = (int***)calloc(img->max_num_references, sizeof(int**))) == NULL)
  145|      0|        no_mem_exit ("get_mem_mv: mv");
  146|      0|      for (k=0; k<img->max_num_references; k++)
  147|      0|      {
  148|      0|        if (((*mv)[i][j][k] = (int**)calloc(9,sizeof(int*))) == NULL)
  149|      0|          no_mem_exit ("get_mem_mv: mv");
  150|      0|        for (l=0; l<9; l++)
  151|      0|          if (((*mv)[i][j][k][l] = (int*)calloc(3,sizeof(int))) == NULL)
  152|      0|            no_mem_exit ("get_mem_mv: mv");
  153|      0|      }
  154|      0|    }
  155|      0|  }
  156|       |
  157|      0|  return img->width/4*img->height/4*img->max_num_references*9*3*sizeof(int);
  158|      0|}
  159|       |/*!
  160|       | *******************************************************************************
  161|       | * \brief
  162|       | *    Dynamic memory allocation of all infomation needed for backward prediction
  163|       | * \par Input:
  164|       | * \return Number of allocated bytes
  165|       | * \date 
  166|       | *    2003/3
  167|       | *******************************************************************************
  168|       | */
  169|       |int get_mem_bwmincost (int****** mv)
  170|      0|{
  171|      0|  int i, j, k, l;
  172|       |
  173|       |
  174|      0|  if ((*mv = (int*****)calloc(img->width/4,sizeof(int****))) == NULL)
  175|      0|    no_mem_exit ("get_mem_mv: mv");
  176|      0|  for (i=0; i<img->width/4; i++)
  177|      0|  {
  178|      0|    if (((*mv)[i] = (int****)calloc(img->height/4,sizeof(int***))) == NULL)
  179|      0|      no_mem_exit ("get_mem_mv: mv");
  180|      0|    for (j=0; j<img->height/4; j++)
  181|      0|    {
  182|      0|      if (((*mv)[i][j] = (int***)calloc(img->max_num_references,sizeof(int**))) == NULL)
  183|      0|        no_mem_exit ("get_mem_mv: mv");
  184|      0|      for (k=0; k<img->max_num_references; k++)
  185|      0|      {
  186|      0|        if (((*mv)[i][j][k] = (int**)calloc(9,sizeof(int*))) == NULL)
  187|      0|          no_mem_exit ("get_mem_mv: mv");
  188|      0|        for (l=0; l<9; l++)
  189|      0|          if (((*mv)[i][j][k][l] = (int*)calloc(3,sizeof(int))) == NULL)
  190|      0|            no_mem_exit ("get_mem_mv: mv");
  191|      0|      }
  192|      0|    }
  193|      0|  }
  194|       |
  195|      0|  return img->width/4*img->height/4*img->max_num_references*9*3*sizeof(int);
  196|      0|}
  197|       |
  198|       |int get_mem_FME()
  199|      0|{
  200|      0|  int memory_size = 0;
  201|      0|  if (NULL==(flag_intra = calloc ((img->width>>4)+1,sizeof(int)))) no_mem_exit("get_mem_FME: flag_intra");
  202|       |
  203|      0|  memory_size += get_mem2Dint(&McostState, 2*input->search_range+1, 2*input->search_range+1);
  204|      0|  memory_size += get_mem_mincost (&(all_mincost));
  205|      0|  memory_size += get_mem_bwmincost(&(all_bwmincost));
  206|      0|  memory_size += get_mem2D(&SearchState,7,7);
  207|       |  
  208|      0|  return memory_size;
  209|      0|}
  210|       |/*!
  211|       | ************************************************************************
  212|       | * \brief
  213|       | *    free the memory allocated for of all infomation needed for Fast ME
  214|       | * \par Input:
  215|       | * \date 
  216|       | *    2003/3
  217|       | ************************************************************************
  218|       | */
  219|       |void free_mem_mincost (int***** mv)
  220|      0|{
  221|      0|  int i, j, k, l;
  222|       |
  223|      0|  for (i=0; i<img->width/4; i++)
  224|      0|  {
  225|      0|    for (j=0; j<img->height/4; j++)
  226|      0|    {
  227|      0|      for (k=0; k<img->max_num_references; k++)
  228|      0|      {
  229|      0|        for (l=0; l<9; l++)
  230|      0|          free (mv[i][j][k][l]);
  231|      0|        free (mv[i][j][k]);
  232|      0|      }
  233|      0|      free (mv[i][j]);
  234|      0|    }
  235|      0|    free (mv[i]);
  236|      0|  }
  237|      0|  free (mv);
  238|      0|}
  239|       |
  240|       |/*!
  241|       | ***********************************************************************************
  242|       | * \brief
  243|       | *    free the memory allocated for of all infomation needed for backward prediction
  244|       | * \date 
  245|       | *    2003/3
  246|       | ***********************************************************************************
  247|       | */
  248|       |void free_mem_bwmincost (int***** mv)
  249|      0|{
  250|      0|  int i, j, k, l;
  251|       |
  252|      0|  for (i=0; i<img->width/4; i++)
  253|      0|  {
  254|      0|    for (j=0; j<img->height/4; j++)
  255|      0|    {
  256|      0|      for (k=0; k<img->max_num_references; k++)
  257|      0|      {
  258|      0|        for (l=0; l<9; l++)
  259|      0|          free (mv[i][j][k][l]);
  260|      0|        free (mv[i][j][k]);
  261|      0|      }
  262|      0|      free (mv[i][j]);
  263|      0|    }
  264|      0|    free (mv[i]);
  265|      0|  }
  266|      0|  free (mv);
  267|      0|}
  268|       |
  269|       |void free_mem_FME()
  270|      0|{
  271|      0|  free_mem2Dint(McostState);
  272|      0|  free_mem_mincost (all_mincost);
  273|      0|  free_mem_bwmincost(all_bwmincost);
  274|       |
  275|      0|  free_mem2D(SearchState);
  276|       |
  277|      0|  free (flag_intra);
  278|      0|}
  279|       |
  280|       |
  281|       |int PartCalMad(pel_t *ref_pic,pel_t** orig_pic,pel_t *(*get_ref_line)(int, pel_t*, int, int, int, int), int blocksize_y,int blocksize_x, int blocksize_x4,int mcost,int min_mcost,int cand_x,int cand_y)
  282|      0|{
  283|      0|  int y,x4;
  284|      0|  int height=((img->MbaffFrameFlag)&&(img->mb_data[img->current_mb_nr].mb_field))?img->height/2:img->height;
  285|      0|  pel_t *orig_line, *ref_line;
  286|      0|  for (y=0; y<blocksize_y; y++)
  287|      0|    {
  288|      0|    ref_line  = get_ref_line (blocksize_x, ref_pic, cand_y+y, cand_x, /*img->*/height, img->width);//2004.3.3
  289|      0|    orig_line = orig_pic [y];
  290|       |    
  291|      0|    for (x4=0; x4<blocksize_x4; x4++)
  292|      0|    {
  293|      0|      mcost += byte_abs[ *orig_line++ - *ref_line++ ];
  294|      0|      mcost += byte_abs[ *orig_line++ - *ref_line++ ];
  295|      0|      mcost += byte_abs[ *orig_line++ - *ref_line++ ];
  296|      0|      mcost += byte_abs[ *orig_line++ - *ref_line++ ];
  297|      0|    }
  298|      0|    if (mcost >= min_mcost)
  299|      0|    {
  300|      0|      break;
  301|      0|    }
  302|      0|    }
  303|      0|    return mcost;
  304|      0|}
  305|       |
  306|       |/*!
  307|       | ************************************************************************
  308|       | * \brief
  309|       | *    FastIntegerPelBlockMotionSearch: fast pixel block motion search 
  310|       | *    this algrithm is called UMHexagonS(see JVT-D016),which includes 
  311|       | *    four steps with different kinds of search patterns
  312|       | * \par Input:
  313|       | * pel_t**   orig_pic,     // <--  original picture
  314|       | * int       ref,          // <--  reference frame (0... or -1 (backward))
  315|       | * int       pic_pix_x,    // <--  absolute x-coordinate of regarded AxB block
  316|       | * int       pic_pix_y,    // <--  absolute y-coordinate of regarded AxB block
  317|       | * int       blocktype,    // <--  block type (1-16x16 ... 7-4x4)
  318|       | * int       pred_mv_x,    // <--  motion vector predictor (x) in sub-pel units
  319|       | * int       pred_mv_y,    // <--  motion vector predictor (y) in sub-pel units
  320|       | * int*      mv_x,         //  --> motion vector (x) - in pel units
  321|       | * int*      mv_y,         //  --> motion vector (y) - in pel units
  322|       | * int       search_range, // <--  1-d search range in pel units                         
  323|       | * int       min_mcost,    // <--  minimum motion cost (cost for center or huge value)
  324|       | * double    lambda        // <--  lagrangian parameter for determining motion cost
  325|       | * \par
  326|       | * Three macro definitions defined in this program:
  327|       | * 1. EARLY_TERMINATION: early termination algrithm, refer to JVT-D016.doc
  328|       | * 2. SEARCH_ONE_PIXEL: search one pixel in search range
  329|       | * 3. SEARCH_ONE_PIXEL1(value_iAbort): search one pixel in search range,
  330|       | *                                 but give a parameter to show if mincost refeshed
  331|       | * \author
  332|       | *   Main contributors: (see contributors.h for copyright, address and affiliation details)
  333|       | *   - Zhibo Chen         <chenzhibo@tsinghua.org.cn>
  334|       | *   - JianFeng Xu        <fenax@video.mdc.tsinghua.edu.cn>  
  335|       | * \date   :
  336|       | *   2003.8
  337|       | ************************************************************************
  338|       | */
  339|       |int                                     //  ==> minimum motion cost after search
  340|       |FastIntegerPelBlockMotionSearch  (pel_t**   orig_pic,     // <--  not used
  341|       |                                  short     ref,          // <--  reference frame (0... or -1 (backward))
  342|       |                                  int       list,
  343|       |                                  int       pic_pix_x,    // <--  absolute x-coordinate of regarded AxB block
  344|       |                                  int       pic_pix_y,    // <--  absolute y-coordinate of regarded AxB block
  345|       |                                  int       blocktype,    // <--  block type (1-16x16 ... 7-4x4)
  346|       |                                  short     pred_mv_x,    // <--  motion vector predictor (x) in sub-pel units
  347|       |                                  short     pred_mv_y,    // <--  motion vector predictor (y) in sub-pel units
  348|       |                                  short*    mv_x,         //  --> motion vector (x) - in pel units
  349|       |                                  short*    mv_y,         //  --> motion vector (y) - in pel units
  350|       |                                  int       search_range, // <--  1-d search range in pel units                         
  351|       |                                  int       min_mcost,    // <--  minimum motion cost (cost for center or huge value)
  352|       |                                  double    lambda)       // <--  lagrangian parameter for determining motion cost
  353|      0|{
  354|      0|  static int Diamond_x[4] = {-1, 0, 1, 0};
  355|      0|  static int Diamond_y[4] = {0, 1, 0, -1};
  356|      0|  static int Hexagon_x[6] = {2, 1, -1, -2, -1, 1};
  357|      0|  static int Hexagon_y[6] = {0, -2, -2, 0,  2, 2};
  358|      0|  static int Big_Hexagon_x[16] = {0,-2, -4,-4,-4, -4, -4, -2,  0,  2,  4,  4, 4, 4, 4, 2};
  359|      0|  static int Big_Hexagon_y[16] = {4, 3, 2,  1, 0, -1, -2, -3, -4, -3, -2, -1, 0, 1, 2, 3};
  360|       |
  361|      0|  int   pos, cand_x, cand_y,  mcost;
  362|      0|  pel_t *(*get_ref_line)(int, pel_t*, int, int, int, int);
  363|      0|  int   list_offset   = ((img->MbaffFrameFlag)&&(img->mb_data[img->current_mb_nr].mb_field))? img->current_mb_nr%2 ? 4 : 2 : 0;
  364|      0|  pel_t*  ref_pic       = listX[list+list_offset][ref]->imgY_11;//img->type==B_IMG? Refbuf11 [ref+((mref==mref_fld)) +1] : Refbuf11[ref];
  365|      0|  int   lambda_factor = LAMBDA_FACTOR (lambda);                   // factor for determining lagragian motion cost
  366|      0|  int   mvshift       = 2;                  // motion vector shift for getting sub-pel units
  367|      0|  int   blocksize_y   = input->blc_size[blocktype][1];            // vertical block size
  368|      0|  int   blocksize_x   = input->blc_size[blocktype][0];            // horizontal block size
  369|      0|  int   blocksize_x4  = blocksize_x >> 2;                         // horizontal block size in 4-pel units
  370|      0|  int   pred_x        = (pic_pix_x << mvshift) + pred_mv_x;       // predicted position x (in sub-pel units)
  371|      0|  int   pred_y        = (pic_pix_y << mvshift) + pred_mv_y;       // predicted position y (in sub-pel units)
  372|      0|  int   center_x      = pic_pix_x + *mv_x;                        // center position x (in pel units)
  373|      0|  int   center_y      = pic_pix_y + *mv_y;                        // center position y (in pel units)
  374|      0|  int   best_x = 0, best_y = 0;
  375|      0|  int   search_step,iYMinNow, iXMinNow;
  376|      0|  int   i,m, iSADLayer; 
  377|      0|  int   iAbort;
  378|      0|  int   N_Bframe = input->successive_Bframe;
  379|      0|  float betaSec,betaThird;
  380|      0|  int height=((img->MbaffFrameFlag)&&(img->mb_data[img->current_mb_nr].mb_field))?img->height/2:img->height;
  381|       |   
  382|       |
  383|       |  //===== set function for getting reference picture lines =====
  384|      0|  if ((center_x > search_range) && (center_x < img->width -1-search_range-blocksize_x) &&
  385|      0|    (center_y > search_range) && (center_y < height-1-search_range-blocksize_y)   )
  386|      0|  {
  387|      0|    get_ref_line = FastLineX;
  388|      0|  }
  389|      0|  else
  390|      0|  {
  391|      0|    get_ref_line = UMVLineX;
  392|      0|  }
  393|       |  
  394|       |  //////allocate memory for search state//////////////////////////
  395|      0|  memset(McostState[0],0,(2*search_range+1)*(2*search_range+1)*4);
  396|       |  
  397|       |   ///////Threshold defined for early termination///////////////////  
  398|      0|  if(ref>0) 
  399|      0|  {
  400|      0|    if(pred_SAD_ref!=0)
  401|      0|    {
  402|      0|      betaSec = Bsize[blocktype]/(pred_SAD_ref*pred_SAD_ref)-AlphaSec[blocktype];
  403|      0|      betaThird = Bsize[blocktype]/(pred_SAD_ref*pred_SAD_ref)-AlphaThird[blocktype];
  404|      0|    }
  405|      0|    else
  406|      0|    {
  407|      0|      betaSec = 0;
  408|      0|      betaThird = 0;
  409|      0|    }
  410|      0|  }
  411|      0|  else 
  412|      0|  {
  413|      0|    if(blocktype==1)
  414|      0|    {
  415|      0|      if(pred_SAD_space !=0)
  416|      0|      {
  417|      0|        betaSec = Bsize[blocktype]/(pred_SAD_space*pred_SAD_space)-AlphaSec[blocktype];
  418|      0|        betaThird = Bsize[blocktype]/(pred_SAD_space*pred_SAD_space)-AlphaThird[blocktype];
  419|      0|      }
  420|      0|      else
  421|      0|      {
  422|      0|        betaSec = 0;
  423|      0|        betaThird = 0;
  424|      0|      }
  425|      0|    }
  426|      0|    else
  427|      0|    {
  428|      0|      if(pred_SAD_uplayer !=0)
  429|      0|      {
  430|      0|        betaSec = Bsize[blocktype]/(pred_SAD_uplayer*pred_SAD_uplayer)-AlphaSec[blocktype];
  431|      0|        betaThird = Bsize[blocktype]/(pred_SAD_uplayer*pred_SAD_uplayer)-AlphaThird[blocktype];
  432|      0|      }
  433|      0|      else
  434|      0|      {
  435|      0|        betaSec = 0;
  436|      0|        betaThird = 0;
  437|      0|      }
  438|      0|    }
  439|      0|  }
  440|       |  /*****************************/
  441|       |
  442|       |  //check the center median predictor
  443|      0|  cand_x = center_x ;
  444|      0|  cand_y = center_y ;
  445|      0|  mcost = MV_COST (lambda_factor, mvshift, cand_x, cand_y, pred_x, pred_y);
  446|      0|  mcost = PartCalMad(ref_pic, orig_pic, get_ref_line,blocksize_y,blocksize_x,blocksize_x4,mcost,min_mcost,cand_x,cand_y);
  447|      0|  McostState[search_range][search_range] = mcost;
  448|      0|  if (mcost < min_mcost)
  449|      0|  {
  450|      0|    min_mcost = mcost;
  451|      0|    best_x = cand_x;
  452|      0|    best_y = cand_y;
  453|      0|  }
  454|       |
  455|      0|  iXMinNow = best_x;
  456|      0|  iYMinNow = best_y;
  457|      0|  for (m = 0; m < 4; m++)
  458|      0|  {   
  459|      0|    cand_x = iXMinNow + Diamond_x[m];
  460|      0|    cand_y = iYMinNow + Diamond_y[m];   
  461|      0|    SEARCH_ONE_PIXEL
  462|      0|  } 
  463|       |
  464|      0|  if(center_x != pic_pix_x || center_y != pic_pix_y)
  465|      0|  {
  466|      0|    cand_x = pic_pix_x ;
  467|      0|    cand_y = pic_pix_y ;
  468|      0|    SEARCH_ONE_PIXEL
  469|       |
  470|      0|    iXMinNow = best_x;
  471|      0|    iYMinNow = best_y;
  472|      0|    for (m = 0; m < 4; m++)
  473|      0|    {   
  474|      0|      cand_x = iXMinNow + Diamond_x[m];
  475|      0|      cand_y = iYMinNow + Diamond_y[m];   
  476|      0|      SEARCH_ONE_PIXEL
  477|      0|    } 
  478|      0|  }
  479|       |  
  480|      0|    if(blocktype>1)
  481|      0|  {
  482|      0|    cand_x = pic_pix_x + (pred_MV_uplayer[0]/4);
  483|      0|    cand_y = pic_pix_y + (pred_MV_uplayer[1]/4);
  484|      0|    SEARCH_ONE_PIXEL
  485|      0|    if ((min_mcost-pred_SAD_uplayer)<pred_SAD_uplayer*betaThird)
  486|      0|      goto third_step;
  487|      0|    else if((min_mcost-pred_SAD_uplayer)<pred_SAD_uplayer*betaSec)
  488|      0|      goto sec_step;
  489|      0|  } 
  490|       |
  491|       |  //coordinate position prediction
  492|      0|  if ((img->number > 1 + ref && ref!=-1) || (list == 1 && (Bframe_ctr%N_Bframe) > 1))  //for debug
  493|      0|  {
  494|      0|    cand_x = pic_pix_x + pred_MV_time[0]/4;
  495|      0|    cand_y = pic_pix_y + pred_MV_time[1]/4;
  496|      0|    SEARCH_ONE_PIXEL
  497|      0|  }
  498|       |
  499|       |  //prediciton using mV of last ref moiton vector
  500|      0|  if (input->PicInterlace == FIELD_CODING)
  501|      0|  {
  502|      0|    if ((list==0 && ref > 0) || (img->type == B_SLICE && list == 0 && (ref==0 ||ref==2 ) )) 
  503|       |      //Notes: for interlace case, ref==1 should be added
  504|      0|    {
  505|      0|      cand_x = pic_pix_x + pred_MV_ref[0]/4;
  506|      0|      cand_y = pic_pix_y + pred_MV_ref[1]/4;
  507|      0|      SEARCH_ONE_PIXEL
  508|      0|    }
  509|      0|  }
  510|      0|  else
  511|      0|  {
  512|      0|    if ((list==0 && ref > 0) || (img->type == B_SLICE && list == 0 && ref==0 )) 
  513|       |      //Notes: for interlace case, ref==1 should be added
  514|      0|    {
  515|      0|      cand_x = pic_pix_x + pred_MV_ref[0]/4;
  516|      0|      cand_y = pic_pix_y + pred_MV_ref[1]/4;
  517|      0|      SEARCH_ONE_PIXEL
  518|      0|    }
  519|      0|  }
  520|       |  //small local search
  521|      0|  iXMinNow = best_x;
  522|      0|  iYMinNow = best_y;
  523|      0|  for (m = 0; m < 4; m++)
  524|      0|  {   
  525|      0|    cand_x = iXMinNow + Diamond_x[m];
  526|      0|    cand_y = iYMinNow + Diamond_y[m];   
  527|      0|    SEARCH_ONE_PIXEL
  528|      0|  } 
  529|       |
  530|       |  //early termination algrithm, refer to JVT-D016
  531|      0|    EARLY_TERMINATION
  532|       |  
  533|      0|  if(blocktype>6)
  534|      0|    goto sec_step;
  535|      0|  else
  536|      0|    goto first_step;
  537|       |  
  538|      0|first_step: //Unsymmetrical-cross search 
  539|      0|  iXMinNow = best_x;
  540|      0|  iYMinNow = best_y;
  541|       |  
  542|      0|  for(i=1;i<=search_range/2;i++)
  543|      0|  {
  544|      0|    search_step = 2*i - 1;
  545|      0|    cand_x = iXMinNow + search_step;
  546|      0|    cand_y = iYMinNow ;
  547|      0|    SEARCH_ONE_PIXEL    
  548|      0|    cand_x = iXMinNow - search_step;
  549|      0|    cand_y = iYMinNow ;
  550|      0|    SEARCH_ONE_PIXEL
  551|      0|  }
  552|       |  
  553|      0|  for(i=1;i<=search_range/4;i++)
  554|      0|  {
  555|      0|    search_step = 2*i - 1;
  556|      0|    cand_x = iXMinNow ;
  557|      0|    cand_y = iYMinNow + search_step;
  558|      0|    SEARCH_ONE_PIXEL
  559|      0|    cand_x = iXMinNow ;
  560|      0|    cand_y = iYMinNow - search_step;
  561|      0|    SEARCH_ONE_PIXEL
  562|      0|  }
  563|       |  //early termination algrithm, refer to JVT-D016
  564|      0|    EARLY_TERMINATION
  565|       |  
  566|      0|  iXMinNow = best_x;
  567|      0|  iYMinNow = best_y;
  568|       |    // Uneven Multi-Hexagon-grid Search 
  569|      0|  for(pos=1;pos<25;pos++)
  570|      0|  {
  571|      0|    cand_x = iXMinNow + spiral_search_x[pos];
  572|      0|    cand_y = iYMinNow + spiral_search_y[pos];
  573|      0|    SEARCH_ONE_PIXEL
  574|      0|  }
  575|       |  //early termination algrithm, refer to JVT-D016
  576|      0|    EARLY_TERMINATION
  577|       |  
  578|      0|  for(i=1;i<=search_range/4; i++)
  579|      0|  {
  580|      0|    iAbort = 0;   
  581|      0|    for (m = 0; m < 16; m++)
  582|      0|    {
  583|      0|      cand_x = iXMinNow + Big_Hexagon_x[m]*i;
  584|      0|      cand_y = iYMinNow + Big_Hexagon_y[m]*i; 
  585|      0|      SEARCH_ONE_PIXEL1(1)
  586|      0|    }
  587|      0|    if (iAbort)
  588|      0|    { 
  589|       |      //early termination algrithm, refer to JVT-D016
  590|      0|      EARLY_TERMINATION
  591|      0|    }
  592|      0|  }
  593|      0|sec_step:  //Extended Hexagon-based Search
  594|      0|      iXMinNow = best_x;
  595|      0|      iYMinNow = best_y;
  596|      0|      for(i=0;i<search_range;i++) 
  597|      0|      {
  598|      0|        iAbort = 1;   
  599|      0|        for (m = 0; m < 6; m++)
  600|      0|        {   
  601|      0|          cand_x = iXMinNow + Hexagon_x[m];
  602|      0|          cand_y = iYMinNow + Hexagon_y[m];   
  603|      0|          SEARCH_ONE_PIXEL1(0)
  604|      0|        } 
  605|      0|        if(iAbort)
  606|      0|          break;
  607|      0|        iXMinNow = best_x;
  608|      0|        iYMinNow = best_y;
  609|      0|      }
  610|      0|third_step: // the third step with a small search pattern
  611|      0|      iXMinNow = best_x;
  612|      0|      iYMinNow = best_y;
  613|      0|      for(i=0;i<search_range;i++) 
  614|      0|      {
  615|      0|        iSADLayer = 65536;
  616|      0|        iAbort = 1;   
  617|      0|        for (m = 0; m < 4; m++)
  618|      0|        {   
  619|      0|          cand_x = iXMinNow + Diamond_x[m];
  620|      0|          cand_y = iYMinNow + Diamond_y[m];   
  621|      0|          SEARCH_ONE_PIXEL1(0)
  622|      0|        } 
  623|      0|        if(iAbort)
  624|      0|          break;
  625|      0|        iXMinNow = best_x;
  626|      0|        iYMinNow = best_y;
  627|      0|      }
  628|       |
  629|      0|      *mv_x = best_x - pic_pix_x;
  630|      0|      *mv_y = best_y - pic_pix_y; 
  631|      0|      return min_mcost;
  632|      0|  }
  633|       |
  634|       |
  635|       |  /*!
  636|       | ************************************************************************
  637|       | * \brief
  638|       | * Functions for fast fractional pel motion estimation.
  639|       | * 1. int AddUpSADQuarter() returns SADT of a fractiona pel MV
  640|       | * 2. int FastSubPelBlockMotionSearch () proceed the fast fractional pel ME
  641|       | * \authors  
  642|       | *    Zhibo Chen
  643|       | *    Dept.of EE, Tsinghua Univ.
  644|       | * \date 
  645|       | *    2003.4
  646|       | ************************************************************************
  647|       | */
  648|       |int AddUpSADQuarter(int pic_pix_x,int pic_pix_y,int blocksize_x,int blocksize_y,
  649|       |                    int cand_mv_x,int cand_mv_y, StorablePicture *ref_picture, pel_t**   orig_pic, 
  650|       |                    int Mvmcost, int min_mcost,int useABT)
  651|      0|{
  652|      0|  int abort_search, y0, x0, rx0, ry0, ry; 
  653|      0|  pel_t *orig_line;
  654|      0|  int   diff[16], *d; 
  655|      0|  int  mcost = Mvmcost;
  656|      0|  int yy,kk,xx;
  657|      0|  int   curr_diff[MB_BLOCK_SIZE][MB_BLOCK_SIZE]; // for ABT SATD calculation
  658|       |//2004.3.3
  659|      0|  pel_t **ref_pic = ref_picture->imgY_ups;
  660|      0|  int img_width  = ref_picture->size_x;
  661|      0|  int img_height = ref_picture->size_y;
  662|       |
  663|       |  
  664|      0|  for (y0=0, abort_search=0; y0<blocksize_y && !abort_search; y0+=4)
  665|      0|  {
  666|      0|    ry0 = ((pic_pix_y+y0)<<2) + cand_mv_y;
  667|       |    
  668|      0|    for (x0=0; x0<blocksize_x; x0+=4)
  669|      0|    {
  670|      0|      rx0 = ((pic_pix_x+x0)<<2) + cand_mv_x;
  671|      0|      d   = diff;
  672|       |      
  673|      0|      orig_line = orig_pic [y0  ];    ry=ry0;
  674|      0|      *d++      = orig_line[x0  ]  -  PelY_14 (ref_pic, ry, rx0   , img_height, img_width);
  675|      0|      *d++      = orig_line[x0+1]  -  PelY_14 (ref_pic, ry, rx0+ 4, img_height, img_width);
  676|      0|      *d++      = orig_line[x0+2]  -  PelY_14 (ref_pic, ry, rx0+ 8, img_height, img_width);
  677|      0|      *d++      = orig_line[x0+3]  -  PelY_14 (ref_pic, ry, rx0+ 12, img_height, img_width);
  678|       |      
  679|      0|      orig_line = orig_pic [y0+1];    ry=ry0+4;
  680|      0|      *d++      = orig_line[x0  ]  -  PelY_14 (ref_pic, ry, rx0   , img_height, img_width);
  681|      0|      *d++      = orig_line[x0+1]  -  PelY_14 (ref_pic, ry, rx0+ 4, img_height, img_width);
  682|      0|      *d++      = orig_line[x0+2]  -  PelY_14 (ref_pic, ry, rx0+ 8, img_height, img_width);
  683|      0|      *d++      = orig_line[x0+3]  -  PelY_14 (ref_pic, ry, rx0+ 12, img_height, img_width);
  684|       |      
  685|      0|      orig_line = orig_pic [y0+2];    ry=ry0+8;
  686|      0|      *d++      = orig_line[x0  ]  -  PelY_14 (ref_pic, ry, rx0   , img_height, img_width);
  687|      0|      *d++      = orig_line[x0+1]  -  PelY_14 (ref_pic, ry, rx0+ 4, img_height, img_width);
  688|      0|      *d++      = orig_line[x0+2]  -  PelY_14 (ref_pic, ry, rx0+ 8, img_height, img_width);
  689|      0|      *d++      = orig_line[x0+3]  -  PelY_14 (ref_pic, ry, rx0+ 12, img_height, img_width);
  690|       |      
  691|      0|      orig_line = orig_pic [y0+3];    ry=ry0+12;
  692|      0|      *d++      = orig_line[x0  ]  -  PelY_14 (ref_pic, ry, rx0   , img_height, img_width);
  693|      0|      *d++      = orig_line[x0+1]  -  PelY_14 (ref_pic, ry, rx0+ 4, img_height, img_width);
  694|      0|      *d++      = orig_line[x0+2]  -  PelY_14 (ref_pic, ry, rx0+ 8, img_height, img_width);
  695|      0|      *d        = orig_line[x0+3]  -  PelY_14 (ref_pic, ry, rx0+ 12, img_height, img_width);
  696|       |      
  697|      0|      if (!useABT)
  698|      0|      {
  699|      0|        if ((mcost += SATD (diff, input->hadamard)) > min_mcost)
  700|      0|        {
  701|      0|          abort_search = 1;
  702|      0|          break;
  703|      0|        }
  704|      0|      }
  705|      0|      else  // copy diff to curr_diff for ABT SATD calculation
  706|      0|      {
  707|      0|        for (yy=y0,kk=0; yy<y0+4; yy++)
  708|      0|          for (xx=x0; xx<x0+4; xx++, kk++)
  709|      0|            curr_diff[yy][xx] = diff[kk];
  710|      0|      }
  711|      0|    }
  712|      0|  }
  713|       |  
  714|      0|  return mcost;
  715|      0|}
  716|       |
  717|       |
  718|       |int                                                   //  ==> minimum motion cost after search
  719|       |FastSubPelBlockMotionSearch (pel_t**   orig_pic,      // <--  original pixel values for the AxB block
  720|       |                             short     ref,           // <--  reference frame (0... or -1 (backward))
  721|       |                             int       list,
  722|       |                             int       pic_pix_x,     // <--  absolute x-coordinate of regarded AxB block
  723|       |                             int       pic_pix_y,     // <--  absolute y-coordinate of regarded AxB block
  724|       |                             int       blocktype,     // <--  block type (1-16x16 ... 7-4x4)
  725|       |                             short     pred_mv_x,     // <--  motion vector predictor (x) in sub-pel units
  726|       |                             short     pred_mv_y,     // <--  motion vector predictor (y) in sub-pel units
  727|       |                             short*    mv_x,          // <--> in: search center (x) / out: motion vector (x) - in pel units
  728|       |                             short*    mv_y,          // <--> in: search center (y) / out: motion vector (y) - in pel units
  729|       |                             int       search_pos2,   // <--  search positions for    half-pel search  (default: 9)
  730|       |                             int       search_pos4,   // <--  search positions for quarter-pel search  (default: 9)
  731|       |                             int       min_mcost,     // <--  minimum motion cost (cost for center or huge value)
  732|       |                             double    lambda,
  733|       |                             int useABT)        // <--  lagrangian parameter for determining motion cost
  734|      0|{
  735|      0|  static int Diamond_x[4] = {-1, 0, 1, 0};
  736|      0|  static int Diamond_y[4] = {0, 1, 0, -1};
  737|      0|  int   mcost;
  738|      0|  int   cand_mv_x, cand_mv_y;
  739|       |  
  740|      0|  int   list_offset   = ((img->MbaffFrameFlag)&&(img->mb_data[img->current_mb_nr].mb_field))? img->current_mb_nr%2 ? 4 : 2 : 0;
  741|      0|  StorablePicture *ref_picture = listX[list+list_offset][ref];
  742|       |  
  743|      0|  int   lambda_factor   = LAMBDA_FACTOR (lambda);
  744|      0|  int   mv_shift        = 0;
  745|      0|  int   blocksize_x     = input->blc_size[blocktype][0];
  746|      0|  int   blocksize_y     = input->blc_size[blocktype][1];
  747|      0|  int   pic4_pix_x      = (pic_pix_x << 2);
  748|      0|  int   pic4_pix_y      = (pic_pix_y << 2);
  749|      0|  int   max_pos_x4      = ((ref_picture->size_x/*img->width*/-blocksize_x+1)<<2);
  750|      0|  int   max_pos_y4      = ((ref_picture->size_y/*img->height*/-blocksize_y+1)<<2);
  751|       |  
  752|      0|  int   search_range_dynamic,iXMinNow,iYMinNow,i;
  753|      0|  int   iSADLayer,m,currmv_x = 0,currmv_y = 0,iCurrSearchRange;
  754|      0|  int   pred_frac_mv_x,pred_frac_mv_y,abort_search;
  755|      0|  int   mv_cost; 
  756|       |  
  757|      0|  int   pred_frac_up_mv_x, pred_frac_up_mv_y;
  758|       |  
  759|      0|  *mv_x <<= 2;
  760|      0|  *mv_y <<= 2;
  761|      0|  if ((pic4_pix_x + *mv_x > 1) && (pic4_pix_x + *mv_x < max_pos_x4 - 2) &&
  762|      0|    (pic4_pix_y + *mv_y > 1) && (pic4_pix_y + *mv_y < max_pos_y4 - 2)   )
  763|      0|  {
  764|      0|    PelY_14 = FastPelY_14;
  765|      0|  }
  766|      0|  else
  767|      0|  {
  768|      0|    PelY_14 = UMVPelY_14;
  769|      0|  }
  770|       |  
  771|      0|  search_range_dynamic = 3;
  772|      0|  pred_frac_mv_x = (pred_mv_x - *mv_x)%4;
  773|      0|  pred_frac_mv_y = (pred_mv_y - *mv_y)%4; 
  774|       |  
  775|      0|  pred_frac_up_mv_x = (pred_MV_uplayer[0] - *mv_x)%4;
  776|      0|  pred_frac_up_mv_y = (pred_MV_uplayer[1] - *mv_y)%4;
  777|       |  
  778|       |  
  779|      0|  memset(SearchState[0],0,(2*search_range_dynamic+1)*(2*search_range_dynamic+1));
  780|       |  
  781|      0|  if(input->hadamard)
  782|      0|  {
  783|      0|    cand_mv_x = *mv_x;    
  784|      0|    cand_mv_y = *mv_y;    
  785|      0|    mv_cost = MV_COST (lambda_factor, mv_shift, cand_mv_x, cand_mv_y, pred_mv_x, pred_mv_y);    
  786|      0|    mcost = AddUpSADQuarter(pic_pix_x,pic_pix_y,blocksize_x,blocksize_y,cand_mv_x,cand_mv_y,ref_picture/*ref_pic*//*Wenfang Fu 2004.3.12*/,orig_pic,mv_cost,min_mcost,useABT);
  787|      0|    SearchState[search_range_dynamic][search_range_dynamic] = 1;
  788|      0|    if (mcost < min_mcost)
  789|      0|    {
  790|      0|      min_mcost = mcost;
  791|      0|      currmv_x = cand_mv_x;
  792|      0|      currmv_y = cand_mv_y; 
  793|      0|    }
  794|      0|  }
  795|      0|  else
  796|      0|  {
  797|      0|    SearchState[search_range_dynamic][search_range_dynamic] = 1;
  798|      0|    currmv_x = *mv_x;
  799|      0|    currmv_y = *mv_y; 
  800|      0|  }
  801|       |  
  802|      0|  if(pred_frac_mv_x!=0 || pred_frac_mv_y!=0)
  803|      0|  {
  804|      0|    cand_mv_x = *mv_x + pred_frac_mv_x;    
  805|      0|    cand_mv_y = *mv_y + pred_frac_mv_y;    
  806|      0|    mv_cost = MV_COST (lambda_factor, mv_shift, cand_mv_x, cand_mv_y, pred_mv_x, pred_mv_y);    
  807|      0|    mcost = AddUpSADQuarter(pic_pix_x,pic_pix_y,blocksize_x,blocksize_y,cand_mv_x,cand_mv_y,ref_picture/*ref_pic*//*Wenfang Fu 2004.3.12*/,orig_pic,mv_cost,min_mcost,useABT);
  808|      0|    SearchState[cand_mv_y -*mv_y + search_range_dynamic][cand_mv_x - *mv_x + search_range_dynamic] = 1;
  809|      0|    if (mcost < min_mcost)
  810|      0|    {
  811|      0|      min_mcost = mcost;
  812|      0|      currmv_x = cand_mv_x;
  813|      0|      currmv_y = cand_mv_y; 
  814|      0|    }
  815|      0|  }
  816|       |  
  817|       |  
  818|      0|  iXMinNow = currmv_x;
  819|      0|  iYMinNow = currmv_y;
  820|      0|  iCurrSearchRange = 2*search_range_dynamic+1; 
  821|      0|  for(i=0;i<iCurrSearchRange;i++) 
  822|      0|  {
  823|      0|    abort_search=1;
  824|      0|    iSADLayer = 65536;
  825|      0|    for (m = 0; m < 4; m++)
  826|      0|    {
  827|      0|      cand_mv_x = iXMinNow + Diamond_x[m];    
  828|      0|      cand_mv_y = iYMinNow + Diamond_y[m]; 
  829|       |      
  830|      0|      if(abs(cand_mv_x - *mv_x) <=search_range_dynamic && abs(cand_mv_y - *mv_y)<= search_range_dynamic)
  831|      0|      {
  832|      0|        if(!SearchState[cand_mv_y -*mv_y+ search_range_dynamic][cand_mv_x -*mv_x+ search_range_dynamic])
  833|      0|        {
  834|      0|          mv_cost = MV_COST (lambda_factor, mv_shift, cand_mv_x, cand_mv_y, pred_mv_x, pred_mv_y);    
  835|      0|          mcost = AddUpSADQuarter(pic_pix_x,pic_pix_y,blocksize_x,blocksize_y,cand_mv_x,cand_mv_y,ref_picture/*ref_pic*//*Wenfang Fu 2004.3.12*/,orig_pic,mv_cost,min_mcost,useABT);
  836|      0|          SearchState[cand_mv_y - *mv_y + search_range_dynamic][cand_mv_x - *mv_x + search_range_dynamic] = 1;
  837|      0|          if (mcost < min_mcost)
  838|      0|          {
  839|      0|            min_mcost = mcost;
  840|      0|            currmv_x = cand_mv_x;
  841|      0|            currmv_y = cand_mv_y; 
  842|      0|            abort_search = 0; 
  843|       |            
  844|      0|          }
  845|      0|        }
  846|      0|      }
  847|      0|    }
  848|      0|    iXMinNow = currmv_x;
  849|      0|    iYMinNow = currmv_y;
  850|      0|    if(abort_search)
  851|      0|      break;
  852|      0|  }
  853|       |  
  854|      0|  *mv_x = currmv_x;
  855|      0|  *mv_y = currmv_y;
  856|       |  
  857|       |  //===== return minimum motion cost =====
  858|      0|  return min_mcost;
  859|      0|}
  860|       |
  861|       |/*!
  862|       | ************************************************************************
  863|       | * \brief
  864|       | * Functions for SAD prediction of intra block cases.
  865|       | * 1. void   decide_intrabk_SAD() judges the block coding type(intra/inter) 
  866|       | *    of neibouring blocks
  867|       | * 2. void skip_intrabk_SAD() set the SAD to zero if neigouring block coding 
  868|       | *    type is intra
  869|       | * \date
  870|       | *    2003.4
  871|       | ************************************************************************
  872|       | */
  873|       |void   decide_intrabk_SAD()
  874|      0|{
  875|      0|  if (img->type != 0)
  876|      0|  {
  877|      0|    if (img->pix_x == 0 && img->pix_y == 0)
  878|      0|    {
  879|      0|      flag_intra_SAD = 0;
  880|      0|    }
  881|      0|    else if (img->pix_x == 0)
  882|      0|    {
  883|      0|      flag_intra_SAD = flag_intra[(img->pix_x)>>4];
  884|      0|    }
  885|      0|    else if (img->pix_y == 0)
  886|      0|    {
  887|      0|      flag_intra_SAD = flag_intra[((img->pix_x)>>4)-1];
  888|      0|    }
  889|      0|    else 
  890|      0|    {
  891|      0|      flag_intra_SAD = ((flag_intra[(img->pix_x)>>4])||(flag_intra[((img->pix_x)>>4)-1])||(flag_intra[((img->pix_x)>>4)+1])) ;
  892|      0|    }
  893|      0|  }
  894|      0|  return;
  895|      0|}
  896|       |
  897|       |void skip_intrabk_SAD(int best_mode, int ref_max)
  898|      0|{
  899|      0|  int i,j,k, ref;
  900|      0|  if (img->number > 0) 
  901|      0|    flag_intra[(img->pix_x)>>4] = (best_mode == 9 || best_mode == 10) ? 1:0;
  902|      0|  if (img->type!=0  && (best_mode == 9 || best_mode == 10))
  903|      0|  {
  904|      0|    for (i=0; i < 4; i++)
  905|      0|    {
  906|      0|      for (j=0; j < 4; j++)
  907|      0|      {
  908|      0|        for (k=1; k < 8;k++)
  909|      0|        {
  910|      0|          for (ref=0; ref<ref_max;ref++)
  911|      0|          {
  912|      0|            all_mincost[(img->pix_x>>2)+i][(img->pix_y>>2)+j][ref][k][0] = 0;   
  913|      0|          }
  914|      0|        }
  915|      0|      }
  916|      0|    }
  917|       |  
  918|      0|  }
  919|      0|  return;
  920|      0|}
  921|       |

/home/xzp/speccpu2006-v1.0.1/benchspec/CPU2006/464.h264ref/run/build_base_ql_riscv_llvm17.0000/fast_me.h:
    1|       |
    2|       |/*!
    3|       | ************************************************************************
    4|       | *
    5|       | * \file fast_me.h
    6|       | *
    7|       | * \brief
    8|       | *   Macro definitions and global variables for fast integer pel motion 
    9|       | *   estimation and fractional pel motion estimation
   10|       | *
   11|       | * \author
   12|       | *   Main contributors: (see contributors.h for copyright, address and affiliation details)
   13|       | *    - Zhibo Chen         <chenzhibo@tsinghua.org.cn>
   14|       | *    - JianFeng Xu        <fenax@video.mdc.tsinghua.edu.cn>  
   15|       | *
   16|       | * \date
   17|       | *   Apr. 2003
   18|       | ************************************************************************
   19|       | */
   20|       |
   21|       |#ifndef _FAST_ME_H_
   22|       |#define _FAST_ME_H_
   23|       |
   24|       |#include "mbuffer.h"
   25|       |
   26|      0|#define EARLY_TERMINATION  if(ref>0)  \
   27|      0|  {                                                                    \
   28|      0|  if ((min_mcost-pred_SAD_ref)<pred_SAD_ref*betaThird)             \
   29|      0|  goto third_step;                                             \
   30|      0|  else if((min_mcost-pred_SAD_ref)<pred_SAD_ref*betaSec)           \
   31|      0|  goto sec_step;                                               \
   32|      0|  }                                                                    \
   33|      0|  else if(blocktype>1)                                                 \
   34|      0|  {                                                                    \
   35|      0|  if ((min_mcost-pred_SAD_uplayer)<pred_SAD_uplayer*betaThird)     \
   36|      0|    {                                                                \
   37|      0|    goto third_step;                                             \
   38|      0|    }                                                                \
   39|      0|    else if((min_mcost-pred_SAD_uplayer)<pred_SAD_uplayer*betaSec)   \
   40|      0|    goto sec_step;                                               \
   41|      0|  }                                                                    \
   42|      0|  else                                                                 \
   43|      0|  {                                                                    \
   44|      0|  if ((min_mcost-pred_SAD_space)<pred_SAD_space*betaThird)         \
   45|      0|    {                                                                \
   46|      0|    goto third_step;                                             \
   47|      0|    }                                                                \
   48|      0|    else if((min_mcost-pred_SAD_space)<pred_SAD_space*betaSec)       \
   49|      0|    goto sec_step;                                               \
   50|      0|  }
   51|       |
   52|       |
   53|      0|#define SEARCH_ONE_PIXEL  if(abs(cand_x - center_x) <=search_range && abs(cand_y - center_y)<= search_range) \
   54|      0|    { \
   55|      0|    if(!McostState[cand_y-center_y+search_range][cand_x-center_x+search_range]) \
   56|      0|    { \
   57|      0|    mcost = MV_COST (lambda_factor, mvshift, cand_x, cand_y, pred_x, pred_y); \
   58|      0|    mcost = PartCalMad(ref_pic, orig_pic, get_ref_line,blocksize_y,blocksize_x,blocksize_x4,mcost,min_mcost,cand_x,cand_y); \
   59|      0|    McostState[cand_y-center_y+search_range][cand_x-center_x+search_range] = mcost; \
   60|      0|    if (mcost < min_mcost) \
   61|      0|    { \
   62|      0|    best_x = cand_x; \
   63|      0|    best_y = cand_y; \
   64|      0|    min_mcost = mcost; \
   65|      0|    } \
   66|      0|    } \
   67|      0|    }
   68|      0|#define SEARCH_ONE_PIXEL1(value_iAbort) if(abs(cand_x - center_x) <=search_range && abs(cand_y - center_y)<= search_range) \
   69|      0|      { \
   70|      0|      if(!McostState[cand_y-center_y+search_range][cand_x-center_x+search_range]) \
   71|      0|        { \
   72|      0|        mcost = MV_COST (lambda_factor, mvshift, cand_x, cand_y, pred_x, pred_y); \
   73|      0|        mcost = PartCalMad(ref_pic, orig_pic, get_ref_line,blocksize_y,blocksize_x,blocksize_x4,mcost,min_mcost,cand_x,cand_y); \
   74|      0|        McostState[cand_y-center_y+search_range][cand_x-center_x+search_range] = mcost; \
   75|      0|        if (mcost < min_mcost) \
   76|      0|          { \
   77|      0|          best_x = cand_x; \
   78|      0|          best_y = cand_y; \
   79|      0|          min_mcost = mcost; \
   80|      0|          iAbort = value_iAbort; \
   81|      0|          } \
   82|      0|        } \
   83|      0|      }
   84|       |
   85|       |
   86|       |#if defined(SPEC_CPU)
   87|       |extern int **McostState; //state for integer pel search
   88|       |
   89|       |extern int *****all_mincost;//store the MV and SAD information needed;
   90|       |extern int *****all_bwmincost;//store for backward prediction
   91|       |extern int pred_SAD_space,pred_SAD_time,pred_SAD_ref,pred_SAD_uplayer;//SAD prediction
   92|       |extern int FME_blocktype;  //blocktype for FME SetMotionVectorPredictor
   93|       |extern int pred_MV_time[2],pred_MV_ref[2],pred_MV_uplayer[2];//pred motion vector by space or temporal correlation,Median is provided
   94|       |
   95|       |//for early termination
   96|       |extern float Quantize_step;
   97|       |extern float  Bsize[8];
   98|       |extern int Thresh4x4;
   99|       |extern float AlphaSec[8];
  100|       |extern float AlphaThird[8];
  101|       |extern int  *flag_intra;
  102|       |extern int  flag_intra_SAD;
  103|       |extern byte **SearchState; //state for fractional pel search
  104|       |
  105|       |#else /* SPEC_CPU */
  106|       |
  107|       |int **McostState; //state for integer pel search
  108|       |
  109|       |int *****all_mincost;//store the MV and SAD information needed;
  110|       |int *****all_bwmincost;//store for backward prediction
  111|       |int pred_SAD_space,pred_SAD_time,pred_SAD_ref,pred_SAD_uplayer;//SAD prediction
  112|       |int FME_blocktype;  //blocktype for FME SetMotionVectorPredictor
  113|       |int pred_MV_time[2],pred_MV_ref[2],pred_MV_uplayer[2];//pred motion vector by space or temporal correlation,Median is provided
  114|       |
  115|       |//for early termination
  116|       |float Quantize_step;
  117|       |float  Bsize[8];
  118|       |int Thresh4x4;
  119|       |float AlphaSec[8];
  120|       |float AlphaThird[8];
  121|       |int  *flag_intra;
  122|       |int  flag_intra_SAD;
  123|       |
  124|       |byte **SearchState; //state for fractional pel search
  125|       |#endif /* SPEC_CPU */
  126|       |
  127|       |void DefineThreshold();
  128|       |void DefineThresholdMB();
  129|       |int get_mem_mincost (int****** mv);
  130|       |int get_mem_bwmincost (int****** mv);
  131|       |int get_mem_FME();
  132|       |void free_mem_mincost (int***** mv);
  133|       |void free_mem_bwmincost (int***** mv);
  134|       |void free_mem_FME();
  135|       |void   decide_intrabk_SAD();
  136|       |void skip_intrabk_SAD(int best_mode, int ref_max);
  137|       |
  138|       |int                                     //  ==> minimum motion cost after search
  139|       |FastIntegerPelBlockMotionSearch  (pel_t**   orig_pic,     // <--  not used
  140|       |                                  short     ref,          // <--  reference frame (0... or -1 (backward))
  141|       |                                  int       list,
  142|       |                                  int       pic_pix_x,    // <--  absolute x-coordinate of regarded AxB block
  143|       |                                  int       pic_pix_y,    // <--  absolute y-coordinate of regarded AxB block
  144|       |                                  int       blocktype,    // <--  block type (1-16x16 ... 7-4x4)
  145|       |                                  short     pred_mv_x,    // <--  motion vector predictor (x) in sub-pel units
  146|       |                                  short     pred_mv_y,    // <--  motion vector predictor (y) in sub-pel units
  147|       |                                  short*    mv_x,         //  --> motion vector (x) - in pel units
  148|       |                                  short*    mv_y,         //  --> motion vector (y) - in pel units
  149|       |                                  int       search_range, // <--  1-d search range in pel units                         
  150|       |                                  int       min_mcost,    // <--  minimum motion cost (cost for center or huge value)
  151|       |                                  double    lambda) ;     // <--  lagrangian parameter for determining motion cost
  152|       |
  153|       |int AddUpSADQuarter(int pic_pix_x,int pic_pix_y,int blocksize_x,int blocksize_y,
  154|       |                    int cand_mv_x,int cand_mv_y, StorablePicture *ref_picture, pel_t**   orig_pic, 
  155|       |                    int Mvmcost, int min_mcost,int useABT);
  156|       |
  157|       |int                                                   //  ==> minimum motion cost after search
  158|       |FastSubPelBlockMotionSearch (pel_t**   orig_pic,      // <--  original pixel values for the AxB block
  159|       |                             short       ref,           // <--  reference frame (0... or -1 (backward))
  160|       |                             int       list,
  161|       |                             int       pic_pix_x,     // <--  absolute x-coordinate of regarded AxB block
  162|       |                             int       pic_pix_y,     // <--  absolute y-coordinate of regarded AxB block
  163|       |                             int       blocktype,     // <--  block type (1-16x16 ... 7-4x4)
  164|       |                             short     pred_mv_x,     // <--  motion vector predictor (x) in sub-pel units
  165|       |                             short     pred_mv_y,     // <--  motion vector predictor (y) in sub-pel units
  166|       |                             short*    mv_x,          // <--> in: search center (x) / out: motion vector (x) - in pel units
  167|       |                             short*    mv_y,          // <--> in: search center (y) / out: motion vector (y) - in pel units
  168|       |                             int       search_pos2,   // <--  search positions for    half-pel search  (default: 9)
  169|       |                             int       search_pos4,   // <--  search positions for quarter-pel search  (default: 9)
  170|       |                             int       min_mcost,     // <--  minimum motion cost (cost for center or huge value)
  171|       |                             double    lambda,        // <--  lagrangian parameter for determining motion cost
  172|       |                             int  useABT);
  173|       |
  174|       |int                                               //  ==> minimum motion cost after search
  175|       |SubPelBlockMotionSearch (pel_t**   orig_pic,      // <--  original pixel values for the AxB block
  176|       |                         short     ref,           // <--  reference frame (0... or -1 (backward))
  177|       |                         int       list,
  178|       |                         int       pic_pix_x,     // <--  absolute x-coordinate of regarded AxB block
  179|       |                         int       pic_pix_y,     // <--  absolute y-coordinate of regarded AxB block
  180|       |                         int       blocktype,     // <--  block type (1-16x16 ... 7-4x4)
  181|       |                         short     pred_mv_x,     // <--  motion vector predictor (x) in sub-pel units
  182|       |                         short     pred_mv_y,     // <--  motion vector predictor (y) in sub-pel units
  183|       |                         short*    mv_x,          // <--> in: search center (x) / out: motion vector (x) - in pel units
  184|       |                         short*    mv_y,          // <--> in: search center (y) / out: motion vector (y) - in pel units
  185|       |                         int       search_pos2,   // <--  search positions for    half-pel search  (default: 9)
  186|       |                         int       search_pos4,   // <--  search positions for quarter-pel search  (default: 9)
  187|       |                         int       min_mcost,     // <--  minimum motion cost (cost for center or huge value)
  188|       |                         double    lambda         // <--  lagrangian parameter for determining motion cost
  189|       |                         );
  190|       |
  191|       |int                                         //  ==> minimum motion cost after search
  192|       |FME_BlockMotionSearch (short     ref,           // <--  reference frame (0... or -1 (backward))
  193|       |                       int       list,
  194|       |                       int       pic_pix_x,     // <--  absolute x-coordinate of regarded AxB block
  195|       |                       int       pic_pix_y,     // <--  absolute y-coordinate of regarded AxB block
  196|       |                       int       blocktype,     // <--  block type (1-16x16 ... 7-4x4)
  197|       |                       int       search_range,  // <--  1-d search range for integer-position search
  198|       |                       double    lambda         // <--  lagrangian parameter for determining motion cost
  199|       |                       );
  200|       |
  201|       |int                                              //!< minimum motion cost after search
  202|       |noFME_BlockMotionSearch (short     ref,          //!< reference idx
  203|       |                         int       list,         //!< reference pciture list
  204|       |                         int       mb_x,         //!< x-coordinate inside macroblock
  205|       |                         int       mb_y,         //!< y-coordinate inside macroblock
  206|       |                         int       blocktype,    //!< block type (1-16x16 ... 7-4x4)
  207|       |                         int       search_range, //!< 1-d search range for integer-position search
  208|       |                         double    lambda        //!< lagrangian parameter for determining motion cost
  209|       |                         );
  210|       |#endif

/home/xzp/speccpu2006-v1.0.1/benchspec/CPU2006/464.h264ref/run/build_base_ql_riscv_llvm17.0000/filehandle.c:
    1|       |
    2|       |/*!
    3|       | **************************************************************************************
    4|       | * \file
    5|       | *    filehandle.c
    6|       | * \brief
    7|       | *    Start and terminate sequences
    8|       | * \author
    9|       | *    Main contributors (see contributors.h for copyright, address and affiliation details)
   10|       | *      - Thomas Stockhammer            <stockhammer@ei.tum.de>
   11|       | *      - Detlev Marpe                  <marpe@hhi.de>
   12|       | ***************************************************************************************
   13|       | */
   14|       |
   15|       |#include "contributors.h"
   16|       |
   17|       |#include <stdlib.h>
   18|       |
   19|       |#include "global.h"
   20|       |
   21|       |#include "rtp.h"
   22|       |#include "annexb.h"
   23|       |#include "parset.h"
   24|       |#include "mbuffer.h"
   25|       |
   26|       |
   27|       |/*!
   28|       | ************************************************************************
   29|       | * \brief
   30|       | *    Error handling procedure. Print error message to stderr and exit
   31|       | *    with supplied code.
   32|       | * \param text
   33|       | *    Error message
   34|       | * \param code
   35|       | *    Exit code
   36|       | ************************************************************************
   37|       | */
   38|       |void error(char *text, int code)
   39|      0|{
   40|      0|  fprintf(stderr, "%s\n", text);
   41|      0|  flush_dpb();
   42|      0|  exit(code);
   43|      0|}
   44|       |
   45|       |/*!
   46|       | ************************************************************************
   47|       | * \brief
   48|       | *     This function generates and writes the PPS 
   49|       | *
   50|       | ************************************************************************
   51|       | */
   52|       |int write_PPS(int len, int PPS_id)
   53|      1|{  
   54|      1|  NALU_t *nalu;
   55|      1|  nalu = NULL;
   56|      1|  nalu = GeneratePic_parameter_set_NALU (PPS_id);
   57|      1|  len += WriteNALU (nalu);
   58|      1|  FreeNALU (nalu);
   59|       |  
   60|      1|  return len;
   61|      1|}
   62|       |
   63|       |/*!
   64|       | ************************************************************************
   65|       | * \brief
   66|       | *    This function opens the output files and generates the
   67|       | *    appropriate sequence header
   68|       | ************************************************************************
   69|       | */
   70|       |int start_sequence()
   71|      1|{
   72|      1|  int i,len=0, total_pps = (input->GenerateMultiplePPS) ? 3 : 1;
   73|      1|  NALU_t *nalu;
   74|       |  
   75|       |
   76|      1|  switch(input->of_mode)
   77|      1|  {
   78|      1|    case PAR_OF_ANNEXB:
   79|      1|      OpenAnnexbFile (input->outfile);
   80|      1|      WriteNALU = WriteAnnexbNALU;
   81|      1|      break;
   82|      0|    case PAR_OF_RTP:
   83|      0|      OpenRTPFile (input->outfile);
   84|      0|      WriteNALU = WriteRTPNALU;
   85|      0|      break;
   86|      0|    default:
   87|      0|      snprintf(errortext, ET_SIZE, "Output File Mode %d not supported", input->of_mode);
   88|      0|      error(errortext,1);
   89|      0|      return 1;
   90|      1|  }
   91|       |
   92|       |  //! As a sequence header, here we write the both sequence and picture
   93|       |  //! parameter sets.  As soon as IDR is implemented, this should go to the
   94|       |  //! IDR part, as both parsets have to be transmitted as part of an IDR.
   95|       |  //! An alternative may be to consider this function the IDR start function.
   96|       |  
   97|      1|  nalu = NULL;
   98|      1|  nalu = GenerateSeq_parameter_set_NALU ();
   99|      1|  len += WriteNALU (nalu);
  100|      1|  FreeNALU (nalu);
  101|       |  
  102|       |  //! Lets write now the Picture Parameter sets. Output will be equal to the total number of bits spend here.
  103|      2|  for (i=0;i<total_pps;i++)
  104|      1|  {
  105|      1|     len = write_PPS(len, i);
  106|      1|  }
  107|      1|  stats->bit_ctr_parametersets_n = len;
  108|      1|  return 0;
  109|      1|}
  110|       |
  111|       |/*!
  112|       | ************************************************************************
  113|       | * \brief
  114|       | *     This function terminates the sequence and closes the
  115|       | *     output files
  116|       | ************************************************************************
  117|       | */
  118|       |int terminate_sequence()
  119|      1|{
  120|       |//  Bitstream *currStream;
  121|       |
  122|       |  // Mainly flushing of everything
  123|       |  // Add termination symbol, etc.
  124|       |
  125|      1|  switch(input->of_mode)
  126|      1|  {
  127|      1|    case PAR_OF_ANNEXB:
  128|      1|      CloseAnnexbFile();
  129|      1|      break;
  130|      0|    case PAR_OF_RTP:
  131|      0|      CloseRTPFile();
  132|      0|      return 0;
  133|      0|    default:
  134|      0|      snprintf(errortext, ET_SIZE, "Output File Mode %d not supported", input->of_mode);
  135|      0|      error(errortext,1);
  136|      0|      return 1;
  137|      1|  }
  138|      1|  return 1;   // make lint happy
  139|      1|}
  140|       |

/home/xzp/speccpu2006-v1.0.1/benchspec/CPU2006/464.h264ref/run/build_base_ql_riscv_llvm17.0000/fmo.c:
    1|       |/*!
    2|       | *****************************************************************************
    3|       | *
    4|       | * \file fmo.c
    5|       | *
    6|       | * \brief
    7|       | *    Support for Flexible Macroblock Ordering for different Slice Group Modes: MBAmap handling
    8|       | *
    9|       | * \date
   10|       | *    16 June, 2002  Modified April 25, 2004
   11|       | *
   12|       | * \author
   13|       | *    Stephan Wenger   stewe@cs.tu-berlin.de
   14|       | *    Dong Wang (modify)	Dong.Wang@bristol.ac.uk
   15|       | * 
   16|       | *****************************************************************************/
   17|       |
   18|       |/*!
   19|       | ****************************************************************************
   20|       | *   Notes by Dong Wang (April 25 2004)
   21|       | *
   22|       | *  Source codes are modified to support 7 slice group types (fmo modes).
   23|       | *  The functions for generating map are very similar to that in decoder, but have 
   24|       | *  a little difference. 
   25|       | *
   26|       | *  The MB map is calculated at the beginning of coding of each picture (frame or field).
   27|       | *
   28|       | *  'slice_group_change_cycle' in structure 'ImageParameters' is the syntax in the slice 
   29|       | *  header. It's set to be 1 before the initialization of FMO in function code_a_picture().
   30|       | *  It can be changed every time if needed.
   31|       | *
   32|       | **************************************************************************** 
   33|       | */
   34|       |
   35|       |/*!
   36|       | *****************************************************************************
   37|       | *  How does a MBAmap look like?
   38|       | *
   39|       | *  An MBAmap is a one-diemnsional array of ints.  Each int 
   40|       | *  represents an MB in scan order.  A zero or positive value represents
   41|       | *  a slice group ID.  Negative values are reserved for future extensions.
   42|       | *  The numbering range for the SliceGroupIDs is 0..7 as per JVT-C167.
   43|       | *
   44|       | *  This module contains a static variable MBAmap.  This is the MBAmap of the
   45|       | *  picture currently coded.  It can be accessed only through the access
   46|       | *  functions.
   47|       | *****************************************************************************
   48|       |*/
   49|       |
   50|       |//#define PRINT_FMO_MAPS  1
   51|       |
   52|       |
   53|       |#include <stdlib.h>
   54|       |#include <string.h>
   55|       |#include <assert.h>
   56|       |#include <memory.h>
   57|       |
   58|       |#include "global.h"
   59|       |
   60|       |#include "fmo.h"
   61|       |
   62|       |
   63|       |static int FirstMBInSlice[MAXSLICEGROUPIDS];
   64|       |
   65|       |byte *MBAmap = NULL;   
   66|       |byte *MapUnitToSliceGroupMap = NULL; 
   67|       |unsigned PicSizeInMapUnits;
   68|       |
   69|       |
   70|       |static void FmoGenerateType0MapUnitMap (ImageParameters * img, pic_parameter_set_rbsp_t * pps);
   71|       |static void FmoGenerateType1MapUnitMap (ImageParameters * img, pic_parameter_set_rbsp_t * pps);
   72|       |static void FmoGenerateType2MapUnitMap (ImageParameters * img, pic_parameter_set_rbsp_t * pps);
   73|       |static void FmoGenerateType3MapUnitMap (ImageParameters * img, pic_parameter_set_rbsp_t * pps);
   74|       |static void FmoGenerateType4MapUnitMap (ImageParameters * img, pic_parameter_set_rbsp_t * pps);
   75|       |static void FmoGenerateType5MapUnitMap (ImageParameters * img, pic_parameter_set_rbsp_t * pps);
   76|       |static void FmoGenerateType6MapUnitMap (ImageParameters * img, pic_parameter_set_rbsp_t * pps);
   77|       |
   78|       |
   79|       |static int FmoGenerateMapUnitToSliceGroupMap (ImageParameters * img, pic_parameter_set_rbsp_t * pps);
   80|       |static int FmoGenerateMBAmap (ImageParameters * img, seq_parameter_set_rbsp_t* sps);
   81|       |
   82|       |
   83|       |/*!
   84|       | ************************************************************************
   85|       | * \brief
   86|       | *    Generates MapUnitToSliceGroupMap
   87|       | *
   88|       | * \param img
   89|       | *    Image Parameter to be used for map generation
   90|       | * \param pps
   91|       | *    Picture Parameter set to be used for map generation
   92|       | *
   93|       | ************************************************************************
   94|       | */
   95|       |static int FmoGenerateMapUnitToSliceGroupMap (ImageParameters * img, pic_parameter_set_rbsp_t * pps)
   96|    171|{
   97|    171|  PicSizeInMapUnits = img->PicHeightInMapUnits * img->PicWidthInMbs;
   98|       |  
   99|       |  
  100|    171|  if (pps->slice_group_map_type == 6)
  101|      0|  {
  102|      0|    if ((pps->pic_size_in_map_units_minus1+1) != PicSizeInMapUnits)
  103|      0|    {
  104|      0|      error ("wrong pps->pic_size_in_map_units_minus1 for used SPS and FMO type 6", 500);
  105|      0|    }
  106|      0|  }
  107|       |  
  108|       |  // allocate memory for MapUnitToSliceGroupMap
  109|    171|  if (MapUnitToSliceGroupMap)
  110|    170|    free (MapUnitToSliceGroupMap);
  111|       |  
  112|    171|  if ((MapUnitToSliceGroupMap = malloc ((PicSizeInMapUnits) * sizeof (byte))) == NULL)
  113|      0|  {
  114|      0|    printf ("cannot allocated %d bytes for MapUnitToSliceGroupMap, exit\n", PicSizeInMapUnits * sizeof (byte));
  115|      0|    exit (-1);
  116|      0|  }
  117|       |  
  118|    171|  if (pps->num_slice_groups_minus1 == 0)    // only one slice group
  119|    171|  {
  120|    171|    memset (MapUnitToSliceGroupMap, 0,  PicSizeInMapUnits * sizeof (byte));
  121|    171|    return 0;
  122|    171|  }
  123|       |  
  124|      0|  switch (pps->slice_group_map_type)
  125|      0|  {
  126|      0|  case 0:
  127|      0|    FmoGenerateType0MapUnitMap (img, pps);
  128|      0|    break;
  129|      0|  case 1:
  130|      0|    FmoGenerateType1MapUnitMap (img, pps);
  131|      0|    break;
  132|      0|  case 2:
  133|      0|    FmoGenerateType2MapUnitMap (img, pps);
  134|      0|    break;
  135|      0|  case 3:
  136|      0|    FmoGenerateType3MapUnitMap (img, pps);
  137|      0|    break;
  138|      0|  case 4:
  139|      0|    FmoGenerateType4MapUnitMap (img, pps);
  140|      0|    break;
  141|      0|  case 5:
  142|      0|    FmoGenerateType5MapUnitMap (img, pps);
  143|      0|    break;
  144|      0|  case 6:
  145|      0|    FmoGenerateType6MapUnitMap (img, pps);
  146|      0|    break;
  147|      0|  default:
  148|      0|    printf ("Illegal slice_group_map_type %d , exit \n", pps->slice_group_map_type);
  149|      0|    exit (-1);
  150|      0|  }
  151|      0|  return 0;
  152|      0|}
  153|       |
  154|       |
  155|       |/*!
  156|       | ************************************************************************
  157|       | * \brief
  158|       | *    Generates MBAmap from MapUnitToSliceGroupMap
  159|       | *
  160|       | * \param img
  161|       | *    Image Parameter to be used for map generation
  162|       | * \param sps
  163|       | *    Sequence Parameter set to be used for map generation
  164|       | *
  165|       | ************************************************************************
  166|       | */
  167|       |static int FmoGenerateMBAmap (ImageParameters * img, seq_parameter_set_rbsp_t* sps)
  168|    171|{
  169|    171|  unsigned i;
  170|       |  
  171|       |  // allocate memory for MBAmap
  172|    171|  if (MBAmap)
  173|    170|    free (MBAmap);
  174|       |  
  175|       |  
  176|    171|  if ((MBAmap = malloc ((img->PicSizeInMbs) * sizeof (byte))) == NULL)
  177|      0|  {
  178|      0|    printf ("cannot allocated %d bytes for MBAmap, exit\n", (img->PicSizeInMbs) * sizeof (byte));
  179|      0|    exit (-1);
  180|      0|  }
  181|       |  
  182|    171|  if ((sps->frame_mbs_only_flag) || img->field_picture)
  183|    171|  {
  184|   109k|    for (i=0; i<img->PicSizeInMbs; i++)
  185|   109k|    {
  186|   109k|      MBAmap[i] = MapUnitToSliceGroupMap[i];
  187|   109k|    }
  188|    171|  }
  189|      0|  else
  190|      0|    if (sps->mb_adaptive_frame_field_flag  &&  (! img->field_picture))
  191|      0|    {
  192|      0|      for (i=0; i<img->PicSizeInMbs; i++)
  193|      0|      {
  194|      0|        MBAmap[i] = MapUnitToSliceGroupMap[i/2];
  195|      0|      }
  196|      0|    }
  197|      0|    else
  198|      0|    {
  199|      0|      for (i=0; i<img->PicSizeInMbs; i++)
  200|      0|      {
  201|      0|        MBAmap[i] = MapUnitToSliceGroupMap[(i/(2*img->PicWidthInMbs))*img->PicWidthInMbs+(i%img->PicWidthInMbs)];
  202|      0|      }
  203|      0|    }
  204|    171|    return 0;
  205|    171|}
  206|       |
  207|       |
  208|       |/*!
  209|       | ************************************************************************
  210|       | * \brief
  211|       | *    FMO initialization: Generates MapUnitToSliceGroupMap and MBAmap.
  212|       | *
  213|       | * \param img
  214|       | *    Image Parameter to be used for map generation
  215|       | * \param pps
  216|       | *    Picture Parameter set to be used for map generation
  217|       | * \param sps
  218|       | *    Sequence Parameter set to be used for map generation
  219|       | ************************************************************************
  220|       | */
  221|       |int FmoInit(ImageParameters * img, pic_parameter_set_rbsp_t * pps, seq_parameter_set_rbsp_t * sps)
  222|    171|{
  223|       |  
  224|       |#ifdef PRINT_FMO_MAPS
  225|       |  unsigned i,j;
  226|       |  int bottom;
  227|       |#endif
  228|       |  
  229|    171|  int k;
  230|  1.53k|  for (k=0;k<MAXSLICEGROUPIDS;k++)
  231|  1.36k|    FirstMBInSlice[k] = -1;
  232|       |  
  233|       |  
  234|       |  
  235|    171|  FmoGenerateMapUnitToSliceGroupMap(img, pps);
  236|    171|  FmoGenerateMBAmap(img, sps);
  237|       |  
  238|       |#ifdef PRINT_FMO_MAPS
  239|       |  printf("\n");
  240|       |  printf("FMO Map (Units):\n");
  241|       |  
  242|       |  for (j=0; j<img->PicHeightInMapUnits; j++)
  243|       |  {
  244|       |    for (i=0; i<img->PicWidthInMbs; i++)
  245|       |    {
  246|       |      printf("%d ",MapUnitToSliceGroupMap[i+j*img->PicWidthInMbs]);
  247|       |    }
  248|       |    printf("\n");
  249|       |  }
  250|       |  printf("\n");
  251|       |  
  252|       |  if(sps->mb_adaptive_frame_field_flag==0)
  253|       |  {
  254|       |    printf("FMO Map (Mb):\n");	
  255|       |    for (j=0; j<(img->PicSizeInMbs/img->PicWidthInMbs); j++)
  256|       |    {
  257|       |      for (i=0; i<img->PicWidthInMbs; i++)
  258|       |      {
  259|       |        printf("%d ",MBAmap[i+j*img->PicWidthInMbs]);
  260|       |      }
  261|       |      printf("\n");
  262|       |    }
  263|       |    printf("\n");
  264|       |  }
  265|       |  else 
  266|       |  {
  267|       |    printf("FMO Map (Mb in scan order for MBAFF):\n");	
  268|       |    for (j=0; j<(img->PicSizeInMbs/img->PicWidthInMbs); j++)
  269|       |    {
  270|       |      for (i=0; i<img->PicWidthInMbs; i++)
  271|       |      {
  272|       |        bottom=(j%2);
  273|       |        printf("%d ",MBAmap[(j-bottom)*img->PicWidthInMbs+i*2+bottom]);
  274|       |      }
  275|       |      printf("\n");
  276|       |      
  277|       |    }
  278|       |    printf("\n");
  279|       |    
  280|       |  }
  281|       |  
  282|       |#endif
  283|       |  
  284|    171|  return 0;
  285|    171|}
  286|       |
  287|       |
  288|       |/*!
  289|       | ************************************************************************
  290|       | * \brief
  291|       | *    Free memory if allocated by FMO functions
  292|       | ************************************************************************
  293|       | */
  294|       |void FmoUninit()
  295|      1|{
  296|      1|  if (MBAmap)
  297|      1|  {
  298|      1|    free (MBAmap);
  299|      1|    MBAmap = NULL;
  300|      1|  }
  301|      1|  if (MapUnitToSliceGroupMap)
  302|      1|  {
  303|      1|    free (MapUnitToSliceGroupMap);
  304|      1|    MapUnitToSliceGroupMap = NULL; 
  305|      1|  }
  306|       |  
  307|      1|}
  308|       |
  309|       |
  310|       |/*!
  311|       | ************************************************************************
  312|       | * \brief
  313|       | *    Generate interleaved slice group map type MapUnit map (type 0)
  314|       | *
  315|       | * \param img
  316|       | *    Image Parameter to be used for map generation
  317|       | * \param pps
  318|       | *    Picture Parameter set to be used for map generation
  319|       | ************************************************************************
  320|       | */
  321|       |static void FmoGenerateType0MapUnitMap (ImageParameters * img, pic_parameter_set_rbsp_t * pps )
  322|      0|{
  323|      0|  unsigned iGroup, j;
  324|      0|  unsigned i = 0;
  325|      0|  do
  326|      0|  {
  327|      0|    for( iGroup = 0; 
  328|      0|    (iGroup <= pps->num_slice_groups_minus1) && (i < PicSizeInMapUnits); 
  329|      0|    i += pps->run_length_minus1[iGroup++] + 1)
  330|      0|    {
  331|      0|      for( j = 0; j <= pps->run_length_minus1[ iGroup ] && i + j < PicSizeInMapUnits; j++ )
  332|      0|        MapUnitToSliceGroupMap[i+j] = iGroup;
  333|      0|    }
  334|      0|  }
  335|      0|  while( i < PicSizeInMapUnits );
  336|      0|}
  337|       |
  338|       |  
  339|       |/*!
  340|       | ************************************************************************
  341|       | * \brief
  342|       | *    Generate dispersed slice group map type MapUnit map (type 1)
  343|       | *
  344|       | * \param img
  345|       | *    Image Parameter to be used for map generation
  346|       | * \param pps
  347|       | *    Picture Parameter set to be used for map generation
  348|       | ************************************************************************
  349|       | */
  350|       |static void FmoGenerateType1MapUnitMap (ImageParameters * img, pic_parameter_set_rbsp_t * pps )
  351|      0|{
  352|      0|  unsigned i;
  353|      0|  for( i = 0; i < PicSizeInMapUnits; i++ )
  354|      0|  {
  355|      0|    MapUnitToSliceGroupMap[i] = ((i%img->PicWidthInMbs)+(((i/img->PicWidthInMbs)*(pps->num_slice_groups_minus1+1))/2))
  356|      0|      %(pps->num_slice_groups_minus1+1);
  357|      0|  }
  358|      0|}
  359|       |
  360|       |/*!
  361|       | ************************************************************************
  362|       | * \brief
  363|       | *    Generate foreground with left-over slice group map type MapUnit map (type 2)
  364|       | *
  365|       | * \param img
  366|       | *    Image Parameter to be used for map generation
  367|       | * \param pps
  368|       | *    Picture Parameter set to be used for map generation
  369|       | ************************************************************************
  370|       | */
  371|       |static void FmoGenerateType2MapUnitMap (ImageParameters * img, pic_parameter_set_rbsp_t * pps )
  372|      0|{
  373|      0|  int iGroup;
  374|      0|  unsigned i, x, y;
  375|      0|  unsigned yTopLeft, xTopLeft, yBottomRight, xBottomRight;
  376|       |  
  377|      0|  for( i = 0; i < PicSizeInMapUnits; i++ )
  378|      0|    MapUnitToSliceGroupMap[ i ] = pps->num_slice_groups_minus1;
  379|       |  
  380|      0|  for( iGroup = pps->num_slice_groups_minus1 - 1 ; iGroup >= 0; iGroup-- ) 
  381|      0|  {
  382|      0|    yTopLeft = pps->top_left[ iGroup ] / img->PicWidthInMbs;
  383|      0|    xTopLeft = pps->top_left[ iGroup ] % img->PicWidthInMbs;
  384|      0|    yBottomRight = pps->bottom_right[ iGroup ] / img->PicWidthInMbs;
  385|      0|    xBottomRight = pps->bottom_right[ iGroup ] % img->PicWidthInMbs;
  386|      0|    for( y = yTopLeft; y <= yBottomRight; y++ )
  387|      0|      for( x = xTopLeft; x <= xBottomRight; x++ )
  388|      0|        MapUnitToSliceGroupMap[ y * img->PicWidthInMbs + x ] = iGroup;
  389|      0|  }
  390|      0|}
  391|       |
  392|       |
  393|       |/*!
  394|       | ************************************************************************
  395|       | * \brief
  396|       | *    Generate box-out slice group map type MapUnit map (type 3)
  397|       | *
  398|       | * \param img
  399|       | *    Image Parameter to be used for map generation
  400|       | * \param pps
  401|       | *    Picture Parameter set to be used for map generation
  402|       | ************************************************************************
  403|       | */
  404|       |static void FmoGenerateType3MapUnitMap (ImageParameters * img, pic_parameter_set_rbsp_t * pps )
  405|      0|{
  406|      0|  unsigned i, k;
  407|      0|  int leftBound, topBound, rightBound, bottomBound;
  408|      0|  int x, y, xDir, yDir;
  409|      0|  int mapUnitVacant;
  410|       |  
  411|      0|  unsigned mapUnitsInSliceGroup0 = min((pps->slice_group_change_rate_minus1 + 1) * img->slice_group_change_cycle, PicSizeInMapUnits);
  412|       |  
  413|      0|  for( i = 0; i < PicSizeInMapUnits; i++ )
  414|      0|    MapUnitToSliceGroupMap[ i ] = 2;
  415|       |  
  416|      0|  x = ( img->PicWidthInMbs - pps->slice_group_change_direction_flag ) / 2;
  417|      0|  y = ( img->PicHeightInMapUnits - pps->slice_group_change_direction_flag ) / 2;
  418|       |  
  419|      0|  leftBound   = x;
  420|      0|  topBound    = y;
  421|      0|  rightBound  = x;
  422|      0|  bottomBound = y;
  423|       |  
  424|      0|  xDir =  pps->slice_group_change_direction_flag - 1;
  425|      0|  yDir =  pps->slice_group_change_direction_flag;
  426|       |  
  427|      0|  for( k = 0; k < PicSizeInMapUnits; k += mapUnitVacant ) 
  428|      0|  {
  429|      0|    mapUnitVacant = ( MapUnitToSliceGroupMap[ y * img->PicWidthInMbs + x ]  ==  2 );
  430|      0|    if( mapUnitVacant )
  431|      0|      MapUnitToSliceGroupMap[ y * img->PicWidthInMbs + x ] = ( k >= mapUnitsInSliceGroup0 );
  432|       |    
  433|      0|    if( xDir  ==  -1  &&  x  ==  leftBound ) 
  434|      0|    {
  435|      0|      leftBound = max( leftBound - 1, 0 );
  436|      0|      x = leftBound;
  437|      0|      xDir = 0;
  438|      0|      yDir = 2 * pps->slice_group_change_direction_flag - 1;
  439|      0|    }
  440|      0|    else 
  441|      0|      if( xDir  ==  1  &&  x  ==  rightBound ) 
  442|      0|      {
  443|      0|        rightBound = min( rightBound + 1, (int)img->PicWidthInMbs - 1 );
  444|      0|        x = rightBound;
  445|      0|        xDir = 0;
  446|      0|        yDir = 1 - 2 * pps->slice_group_change_direction_flag;
  447|      0|      }
  448|      0|      else
  449|      0|        if( yDir  ==  -1  &&  y  ==  topBound ) 
  450|      0|        {
  451|      0|          topBound = max( topBound - 1, 0 );
  452|      0|          y = topBound;
  453|      0|          xDir = 1 - 2 * pps->slice_group_change_direction_flag;
  454|      0|          yDir = 0;
  455|      0|        }
  456|      0|        else 
  457|      0|          if( yDir  ==  1  &&  y  ==  bottomBound ) 
  458|      0|          {
  459|      0|            bottomBound = min( bottomBound + 1, (int)img->PicHeightInMapUnits - 1 );
  460|      0|            y = bottomBound;
  461|      0|            xDir = 2 * pps->slice_group_change_direction_flag - 1;
  462|      0|            yDir = 0;
  463|      0|          }
  464|      0|          else
  465|      0|          {
  466|      0|            x = x + xDir;
  467|      0|            y = y + yDir;
  468|      0|          }
  469|      0|  }
  470|       |  
  471|      0|}
  472|       |
  473|       |/*!
  474|       | ************************************************************************
  475|       | * \brief
  476|       | *    Generate raster scan slice group map type MapUnit map (type 4)
  477|       | *
  478|       | * \param img
  479|       | *    Image Parameter to be used for map generation
  480|       | * \param pps
  481|       | *    Picture Parameter set to be used for map generation
  482|       | ************************************************************************
  483|       | */
  484|       |static void FmoGenerateType4MapUnitMap (ImageParameters * img, pic_parameter_set_rbsp_t * pps )
  485|      0|{
  486|       |  
  487|      0|  unsigned mapUnitsInSliceGroup0 = min((pps->slice_group_change_rate_minus1 + 1) * img->slice_group_change_cycle, PicSizeInMapUnits);
  488|      0|  unsigned sizeOfUpperLeftGroup = pps->slice_group_change_direction_flag ? ( PicSizeInMapUnits - mapUnitsInSliceGroup0 ) : mapUnitsInSliceGroup0;
  489|       |  
  490|      0|  unsigned i;
  491|       |  
  492|      0|  for( i = 0; i < PicSizeInMapUnits; i++ )
  493|      0|    if( i < sizeOfUpperLeftGroup )
  494|      0|      MapUnitToSliceGroupMap[ i ] = pps->slice_group_change_direction_flag;
  495|      0|    else
  496|      0|      MapUnitToSliceGroupMap[ i ] = 1 - pps->slice_group_change_direction_flag;
  497|       |    
  498|      0|}
  499|       |
  500|       |/*!
  501|       | ************************************************************************
  502|       | * \brief
  503|       | *    Generate wipe slice group map type MapUnit map (type 5)
  504|       | *
  505|       | * \param img
  506|       | *    Image Parameter to be used for map generation
  507|       | * \param pps
  508|       | *    Picture Parameter set to be used for map generation
  509|       | ************************************************************************
  510|       |*/
  511|       |static void FmoGenerateType5MapUnitMap (ImageParameters * img, pic_parameter_set_rbsp_t * pps )
  512|      0|{
  513|       |  
  514|      0|  unsigned mapUnitsInSliceGroup0 = min((pps->slice_group_change_rate_minus1 + 1) * img->slice_group_change_cycle, PicSizeInMapUnits);
  515|      0|  unsigned sizeOfUpperLeftGroup = pps->slice_group_change_direction_flag ? ( PicSizeInMapUnits - mapUnitsInSliceGroup0 ) : mapUnitsInSliceGroup0;
  516|       |  
  517|      0|  unsigned i,j, k = 0;
  518|       |  
  519|      0|  for( j = 0; j < img->PicWidthInMbs; j++ )
  520|      0|    for( i = 0; i < img->PicHeightInMapUnits; i++ )
  521|      0|      if( k++ < sizeOfUpperLeftGroup )
  522|      0|        MapUnitToSliceGroupMap[ i * img->PicWidthInMbs + j ] = 1 - pps->slice_group_change_direction_flag;
  523|      0|      else
  524|      0|        MapUnitToSliceGroupMap[ i * img->PicWidthInMbs + j ] = pps->slice_group_change_direction_flag;
  525|       |      
  526|      0|}
  527|       |
  528|       |/*!
  529|       | ************************************************************************
  530|       | * \brief
  531|       | *    Generate explicit slice group map type MapUnit map (type 6)
  532|       | *
  533|       | * \param img
  534|       | *    Image Parameter to be used for map generation
  535|       | * \param pps
  536|       | *    Picture Parameter set to be used for map generation
  537|       | ************************************************************************
  538|       | */
  539|       |static void FmoGenerateType6MapUnitMap (ImageParameters * img, pic_parameter_set_rbsp_t * pps )
  540|      0|{
  541|      0|  unsigned i;
  542|      0|  for (i=0; i<PicSizeInMapUnits; i++)
  543|      0|  {
  544|      0|    MapUnitToSliceGroupMap[i] = pps->slice_group_id[i];
  545|      0|  }
  546|      0|}
  547|       |
  548|       |/*!
  549|       | ************************************************************************
  550|       | * \brief
  551|       | *    FmoStartPicture: initializes FMO at the begin of each new picture
  552|       | *
  553|       | * \par Input:
  554|       | *    None
  555|       | ************************************************************************
  556|       | */
  557|       |int FmoStartPicture ()
  558|    171|{
  559|    171|  int i;
  560|       |  
  561|    171|  assert (MBAmap != NULL);
  562|       |  
  563|  1.53k|  for (i=0; i<MAXSLICEGROUPIDS; i++)
  564|  1.36k|    FirstMBInSlice[i] = FmoGetFirstMBOfSliceGroup (i);
  565|    171|  return 0;
  566|    171|}
  567|       |
  568|       |
  569|       |
  570|       |/*!
  571|       | ************************************************************************
  572|       | * \brief
  573|       | *    FmoEndPicture: Ends the Scattered Slices Module (called once
  574|       | *    per picture).
  575|       | *
  576|       | * \par Input:
  577|       | *    None
  578|       | ************************************************************************
  579|       | */
  580|       |int FmoEndPicture ()
  581|    171|{
  582|       |  // Do nothing
  583|    171|  return 0;
  584|    171|}
  585|       |
  586|       |
  587|       |/*!
  588|       | ************************************************************************
  589|       | * \brief
  590|       | *    FmoMB2Slice: Returns SliceID for a given MB
  591|       | *
  592|       | * \par Input:
  593|       | *    Macroblock Nr (in scan order)
  594|       | ************************************************************************
  595|       | */
  596|       |int FmoMB2SliceGroup ( int mb)
  597|  71.3M|{
  598|  71.3M|  assert (mb < (int)img->PicSizeInMbs);
  599|  71.3M|  assert (MBAmap != NULL);
  600|  71.3M|  return MBAmap[mb];
  601|  71.3M|}
  602|       |
  603|       |/*!
  604|       | ************************************************************************
  605|       | * \brief
  606|       | *    FmoGetNextMBBr: Returns the MB-Nr (in scan order) of the next
  607|       | *    MB in the (FMO) Slice, -1 if the SliceGroup is finished
  608|       | *
  609|       | * \par Input:
  610|       | *    CurrentMbNr
  611|       | ************************************************************************
  612|       | */
  613|       |int FmoGetNextMBNr (int CurrentMbNr)
  614|   109k|{
  615|       |  
  616|   109k|  int  SliceGroupID = FmoMB2SliceGroup (CurrentMbNr); 
  617|       |  
  618|   109k|  while (++CurrentMbNr<(int)img->PicSizeInMbs &&  MBAmap[CurrentMbNr] != SliceGroupID)
  619|      0|    ;
  620|       |  
  621|   109k|  if (CurrentMbNr >= (int)img->PicSizeInMbs)
  622|    342|    return -1;    // No further MB in this slice (could be end of picture)
  623|   109k|  else
  624|   109k|    return CurrentMbNr;
  625|   109k|}
  626|       |
  627|       |
  628|       |/*!
  629|       | ************************************************************************
  630|       | * \brief
  631|       | *    FmoGetNextMBBr: Returns the MB-Nr (in scan order) of the next
  632|       | *    MB in the (FMO) Slice, -1 if the SliceGroup is finished
  633|       | *
  634|       | * \par Input:
  635|       | *    CurrentMbNr
  636|       | ************************************************************************
  637|       | */
  638|       |int FmoGetPreviousMBNr (int CurrentMbNr)
  639|   327k|{
  640|       |  
  641|   327k|  int  SliceGroupID = FmoMB2SliceGroup (CurrentMbNr); 
  642|   327k|  CurrentMbNr--;
  643|   327k|  while (CurrentMbNr>=0 &&  MBAmap[CurrentMbNr] != SliceGroupID)
  644|      0|    CurrentMbNr--;
  645|       |  
  646|   327k|  if (CurrentMbNr < 0)
  647|    171|    return -1;    // No previous MB in this slice
  648|   327k|  else
  649|   327k|    return CurrentMbNr;
  650|   327k|}
  651|       |
  652|       |
  653|       |/*!
  654|       | ************************************************************************
  655|       | * \brief
  656|       | *    FmoGetFirstMBOfSliceGroup: Returns the MB-Nr (in scan order) of the 
  657|       | *    next first MB of the Slice group, -1 if no such MB exists
  658|       | *
  659|       | * \par Input:
  660|       | *    SliceGroupID: Id of SliceGroup
  661|       | ************************************************************************
  662|       | */
  663|       |int FmoGetFirstMBOfSliceGroup (int SliceGroupID)
  664|  1.36k|{
  665|  1.36k|  int i = 0;
  666|   767k|  while ((i<(int)img->PicSizeInMbs) && (FmoMB2SliceGroup (i) != SliceGroupID))
  667|   766k|    i++;
  668|       |
  669|  1.36k|  if (i < (int)img->PicSizeInMbs)
  670|    171|    return i;
  671|  1.19k|  else
  672|  1.19k|    return -1;
  673|  1.36k|}
  674|       |
  675|       |
  676|       |/*!
  677|       | ************************************************************************
  678|       | * \brief
  679|       | *    FmoGetLastCodedMBOfSlice: Returns the MB-Nr (in scan order) of 
  680|       | *    the last MB of the slice group
  681|       | *
  682|       | * \par Input:
  683|       | *    SliceGroupID
  684|       | * \par Return
  685|       | *    MB Nr in case of success (is always >= 0)
  686|       | *    -1 if the SliceGroup doesn't exist
  687|       | ************************************************************************
  688|       | */
  689|       |int FmoGetLastCodedMBOfSliceGroup (int SliceGroupID)
  690|   109k|{
  691|   109k|  int i;
  692|   109k|  int LastMB = -1;
  693|       |  
  694|  70.1M|  for (i=0; i<(int)img->PicSizeInMbs; i++)
  695|  70.0M|    if (FmoMB2SliceGroup (i) == SliceGroupID)
  696|  70.0M|      LastMB = i;
  697|   109k|  return LastMB;
  698|   109k|}
  699|       |
  700|       |
  701|       |void FmoSetLastMacroblockInSlice ( int mb)
  702|    171|{
  703|       |  // called by terminate_slice(), writes the last processed MB into the
  704|       |  // FirstMBInSlice[MAXSLICEGROUPIDS] array.  FmoGetFirstMacroblockInSlice()
  705|       |  // uses this info to identify the first uncoded MB in each slice group
  706|       |  
  707|    171|  int currSliceGroup = FmoMB2SliceGroup (mb);
  708|    171|  assert (mb >= 0);
  709|    171|  mb = FmoGetNextMBNr (mb);   // The next (still uncoded) MB, or -1 if SG is finished
  710|    171|  FirstMBInSlice[currSliceGroup] = mb;
  711|    171|}
  712|       |
  713|       |int FmoGetFirstMacroblockInSlice ( int SliceGroup)
  714|    513|{
  715|    513|  return FirstMBInSlice[SliceGroup];
  716|       |  // returns the first uncoded MB in each slice group, -1 if there is no
  717|       |  // more to do in this slice group
  718|    513|}
  719|       |
  720|       |
  721|       |int FmoSliceGroupCompletelyCoded( int SliceGroupID)
  722|    342|{
  723|    342|  if (FmoGetFirstMacroblockInSlice (SliceGroupID) < 0)  // slice group completelty coded or not present
  724|    171|    return TRUE;
  725|    171|  else
  726|    171|    return FALSE;
  727|    342|}
  728|       |
  729|       |
  730|       |

/home/xzp/speccpu2006-v1.0.1/benchspec/CPU2006/464.h264ref/run/build_base_ql_riscv_llvm17.0000/fmo.h:
    1|       |
    2|       |/*!
    3|       | ***************************************************************************
    4|       | *
    5|       | * \file fmo.h
    6|       | *
    7|       | * \brief
    8|       | *    Support for Flexible Macroblock Ordering
    9|       | *
   10|       | * \date
   11|       | *    16 June 2002
   12|       | *
   13|       | * \author
   14|       | *    Stephan Wenger   stewe@cs.tu-berlin.de
   15|       | **************************************************************************/
   16|       |
   17|       |#ifndef _FMO_H_
   18|       |#define _FMO_H_
   19|       |
   20|  3.07k|#define MAXSLICEGROUPIDS 8
   21|       |
   22|       |int FmoInit(ImageParameters * img, pic_parameter_set_rbsp_t * pps, seq_parameter_set_rbsp_t * sps);
   23|       |void FmoUninit ();
   24|       |int FmoFinit (seq_parameter_set_rbsp_t * sps);
   25|       |int FmoMB2SliceGroup (int mb);
   26|       |int FmoGetFirstMBOfSliceGroup (int SliceGroupID);
   27|       |int FmoGetFirstMacroblockInSlice (int SliceGroup);
   28|       |int FmoGetNextMBNr (int CurrentMbNr);
   29|       |int FmoGetLastCodedMBOfSliceGroup (int SliceGroupID);
   30|       |int FmoStartPicture ();
   31|       |int FmoEndPicture();
   32|       |int FmoSliceGroupCompletelyCoded(int SliceGroupID);
   33|       |void FmoSetLastMacroblockInSlice (int mb);
   34|       |
   35|       |int FmoGetPreviousMBNr (int CurrentMbNr);
   36|       |
   37|       |extern byte *MBAmap; 
   38|       |
   39|       |#endif

/home/xzp/speccpu2006-v1.0.1/benchspec/CPU2006/464.h264ref/run/build_base_ql_riscv_llvm17.0000/global.h:
    1|       |
    2|       |/*!
    3|       | ************************************************************************
    4|       | *  \file
    5|       | *     global.h
    6|       | *
    7|       | *  \brief
    8|       | *     global definitions for for H.264 encoder.
    9|       | *
   10|       | *  \author
   11|       | *     Copyright (C) 1999  Telenor Satellite Services,Norway
   12|       | *                         Ericsson Radio Systems, Sweden
   13|       | *
   14|       | *     Inge Lille-Langoy               <inge.lille-langoy@telenor.com>
   15|       | *
   16|       | *     Telenor Satellite Services
   17|       | *     Keysers gt.13                       tel.:   +47 23 13 86 98
   18|       | *     N-0130 Oslo,Norway                  fax.:   +47 22 77 79 80
   19|       | *
   20|       | *     Rickard Sjoberg                 <rickard.sjoberg@era.ericsson.se>
   21|       | *
   22|       | *     Ericsson Radio Systems
   23|       | *     KI/ERA/T/VV
   24|       | *     164 80 Stockholm, Sweden
   25|       | *
   26|       | ************************************************************************
   27|       | */
   28|       |#ifndef _GLOBAL_H_
   29|       |#define _GLOBAL_H_
   30|       |
   31|       |#include <stdio.h>
   32|       |
   33|       |#include "defines.h"
   34|       |#include "parsetcommon.h"
   35|       |#include "q_matrix.h"
   36|       |#include "q_offsets.h"
   37|       |#include "minmax.h"
   38|       |
   39|       |#if defined(SPEC_CPU)
   40|       |#include "specrand.h"
   41|       |#endif /* SPEC_CPU */
   42|       |
   43|       |#ifdef WIN32
   44|       |  #define  snprintf _snprintf
   45|       |#endif
   46|       |
   47|       |#if defined(SPEC_CPU_NO_INTTYPES)
   48|       |#ifndef INT64_MIN
   49|       |# define INT64_MIN        (-9223372036854775807LL - 1LL)
   50|       |#endif
   51|       |#if defined(WIN32) && !defined(__GNUC__)
   52|       |  typedef __int64   int64;
   53|       |#else
   54|       |  typedef long long int64;
   55|       |#endif
   56|       |#else
   57|       |#if defined(SPEC_CPU_AIX)
   58|       |#include <stdint.h>
   59|       |#include <inttypes.h>
   60|       |#else
   61|       |#include <inttypes.h>
   62|       |  typedef int64_t int64;
   63|       |#endif
   64|       |#endif
   65|       |
   66|       |
   67|       |#ifdef WIN32
   68|       |#define  snprintf _snprintf
   69|       |#define  open     _open
   70|       |#define  close    _close
   71|       |#define  read     _read
   72|       |#define  write    _write
   73|       |#define  lseek    _lseeki64
   74|       |#define  fsync    _commit
   75|       |#define  OPENFLAGS_WRITE _O_WRONLY|_O_CREAT|_O_BINARY|_O_TRUNC
   76|       |#define  OPEN_PERMISSIONS _S_IREAD | _S_IWRITE
   77|       |#define  OPENFLAGS_READ  _O_RDONLY|_O_BINARY
   78|       |#else
   79|      0|#define  OPENFLAGS_WRITE O_WRONLY|O_CREAT|O_TRUNC
   80|      1|#define  OPENFLAGS_READ  O_RDONLY
   81|      0|#define  OPEN_PERMISSIONS S_IRUSR | S_IWUSR
   82|       |#endif
   83|       |
   84|       |
   85|       |/***********************************************************************
   86|       | * T y p e    d e f i n i t i o n s    f o r    T M L
   87|       | ***********************************************************************
   88|       | */
   89|       |
   90|       |//#define pel_t byte
   91|       |
   92|   917M|#define imgpel unsigned short
   93|   849M|#define pel_t imgpel
   94|       |
   95|       |//! Data Partitioning Modes
   96|       |typedef enum
   97|       |{
   98|       |  PAR_DP_1,   //!< no data partitioning is supported
   99|       |  PAR_DP_3,   //!< data partitioning with 3 partitions
  100|       |} PAR_DP_TYPE;
  101|       |
  102|       |
  103|       |//! Output File Types
  104|       |typedef enum
  105|       |{
  106|       |  PAR_OF_ANNEXB,    //!< Annex B byte stream format
  107|       |  PAR_OF_RTP,       //!< RTP packets in outfile
  108|       |} PAR_OF_TYPE;
  109|       |
  110|       |//! Field Coding Types
  111|       |typedef enum 
  112|       |{
  113|       |  FRAME_CODING,
  114|       |  FIELD_CODING,
  115|       |  ADAPTIVE_CODING
  116|       |} CodingType;
  117|       |
  118|       |//! definition of H.264 syntax elements
  119|       |typedef enum 
  120|       |{
  121|       |  SE_HEADER,
  122|       |  SE_PTYPE,
  123|       |  SE_MBTYPE,
  124|       |  SE_REFFRAME,
  125|       |  SE_INTRAPREDMODE,
  126|       |  SE_MVD,
  127|       |  SE_CBP_INTRA,
  128|       |  SE_LUM_DC_INTRA,
  129|       |  SE_CHR_DC_INTRA,
  130|       |  SE_LUM_AC_INTRA,
  131|       |  SE_CHR_AC_INTRA,
  132|       |  SE_CBP_INTER,
  133|       |  SE_LUM_DC_INTER,
  134|       |  SE_CHR_DC_INTER,
  135|       |  SE_LUM_AC_INTER,
  136|       |  SE_CHR_AC_INTER,
  137|       |  SE_DELTA_QUANT_INTER,
  138|       |  SE_DELTA_QUANT_INTRA,
  139|       |  SE_BFRAME,
  140|       |  SE_EOS,
  141|       |  SE_TRANSFORM_SIZE_FLAG,
  142|       |  SE_MAX_ELEMENTS  //!< number of maximum syntax elements
  143|       |} SE_type;         // substituting the definitions in elements.h
  144|       |
  145|       |
  146|       |typedef enum 
  147|       |{
  148|       |  INTER_MB,
  149|       |  INTRA_MB_4x4,
  150|       |  INTRA_MB_16x16
  151|       |} IntraInterDecision;
  152|       |
  153|       |
  154|       |typedef enum 
  155|       |{
  156|       |  BITS_HEADER,
  157|       |  BITS_TOTAL_MB,
  158|       |  BITS_MB_MODE,
  159|       |  BITS_INTER_MB,
  160|       |  BITS_CBP_MB,
  161|       |  BITS_COEFF_Y_MB,
  162|       |  BITS_COEFF_UV_MB,
  163|       |  BITS_DELTA_QUANT_MB,
  164|       |  MAX_BITCOUNTER_MB
  165|       |} BitCountType;
  166|       |
  167|       |
  168|       |typedef enum 
  169|       |{
  170|       |  NO_SLICES,
  171|       |  FIXED_MB,
  172|       |  FIXED_RATE,
  173|       |  CALLBACK,
  174|       |  FMO
  175|       |} SliceMode;
  176|       |
  177|       |
  178|       |typedef enum 
  179|       |{
  180|       |  UVLC,
  181|       |  CABAC
  182|       |} SymbolMode;
  183|       |
  184|       |
  185|       |typedef enum 
  186|       |{
  187|       |  FRAME,
  188|       |  TOP_FIELD,
  189|       |  BOTTOM_FIELD
  190|       |} PictureStructure;           //!< New enum for field processing
  191|       |
  192|       |typedef enum 
  193|       |{
  194|       |  P_SLICE = 0,
  195|       |  B_SLICE,
  196|       |  I_SLICE,
  197|       |  SP_SLICE,
  198|       |  SI_SLICE
  199|       |} SliceType;
  200|       |
  201|       |/***********************************************************************
  202|       | * D a t a    t y p e s   f o r  C A B A C
  203|       | ***********************************************************************
  204|       | */
  205|       |
  206|       |//! struct to characterize the state of the arithmetic coding engine
  207|       |typedef struct
  208|       |{
  209|       |  unsigned int  Elow, Erange;
  210|       |  unsigned int  Ebuffer;
  211|       |  unsigned int  Ebits_to_go;
  212|       |  unsigned int  Ebits_to_follow;
  213|       |  byte          *Ecodestrm;
  214|       |  int           *Ecodestrm_len;
  215|       |
  216|       |  // storage in case of recode MB
  217|       |  unsigned int  ElowS, ErangeS;
  218|       |  unsigned int  EbufferS;
  219|       |  unsigned int  Ebits_to_goS;
  220|       |  unsigned int  Ebits_to_followS;
  221|       |  byte          *EcodestrmS;
  222|       |  int           *Ecodestrm_lenS;
  223|       |  int           C, CS;
  224|       |  int           E, ES;
  225|       |  int           B, BS;
  226|       |} EncodingEnvironment;
  227|       |
  228|       |typedef EncodingEnvironment *EncodingEnvironmentPtr;
  229|       |
  230|       |//! struct for context management
  231|       |typedef struct
  232|       |{
  233|       |  unsigned short state;         // index into state-table CP  
  234|       |  unsigned char  MPS;           // Least Probable Symbol 0/1 CP
  235|       |
  236|       |  unsigned long  count;
  237|       |
  238|       |} BiContextType;
  239|       |
  240|       |typedef BiContextType *BiContextTypePtr;
  241|       |
  242|       |
  243|       |/**********************************************************************
  244|       | * C O N T E X T S   F O R   T M L   S Y N T A X   E L E M E N T S
  245|       | **********************************************************************
  246|       | */
  247|       |
  248|       |
  249|       |#define NUM_MB_TYPE_CTX  11
  250|       |#define NUM_B8_TYPE_CTX  9
  251|       |#define NUM_MV_RES_CTX   10
  252|       |#define NUM_REF_NO_CTX   6
  253|       |#define NUM_DELTA_QP_CTX 4
  254|       |#define NUM_MB_AFF_CTX 4
  255|       |
  256|       |#define NUM_TRANSFORM_SIZE_CTX 3
  257|       |
  258|       |typedef struct
  259|       |{
  260|       |  BiContextType mb_type_contexts [3][NUM_MB_TYPE_CTX];
  261|       |  BiContextType b8_type_contexts [2][NUM_B8_TYPE_CTX];
  262|       |  BiContextType mv_res_contexts  [2][NUM_MV_RES_CTX];
  263|       |  BiContextType ref_no_contexts  [2][NUM_REF_NO_CTX];
  264|       |  BiContextType delta_qp_contexts   [NUM_DELTA_QP_CTX];
  265|       |  BiContextType mb_aff_contexts     [NUM_MB_AFF_CTX];
  266|       |  BiContextType transform_size_contexts   [NUM_TRANSFORM_SIZE_CTX];
  267|       |  
  268|       |} MotionInfoContexts;
  269|       |
  270|       |
  271|       |#define NUM_IPR_CTX    2
  272|       |#define NUM_CIPR_CTX   4
  273|       |#define NUM_CBP_CTX    4
  274|       |#define NUM_BCBP_CTX   4
  275|       |#define NUM_MAP_CTX   15
  276|       |#define NUM_LAST_CTX  15
  277|       |#define NUM_ONE_CTX    5
  278|       |#define NUM_ABS_CTX    5
  279|       |
  280|       |
  281|       |typedef struct
  282|       |{
  283|       |  BiContextType  ipr_contexts [NUM_IPR_CTX]; 
  284|       |  BiContextType  cipr_contexts[NUM_CIPR_CTX]; 
  285|       |  BiContextType  cbp_contexts [3][NUM_CBP_CTX];
  286|       |  BiContextType  bcbp_contexts[NUM_BLOCK_TYPES][NUM_BCBP_CTX];
  287|       |  BiContextType  map_contexts [NUM_BLOCK_TYPES][NUM_MAP_CTX];
  288|       |  BiContextType  last_contexts[NUM_BLOCK_TYPES][NUM_LAST_CTX];
  289|       |  BiContextType  one_contexts [NUM_BLOCK_TYPES][NUM_ONE_CTX];
  290|       |  BiContextType  abs_contexts [NUM_BLOCK_TYPES][NUM_ABS_CTX];
  291|       |  BiContextType  fld_map_contexts [NUM_BLOCK_TYPES][NUM_MAP_CTX];
  292|       |  BiContextType  fld_last_contexts[NUM_BLOCK_TYPES][NUM_LAST_CTX];
  293|       |} TextureInfoContexts;
  294|       |
  295|       |//*********************** end of data type definition for CABAC *******************
  296|       |
  297|       |typedef struct pix_pos
  298|       |{
  299|       |  int available;
  300|       |  int mb_addr;
  301|       |  int x;
  302|       |  int y;
  303|       |  int pos_x;
  304|       |  int pos_y;
  305|       |} PixelPos;
  306|       |
  307|       |/*! Buffer structure for RMPNI commands */
  308|       |typedef struct RMPNIbuffer_s
  309|       |{
  310|       |  int RMPNI;
  311|       |  int Data;
  312|       |  struct RMPNIbuffer_s *Next;
  313|       |} RMPNIbuffer_t;
  314|       |
  315|       |/*! Buffer structure for decoded referenc picture marking commands */
  316|       |typedef struct DecRefPicMarking_s
  317|       |{
  318|       |  int memory_management_control_operation;
  319|       |  int difference_of_pic_nums_minus1;
  320|       |  int long_term_pic_num;
  321|       |  int long_term_frame_idx;
  322|       |  int max_long_term_frame_idx_plus1;
  323|       |  struct DecRefPicMarking_s *Next;
  324|       |} DecRefPicMarking_t;
  325|       |
  326|       |//! Syntaxelement
  327|       |typedef struct syntaxelement
  328|       |{
  329|       |  int                 type;           //!< type of syntax element for data part.
  330|       |  int                 value1;         //!< numerical value of syntax element
  331|       |  int                 value2;         //!< for blocked symbols, e.g. run/level
  332|       |  int                 len;            //!< length of code
  333|       |  int                 inf;            //!< info part of UVLC code
  334|       |  unsigned int        bitpattern;     //!< UVLC bitpattern
  335|       |  int                 context;        //!< CABAC context
  336|       |  int                 k;              //!< CABAC context for coeff_count,uv
  337|       |
  338|       |#if TRACE
  339|       |  #define             TRACESTRING_SIZE 100            //!< size of trace string
  340|       |  char                tracestring[TRACESTRING_SIZE];  //!< trace string
  341|       |#endif
  342|       |
  343|       |  //!< for mapping of syntaxElement to UVLC
  344|       |  void    (*mapping)(int value1, int value2, int* len_ptr, int* info_ptr);
  345|       |  //!< used for CABAC: refers to actual coding method of each individual syntax element type
  346|       |  void    (*writing)(struct syntaxelement *, EncodingEnvironmentPtr);
  347|       |
  348|       |} SyntaxElement;
  349|       |
  350|       |//! Macroblock
  351|       |typedef struct macroblock
  352|       |{
  353|       |  int                 currSEnr;                   //!< number of current syntax element
  354|       |  int                 slice_nr;
  355|       |  int                 delta_qp;
  356|       |  int                 qp ;
  357|       |  int                 qpsp ;
  358|       |  int                 bitcounter[MAX_BITCOUNTER_MB];
  359|       |
  360|       |  struct macroblock   *mb_available_up;   //!< pointer to neighboring MB (CABAC)
  361|       |  struct macroblock   *mb_available_left; //!< pointer to neighboring MB (CABAC)
  362|       |
  363|       |  int                 mb_type;
  364|       |  int                 mvd[2][BLOCK_MULTIPLE][BLOCK_MULTIPLE][2];          //!< indices correspond to [forw,backw][block_y][block_x][x,y]
  365|       |  int                 intra_pred_modes[BLOCK_MULTIPLE*BLOCK_MULTIPLE];
  366|       |  int                 intra_pred_modes8x8[BLOCK_MULTIPLE*BLOCK_MULTIPLE];                             //!< four 8x8 blocks in a macroblock
  367|       |  int                 cbp ;
  368|       |  int64               cbp_blk ;    //!< 1 bit set for every 4x4 block with coefs (not implemented for INTRA)
  369|       |  int                 b8mode[4];
  370|       |  int                 b8pdir[4];
  371|       |  unsigned long       cbp_bits;
  372|       |
  373|       |  int                 lf_disable;
  374|       |  int                 lf_alpha_c0_offset;
  375|       |  int                 lf_beta_offset;
  376|       |
  377|       |  int                 c_ipred_mode;      //!< chroma intra prediction mode
  378|       |  int                 IntraChromaPredModeFlag;
  379|       |  
  380|       |  int                 mb_field;
  381|       |
  382|       |  int mbAddrA, mbAddrB, mbAddrC, mbAddrD;
  383|       |  int mbAvailA, mbAvailB, mbAvailC, mbAvailD;
  384|       |
  385|       |  int                 all_blk_8x8;
  386|       |  int                 luma_transform_size_8x8_flag;
  387|       |  int                 NoMbPartLessThan8x8Flag;
  388|       |
  389|       |#if BI_PREDICTION
  390|       |  int    bi_pred_me;
  391|       |#endif
  392|       |  
  393|       |  // rate control
  394|       |  double              actj;               // macroblock activity measure for macroblock j
  395|       |  int                 prev_qp;
  396|       |  int                 prev_delta_qp;
  397|       |  int                 prev_cbp;
  398|       |  int                 predict_qp;
  399|       |  int                 predict_error;
  400|       |
  401|       |  int                 LFDisableIdc;
  402|       |  int                 LFAlphaC0Offset;
  403|       |  int                 LFBetaOffset;
  404|       |
  405|       |  int                 skip_flag;
  406|       |} Macroblock;
  407|       |
  408|       |
  409|       |
  410|       |//! Bitstream
  411|       |typedef struct
  412|       |{
  413|       |  int             byte_pos;           //!< current position in bitstream;
  414|       |  int             bits_to_go;         //!< current bitcounter
  415|       |  byte            byte_buf;           //!< current buffer for last written byte
  416|       |  int             stored_byte_pos;    //!< storage for position in bitstream;
  417|       |  int             stored_bits_to_go;  //!< storage for bitcounter
  418|       |  byte            stored_byte_buf;    //!< storage for buffer of last written byte
  419|       |
  420|       |  byte            byte_buf_skip;      //!< current buffer for last written byte
  421|       |  int             byte_pos_skip;      //!< storage for position in bitstream;
  422|       |  int             bits_to_go_skip;    //!< storage for bitcounter
  423|       |
  424|       |  byte            *streamBuffer;      //!< actual buffer for written bytes
  425|       |  int             write_flag;         //!< Bitstream contains data and needs to be written
  426|       |
  427|       |} Bitstream;
  428|       |
  429|       |//! DataPartition
  430|       |typedef struct datapartition
  431|       |{
  432|       |
  433|       |  Bitstream           *bitstream;
  434|       |  EncodingEnvironment ee_cabac;
  435|       |
  436|       |  int                 (*writeSyntaxElement)(SyntaxElement *, struct datapartition *);
  437|       |                      /*!< virtual function;
  438|       |                           actual method depends on chosen data partition and
  439|       |                           entropy coding method  */
  440|       |} DataPartition;
  441|       |
  442|       |//! Slice
  443|       |typedef struct
  444|       |{
  445|       |  int                 picture_id;
  446|       |  int                 qp;
  447|       |  int                 picture_type; //!< picture type
  448|       |  int                 start_mb_nr;
  449|       |  int                 max_part_nr;  //!< number of different partitions
  450|       |  int                 num_mb;       //!< number of MBs in the slice
  451|       |  DataPartition       *partArr;     //!< array of partitions
  452|       |  MotionInfoContexts  *mot_ctx;     //!< pointer to struct of context models for use in CABAC
  453|       |  TextureInfoContexts *tex_ctx;     //!< pointer to struct of context models for use in CABAC
  454|       |
  455|       |  // !KS: RMPNI buffer should be retired. just do some sore simple stuff
  456|       |  RMPNIbuffer_t        *rmpni_buffer; //!< stores the slice temporary buffer remapping commands
  457|       |
  458|       |  int                 ref_pic_list_reordering_flag_l0;
  459|       |  int                 *remapping_of_pic_nums_idc_l0;
  460|       |  int                 *abs_diff_pic_num_minus1_l0;
  461|       |  int                 *long_term_pic_idx_l0;
  462|       |  int                 ref_pic_list_reordering_flag_l1;
  463|       |  int                 *remapping_of_pic_nums_idc_l1;
  464|       |  int                 *abs_diff_pic_num_minus1_l1;
  465|       |  int                 *long_term_pic_idx_l1;
  466|       |
  467|       |  Boolean             (*slice_too_big)(int bits_slice); //!< for use of callback functions
  468|       |
  469|       |  int                 field_ctx[3][2]; //GB
  470|       |
  471|       |} Slice;
  472|       |
  473|       |
  474|    171|#define MAXSLICEPERPICTURE 100
  475|       |typedef struct 
  476|       |{
  477|       |  int   no_slices;
  478|       |  int   idr_flag;
  479|       |  Slice *slices[MAXSLICEPERPICTURE];
  480|       |  int bits_per_picture;
  481|       |  float distortion_y;
  482|       |  float distortion_u;
  483|       |  float distortion_v;
  484|       |} Picture;
  485|       |
  486|       |#if defined(SPEC_CPU)
  487|       |extern Picture *top_pic;
  488|       |extern Picture *bottom_pic;
  489|       |extern Picture *frame_pic;
  490|       |extern Picture *frame_pic2;
  491|       |extern Picture *frame_pic3;
  492|       |
  493|       |// global picture format dependend buffers, mem allocation in image.c
  494|       |extern imgpel **imgY_org;           //!< Reference luma image
  495|       |extern imgpel ***imgUV_org;         //!< Reference chroma image
  496|       |extern int    **img4Y_tmp;          //!< for quarter pel interpolation
  497|       |
  498|       |extern unsigned int log2_max_frame_num_minus4;
  499|       |extern unsigned int log2_max_pic_order_cnt_lsb_minus4;
  500|       |
  501|       |extern int  me_tot_time,me_time;
  502|       |extern pic_parameter_set_rbsp_t *active_pps;
  503|       |extern seq_parameter_set_rbsp_t *active_sps;
  504|       |
  505|       |// B pictures
  506|       |// motion vector : forward, backward, direct
  507|       |extern int  mb_adaptive;       //!< For MB level field/frame coding tools
  508|       |extern int  MBPairIsField;     //!< For MB level field/frame coding tools
  509|       |
  510|       |
  511|       |//Weighted prediction
  512|       |extern int ***wp_weight;  // weight in [list][index][component] order
  513|       |extern int ***wp_offset;  // offset in [list][index][component] order
  514|       |extern int ****wbp_weight;  // weight in [list][fwd_index][bwd_idx][component] order
  515|       |extern int luma_log_weight_denom;
  516|       |extern int chroma_log_weight_denom;
  517|       |extern int wp_luma_round;
  518|       |extern int wp_chroma_round;
  519|       |
  520|       |// global picture format dependend buffers, mem allocation in image.c (field picture)
  521|       |extern imgpel   **imgY_org_top;
  522|       |extern imgpel   **imgY_org_bot;
  523|       |
  524|       |extern imgpel  ***imgUV_org_top;
  525|       |extern imgpel  ***imgUV_org_bot;
  526|       |
  527|       |extern imgpel   **imgY_org_frm;
  528|       |extern imgpel  ***imgUV_org_frm;
  529|       |
  530|       |extern imgpel   **imgY_com;               //!< Encoded luma images
  531|       |extern imgpel  ***imgUV_com;              //!< Encoded croma images
  532|       |
  533|       |extern short   ***direct_ref_idx;           //!< direct mode reference index buffer
  534|       |extern short    **direct_pdir;              //!< direct mode reference index buffer
  535|       |
  536|       |// Buffers for rd optimization with packet losses, Dim. Kontopodis
  537|       |extern byte **pixel_map;   //!< Shows the latest reference frame that is reliable for each pixel
  538|       |extern byte **refresh_map; //!< Stores the new values for pixel_map  
  539|       |extern int intras;         //!< Counts the intra updates in each frame.
  540|       |
  541|       |extern int  Iframe_ctr, Pframe_ctr,Bframe_ctr;
  542|       |extern int  frame_no, nextP_tr_fld, nextP_tr_frm;
  543|       |extern int  tot_time;
  544|       |
  545|      0|#define ET_SIZE 300      //!< size of error text buffer
  546|       |extern char errortext[ET_SIZE]; //!< buffer for error message for exit with error()
  547|       |
  548|       |// Residue Color Transform
  549|       |extern int resTrans_R[16][16], resTrans_G[16][16], resTrans_B[16][16];
  550|       |extern int rec_resR[16][16], rec_resG[16][16], rec_resB[16][16];
  551|       |extern int mprRGB[3][16][16];
  552|       |extern int dc_level[2][4][4], dc_level_temp[2][4][4];
  553|       |extern int cbp_chroma_block[2][4][4], cbp_chroma_block_temp[2][4][4];
  554|       |extern int b8_ipredmode8x8[4][4], b8_intra_pred_modes8x8[16];
  555|       |
  556|       |#else /* SPEC_CPU */
  557|       |
  558|       |Picture *top_pic;
  559|       |Picture *bottom_pic;
  560|       |Picture *frame_pic;
  561|       |Picture *frame_pic2;
  562|       |Picture *frame_pic3;
  563|       |
  564|       |// global picture format dependend buffers, mem allocation in image.c
  565|       |imgpel **imgY_org;           //!< Reference luma image
  566|       |imgpel ***imgUV_org;         //!< Reference chroma image
  567|       |int    **img4Y_tmp;          //!< for quarter pel interpolation
  568|       |
  569|       |unsigned int log2_max_frame_num_minus4;
  570|       |unsigned int log2_max_pic_order_cnt_lsb_minus4;
  571|       |
  572|       |int  me_tot_time,me_time;
  573|       |pic_parameter_set_rbsp_t *active_pps;
  574|       |seq_parameter_set_rbsp_t *active_sps;
  575|       |
  576|       |// B pictures
  577|       |// motion vector : forward, backward, direct
  578|       |int  mb_adaptive;       //!< For MB level field/frame coding tools
  579|       |int  MBPairIsField;     //!< For MB level field/frame coding tools
  580|       |
  581|       |
  582|       |//Weighted prediction
  583|       |int ***wp_weight;  // weight in [list][index][component] order
  584|       |int ***wp_offset;  // offset in [list][index][component] order
  585|       |int ****wbp_weight;  // weight in [list][fwd_index][bwd_idx][component] order
  586|       |int luma_log_weight_denom;
  587|       |int chroma_log_weight_denom;
  588|       |int wp_luma_round;
  589|       |int wp_chroma_round;
  590|       |
  591|       |// global picture format dependend buffers, mem allocation in image.c (field picture)
  592|       |imgpel   **imgY_org_top;
  593|       |imgpel   **imgY_org_bot;
  594|       |
  595|       |imgpel  ***imgUV_org_top;
  596|       |imgpel  ***imgUV_org_bot;
  597|       |
  598|       |imgpel   **imgY_org_frm;
  599|       |imgpel  ***imgUV_org_frm;
  600|       |
  601|       |imgpel   **imgY_com;               //!< Encoded luma images
  602|       |imgpel  ***imgUV_com;              //!< Encoded croma images
  603|       |
  604|       |short   ***direct_ref_idx;           //!< direct mode reference index buffer
  605|       |short    **direct_pdir;              //!< direct mode reference index buffer
  606|       |
  607|       |// Buffers for rd optimization with packet losses, Dim. Kontopodis
  608|       |byte **pixel_map;   //!< Shows the latest reference frame that is reliable for each pixel
  609|       |byte **refresh_map; //!< Stores the new values for pixel_map  
  610|       |int intras;         //!< Counts the intra updates in each frame.
  611|       |
  612|       |int  Iframe_ctr, Pframe_ctr,Bframe_ctr;
  613|       |int  frame_no, nextP_tr_fld, nextP_tr_frm;
  614|       |int  tot_time;
  615|       |
  616|       |#define ET_SIZE 300      //!< size of error text buffer
  617|       |char errortext[ET_SIZE]; //!< buffer for error message for exit with error()
  618|       |
  619|       |// Residue Color Transform
  620|       |int resTrans_R[16][16], resTrans_G[16][16], resTrans_B[16][16];
  621|       |int rec_resR[16][16], rec_resG[16][16], rec_resB[16][16];
  622|       |int mprRGB[3][16][16];
  623|       |int dc_level[2][4][4], dc_level_temp[2][4][4];
  624|       |int   cbp_chroma_block[2][4][4], cbp_chroma_block_temp[2][4][4];
  625|       |int b8_ipredmode8x8[4][4], b8_intra_pred_modes8x8[16];
  626|       |
  627|       |#endif /* SPEC_CPU */
  628|       |
  629|       |//! Info for the "decoders-in-the-encoder" used for rdoptimization with packet losses
  630|       |typedef struct
  631|       |{
  632|       |  int  **resY;               //!< Residue of Luminance
  633|       |  imgpel ***decY;            //!< Decoded values at the simulated decoders
  634|       |  imgpel ****decref;         //!< Reference frames of the simulated decoders
  635|       |  imgpel ***decY_best;       //!< Decoded frames for the best mode for all decoders
  636|       |  imgpel **RefBlock;
  637|       |  byte **status_map;
  638|       |  byte **dec_mb_mode;
  639|       |} Decoders;
  640|       |extern Decoders *decs;
  641|       |
  642|       |//! SNRParameters
  643|       |typedef struct
  644|       |{
  645|       |  float snr_y;               //!< current Y SNR
  646|       |  float snr_u;               //!< current U SNR
  647|       |  float snr_v;               //!< current V SNR
  648|       |  float snr_y1;              //!< SNR Y(dB) first frame
  649|       |  float snr_u1;              //!< SNR U(dB) first frame
  650|       |  float snr_v1;              //!< SNR V(dB) first frame
  651|       |  float snr_yt[3];             //!< SNR Y(dB) based on frame type
  652|       |  float snr_ut[3];             //!< SNR U(dB) based on frame type
  653|       |  float snr_vt[3];             //!< SNR V(dB) based on frame type
  654|       |  float snr_ya;               //!< Average SNR Y(dB) remaining frames
  655|       |  float snr_ua;              //!< Average SNR U(dB) remaining frames
  656|       |  float snr_va;              //!< Average SNR V(dB) remaining frames
  657|       |} SNRParameters;
  658|       |
  659|      8|#define FILE_NAME_SIZE 200
  660|       |                             //! all input parameters
  661|       |typedef struct
  662|       |{
  663|       |  int ProfileIDC;               //!< profile idc
  664|       |  int LevelIDC;                 //!< level idc
  665|       |
  666|       |  int no_frames;                //!< number of frames to be encoded
  667|       |  int qp0;                      //!< QP of first frame
  668|       |  int qpN;                      //!< QP of remaining frames
  669|       |  int jumpd;                    //!< number of frames to skip in input sequence (e.g 2 takes frame 0,3,6,9...)
  670|       |  int hadamard;                 /*!< 0: 'normal' SAD in sub pixel search.  1: use 4x4 Hadamard transform and '
  671|       |                                     Sum of absolute transform difference' in sub pixel search                   */
  672|       |  int hadamardqpel;             //!< Use Hadamard transform only for quarter pel positions.
  673|       |  int search_range;             /*!< search range - integer pel search and 16x16 blocks.  The search window is
  674|       |                                     generally around the predicted vector. Max vector is 2xmcrange.  For 8x8
  675|       |                                     and 4x4 block sizes the search range is 1/2 of that for 16x16 blocks.       */
  676|       |  int num_ref_frames;           //!< number of reference frames to be used
  677|       |  int P_List0_refs;
  678|       |  int B_List0_refs;
  679|       |  int B_List1_refs;
  680|       |  int Log2MaxFrameNum;
  681|       |  int ResendPPS;
  682|       |  int GenerateMultiplePPS;
  683|       |
  684|       |  int img_width;                //!< image width  (must be a multiple of 16 pels)
  685|       |  int img_height;               //!< image height (must be a multiple of 16 pels)
  686|       |  int yuv_format;               //!< YUV format (0=4:0:0, 1=4:2:0, 2=4:2:2, 3=4:4:4)
  687|       |  int intra_upd;                /*!< For error robustness. 0: no special action. 1: One GOB/frame is intra coded
  688|       |                                     as regular 'update'. 2: One GOB every 2 frames is intra coded etc.
  689|       |                                     In connection with this intra update, restrictions is put on motion vectors
  690|       |                                     to prevent errors to propagate from the past                                */
  691|       |  int blc_size[8][2];           //!< array for different block sizes
  692|       |  int part_size[8][2];          //!< array for different partition sizes
  693|       |  int slice_mode;               //!< Indicate what algorithm to use for setting slices
  694|       |  int slice_argument;           //!< Argument to the specified slice algorithm
  695|       |  int UseConstrainedIntraPred;  //!< 0: Inter MB pixels are allowed for intra prediction 1: Not allowed
  696|       |  int  infile_header;           //!< If input file has a header set this to the length of the header
  697|       |  char infile[FILE_NAME_SIZE];             //!< YUV 4:2:0 input format
  698|       |  char outfile[FILE_NAME_SIZE];            //!< H.264 compressed output bitstream
  699|       |  char ReconFile[FILE_NAME_SIZE];          //!< Reconstructed Pictures
  700|       |  char TraceFile[FILE_NAME_SIZE];          //!< Trace Outputs
  701|       |  char QmatrixFile[FILE_NAME_SIZE];        //!< Q matrix cfg file
  702|       |  int intra_period;             //!< Random Access period though intra
  703|       |
  704|       |  int idr_enable;				//!< Encode intra slices as IDR
  705|       |  int start_frame;				//!< Encode sequence starting from Frame start_frame
  706|       |
  707|       |  // B pictures
  708|       |  int successive_Bframe;        //!< number of B frames that will be used
  709|       |  int qpB;                      //!< QP for non-reference B slice coded pictures
  710|       |  int qpBRSOffset;                     //!< QP for reference B slice coded pictures
  711|       |  int direct_spatial_mv_pred_flag;              //!< Direct Mode type to be used (0: Temporal, 1: Spatial)
  712|       |  int directInferenceFlag;      //!< Direct Inference Flag
  713|       |#if BI_PREDICTION
  714|       |  int BiPredMotionEstimation;
  715|       |  int BiPredMERefinements;
  716|       |  int BiPredMESearchRange;
  717|       |  int BiPredMESubPel;
  718|       |#endif
  719|       |
  720|       |  // SP Pictures
  721|       |  int sp_periodicity;           //!< The periodicity of SP-pictures
  722|       |  int qpsp;                     //!< SP Picture QP for prediction error
  723|       |  int qpsp_pred;                //!< SP Picture QP for predicted block
  724|       |
  725|       |  int WeightedPrediction;        //!< Weighted prediciton for P frames (0: not used, 1: explicit)
  726|       |  int WeightedBiprediction;      //!< Weighted prediciton for B frames (0: not used, 1: explicit, 2: implicit)
  727|       |  int UseWeightedReferenceME;    //!< Use Weighted Reference for ME.
  728|       |  int RDPictureDecision;         //!< Perform RD optimal decision between various coded versions of same picture
  729|       |  int RDPictureIntra;            //!< Enabled RD pic decision for intra as well.
  730|       |  int RDPSliceWeightOnly;        //!< If enabled, does not check QP variations for P slices.
  731|       |  int RDBSliceWeightOnly;        //!< If enabled, does not check QP variations for B slices.
  732|       |  int SkipIntraInInterSlices;    //!< Skip intra type checking in inter slices if best_mode is skip/direct
  733|       |  int BRefPictures;              //!< B coded reference pictures replace P pictures (0: not used, 1: used)
  734|       |  int PyramidCoding;
  735|       |  char ExplicitPyramidFormat[1024];  //!< Explicit GOP format (PyramidCoding==3). 
  736|       |  int PyramidRefReorder;       //!< Reordering based on Poc distances for PyramidCoding
  737|       |  int PocMemoryManagement;       //!< Memory management based on Poc distances for PyramidCoding
  738|       |
  739|       |  int symbol_mode;              //!< Specifies the mode the symbols are mapped on bits
  740|       |  int of_mode;                  //!< Specifies the mode of the output file
  741|       |  int partition_mode;           //!< Specifies the mode of data partitioning
  742|       |
  743|       |  int InterSearch16x16;
  744|       |  int InterSearch16x8;
  745|       |  int InterSearch8x16;
  746|       |  int InterSearch8x8;
  747|       |  int InterSearch8x4;
  748|       |  int InterSearch4x8;
  749|       |  int InterSearch4x4;
  750|       |
  751|       |  int IntraDisableInterOnly;
  752|       |  int Intra4x4ParDisable;
  753|       |  int Intra4x4DiagDisable;
  754|       |  int Intra4x4DirDisable;
  755|       |  int Intra16x16ParDisable;
  756|       |  int Intra16x16PlaneDisable;
  757|       |  int ChromaIntraDisable;
  758|       |
  759|       |  double FrameRate;
  760|       |
  761|       |  int chroma_qp_index_offset;
  762|       |#ifdef _FULL_SEARCH_RANGE_
  763|       |  int full_search;
  764|       |#endif
  765|       |#ifdef _ADAPT_LAST_GROUP_
  766|       |  int last_frame;
  767|       |#endif
  768|       |#ifdef _CHANGE_QP_
  769|       |  int qpN2, qpB2, qp2start;
  770|       |  int qp02, qpBRS2Offset;
  771|       |#endif
  772|       |  int rdopt;
  773|       |  int disthres;
  774|       |  int nobskip;
  775|       |
  776|       |#ifdef _LEAKYBUCKET_
  777|       |  int NumberLeakyBuckets;
  778|       |  char LeakyBucketRateFile[FILE_NAME_SIZE];
  779|       |  char LeakyBucketParamFile[FILE_NAME_SIZE];
  780|       |#endif
  781|       |
  782|       |  int PicInterlace;           //!< picture adaptive frame/field
  783|       |  int MbInterlace;            //!< macroblock adaptive frame/field
  784|       |
  785|       |  int IntraBottom;            //!< Force Intra Bottom at GOP periods.
  786|       |
  787|       |  int LossRateA;              //!< assumed loss probablility of partition A (or full slice), in per cent, used for loss-aware R/D optimization
  788|       |  int LossRateB;              //!< assumed loss probablility of partition B, in per cent, used for loss-aware R/D 
  789|       |  int LossRateC;              //!< assumed loss probablility of partition C, in per cent, used for loss-aware R/D 
  790|       |  int NoOfDecoders;
  791|       |  int RestrictRef;
  792|       |  int NumFramesInELSubSeq;
  793|       |  int NumFrameIn2ndIGOP;
  794|       |
  795|       |  int RandomIntraMBRefresh;     //!< Number of pseudo-random intra-MBs per picture
  796|       |
  797|       |  int LFSendParameters;
  798|       |  int LFDisableIdc;
  799|       |  int LFAlphaC0Offset;
  800|       |  int LFBetaOffset;
  801|       |
  802|       |  int SparePictureOption;
  803|       |  int SPDetectionThreshold;
  804|       |  int SPPercentageThreshold;
  805|       |
  806|       |  // FMO
  807|       |  char SliceGroupConfigFileName[FILE_NAME_SIZE];    //!< Filename for config info fot type 0, 2, 6	
  808|       |  int num_slice_groups_minus1;           //!< "FmoNumSliceGroups" in encoder.cfg, same as FmoNumSliceGroups, which should be erased later
  809|       |  int slice_group_map_type; 
  810|       |
  811|       |  int *top_left;                         //!< top_left and bottom_right store values indicating foregrounds
  812|       |  int *bottom_right; 
  813|       |  byte *slice_group_id;                   //!< slice_group_id is for slice group type being 6  
  814|       |  int *run_length_minus1;                //!< run_length_minus1 is for slice group type being 0
  815|       |
  816|       |  int slice_group_change_direction_flag;
  817|       |  int slice_group_change_rate_minus1;
  818|       |  int slice_group_change_cycle;
  819|       |
  820|       |  int redundant_slice_flag; //! whether redundant slices exist,  JVT-D101
  821|       |  int pic_order_cnt_type;   // POC200301
  822|       |
  823|       |  int context_init_method;
  824|       |  int model_number;
  825|       |  int AllowTransform8x8;
  826|       |  int LowPassForIntra8x8;
  827|       |  int ReportFrameStats;
  828|       |  int DisplayEncParams;
  829|       |
  830|       |  //! Rate Control on JVT standard 
  831|       |  int RCEnable;    
  832|       |  int bit_rate;
  833|       |  int SeinitialQP;
  834|       |  int basicunit;
  835|       |  int channel_type;
  836|       |
  837|       |  int ScalingMatrixPresentFlag;
  838|       |  int ScalingListPresentFlag[8];
  839|       |
  840|       |  // FastME enable
  841|       |  int FMEnable;
  842|       |
  843|       |  // Fidelity Range Extensions
  844|       |  int BitDepthLuma;
  845|       |  int BitDepthChroma;
  846|       |  int img_height_cr;
  847|       |  int img_width_cr;
  848|       |  int rgb_input_flag;
  849|       |  int cb_qp_index_offset;
  850|       |  int cr_qp_index_offset;
  851|       |
  852|       |  // Lossless Coding
  853|       |  int lossless_qpprime_y_zero_flag;
  854|       |
  855|       |  //Residue Color Transform
  856|       |  int residue_transform_flag;
  857|       |
  858|       |  // Lambda Params
  859|       |  int UseExplicitLambdaParams;
  860|       |  double LambdaWeight[6];
  861|       |
  862|       |  char QOffsetMatrixFile[FILE_NAME_SIZE];        //!< Quantization Offset matrix cfg file
  863|       |  int  OffsetMatrixPresentFlag;                  //!< Enable Explicit Quantization Offset Matrices
  864|       |
  865|       |} InputParameters;
  866|       |
  867|       |//! ImageParameters
  868|       |typedef struct
  869|       |{
  870|       |  int number;                  //!< current image number to be encoded
  871|       |  int pn;                      //!< picture number
  872|       |  int nb_references;
  873|       |  int current_mb_nr;
  874|       |  int total_number_mb;
  875|       |  int current_slice_nr;
  876|       |  int type;
  877|       |  int structure;               //!< picture structure
  878|       |  int num_ref_frames;          //!< number of reference frames to be used
  879|       |  int max_num_references;      //!< maximum number of reference pictures that may occur
  880|       |  int qp;                      //!< quant for the current frame
  881|       |  int qpsp;                    //!< quant for the prediction frame of SP-frame
  882|       |  float framerate;
  883|       |  int width;                   //!< Number of pels
  884|       |  int width_cr;                //!< Number of pels chroma
  885|       |  int height;                  //!< Number of lines
  886|       |  int height_cr;               //!< Number of lines  chroma
  887|       |  int height_cr_frame;         //!< Number of lines  chroma frame
  888|       |  int subblock_x;              //!< current subblock horizontal
  889|       |  int subblock_y;              //!< current subblock vertical
  890|       |  int is_intra_block;
  891|       |  int is_v_block;
  892|       |  int mb_y_upd;
  893|       |  int mb_y_intra;              //!< which GOB to intra code
  894|       |  int block_c_x;               //!< current block chroma vertical
  895|       |  int **ipredmode;             //!< intra prediction mode
  896|       |  int **ipredmode8x8;          //!< help storage for 8x8 modes, inserted by YV
  897|       |
  898|       |  int cod_counter;             //!< Current count of number of skipped macroblocks in a row
  899|       |  int ***nz_coeff;             //!< number of coefficients per block (CAVLC)
  900|       |
  901|       |  int mb_x;                    //!< current MB horizontal
  902|       |  int mb_y;                    //!< current MB vertical
  903|       |  int block_x;                 //!< current block horizontal
  904|       |  int block_y;                 //!< current block vertical
  905|       |  int pix_x;                   //!< current pixel horizontal
  906|       |  int pix_y;                   //!< current pixel vertical
  907|       |  int pix_c_x;                 //!< current pixel chroma horizontal
  908|       |  int pix_c_y;                 //!< current pixel chroma vertical
  909|       |
  910|       |  int opix_x;                   //!< current original picture pixel horizontal
  911|       |  int opix_y;                   //!< current original picture pixel vertical
  912|       |  int opix_c_x;                 //!< current original picture pixel chroma horizontal
  913|       |  int opix_c_y;                 //!< current original picture pixel chroma vertical
  914|       |
  915|       |
  916|       |  // some temporal buffers
  917|       |  imgpel mprr[9][16][16];      //!< all 9 prediction modes? // enlarged from 4 to 16 for ABT (is that neccessary?)
  918|       |
  919|       |  imgpel mprr_2[5][16][16];    //!< all 4 new intra prediction modes
  920|       |  imgpel mprr_3[9][8][8];      //!< all 9 prediction modes for 8x8 transformation
  921|       |  imgpel mprr_c[2][4][16][16]; //!< chroma intra prediction modes
  922|       |  imgpel mpr[16][16];          //!< current best prediction mode
  923|       |  int m7[16][16];              //!< the diff pixel values between orginal image and prediction
  924|       |
  925|       |  int ****cofAC;               //!< AC coefficients [8x8block][4x4block][level/run][scan_pos]
  926|       |  int ***cofDC;                //!< DC coefficients [yuv][level/run][scan_pos]
  927|       |
  928|       |  Picture     *currentPicture; //!< The coded picture currently in the works (typically frame_pic, top_pic, or bottom_pic)
  929|       |  Slice       *currentSlice;                                //!< pointer to current Slice data struct
  930|       |  Macroblock    *mb_data;                                   //!< array containing all MBs of a whole frame
  931|       |  SyntaxElement   MB_SyntaxElements[MAX_SYMBOLS_PER_MB];    //!< temporal storage for all chosen syntax elements of one MB
  932|       |
  933|       |  int *quad;               //!< Array containing square values,used for snr computation  */                                         /* Values are limited to 5000 for pixel differences over 70 (sqr(5000)).
  934|       |  int *intra_block;
  935|       |
  936|       |  int tr;
  937|       |  int fld_type;                        //!< top or bottom field
  938|       |  unsigned int fld_flag;                                
  939|       |  unsigned int rd_pass;
  940|       |  int direct_intraP_ref[4][4];
  941|       |  int pstruct_next_P;
  942|       |  int imgtr_next_P_frm;
  943|       |  int imgtr_last_P_frm;
  944|       |  int imgtr_next_P_fld;
  945|       |  int imgtr_last_P_fld;
  946|       |
  947|       |  // B pictures
  948|       |  double b_interval;
  949|       |  int p_interval;
  950|       |  int b_frame_to_code;
  951|       |  int fw_mb_mode;
  952|       |  int bw_mb_mode;
  953|       |
  954|       |  short****** pred_mv;                 //!< motion vector predictors for all block types and all reference frames
  955|       |  short****** all_mv;                  //!< replaces local all_mv
  956|       |#if BI_PREDICTION
  957|       |  short****** bipred_mv1;              //!< Biprediction MVs
  958|       |  short****** bipred_mv2;              //!< Biprediction MVs
  959|       |  short bi_pred_me[MAXMODE];
  960|       |#endif
  961|       |
  962|       |
  963|       |  int LFDisableIdc;
  964|       |  int LFAlphaC0Offset;
  965|       |  int LFBetaOffset;
  966|       |
  967|       |  int direct_spatial_mv_pred_flag;              //!< Direct Mode type to be used (0: Temporal, 1: Spatial)
  968|       |
  969|       |  int num_ref_idx_l0_active;
  970|       |  int num_ref_idx_l1_active;
  971|       |
  972|       |  int field_mode;     //!< For MB level field/frame -- field mode on flag
  973|       |  int top_field;      //!< For MB level field/frame -- top field flag
  974|       |  int mvscale[6][MAX_REFERENCE_PICTURES];
  975|       |  int buf_cycle;
  976|       |  int i16offset;
  977|       |
  978|       |  int layer;             //!< which layer this picture belonged to
  979|       |  int old_layer;         //!< old layer number
  980|       |  int NoResidueDirect;
  981|       |
  982|       |  int redundant_pic_cnt; // JVT-D101
  983|       |
  984|       |  int MbaffFrameFlag;    //!< indicates frame with mb aff coding
  985|       |
  986|       |  //the following should probably go in sequence parameters
  987|       |  // unsigned int log2_max_frame_num_minus4;
  988|       |  unsigned int pic_order_cnt_type;
  989|       |  // for poc mode 0, POC200301
  990|       |  // unsigned int log2_max_pic_order_cnt_lsb_minus4;  
  991|       |  // for poc mode 1, POC200301
  992|       |  unsigned int delta_pic_order_always_zero_flag;
  993|       |           int offset_for_non_ref_pic;
  994|       |           int offset_for_top_to_bottom_field;
  995|       |  unsigned int num_ref_frames_in_pic_order_cnt_cycle;
  996|       |           int offset_for_ref_frame[1];  // MAX_LENGTH_POC_CYCLE in decoder
  997|       |
  998|       |  // POC200301
  999|       |  //the following is for slice header syntax elements of poc
 1000|       |  // for poc mode 0.
 1001|       |  unsigned int pic_order_cnt_lsb;
 1002|       |           int delta_pic_order_cnt_bottom;
 1003|       |  // for poc mode 1.
 1004|       |           int delta_pic_order_cnt[2];
 1005|       |
 1006|       |
 1007|       |  // POC200301
 1008|       |  unsigned int field_picture;
 1009|       |    signed int toppoc;      //!< poc for this frame or field
 1010|       |    signed int bottompoc;   //!< for completeness - poc of bottom field of a frame (always = poc+1)
 1011|       |    signed int framepoc;    //!< min (toppoc, bottompoc)
 1012|       |    signed int ThisPOC;     //!< current picture POC
 1013|       |  unsigned int frame_num;   //!< frame_num for this frame
 1014|       |  
 1015|       |  unsigned PicWidthInMbs;
 1016|       |  unsigned PicHeightInMapUnits;
 1017|       |  unsigned FrameHeightInMbs;
 1018|       |  unsigned PicHeightInMbs;
 1019|       |  unsigned PicSizeInMbs;
 1020|       |  unsigned FrameSizeInMbs;
 1021|       |
 1022|       |  //the following should probably go in picture parameters
 1023|       |  unsigned int pic_order_present_flag; // ????????
 1024|       |
 1025|       |  //the following are sent in the slice header
 1026|       |//  int delta_pic_order_cnt[2];
 1027|       |  int nal_reference_idc;
 1028|       |
 1029|       |  int adaptive_ref_pic_buffering_flag;
 1030|       |  int no_output_of_prior_pics_flag;
 1031|       |  int long_term_reference_flag;
 1032|       |
 1033|       |  DecRefPicMarking_t *dec_ref_pic_marking_buffer;
 1034|       |
 1035|       |  int model_number;
 1036|       |
 1037|       |
 1038|       |  /*rate control*/
 1039|       |  int NumberofHeaderBits; 
 1040|       |  int NumberofTextureBits;
 1041|       |  int NumberofBasicUnitHeaderBits;
 1042|       |  int NumberofBasicUnitTextureBits;
 1043|       |  double TotalMADBasicUnit;
 1044|       |  int NumberofMBTextureBits;
 1045|       |  int NumberofMBHeaderBits;
 1046|       |  int NumberofCodedBFrame; 
 1047|       |  int NumberofCodedPFrame;
 1048|       |  int NumberofGOP;
 1049|       |  int TotalQpforPPicture;
 1050|       |  int NumberofPPicture;
 1051|       |  double *MADofMB;
 1052|       |  int BasicUnitQP;
 1053|       |  int TopFieldFlag;
 1054|       |  int FieldControl;
 1055|       |  int FieldFrame;
 1056|       |  int Frame_Total_Number_MB;
 1057|       |  int IFLAG;
 1058|       |  int NumberofCodedMacroBlocks;
 1059|       |  int BasicUnit;
 1060|       |  int write_macroblock;
 1061|       |  int bot_MB;
 1062|       |  int write_macroblock_frame;
 1063|       |
 1064|       |  int DeblockCall;
 1065|       |        
 1066|       |  int last_pic_bottom_field;
 1067|       |  int last_has_mmco_5;
 1068|       |  int pre_frame_num;
 1069|       |
 1070|       |  int slice_group_change_cycle;
 1071|       |
 1072|       |  int pic_unit_size_on_disk;
 1073|       |  int bitdepth_luma;
 1074|       |  int bitdepth_chroma;
 1075|       |  int bitdepth_luma_qp_scale;
 1076|       |  int bitdepth_chroma_qp_scale;
 1077|       |  int bitdepth_lambda_scale;
 1078|       |  unsigned int dc_pred_value;   //!< value for DC prediction (depends on pel bit depth)
 1079|       |  int max_imgpel_value;         //!< max value that one picture element (pixel) can take (depends on pic_unit_bitdepth)
 1080|       |  int max_imgpel_value_uv;
 1081|       |
 1082|       |  int num_blk8x8_uv;
 1083|       |  int num_cdc_coeff;
 1084|       |  int yuv_format;
 1085|       |  int lossless_qpprime_flag;
 1086|       |  int mb_cr_size_x;
 1087|       |  int mb_cr_size_y;
 1088|       |
 1089|       |  int chroma_qp_offset[2];      //!< offset for qp for chroma [0-Cb, 1-Cr] 
 1090|       |
 1091|       |  // Residue Color Transform
 1092|       |  int residue_transform_flag;
 1093|       |
 1094|       |  int auto_crop_right;
 1095|       |  int auto_crop_bottom;
 1096|       |
 1097|       |} ImageParameters;
 1098|       |
 1099|     12|#define NUM_PIC_TYPE 5
 1100|       |                                //!< statistics
 1101|       |typedef struct
 1102|       |{
 1103|       |  int   quant0;                 //!< quant for the first frame
 1104|       |  int   quant1;                 //!< average quant for the remaining frames
 1105|       |  float bitr;                   //!< bit rate for current frame, used only for output til terminal
 1106|       |  float bitrate;                //!< average bit rate for the sequence except first frame
 1107|       |  int   bit_ctr;                //!< counter for bit usage
 1108|       |  int   bit_ctr_n;              //!< bit usage for the current frame
 1109|       |  int   bit_slice;              //!< number of bits in current slice
 1110|       |  int   bit_ctr_emulationprevention; //!< stored bits needed to prevent start code emulation
 1111|       |  int   b8_mode_0_use[NUM_PIC_TYPE][2];
 1112|       |  int   mode_use_transform_8x8[NUM_PIC_TYPE][MAXMODE];
 1113|       |  int   mode_use_transform_4x4[NUM_PIC_TYPE][MAXMODE];
 1114|       |  int   intra_chroma_mode[4];
 1115|       |  
 1116|       |  // B pictures
 1117|       |  int   *mode_use_Bframe;
 1118|       |  int   *bit_use_mode_Bframe;
 1119|       |  int   bit_ctr_I;
 1120|       |  int   bit_ctr_P;
 1121|       |  int   bit_ctr_B;
 1122|       |  float bitrate_I;
 1123|       |  float bitrate_P;
 1124|       |  float bitrate_B;
 1125|       |
 1126|       |  int   mode_use            [NUM_PIC_TYPE][MAXMODE]; //!< Macroblock mode usage for Intra frames
 1127|       |  int   bit_use_mode        [NUM_PIC_TYPE][MAXMODE]; //!< statistics of bit usage
 1128|       |  int   bit_use_stuffingBits[NUM_PIC_TYPE];
 1129|       |  int   bit_use_mb_type     [NUM_PIC_TYPE];
 1130|       |  int   bit_use_header      [NUM_PIC_TYPE];
 1131|       |  int   tmp_bit_use_cbp     [NUM_PIC_TYPE];
 1132|       |  int   bit_use_coeffY      [NUM_PIC_TYPE];
 1133|       |  int   bit_use_coeffC      [NUM_PIC_TYPE];
 1134|       |  int   bit_use_delta_quant [NUM_PIC_TYPE];
 1135|       |
 1136|       |  int   em_prev_bits_frm;
 1137|       |  int   em_prev_bits_fld;
 1138|       |  int  *em_prev_bits;
 1139|       |  int   bit_ctr_parametersets;
 1140|       |  int   bit_ctr_parametersets_n;
 1141|       |} StatParameters;
 1142|       |
 1143|       |//!< For MB level field/frame coding tools
 1144|       |//!< temporary structure to store MB data for field/frame coding
 1145|       |typedef struct
 1146|       |{
 1147|       |  double min_rdcost;
 1148|       |
 1149|       |  int    rec_mbY[16][16];       // hold the Y component of reconstructed MB
 1150|       |  int    rec_mbU[16][16], rec_mbV[16][16]; 
 1151|       |  int    ****cofAC;
 1152|       |  int    ***cofDC;
 1153|       |  int    mb_type;
 1154|       |#if BI_PREDICTION
 1155|       |  int    bi_pred_me;
 1156|       |#endif  
 1157|       |  int    b8mode[4], b8pdir[4];
 1158|       |  int    **ipredmode;
 1159|       |  int    intra_pred_modes[16];
 1160|       |  int    cbp;
 1161|       |  int64  cbp_blk;
 1162|       |  int    mode;
 1163|       |  short  ******pred_mv;        //!< predicted motion vectors
 1164|       |  short  ******all_mv;         //!< all modes motion vectors
 1165|       |  short  ******bipred_mv1;     //!< all modes motion vectors
 1166|       |  short  ******bipred_mv2;     //!< all modes motion vectors
 1167|       |  short  refar[2][4][4];       //!< reference frame array [list][x][y]
 1168|       |  int    i16offset;
 1169|       |  int    c_ipred_mode;
 1170|       |
 1171|       |  int    luma_transform_size_8x8_flag;
 1172|       |  int    NoMbPartLessThan8x8Flag;
 1173|       |  
 1174|       |  int    qp;
 1175|       |  int    prev_qp;
 1176|       |  int    prev_delta_qp;
 1177|       |} RD_DATA;
 1178|       |
 1179|       |
 1180|       |//!< Set Explicit GOP Parameters.
 1181|       |//!< Currently only supports Enhancement GOP but could be easily extended
 1182|       |typedef struct
 1183|       |{
 1184|       |  int slice_type;       //! Slice type
 1185|       |  int display_no;       //! GOP Display order
 1186|       |  int reference_idc;    //! Is reference?
 1187|       |  int slice_qp;         //! Assigned QP
 1188|       |  int pyramid_layer;    //! Pyramid layer (used with GOP Pyramid option 2
 1189|       |  int pyramidPocDelta;  //! Currently unused
 1190|       |} GOP_DATA;
 1191|       |
 1192|       |
 1193|       |#if defined(SPEC_CPU)
 1194|       |extern int QP,QP2; // added by SPEC because QP is defined in ratectl.c and image.c
 1195|       |
 1196|       |extern GOP_DATA *gop_structure;
 1197|       |extern RD_DATA *rdopt; 
 1198|       |extern RD_DATA rddata_top_frame_mb, rddata_bot_frame_mb; //!< For MB level field/frame coding tools
 1199|       |extern RD_DATA rddata_top_field_mb, rddata_bot_field_mb; //!< For MB level field/frame coding tools
 1200|       |#else
 1201|       |GOP_DATA *gop_structure;
 1202|       |RD_DATA *rdopt; 
 1203|       |RD_DATA rddata_top_frame_mb, rddata_bot_frame_mb; //!< For MB level field/frame coding tools
 1204|       |RD_DATA rddata_top_field_mb, rddata_bot_field_mb; //!< For MB level field/frame coding tools
 1205|       |#endif /* SPEC_CPU */
 1206|       |
 1207|       |extern InputParameters *input;
 1208|       |extern ImageParameters *img;
 1209|       |extern StatParameters  *stats;
 1210|       |
 1211|       |extern SNRParameters *snr;
 1212|       |
 1213|       |#if defined(SPEC_CPU)
 1214|       |// files
 1215|       |extern FILE *p_stat;                    //!< status file for the last encoding session
 1216|       |extern FILE *p_log;                     //!< SNR file
 1217|       |extern FILE *p_trace;                   //!< Trace file
 1218|       |extern int  p_in;                       //!< original YUV file handle
 1219|       |extern int  p_dec;                      //!< decoded image file handle
 1220|       |
 1221|       |
 1222|       |extern int glob_remapping_of_pic_nums_idc_l0[20];
 1223|       |extern int glob_abs_diff_pic_num_minus1_l0[20];
 1224|       |extern int glob_long_term_pic_idx_l0[20];
 1225|       |extern int glob_remapping_of_pic_nums_idc_l1[20];
 1226|       |extern int glob_abs_diff_pic_num_minus1_l1[20];
 1227|       |extern int glob_long_term_pic_idx_l1[20]; 
 1228|       |#else
 1229|       |// files
 1230|       |FILE *p_stat;                    //!< status file for the last encoding session
 1231|       |FILE *p_log;                     //!< SNR file
 1232|       |FILE *p_trace;                   //!< Trace file
 1233|       |int  p_in;                       //!< original YUV file handle
 1234|       |int  p_dec;                      //!< decoded image file handle
 1235|       |
 1236|       |
 1237|       |int glob_remapping_of_pic_nums_idc_l0[20];
 1238|       |int glob_abs_diff_pic_num_minus1_l0[20];
 1239|       |int glob_long_term_pic_idx_l0[20];
 1240|       |int glob_remapping_of_pic_nums_idc_l1[20];
 1241|       |int glob_abs_diff_pic_num_minus1_l1[20];
 1242|       |int glob_long_term_pic_idx_l1[20]; 
 1243|       |#endif /* SPEC_CPU */
 1244|       |
 1245|       |
 1246|       |/***********************************************************************
 1247|       | * P r o t o t y p e s   f o r    T M L
 1248|       | ***********************************************************************
 1249|       | */
 1250|       |
 1251|       |void intrapred_luma(int CurrPixX,int CurrPixY, int *left_available, int *up_available, int *all_available);
 1252|       |void init();
 1253|       |int  find_sad(int hadamard, int m7[16][16]);
 1254|       |int  dct_luma(int pos_mb1,int pos_mb2,int *cnt_nonz, int intra);
 1255|       |int  dct_luma_sp(int pos_mb1,int pos_mb2,int *cnt_nonz);
 1256|       |void copyblock_sp(int pos_mb1,int pos_mb2);
 1257|       |int  dct_chroma(int uv,int i11);
 1258|       |int  dct_chroma_sp(int uv,int i11);
 1259|       |// Residue Color Transform
 1260|       |int  dct_chroma4x4(int uv, int b8, int b4);
 1261|       |int  dct_chroma_DC(int uv, int cr_cbp);
 1262|       |
 1263|       |int  motion_search(int isi);
 1264|       |int  sign(int a,int b);
 1265|       |void intrapred_chroma(int,int,int uv);
 1266|       |void intrapred_luma_16x16();
 1267|       |int  find_sad_16x16(int *intra_mode);
 1268|       |
 1269|       |int dct_luma_16x16(int);
 1270|       |
 1271|       |void init_poc();
 1272|       |
 1273|       |void init_img();
 1274|       |void report();
 1275|       |void information_init();
 1276|       |int  get_picture_type();
 1277|       |int clip1a(int a);
 1278|       |void DeblockFrame(ImageParameters *img, imgpel **, imgpel ***) ;
 1279|       |void MarkAllMacroblockModes(ImageParameters *img, imgpel **, imgpel ***);
 1280|       |
 1281|       |int  TransformDecision(int, int*);
 1282|       |int  SATD8X8(int*, int);
 1283|       |
 1284|       |void LumaPrediction4x4 (int, int, int, int, int, short, short);
 1285|       |int  SATD (int*, int);
 1286|       |
 1287|       |pel_t* FastLineX (int, pel_t*, int, int, int, int);
 1288|       |pel_t* UMVLineX  (int, pel_t*, int, int, int, int);
 1289|       |
 1290|       |void LumaResidualCoding ();
 1291|       |void ChromaResidualCoding (int*);
 1292|       |void IntraChromaPrediction (int*, int*, int*);
 1293|       |void ChromaPrediction4x4 (int, int, int, int, int, int, short, short);
 1294|       |int  writeMBLayer   (int rdopt);
 1295|       |
 1296|       |extern int*   refbits;
 1297|       |extern int**** motion_cost;
 1298|       |
 1299|       |void  Get_Direct_Motion_Vectors ();
 1300|       |void  PartitionMotionSearch     (int, int, double);
 1301|       |int   BIDPartitionCost          (int, int, short, short, int);
 1302|       |int   LumaResidualCoding8x8     (int*, int64*, int, short, int, int, short, short);
 1303|       |int   writeLumaCoeff8x8         (int, int, int);
 1304|       |int   writeMotionVector8x8      (int  i0, int  j0, int  i1, int  j1, int  refframe, int  list_idx, int  mv_mode);
 1305|       |int   writeReferenceFrame       (int, int, int, int, int);
 1306|       |int   writeAbpCoeffIndex        (int, int, int, int);
 1307|       |int   writeIntra4x4Modes        (int);
 1308|       |int   writeChromaIntraPredMode  ();
 1309|       |
 1310|       |void estimate_weighting_factor_B_slice();
 1311|       |void estimate_weighting_factor_P_slice(int offset);
 1312|       |int  test_wp_P_slice(int offset);
 1313|       |int  test_wp_B_slice(int method);
 1314|       |void poc_based_ref_management(int current_pic_num);
 1315|       |int  picture_coding_decision (Picture *picture1, Picture *picture2, int qp);
 1316|       |
 1317|       |unsigned CeilLog2( unsigned uiVal);
 1318|       |
 1319|       |int  Get_Direct_Cost8x8 (int, int*);
 1320|       |
 1321|       |#if BI_PREDICTION
 1322|       |int   BPredPartitionCost  (int, int, short, short, int, int);
 1323|       |void  LumaPrediction4x4Bi (int, int,   int,   int, int, short, short, int);
 1324|       |int   SATDBI (int* , int );
 1325|       |#endif
 1326|       |
 1327|       |int  Get_Direct_CostMB  (double);
 1328|       |int  B8Mode2Value (int b8mode, int b8pdir);
 1329|       |
 1330|       |int  GetSkipCostMB (double lambda);
 1331|       |void FindSkipModeMotionVector ();
 1332|       |
 1333|       |
 1334|       |// dynamic mem allocation
 1335|       |int  init_global_buffers();
 1336|       |void free_global_buffers();
 1337|       |void no_mem_exit  (char *where);
 1338|       |
 1339|       |int  get_mem_mv  (short*******);
 1340|       |void free_mem_mv (short******);
 1341|       |void free_img    ();
 1342|       |
 1343|       |int  get_mem_ACcoeff  (int*****);
 1344|       |int  get_mem_DCcoeff  (int****);
 1345|       |void free_mem_ACcoeff (int****);
 1346|       |void free_mem_DCcoeff (int***);
 1347|       |
 1348|       |int  decide_fld_frame(float snr_frame_Y, float snr_field_Y, int bit_field, int bit_frame, double lambda_picture);
 1349|       |void combine_field();
 1350|       |
 1351|       |Picture *malloc_picture();
 1352|       |void     free_picture (Picture *pic);
 1353|       |
 1354|       |int   encode_one_slice(int SLiceGroupId, Picture *pic);   //! returns the number of MBs in the slice
 1355|       |
 1356|       |void  start_macroblock(int mb_addr, int mb_field);
 1357|       |void  set_MB_parameters (int mb_addr);           //! sets up img-> according to input-> and currSlice->
 1358|       |
 1359|       |int   writeMotionInfo2NAL ();
 1360|       |
 1361|       |void  terminate_macroblock(Boolean *end_of_slice, Boolean *recode_macroblock);
 1362|       |int   slice_too_big(int rlc_bits);
 1363|       |void  write_one_macroblock(int eos_bit);
 1364|       |void  proceed2nextMacroblock();
 1365|       |
 1366|       |void free_slice_list(Picture *currPic);
 1367|       |
 1368|       |void report_stats_on_error();
 1369|       |
 1370|       |#if TRACE
 1371|       |void  trace2out(SyntaxElement *se);
 1372|       |#endif
 1373|       |
 1374|       |
 1375|       |void error(char *text, int code);
 1376|       |int  start_sequence();
 1377|       |int  terminate_sequence();
 1378|       |int  start_slice();
 1379|       |int  terminate_slice();
 1380|       |int  write_PPS(int, int);
 1381|       |
 1382|       |// B pictures
 1383|       |int  get_fwMV(int *min_fw_sad, int tot_intra_sad);
 1384|       |void get_bwMV(int *min_bw_sad);
 1385|       |void get_bid(int *bid_sad, int fw_predframe_no);
 1386|       |void get_dir(int *dir_sad);
 1387|       |void compare_sad(int tot_intra_sad, int fw_sad, int bw_sad, int bid_sad, int dir_sad, int);
 1388|       |int  BlkSize2CodeNumber(int blc_size_h, int blc_size_v);
 1389|       |
 1390|       |void InitMotionVectorSearchModule();
 1391|       |
 1392|       |int  field_flag_inference();
 1393|       |
 1394|       |void set_mbaff_parameters();  // For MB AFF
 1395|       |void writeVlcByteAlign(Bitstream* currStream);
 1396|       |
 1397|       |
 1398|       |int   writeLumaCoeff4x4_CABAC     (int, int, int);
 1399|       |int   writeLumaCoeff8x8_CABAC     (int, int);
 1400|       |int   writeCBPandLumaCoeff        ();
 1401|       |int   writeChromaCoeff            ();
 1402|       |int   writeMB_bits_for_4x4_luma   (int, int, int);
 1403|       |int   writeMB_bits_for_16x16_luma ();
 1404|       |int   writeMB_bits_for_luma       (int);
 1405|       |int   writeMB_bits_for_DC_chroma  (int);
 1406|       |int   writeMB_bits_for_AC_chroma  (int);
 1407|       |int   writeMB_bits_for_CBP        ();
 1408|       |
 1409|       |int   SingleUnifiedMotionSearch   (int, int, int**, int***, int*****, int, int*****, double);
 1410|       |
 1411|       |//============= rate-distortion optimization ===================
 1412|       |void  clear_rdopt      ();
 1413|       |void  init_rdopt       ();
 1414|       |void  RD_Mode_Decision ();
 1415|       |//============= rate-distortion opt with packet losses ===========
 1416|       |void decode_one_macroblock();
 1417|       |void decode_one_mb (int, Macroblock*);
 1418|       |void decode_one_b8block (int, int, int, int, int);
 1419|       |void Get_Reference_Block(imgpel **imY, int block_y, int block_x, int mvhor, int mvver, imgpel **out);
 1420|       |byte Get_Reference_Pixel(imgpel **imY, int y, int x);
 1421|       |int  Half_Upsample(imgpel **imY, int j, int i);
 1422|       |void DecOneForthPix(imgpel **dY, imgpel ***dref);
 1423|       |void compute_residue(int mode);
 1424|       |void compute_residue_b8block (int, int);
 1425|       |void compute_residue_mb (int);
 1426|       |void UpdateDecoders();
 1427|       |void Build_Status_Map(byte **s_map);
 1428|       |void Error_Concealment(imgpel **inY, byte **s_map, imgpel ***refY);
 1429|       |void Conceal_Error(imgpel **inY, int mb_y, int mb_x, imgpel ***refY, byte **s_map);
 1430|       |//============= restriction of reference frames based on the latest intra-refreshes==========
 1431|       |void UpdatePixelMap();
 1432|       |
 1433|       |//============= fast full integer search =======================
 1434|       |#ifdef _FAST_FULL_ME_
 1435|       |void  ClearFastFullIntegerSearch    ();
 1436|       |void  ResetFastFullIntegerSearch    ();
 1437|       |#endif
 1438|       |
 1439|       |void process_2nd_IGOP();
 1440|       |void SetImgType();
 1441|       |
 1442|       |// Tian Dong: for IGOPs
 1443|       |extern Boolean In2ndIGOP;
 1444|       |extern int start_frame_no_in_this_IGOP;
 1445|       |extern int start_tr_in_this_IGOP;
 1446|       |extern int FirstFrameIn2ndIGOP;
 1447|  1.54k|#define IMG_NUMBER (img->number-start_frame_no_in_this_IGOP)
 1448|       |
 1449|       |void AllocNalPayloadBuffer();
 1450|       |void FreeNalPayloadBuffer();
 1451|       |void SODBtoRBSP(Bitstream *currStream);
 1452|       |int RBSPtoEBSP(byte *streamBuffer, int begin_bytepos, int end_bytepos, int min_num_bytes);
 1453|       |#if defined(SPEC_CPU)
 1454|       |extern int Bytes_After_Header;
 1455|       |#else
 1456|       |int Bytes_After_Header;
 1457|       |#endif /* SPEC_CPU */
 1458|       |
 1459|       |// JVT-D101: the bit for redundant_pic_cnt in slice header may be changed, 
 1460|       |// therefore the bit position in the bitstream must be stored.
 1461|       |#if defined(SPEC_CPU)
 1462|       |extern int rpc_bytes_to_go;
 1463|       |extern int rpc_bits_to_go;
 1464|       |#else
 1465|       |int rpc_bytes_to_go;
 1466|       |int rpc_bits_to_go;
 1467|       |#endif /* SPEC_CPU */
 1468|       |void modify_redundant_pic_cnt(unsigned char *streamBuffer);
 1469|       |// End JVT-D101
 1470|       |
 1471|       |// Fast ME enable
 1472|       |int BlockMotionSearch (short,int,int,int,int,int,double);
 1473|       |void encode_one_macroblock (void);
 1474|       |
 1475|       |int RDCost_for_4x4Blocks_Chroma (int b8, int b4, int  chroma);
 1476|       |
 1477|       |#endif
 1478|       |
 1479|       |#include "context_ini.h"
 1480|       |
 1481|       |void store_coding_state_cs_cm();
 1482|       |void reset_coding_state_cs_cm();

/home/xzp/speccpu2006-v1.0.1/benchspec/CPU2006/464.h264ref/run/build_base_ql_riscv_llvm17.0000/header.c:
    1|       |
    2|       |/*!
    3|       | *************************************************************************************
    4|       | * \file header.c
    5|       | *
    6|       | * \brief
    7|       | *    H.264 Slice and Sequence headers
    8|       | *
    9|       | * \author
   10|       | *    Main contributors (see contributors.h for copyright, address and affiliation details)
   11|       | *      - Stephan Wenger                  <stewe@cs.tu-berlin.de>
   12|       | *      - Karsten Suehring                <suehring@hhi.de>
   13|       | *************************************************************************************
   14|       | */
   15|       |
   16|       |#include <math.h>
   17|       |#include <assert.h>
   18|       |#include <string.h>
   19|       |#include <stdlib.h>
   20|       |
   21|       |#include "global.h"
   22|       |
   23|       |#include "elements.h"
   24|       |#include "header.h"
   25|       |#include "rtp.h"
   26|       |#include "mbuffer.h"
   27|       |#include "defines.h"
   28|       |#include "vlc.h"
   29|       |#include "parset.h"
   30|       |
   31|       |// A little trick to avoid those horrible #if TRACE all over the source code
   32|       |#if TRACE
   33|       |#define SYMTRACESTRING(s) strncpy(sym->tracestring,s,TRACESTRING_SIZE)
   34|       |#else
   35|       |#define SYMTRACESTRING(s) // do nothing
   36|       |#endif
   37|       |
   38|       |int * assignSE2partition[2] ;
   39|       |int assignSE2partition_NoDP[SE_MAX_ELEMENTS] =
   40|       |  {  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
   41|       |int assignSE2partition_DP[SE_MAX_ELEMENTS] =
   42|       |  {  0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 2, 2, 2, 2, 0, 0, 0, 0 } ;
   43|       |
   44|       |static int ref_pic_list_reordering();
   45|       |static int dec_ref_pic_marking();
   46|       |static int pred_weight_table();
   47|       |
   48|       |/*!
   49|       | ********************************************************************************************
   50|       | * \brief 
   51|       | *    Write a slice header
   52|       | *
   53|       | * \return
   54|       | *    number of bits used 
   55|       | ********************************************************************************************
   56|       |*/
   57|       |int SliceHeader()
   58|    171|{
   59|    171|  int dP_nr = assignSE2partition[input->partition_mode][SE_HEADER];
   60|    171|  DataPartition *partition = &((img->currentSlice)->partArr[dP_nr]);
   61|    171|  Slice* currSlice = img->currentSlice;
   62|    171|  int len = 0;
   63|    171|  unsigned int field_pic_flag = 0, bottom_field_flag = 0;
   64|       |
   65|    171|  int num_bits_slice_group_change_cycle;
   66|    171|  float numtmp;	
   67|       |	
   68|    171|  if (img->MbaffFrameFlag)
   69|      0|    len  = ue_v("SH: first_mb_in_slice", img->current_mb_nr >> 1,   partition);
   70|    171|  else
   71|    171|    len  = ue_v("SH: first_mb_in_slice", img->current_mb_nr,   partition);
   72|       |
   73|    171|  len += ue_v("SH: slice_type",        get_picture_type (),   partition);
   74|       |
   75|    171|  len += ue_v("SH: pic_parameter_set_id" , active_pps->pic_parameter_set_id ,partition);
   76|       |
   77|       |  // frame_num
   78|    171|  len += u_v (log2_max_frame_num_minus4 + 4,"SH: frame_num", img->frame_num, partition);
   79|       |
   80|    171|  if (!active_sps->frame_mbs_only_flag)
   81|      0|  {
   82|       |    // field_pic_flag    u(1)
   83|      0|    field_pic_flag = (img->structure ==TOP_FIELD || img->structure ==BOTTOM_FIELD)?1:0;
   84|      0|    assert( field_pic_flag == img->fld_flag );
   85|      0|    len += u_1("SH: field_pic_flag", field_pic_flag, partition);
   86|       |
   87|      0|    if (field_pic_flag)
   88|      0|    {
   89|       |      //bottom_field_flag     u(1)
   90|      0|      bottom_field_flag = (img->structure == BOTTOM_FIELD)?1:0;
   91|      0|      len += u_1("SH: bottom_field_flag" , bottom_field_flag ,partition);
   92|      0|    }
   93|      0|  }
   94|       |
   95|    171|  if (img->currentPicture->idr_flag)
   96|      1|  {
   97|       |    // idr_pic_id
   98|      1|    len += ue_v ("SH: idr_pic_id", (img->number % 2), partition);
   99|      1|  }
  100|       |
  101|    171|  if (img->pic_order_cnt_type == 0)
  102|    171|  {
  103|    171|    if (active_sps->frame_mbs_only_flag)
  104|    171|    {
  105|    171|      img->pic_order_cnt_lsb = (img->toppoc & ~((((unsigned int)(-1)) << (log2_max_pic_order_cnt_lsb_minus4+4))) );
  106|    171|    }
  107|      0|    else
  108|      0|    {
  109|      0|      if (!field_pic_flag || img->structure == TOP_FIELD)
  110|      0|        img->pic_order_cnt_lsb = (img->toppoc & ~((((unsigned int)(-1)) << (log2_max_pic_order_cnt_lsb_minus4+4))) );
  111|      0|      else if ( img->structure == BOTTOM_FIELD )
  112|      0|        img->pic_order_cnt_lsb = (img->bottompoc & ~((((unsigned int)(-1)) << (log2_max_pic_order_cnt_lsb_minus4+4))) );
  113|      0|    }
  114|       |
  115|    171|    len += u_v (log2_max_pic_order_cnt_lsb_minus4+4, "SH: pic_order_cnt_lsb", img->pic_order_cnt_lsb, partition);
  116|       |
  117|    171|    if (img->pic_order_present_flag && !field_pic_flag)  // img->fld_flag
  118|      0|    {
  119|      0|      len += se_v ("SH: delta_pic_order_cnt_bottom", img->delta_pic_order_cnt_bottom, partition);
  120|      0|    }
  121|    171|  }
  122|    171|  if (img->pic_order_cnt_type == 1 && !img->delta_pic_order_always_zero_flag)
  123|      0|  {
  124|      0|    len += se_v ("SH: delta_pic_order_cnt[0]", img->delta_pic_order_cnt[0], partition);
  125|       |
  126|      0|    if (img->pic_order_present_flag && !field_pic_flag)  // img->fld_flag
  127|      0|    {
  128|      0|      len += se_v ("SH: delta_pic_order_cnt[1]", img->delta_pic_order_cnt[1], partition);
  129|      0|    }
  130|      0|  }
  131|       |
  132|       |  // redundant slice info redundant_pic_cnt is missing here
  133|    171|  if (input->redundant_slice_flag)
  134|      0|  {
  135|      0|    len += ue_v ("SH: redundant_pic_cnt", img->redundant_pic_cnt, partition);
  136|      0|  }
  137|       |
  138|       |  // Direct Mode Type selection for B pictures
  139|    171|  if (img->type==B_SLICE)
  140|     85|  {
  141|     85|    len +=  u_1 ("SH: direct_spatial_mv_pred_flag", img->direct_spatial_mv_pred_flag, partition);  	
  142|     85|  }
  143|       |
  144|    171|  if ((img->type == P_SLICE) || (img->type == B_SLICE) || (img->type==SP_SLICE))
  145|    142|  {
  146|    142|    int override_flag;
  147|    142|    if ((img->type == P_SLICE) || (img->type==SP_SLICE))
  148|     57|    {
  149|     57|      override_flag = (img->num_ref_idx_l0_active != (active_pps->num_ref_idx_l0_active_minus1 +1)) ? 1 : 0;
  150|     57|    }
  151|     85|    else
  152|     85|    {
  153|     85|      override_flag = ((img->num_ref_idx_l0_active != (active_pps->num_ref_idx_l0_active_minus1 +1)) 
  154|     85|                      || (img->num_ref_idx_l1_active != (active_pps->num_ref_idx_l1_active_minus1 +1))) ? 1 : 0;
  155|     85|    }
  156|       |
  157|    142|    len +=  u_1 ("SH: num_ref_idx_active_override_flag", override_flag, partition);
  158|       |    
  159|    142|    if (override_flag) 
  160|     88|    {
  161|     88|      len += ue_v ("SH: num_ref_idx_l0_active_minus1", img->num_ref_idx_l0_active-1, partition);
  162|     88|      if (img->type==B_SLICE)
  163|     85|      {
  164|     85|        len += ue_v ("SH: num_ref_idx_l1_active_minus1", img->num_ref_idx_l1_active-1, partition);
  165|     85|      }
  166|     88|    }
  167|       |
  168|    142|  }
  169|    171|  len += ref_pic_list_reordering();
  170|       |
  171|    171|  if (((img->type == P_SLICE || img->type == SP_SLICE) && active_pps->weighted_pred_flag) || 
  172|    171|     ((img->type == B_SLICE) && active_pps->weighted_bipred_idc == 1))  
  173|      0|  {
  174|      0|    len += pred_weight_table();
  175|      0|  }
  176|       |
  177|    171|  if (img->nal_reference_idc)
  178|     86|    len += dec_ref_pic_marking();
  179|       |
  180|    171|  if(input->symbol_mode==CABAC && img->type!=I_SLICE /*&& img->type!=SI_IMG*/)
  181|    142|  {
  182|    142|    len += ue_v("SH: cabac_init_idc", img->model_number, partition);
  183|    142|  }
  184|       |
  185|    171|  len += se_v("SH: slice_qp_delta", (currSlice->qp - 26 - active_pps->pic_init_qp_minus26), partition);  
  186|       |
  187|    171|  if (img->type==SP_SLICE /*|| img->type==SI_SLICE*/)
  188|      0|  {
  189|      0|    if (img->type==SP_SLICE) // Switch Flag only for SP pictures
  190|      0|    {
  191|      0|      len += u_1 ("SH: sp_for_switch_flag", 0, partition);   // 1 for switching SP, 0 for normal SP
  192|      0|    }
  193|      0|    len += se_v ("SH: slice_qs_delta", (img->qpsp - 26), partition );
  194|      0|  }
  195|       |
  196|    171|  if (active_pps->deblocking_filter_control_present_flag)
  197|      0|  {
  198|      0|    len += ue_v("SH: disable_deblocking_filter_idc",img->LFDisableIdc, partition);  // Turn loop filter on/off on slice basis 
  199|       |
  200|      0|    if (img->LFDisableIdc!=1)
  201|      0|    {
  202|      0|      len += se_v ("SH: slice_alpha_c0_offset_div2", img->LFAlphaC0Offset / 2, partition);
  203|       |
  204|      0|      len += se_v ("SH: slice_beta_offset_div2", img->LFBetaOffset / 2, partition);
  205|      0|    }
  206|      0|  }
  207|       |
  208|       |	
  209|    171|  if ( active_pps->num_slice_groups_minus1>0 &&
  210|    171|    active_pps->slice_group_map_type>=3 && active_pps->slice_group_map_type<=5)
  211|      0|  {
  212|      0|    numtmp=img->PicHeightInMapUnits*img->PicWidthInMbs/(float)(active_pps->slice_group_change_rate_minus1+1)+1;
  213|      0|    num_bits_slice_group_change_cycle = (int)ceil(log(numtmp)/log(2));
  214|       |
  215|       |    //! img->slice_group_change_cycle can be changed before calling FmoInit()
  216|      0|    len += u_v (num_bits_slice_group_change_cycle, "SH: slice_group_change_cycle", img->slice_group_change_cycle, partition);
  217|      0|  }
  218|       |
  219|       |  // NOTE: The following syntax element is actually part 
  220|       |  //        Slice data partition A RBSP syntax
  221|       |
  222|    171|  if(input->partition_mode&&!img->currentPicture->idr_flag)
  223|      0|  {
  224|      0|    len += ue_v("DPA: slice_id", img->current_slice_nr, partition);
  225|      0|  }
  226|       |
  227|    171|  return len;
  228|    171|}
  229|       |
  230|       |/*!
  231|       | ********************************************************************************************
  232|       | * \brief 
  233|       | *    writes the ref_pic_list_reordering syntax
  234|       | *    based on content of according fields in img structure
  235|       | *
  236|       | * \return
  237|       | *    number of bits used 
  238|       | ********************************************************************************************
  239|       |*/
  240|       |static int ref_pic_list_reordering()
  241|    171|{
  242|    171|  int dP_nr = assignSE2partition[input->partition_mode][SE_HEADER];
  243|    171|  DataPartition *partition = &((img->currentSlice)->partArr[dP_nr]);
  244|    171|  Slice *currSlice = img->currentSlice;
  245|       |
  246|    171|  int i, len=0;
  247|       |
  248|    171|  if ((img->type!=I_SLICE) /*&&(img->type!=SI_IMG)*/ )
  249|    142|  {
  250|    142|    len += u_1 ("SH: ref_pic_list_reordering_flag_l0", currSlice->ref_pic_list_reordering_flag_l0, partition);
  251|    142|    if (currSlice->ref_pic_list_reordering_flag_l0)
  252|      0|    {
  253|      0|      i=-1;
  254|      0|      do
  255|      0|      {
  256|      0|        i++;
  257|      0|        len += ue_v ("SH: remapping_of_pic_num_idc", currSlice->remapping_of_pic_nums_idc_l0[i], partition);
  258|      0|        if (currSlice->remapping_of_pic_nums_idc_l0[i]==0 ||
  259|      0|            currSlice->remapping_of_pic_nums_idc_l0[i]==1)
  260|      0|        {
  261|      0|          len += ue_v ("SH: abs_diff_pic_num_minus1_l0", currSlice->abs_diff_pic_num_minus1_l0[i], partition);
  262|      0|        }
  263|      0|        else
  264|      0|        {
  265|      0|          if (currSlice->remapping_of_pic_nums_idc_l0[i]==2)
  266|      0|          {
  267|      0|            len += ue_v ("SH: long_term_pic_idx_l0", currSlice->long_term_pic_idx_l0[i], partition);
  268|      0|          }
  269|      0|        }
  270|       |
  271|      0|      } while (currSlice->remapping_of_pic_nums_idc_l0[i] != 3);
  272|      0|    }
  273|    142|  }
  274|       |
  275|    171|  if (img->type==B_SLICE)
  276|     85|  {
  277|     85|    len += u_1 ("SH: ref_pic_list_reordering_flag_l1", currSlice->ref_pic_list_reordering_flag_l1, partition);
  278|     85|    if (currSlice->ref_pic_list_reordering_flag_l1)
  279|      0|    {
  280|      0|      i=-1;
  281|      0|      do
  282|      0|      {
  283|      0|        i++;
  284|      0|        len += ue_v ("SH: remapping_of_pic_num_idc", currSlice->remapping_of_pic_nums_idc_l1[i], partition);
  285|      0|        if (currSlice->remapping_of_pic_nums_idc_l1[i]==0 ||
  286|      0|            currSlice->remapping_of_pic_nums_idc_l1[i]==1)
  287|      0|        {
  288|      0|          len += ue_v ("SH: abs_diff_pic_num_minus1_l1", currSlice->abs_diff_pic_num_minus1_l1[i], partition);
  289|      0|        }
  290|      0|        else
  291|      0|        {
  292|      0|          if (currSlice->remapping_of_pic_nums_idc_l1[i]==2)
  293|      0|          {
  294|      0|            len += ue_v ("SH: long_term_pic_idx_l1", currSlice->long_term_pic_idx_l1[i], partition);
  295|      0|          }
  296|      0|        }
  297|      0|      } while (currSlice->remapping_of_pic_nums_idc_l1[i] != 3);
  298|      0|    }
  299|     85|  }
  300|       |
  301|    171|  return len;
  302|    171|}
  303|       |
  304|       |
  305|       |/*!
  306|       | ************************************************************************
  307|       | * \brief
  308|       | *    write the memory management control operations
  309|       | *
  310|       | * \return
  311|       | *    number of bits used 
  312|       | ************************************************************************
  313|       | */
  314|       |static int dec_ref_pic_marking()
  315|     86|{
  316|     86|  int dP_nr = assignSE2partition[input->partition_mode][SE_HEADER];
  317|     86|  DataPartition *partition = &((img->currentSlice)->partArr[dP_nr]);
  318|       |
  319|     86|  DecRefPicMarking_t *tmp_drpm;
  320|       |
  321|     86|  int val, len=0;
  322|       |
  323|     86|  if (img->currentPicture->idr_flag)
  324|      1|  {
  325|      1|    len += u_1("SH: no_output_of_prior_pics_flag", img->no_output_of_prior_pics_flag, partition);
  326|      1|    len += u_1("SH: long_term_reference_flag", img->long_term_reference_flag, partition);
  327|      1|  }
  328|     85|  else
  329|     85|  {
  330|     85|    img->adaptive_ref_pic_buffering_flag = (img->dec_ref_pic_marking_buffer!=NULL);
  331|       |
  332|     85|    len += u_1("SH: adaptive_ref_pic_buffering_flag", img->adaptive_ref_pic_buffering_flag, partition);
  333|       |
  334|     85|    if (img->adaptive_ref_pic_buffering_flag)
  335|      0|    {
  336|      0|      tmp_drpm = img->dec_ref_pic_marking_buffer;
  337|       |      // write Memory Management Control Operation 
  338|      0|      do
  339|      0|      {
  340|      0|        if (tmp_drpm==NULL) error ("Error encoding MMCO commands", 500);
  341|       |        
  342|      0|        val = tmp_drpm->memory_management_control_operation;
  343|      0|        len += ue_v("SH: memory_management_control_operation", val, partition);
  344|       |
  345|      0|        if ((val==1)||(val==3)) 
  346|      0|        {
  347|      0|          len += 1 + ue_v("SH: difference_of_pic_nums_minus1", tmp_drpm->difference_of_pic_nums_minus1, partition);
  348|      0|        }
  349|      0|        if (val==2)
  350|      0|        {
  351|      0|          len+= ue_v("SH: long_term_pic_num", tmp_drpm->long_term_pic_num, partition);
  352|      0|        }
  353|      0|        if ((val==3)||(val==6))
  354|      0|        {
  355|      0|          len+= ue_v("SH: long_term_frame_idx", tmp_drpm->long_term_frame_idx, partition);
  356|      0|        }
  357|      0|        if (val==4)
  358|      0|        {
  359|      0|          len += ue_v("SH: max_long_term_pic_idx_plus1", tmp_drpm->max_long_term_frame_idx_plus1, partition);
  360|      0|        }
  361|       |        
  362|      0|        tmp_drpm=tmp_drpm->Next;
  363|       |        
  364|      0|      } while (val != 0);
  365|       |      
  366|      0|    }
  367|     85|  }
  368|     86|  return len;
  369|     86|}
  370|       |
  371|       |
  372|       |/*!
  373|       | ************************************************************************
  374|       | * \brief
  375|       | *    write prediction weight table
  376|       | *
  377|       | * \return
  378|       | *    number of bits used 
  379|       | ************************************************************************
  380|       | */
  381|       |static int pred_weight_table()
  382|      0|{
  383|      0|  int dP_nr = assignSE2partition[input->partition_mode][SE_HEADER];
  384|      0|  DataPartition *partition = &((img->currentSlice)->partArr[dP_nr]);
  385|       |
  386|      0|  int len = 0;
  387|      0|  int i,j;
  388|       |
  389|      0|  len += ue_v("SH: luma_log_weight_denom", luma_log_weight_denom, partition);
  390|       |  
  391|      0|  len += ue_v("SH: chroma_log_weight_denom", chroma_log_weight_denom, partition);
  392|       |
  393|      0|  for (i=0; i< img->num_ref_idx_l0_active; i++)
  394|      0|  {
  395|      0|    if ( (wp_weight[0][i][0] != 1<<luma_log_weight_denom) || (wp_offset[0][i][0] != 0) )
  396|      0|    {
  397|      0|      len += u_1 ("SH: luma_weight_flag_l0", 1, partition);
  398|       |      
  399|      0|      len += se_v ("SH: luma_weight_l0", wp_weight[0][i][0], partition);
  400|       |        
  401|      0|      len += se_v ("SH: luma_offset_l0", wp_offset[0][i][0], partition);
  402|      0|    }
  403|      0|    else
  404|      0|    {
  405|      0|        len += u_1 ("SH: luma_weight_flag_l0", 0, partition);
  406|      0|    }
  407|       |
  408|      0|    if ( (wp_weight[0][i][1] != 1<<chroma_log_weight_denom) || (wp_offset[0][i][1] != 0) || 
  409|      0|     (wp_weight[0][i][2] != 1<<chroma_log_weight_denom) || (wp_offset[0][i][2] != 0)  )
  410|      0|    {
  411|      0|      len += u_1 ("chroma_weight_flag_l0", 1, partition);
  412|      0|      for (j=1; j<3; j++)
  413|      0|      {
  414|      0|        len += se_v ("chroma_weight_l0", wp_weight[0][i][j] ,partition);
  415|       |      
  416|      0|        len += se_v ("chroma_offset_l0", wp_offset[0][i][j] ,partition);
  417|      0|      }
  418|      0|    }
  419|      0|    else
  420|      0|    {
  421|      0|      len += u_1 ("chroma_weight_flag_l0", 0, partition);
  422|      0|    }
  423|      0|  }
  424|       |
  425|      0|  if (img->type == B_SLICE)
  426|      0|  {
  427|      0|    for (i=0; i< img->num_ref_idx_l1_active; i++)
  428|      0|    {
  429|      0|      if ( (wp_weight[1][i][0] != 1<<luma_log_weight_denom) || (wp_offset[1][i][0] != 0) )
  430|      0|      {
  431|      0|        len += u_1 ("SH: luma_weight_flag_l1", 1, partition);
  432|       |        
  433|      0|        len += se_v ("SH: luma_weight_l1", wp_weight[1][i][0], partition);
  434|       |        
  435|      0|        len += se_v ("SH: luma_offset_l1", wp_offset[1][i][0], partition);
  436|      0|      }
  437|      0|      else
  438|      0|      {
  439|      0|        len += u_1 ("SH: luma_weight_flag_l1", 0, partition);
  440|      0|      }
  441|       |      
  442|      0|      if ( (wp_weight[1][i][1] != 1<<chroma_log_weight_denom) || (wp_offset[1][i][1] != 0) || 
  443|      0|      (wp_weight[1][i][2] != 1<<chroma_log_weight_denom) || (wp_offset[1][i][2] != 0) )
  444|      0|      {
  445|      0|        len += u_1 ("chroma_weight_flag_l1", 1, partition);
  446|      0|        for (j=1; j<3; j++)
  447|      0|        {
  448|      0|          len += se_v ("chroma_weight_l1", wp_weight[1][i][j] ,partition);
  449|       |          
  450|      0|          len += se_v ("chroma_offset_l1", wp_offset[1][i][j] ,partition);
  451|      0|        }
  452|      0|      }
  453|      0|      else
  454|      0|      {
  455|      0|        len += u_1 ("chroma_weight_flag_l1", 0, partition);
  456|      0|      }
  457|      0|    }
  458|      0|  }
  459|      0|  return len;
  460|      0|}
  461|       |  
  462|       |
  463|       |/*!
  464|       | ************************************************************************
  465|       | * \brief
  466|       | *    Selects picture type and codes it to symbol
  467|       | *
  468|       | * \return
  469|       | *    symbol value for picture type
  470|       | ************************************************************************
  471|       | */
  472|       |int get_picture_type()
  473|    171|{
  474|       |  // set this value to zero for transmission without signaling 
  475|       |  // that the whole picture has the same slice type
  476|    171|  int same_slicetype_for_whole_frame = 5;
  477|       |
  478|    171|  switch (img->type)
  479|    171|  {
  480|     29|  case I_SLICE:
  481|     29|    return 2 + same_slicetype_for_whole_frame;
  482|      0|    break;
  483|     57|  case P_SLICE:
  484|     57|    return 0 + same_slicetype_for_whole_frame;
  485|      0|    break;
  486|     85|  case B_SLICE:
  487|     85|    return 1 + same_slicetype_for_whole_frame;
  488|      0|    break;
  489|      0|  case SP_SLICE:
  490|      0|    return 3 + same_slicetype_for_whole_frame;
  491|      0|    break;
  492|      0|  default:
  493|      0|    error("Picture Type not supported!",1);
  494|      0|    break;
  495|    171|  }
  496|       |   
  497|      0|  return 0;
  498|    171|}
  499|       |
  500|       |
  501|       |
  502|       |/*!
  503|       | *****************************************************************************
  504|       | *
  505|       | * \brief 
  506|       | *    int Partition_BC_Header () write the Partition type B, C header
  507|       | *
  508|       | * \return
  509|       | *    Number of bits used by the partition header
  510|       | *
  511|       | * \par Parameters
  512|       | *    PartNo: Partition Number to which the header should be written
  513|       | *
  514|       | * \par Side effects
  515|       | *    Partition header as per VCEG-N72r2 is written into the appropriate 
  516|       | *    partition bit buffer
  517|       | *
  518|       | * \par Limitations/Shortcomings/Tweaks
  519|       | *    The current code does not support the change of picture parameters within
  520|       | *    one coded sequence, hence there is only one parameter set necessary.  This
  521|       | *    is hard coded to zero.
  522|       | *
  523|       | * \date
  524|       | *    October 24, 2001
  525|       | *
  526|       | * \author
  527|       | *    Stephan Wenger   stewe@cs.tu-berlin.de
  528|       | *****************************************************************************/
  529|       |int Partition_BC_Header(int PartNo)
  530|      0|{
  531|      0|  DataPartition *partition = &((img->currentSlice)->partArr[PartNo]);
  532|      0|  SyntaxElement symbol, *sym = &symbol;
  533|       |
  534|      0|  int len = 0;
  535|       |
  536|      0|  assert (input->of_mode == PAR_OF_RTP);
  537|      0|  assert (PartNo > 0 && PartNo < img->currentSlice->max_part_nr);
  538|       |
  539|      0|  sym->type = SE_HEADER;         // This will be true for all symbols generated here
  540|      0|  sym->mapping = ue_linfo;       // Mapping rule: Simple code number to len/info
  541|      0|  sym->value2  = 0;
  542|       |
  543|       |  //ZL 
  544|       |  //changed according to the g050r1
  545|      0|  SYMTRACESTRING("RTP-PH: Slice ID");
  546|      0|  sym->value1 = img->current_slice_nr;
  547|      0|  len += writeSyntaxElement_UVLC (sym, partition);
  548|       |
  549|      0|  if(active_pps->redundant_pic_cnt_present_flag)
  550|      0|  {
  551|      0|  SYMTRACESTRING("RTP-PH: Picture ID");
  552|      0|  sym->value1 = img->currentSlice->picture_id;
  553|      0|  len += writeSyntaxElement_UVLC (sym, partition);
  554|      0|  }
  555|       |
  556|       |
  557|      0|  return len;
  558|      0|}

/home/xzp/speccpu2006-v1.0.1/benchspec/CPU2006/464.h264ref/run/build_base_ql_riscv_llvm17.0000/image.c:
    1|       |
    2|       |/*!
    3|       | *************************************************************************************
    4|       | * \file image.c
    5|       | *
    6|       | * \brief
    7|       | *    Code one image/slice
    8|       | *
    9|       | * \author
   10|       | *    Main contributors (see contributors.h for copyright, address and affiliation details)
   11|       | *     - Inge Lille-Langoy               <inge.lille-langoy@telenor.com>
   12|       | *     - Rickard Sjoberg                 <rickard.sjoberg@era.ericsson.se>
   13|       | *     - Jani Lainema                    <jani.lainema@nokia.com>
   14|       | *     - Sebastian Purreiter             <sebastian.purreiter@mch.siemens.de>
   15|       | *     - Byeong-Moon Jeon                <jeonbm@lge.com>
   16|       | *     - Yoon-Seong Soh                  <yunsung@lge.com>
   17|       | *     - Thomas Stockhammer              <stockhammer@ei.tum.de>
   18|       | *     - Detlev Marpe                    <marpe@hhi.de>
   19|       | *     - Guido Heising                   <heising@hhi.de>
   20|       | *     - Thomas Wedi                     <wedi@tnt.uni-hannover.de>
   21|       | *     - Ragip Kurceren                  <ragip.kurceren@nokia.com>
   22|       | *     - Antti Hallapuro                 <antti.hallapuro@nokia.com>
   23|       | *     - Alexis Michael Tourapis         <alexismt@ieee.org> 
   24|       | *************************************************************************************
   25|       | */
   26|       |#include "contributors.h"
   27|       |
   28|       |#include <stdlib.h>
   29|       |#include <math.h>
   30|       |#include <time.h>
   31|       |#include <sys/timeb.h>
   32|       |#include <string.h>
   33|       |#include <assert.h>
   34|       |
   35|       |#ifdef WIN32
   36|       |#include <io.h>
   37|       |#else
   38|       |#include <unistd.h>
   39|       |#endif
   40|       |
   41|       |#include "global.h"
   42|       |
   43|       |#include "refbuf.h"
   44|       |#include "mbuffer.h"
   45|       |#include "intrarefresh.h"
   46|       |#include "fmo.h"
   47|       |#include "sei.h"
   48|       |#include "memalloc.h"
   49|       |#include "nalu.h"
   50|       |#include "ratectl.h"
   51|       |#include "mb_access.h"
   52|       |#include "output.h"
   53|       |
   54|       |extern pic_parameter_set_rbsp_t PicParSet[MAXPPS];
   55|       |
   56|       |void code_a_picture(Picture *pic);
   57|       |void frame_picture (Picture *frame, int method);
   58|       |void field_picture(Picture *top, Picture *bottom);
   59|       |
   60|       |static int  writeout_picture(Picture *pic);
   61|       |
   62|       |static int  picture_structure_decision(Picture *frame, Picture *top, Picture *bot);
   63|       |static void distortion_fld (float *dis_fld_y, float *dis_fld_u, float *dis_fld_v);
   64|       |static void find_snr();
   65|       |static void find_distortion();
   66|       |
   67|       |static void field_mode_buffer(int bit_field, float snr_field_y, float snr_field_u, float snr_field_v);
   68|       |static void frame_mode_buffer (int bit_frame, float snr_frame_y, float snr_frame_u, float snr_frame_v);
   69|       |
   70|       |static void init_frame();
   71|       |static void init_field();
   72|       |
   73|       |static void put_buffer_frame();
   74|       |static void put_buffer_top();
   75|       |static void put_buffer_bot();
   76|       |
   77|       |static void copy_motion_vectors_MB();
   78|       |
   79|       |static void PaddAutoCropBorders (int org_size_x, int org_size_y, int img_size_x, int img_size_y,
   80|       |                                 int org_size_x_cr, int org_size_y_cr, int img_size_x_cr, int img_size_y_cr);
   81|       |
   82|       |static void ReadOneFrame (int FrameNoInFile, int HeaderSize, int xs, int ys, int xs_cr, int ys_cr);
   83|       |
   84|       |static void writeUnit(Bitstream* currStream ,int partition);
   85|       |static void rdPictureCoding();
   86|       |
   87|       |#ifdef _ADAPT_LAST_GROUP_
   88|       |int *last_P_no;
   89|       |int *last_P_no_frm;
   90|       |int *last_P_no_fld;
   91|       |#endif
   92|       |
   93|       |static void ReportFirstframe(int tmp_time, int me_time);
   94|       |static void ReportIntra(int tmp_time, int me_time);
   95|       |static void ReportSP(int tmp_time, int me_time);
   96|       |static void ReportRB(int tmp_time, int me_time);
   97|       |static void ReportP(int tmp_time, int me_time);
   98|       |static void ReportB(int tmp_time, int me_time);
   99|       |static void ReportNALNonVLCBits(int tmp_time, int me_time);
  100|       |
  101|       |static int CalculateFrameNumber();  // Calculates the next frame number
  102|       |
  103|       |StorablePicture *enc_picture;
  104|       |StorablePicture *enc_frame_picture;
  105|       |StorablePicture *enc_frame_picture2;
  106|       |StorablePicture *enc_frame_picture3;
  107|       |StorablePicture *enc_top_picture;
  108|       |StorablePicture *enc_bottom_picture;
  109|       |//Rate control
  110|       |#if !defined(SPEC_CPU)
  111|       |int    QP;
  112|       |#endif
  113|       |
  114|       |const int ONE_FOURTH_TAP[3][2] =
  115|       |{
  116|       |  {20,20},
  117|       |  {-5,-4},
  118|       |  { 1, 0},
  119|       |};
  120|       |
  121|       |
  122|       |void MbAffPostProc()
  123|      0|{
  124|      0|  imgpel temp[16][32];
  125|       |
  126|      0|  imgpel ** imgY  = enc_picture->imgY;
  127|      0|  imgpel ***imgUV = enc_picture->imgUV;
  128|      0|  int i, x, y, x0, y0, uv;
  129|       |
  130|      0|  if (img->yuv_format != YUV400)
  131|      0|  {
  132|      0|    for (i=0; i<(int)img->PicSizeInMbs; i+=2)
  133|      0|    {
  134|      0|      if (enc_picture->mb_field[i])
  135|      0|      {
  136|      0|        get_mb_pos(i, &x0, &y0);
  137|      0|        for (y=0; y<(2*MB_BLOCK_SIZE);y++)
  138|      0|          for (x=0; x<MB_BLOCK_SIZE; x++)
  139|      0|            temp[x][y] = imgY[y0+y][x0+x];
  140|       |
  141|      0|        for (y=0; y<MB_BLOCK_SIZE;y++)
  142|      0|          for (x=0; x<MB_BLOCK_SIZE; x++)
  143|      0|          {
  144|      0|            imgY[y0+(2*y)][x0+x]   = temp[x][y];
  145|      0|            imgY[y0+(2*y+1)][x0+x] = temp[x][y+MB_BLOCK_SIZE];
  146|      0|          }
  147|       |
  148|      0|        x0 = x0 / (16/img->mb_cr_size_x);
  149|      0|        y0 = y0 / (16/img->mb_cr_size_y);
  150|       |
  151|      0|        for (uv=0; uv<2; uv++)
  152|      0|        {
  153|      0|          for (y=0; y<(2*img->mb_cr_size_y);y++)    
  154|      0|            for (x=0; x<img->mb_cr_size_x; x++)
  155|      0|              temp[x][y] = imgUV[uv][y0+y][x0+x];
  156|       |          
  157|      0|          for (y=0; y<img->mb_cr_size_y;y++)
  158|      0|            for (x=0; x<img->mb_cr_size_x; x++)
  159|      0|            {
  160|      0|              imgUV[uv][y0+(2*y)][x0+x]   = temp[x][y];
  161|      0|              imgUV[uv][y0+(2*y+1)][x0+x] = temp[x][y+img->mb_cr_size_y];
  162|      0|            }
  163|      0|        }
  164|      0|      }
  165|      0|    }
  166|      0|  }
  167|      0|  else
  168|      0|  {
  169|      0|    for (i=0; i<(int)img->PicSizeInMbs; i+=2)
  170|      0|    {
  171|      0|      if (enc_picture->mb_field[i])
  172|      0|      {
  173|      0|        get_mb_pos(i, &x0, &y0);
  174|      0|        for (y=0; y<(2*MB_BLOCK_SIZE);y++)
  175|      0|          for (x=0; x<MB_BLOCK_SIZE; x++)
  176|      0|            temp[x][y] = imgY[y0+y][x0+x];
  177|       |
  178|      0|        for (y=0; y<MB_BLOCK_SIZE;y++)
  179|      0|          for (x=0; x<MB_BLOCK_SIZE; x++)
  180|      0|          {
  181|      0|            imgY[y0+(2*y)][x0+x]   = temp[x][y];
  182|      0|            imgY[y0+(2*y+1)][x0+x] = temp[x][y+MB_BLOCK_SIZE];
  183|      0|          }
  184|      0|      }
  185|      0|    }
  186|      0|  }
  187|      0|}
  188|       |
  189|       |/*!
  190|       | ************************************************************************
  191|       | * \brief
  192|       | *    Encodes a picture
  193|       | *
  194|       | *    This is the main picture coding loop.. It is called by all this
  195|       | *    frame and field coding stuff after the img-> elements have been
  196|       | *    set up.  Not sure whether it is useful for MB-adaptive frame/field
  197|       | *    coding
  198|       | ************************************************************************
  199|       | */
  200|       |void code_a_picture(Picture *pic)
  201|    171|{
  202|    171|  int NumberOfCodedMBs = 0;
  203|    171|  int SliceGroup = 0;
  204|    171|  int j;
  205|       |
  206|    171|  img->currentPicture = pic;
  207|       |
  208|    171|  img->currentPicture->idr_flag = ((!IMG_NUMBER) && (!(img->structure==BOTTOM_FIELD))) || (input->idr_enable && (img->type == I_SLICE || img->type==SP_SLICE || img->type==SI_SLICE)&& (!(img->structure==BOTTOM_FIELD)));
  209|       |
  210|    171|  pic->no_slices = 0;
  211|    171|  pic->distortion_u = pic->distortion_v = pic->distortion_y = 0.0;
  212|       |
  213|    171|  RandomIntraNewPicture ();     //! Allocates forced INTRA MBs (even for fields!)
  214|       |
  215|       |  // The slice_group_change_cycle can be changed here.
  216|       |  // FmoInit() is called before coding each picture, frame or field
  217|    171|  img->slice_group_change_cycle=1;
  218|    171|  FmoInit(img, active_pps, active_sps);
  219|    171|  FmoStartPicture ();           //! picture level initialization of FMO
  220|       |
  221|    171|  CalculateQuantParam();
  222|    171|  CalculateOffsetParam();
  223|       |
  224|    171|  if(input->AllowTransform8x8)
  225|      0|  {
  226|      0|    CalculateQuant8Param();
  227|      0|    CalculateOffset8Param();
  228|      0|  }
  229|       |
  230|    342|  while (NumberOfCodedMBs < img->total_number_mb)       // loop over slices
  231|    171|  {
  232|       |    // Encode one SLice Group
  233|    342|    while (!FmoSliceGroupCompletelyCoded (SliceGroup))
  234|    171|    {
  235|       |      // Encode the current slice
  236|    171|      NumberOfCodedMBs += encode_one_slice (SliceGroup, pic);
  237|    171|      FmoSetLastMacroblockInSlice (img->current_mb_nr);
  238|       |      // Proceed to next slice
  239|    171|      img->current_slice_nr++;
  240|    171|      stats->bit_slice = 0;
  241|    171|    }
  242|       |    // Proceed to next SliceGroup
  243|    171|    SliceGroup++;
  244|    171|  }
  245|    171|  FmoEndPicture ();
  246|       |
  247|    171|  if (input->rdopt == 2 && (img->type != B_SLICE))
  248|      0|    for (j = 0; j < input->NoOfDecoders; j++)
  249|      0|      DeblockFrame (img, decs->decY_best[j], NULL);
  250|       |
  251|    171|  DeblockFrame (img, enc_picture->imgY, enc_picture->imgUV); //comment out to disable loop filter
  252|       |
  253|    171|  if (img->MbaffFrameFlag)
  254|      0|    MbAffPostProc();
  255|       |
  256|    171|}
  257|       |
  258|       |
  259|       |
  260|       |/*!
  261|       | ************************************************************************
  262|       | * \brief
  263|       | *    Encodes one frame
  264|       | ************************************************************************
  265|       | */
  266|       |int encode_one_frame ()
  267|    171|{
  268|    171|  static int prev_frame_no = 0; // POC200301
  269|    171|  static int consecutive_non_reference_pictures = 0; // POC200301
  270|    171|  int        FrameNumberInFile;
  271|       |
  272|    171|#ifdef _LEAKYBUCKET_
  273|    171|  extern long Bit_Buffer[10000];
  274|    171|  extern unsigned long total_frame_buffer;
  275|    171|#endif
  276|       |
  277|    171|  time_t ltime1;
  278|    171|  time_t ltime2;
  279|       |
  280|       |#ifdef WIN32
  281|       |  struct _timeb tstruct1;
  282|       |  struct _timeb tstruct2;
  283|       |#else
  284|    171|  struct timeb tstruct1;
  285|    171|  struct timeb tstruct2;
  286|    171|#endif
  287|       |
  288|    171|  int tmp_time;
  289|    171|  int bits_frm = 0, bits_fld = 0;
  290|    171|  float dis_frm = 0, dis_frm_y = 0, dis_frm_u = 0, dis_frm_v = 0;
  291|    171|  float dis_fld = 0, dis_fld_y = 0, dis_fld_u = 0, dis_fld_v = 0;
  292|       |
  293|       |  //Rate control
  294|    171|  int pic_type, bits = 0; 
  295|       |
  296|    171|  me_time=0;
  297|    171|  img->rd_pass = 0;
  298|    171|  enc_frame_picture  = NULL;
  299|    171|  enc_frame_picture2 = NULL;
  300|    171|  enc_frame_picture3 = NULL;
  301|       |
  302|    171|#if defined(SPEC_CPU)
  303|    171|  tstruct1.time = 0;
  304|    171|  tstruct1.millitm = 0;
  305|    171|  tstruct1.timezone = 0;                 
  306|    171|  tstruct1.dstflag = 0;
  307|    171|  ltime1 = 0;
  308|       |#else 
  309|       |#ifdef WIN32
  310|       |  _ftime (&tstruct1);           // start time ms
  311|       |#else
  312|       |  ftime (&tstruct1);
  313|       |#endif
  314|       |  time (&ltime1);               // start time s
  315|       |#endif /* !SPEC_CPU */
  316|       |
  317|       |  //Rate control 
  318|    171|  img->write_macroblock = 0;
  319|       |/*
  320|       |  //Shankar Regunathan (Oct 2002)
  321|       |  //Prepare Panscanrect SEI payload
  322|       |  UpdatePanScanRectInfo ();
  323|       |  //Prepare Arbitrarydata SEI Payload
  324|       |  UpdateUser_data_unregistered ();
  325|       |  //Prepare Registered data SEI Payload
  326|       |  UpdateUser_data_registered_itu_t_t35 ();
  327|       |  //Prepare RandomAccess SEI Payload
  328|       |  UpdateRandomAccess ();
  329|       |*/
  330|       |
  331|    171|  if (input->ResendPPS && img->number !=0)
  332|      0|  {
  333|      0|    stats->bit_ctr_parametersets_n=write_PPS(0, 0);
  334|       |    //stats->bit_slice += stats->bit_ctr_parametersets_n;
  335|      0|    stats->bit_ctr_parametersets += stats->bit_ctr_parametersets_n;
  336|      0|  }
  337|       |
  338|    171|  put_buffer_frame ();      // sets the pointers to the frame structures 
  339|       |                            // (and not to one of the field structures)
  340|    171|  init_frame ();
  341|    171|  FrameNumberInFile = CalculateFrameNumber();
  342|       |
  343|    171|  ReadOneFrame (FrameNumberInFile, input->infile_header,
  344|    171|                input->img_width, input->img_height, input->img_width_cr, input->img_height_cr);
  345|       |
  346|    171|  PaddAutoCropBorders (input->img_width, input->img_height, img->width, img->height,
  347|    171|                       input->img_width_cr, input->img_height_cr, img->width_cr, img->height_cr);
  348|       |
  349|       |  // set parameters for direct mode and deblocking filter
  350|    171|  img->direct_spatial_mv_pred_flag     = input->direct_spatial_mv_pred_flag;
  351|    171|  img->LFDisableIdc    = input->LFDisableIdc;
  352|    171|  img->LFAlphaC0Offset = input->LFAlphaC0Offset;
  353|    171|  img->LFBetaOffset    = input->LFBetaOffset;
  354|       |
  355|       |  // Following code should consider optimal coding mode. Currently also does not support
  356|       |  // multiple slices per frame.
  357|    171|  if (img->type == B_SLICE)
  358|     85|    Bframe_ctr++;         // Bframe_ctr only used for statistics, should go to stats->
  359|     86|  else if (img->type == I_SLICE)
  360|     29|    Iframe_ctr++;         // Iframe_ctr only used for statistics, should go to stats->
  361|     57|  else
  362|     57|    Pframe_ctr++;         // Pframe_ctr only used for statistics, should go to stats->
  363|       |
  364|    171|  if (input->PicInterlace == FIELD_CODING)
  365|      0|  {
  366|       |    //Rate control
  367|      0|    img->FieldControl=1;
  368|       |
  369|      0|    img->field_picture = 1;  // we encode fields
  370|      0|    field_picture (top_pic, bottom_pic);
  371|      0|    img->fld_flag = 1;
  372|      0|  }
  373|    171|  else
  374|    171|  {
  375|       |    //Rate control
  376|    171|    img->FieldControl=0;
  377|       |
  378|       |    // For frame coding, turn MB level field/frame coding flag on
  379|    171|    if (input->MbInterlace)
  380|      0|      mb_adaptive = 1;
  381|       |
  382|    171|    img->field_picture = 0; // we encode a frame
  383|       |
  384|       |    //Rate control
  385|    171|    if(input->RCEnable)
  386|      0|    { 
  387|       |    /*update the number of MBs in the basic unit for MB adaptive 
  388|       |      f/f coding*/
  389|      0|      if((input->MbInterlace)&&(input->basicunit<img->Frame_Total_Number_MB)\
  390|      0|        &&(img->type==P_SLICE)&&(img->IFLAG==0))
  391|      0|        img->BasicUnit=input->basicunit*2;
  392|      0|      else
  393|      0|        img->BasicUnit=input->basicunit;
  394|       |      
  395|      0|      rc_init_pict(1,0,1); 
  396|      0|      img->qp  = updateQuantizationParameter(0); 
  397|       |      
  398|       |      
  399|      0|      pic_type = img->type;
  400|      0|      QP =0;
  401|      0|    }
  402|       |
  403|    171|    if( active_sps->frame_mbs_only_flag)
  404|    171|      img->TopFieldFlag=0;
  405|       |
  406|    171|    if (input->GenerateMultiplePPS)
  407|      0|      active_pps = &PicParSet[0];
  408|       |
  409|    171|    frame_picture (frame_pic, 0);
  410|       |   
  411|    171|    if ((input->RDPictureIntra || img->type!=I_SLICE) && input->RDPictureDecision)
  412|      0|    {
  413|      0|      rdPictureCoding();
  414|      0|    }         
  415|       |    
  416|       |    // For field coding, turn MB level field/frame coding flag off
  417|    171|    if (input->MbInterlace)
  418|      0|      mb_adaptive = 0;
  419|       |    
  420|    171|    if (input->PicInterlace == ADAPTIVE_CODING)
  421|      0|    {
  422|       |      //Rate control
  423|      0|      img->FieldControl=1;
  424|      0|      img->write_macroblock = 0;
  425|      0|      img->bot_MB = 0;
  426|       |
  427|      0|      img->field_picture = 1;  // we encode fields
  428|      0|      field_picture (top_pic, bottom_pic);
  429|       |      
  430|       |      //! Note: the distortion for a field coded picture is stored in the top field
  431|       |      //! the distortion values in the bottom field are dummies
  432|      0|      dis_fld = top_pic->distortion_y + top_pic->distortion_u + top_pic->distortion_v;
  433|      0|      dis_frm = frame_pic->distortion_y + frame_pic->distortion_u + frame_pic->distortion_v;
  434|       |      
  435|      0|      img->fld_flag = picture_structure_decision (frame_pic, top_pic, bottom_pic);
  436|      0|      update_field_frame_contexts (img->fld_flag);
  437|       |
  438|       |      //Rate control
  439|      0|      if(img->fld_flag==0)
  440|      0|        img->FieldFrame=1;
  441|       |      /*the current choice is field coding*/
  442|      0|      else
  443|      0|        img->FieldFrame=0;
  444|      0|    }
  445|    171|    else
  446|       |   
  447|    171|      img->fld_flag = 0;
  448|    171|  }
  449|       |
  450|    171|  if (img->fld_flag)
  451|      0|    stats->bit_ctr_emulationprevention += stats->em_prev_bits_fld;
  452|    171|  else
  453|    171|    stats->bit_ctr_emulationprevention += stats->em_prev_bits_frm;
  454|       |
  455|    171|  if (img->type != B_SLICE)
  456|     86|  {
  457|     86|    img->pstruct_next_P = img->fld_flag;
  458|     86|  }
  459|       |
  460|       |  // Here, img->structure may be either FRAME or BOTTOM FIELD depending on whether AFF coding is used
  461|       |  // The picture structure decision changes really only the fld_flag
  462|       |
  463|    171|  if (img->fld_flag)            // field mode (use field when fld_flag=1 only)
  464|      0|  {
  465|      0|    field_mode_buffer (bits_fld, dis_fld_y, dis_fld_u, dis_fld_v);
  466|      0|    writeout_picture (top_pic);
  467|      0|    writeout_picture (bottom_pic);
  468|      0|  }
  469|    171|  else                          //frame mode
  470|    171|  {
  471|    171|    frame_mode_buffer (bits_frm, dis_frm_y, dis_frm_u, dis_frm_v);
  472|       |    
  473|    171|    if (input->RDPictureDecision && img->rd_pass == 2)
  474|      0|      writeout_picture (frame_pic3);
  475|    171|    else if (input->RDPictureDecision && img->rd_pass == 1)
  476|      0|      writeout_picture (frame_pic2);
  477|    171|    else
  478|    171|      writeout_picture (frame_pic);
  479|    171|  }
  480|       |
  481|    171|  if (frame_pic3)
  482|      0|    free_slice_list(frame_pic3);  
  483|    171|  if (frame_pic2)
  484|      0|    free_slice_list(frame_pic2);  
  485|    171|  if (frame_pic)
  486|    171|    free_slice_list(frame_pic);
  487|    171|  if (top_pic)
  488|      0|    free_slice_list(top_pic);
  489|    171|  if (bottom_pic)
  490|      0|    free_slice_list(bottom_pic);
  491|       |
  492|       |  /*
  493|       |  // Tian Dong (Sept 2002)
  494|       |  // in frame mode, the newly reconstructed frame has been inserted to the mem buffer
  495|       |  // and it is time to prepare the spare picture SEI payload.
  496|       |  if (input->InterlaceCodingOption == FRAME_CODING
  497|       |      && input->SparePictureOption && img->type != B_SLICE)
  498|       |    CalculateSparePicture ();
  499|       |*/
  500|       |
  501|       |  //Rate control
  502|    171|  if(input->RCEnable)
  503|      0|  {
  504|      0|    bits = stats->bit_ctr-stats->bit_ctr_n;
  505|      0|    rc_update_pict_frame(bits);
  506|      0|  }
  507|       |
  508|       |/*
  509|       |    
  510|       |  if (input->InterlaceCodingOption == FRAME_CODING)
  511|       |  {
  512|       |    if (input->rdopt == 2 && img->type != B_SLICE)
  513|       |      UpdateDecoders ();      // simulate packet losses and move decoded image to reference buffers
  514|       |    
  515|       |    if (input->RestrictRef)
  516|       |      UpdatePixelMap ();
  517|       |  }
  518|       |*/
  519|       |
  520|    171|  find_snr ();
  521|       |
  522|    171|#if defined(SPEC_CPU)
  523|    171|  ltime2 = 0;
  524|    171|  tstruct2.time = 0;
  525|    171|  tstruct2.millitm = 0;
  526|    171|  tstruct2.timezone = 0;
  527|    171|  tstruct2.dstflag = 0;
  528|       |#else
  529|       |  time (&ltime2);               // end time sec
  530|       |#ifdef WIN32
  531|       |  _ftime (&tstruct2);           // end time ms
  532|       |#else
  533|       |  ftime (&tstruct2);            // end time ms
  534|       |#endif
  535|       |#endif /* !SPEC_CPU */
  536|       |
  537|    171|  tmp_time = (ltime2 * 1000 + tstruct2.millitm) - (ltime1 * 1000 + tstruct1.millitm);
  538|    171|  tot_time = tot_time + tmp_time;
  539|       |
  540|    171|  if (input->PicInterlace == ADAPTIVE_CODING)
  541|      0|  {
  542|      0|    if (img->fld_flag)
  543|      0|    {
  544|       |      // store bottom field
  545|      0|      store_picture_in_dpb(enc_bottom_picture);
  546|      0|      free_storable_picture(enc_frame_picture);
  547|      0|    }
  548|      0|    else
  549|      0|    {
  550|       |      // replace top with frame
  551|      0|      replace_top_pic_with_frame(enc_frame_picture);
  552|      0|      free_storable_picture(enc_bottom_picture);
  553|      0|    }
  554|      0|  }
  555|    171|  else
  556|    171|  {
  557|    171|    if (img->fld_flag)
  558|      0|    {
  559|      0|      store_picture_in_dpb(enc_bottom_picture);
  560|      0|    }
  561|    171|    else
  562|    171|    {
  563|    171|      if (img->rd_pass==2)
  564|      0|      {
  565|      0|        store_picture_in_dpb(enc_frame_picture3);
  566|      0|        free_storable_picture(enc_frame_picture);
  567|      0|        free_storable_picture(enc_frame_picture2);
  568|      0|      }
  569|    171|      else if (img->rd_pass==1)
  570|      0|      {
  571|      0|        store_picture_in_dpb(enc_frame_picture2);
  572|      0|        free_storable_picture(enc_frame_picture);
  573|      0|        free_storable_picture(enc_frame_picture3);
  574|      0|      }
  575|    171|      else
  576|    171|      {
  577|    171|        store_picture_in_dpb(enc_frame_picture);
  578|    171|        free_storable_picture(enc_frame_picture2);
  579|    171|        free_storable_picture(enc_frame_picture3);
  580|    171|      }
  581|    171|    }
  582|    171|  }
  583|       |
  584|       |
  585|    171|#ifdef _LEAKYBUCKET_
  586|       |  // Store bits used for this frame and increment counter of no. of coded frames
  587|    171|  Bit_Buffer[total_frame_buffer] = stats->bit_ctr - stats->bit_ctr_n;
  588|    171|  total_frame_buffer++;
  589|    171|#endif
  590|       |
  591|       |  // POC200301: Verify that POC coding type 2 is not used if more than one consecutive 
  592|       |  // non-reference frame is requested or if decoding order is different from output order
  593|    171|  if (img->pic_order_cnt_type == 2)
  594|      0|  {
  595|      0|    if (!img->nal_reference_idc) consecutive_non_reference_pictures++;
  596|      0|    else consecutive_non_reference_pictures = 0;
  597|       |
  598|      0|    if (frame_no < prev_frame_no || consecutive_non_reference_pictures>1)
  599|      0|      error("POC type 2 cannot be applied for the coding pattern where the encoding /decoding order of pictures are different from the output order.\n", -1);
  600|      0|    prev_frame_no = frame_no;
  601|      0|  }
  602|       |
  603|    171|  if (stats->bit_ctr_parametersets_n!=0)
  604|      1|    ReportNALNonVLCBits(tmp_time, me_time);
  605|       |
  606|    171|  if (IMG_NUMBER == 0)
  607|      1|    ReportFirstframe(tmp_time,me_time);
  608|       |    //ReportFirstframe(tmp_time);
  609|    170|  else
  610|    170|  {
  611|       |    //Rate control
  612|    170|    if(input->RCEnable)
  613|      0|    {
  614|      0|      if((!input->PicInterlace)&&(!input->MbInterlace))
  615|      0|        bits=stats->bit_ctr-stats->bit_ctr_n;
  616|      0|      else
  617|      0|      {
  618|      0|        bits = stats->bit_ctr -Pprev_bits; // used for rate control update */
  619|      0|        Pprev_bits = stats->bit_ctr;
  620|      0|      }
  621|      0|    }
  622|       |
  623|    170|    switch (img->type)
  624|    170|    {
  625|     28|    case I_SLICE:
  626|     28|      stats->bit_ctr_I += stats->bit_ctr - stats->bit_ctr_n;
  627|     28|      ReportIntra(tmp_time,me_time);
  628|     28|      break;
  629|      0|    case SP_SLICE:
  630|      0|      stats->bit_ctr_P += stats->bit_ctr - stats->bit_ctr_n;
  631|      0|      ReportSP(tmp_time,me_time);
  632|      0|      break;
  633|     85|    case B_SLICE:
  634|     85|      stats->bit_ctr_B += stats->bit_ctr - stats->bit_ctr_n;
  635|     85|      if (img->nal_reference_idc>0)
  636|      0|        ReportRB(tmp_time,me_time);
  637|     85|      else
  638|     85|        ReportB(tmp_time,me_time);
  639|       |
  640|     85|      break;
  641|     57|    default:      // P
  642|     57|      stats->bit_ctr_P += stats->bit_ctr - stats->bit_ctr_n;
  643|     57|      ReportP(tmp_time,me_time);
  644|    170|    }
  645|    170|  }
  646|       |
  647|    171|  stats->bit_ctr_n = stats->bit_ctr;
  648|       |
  649|       |  //Rate control
  650|    171|  if(input->RCEnable) 
  651|      0|  {
  652|      0|    rc_update_pict(bits);
  653|       |      /*update the parameters of quadratic R-D model*/
  654|      0|    if((img->type==P_SLICE)&&(active_sps->frame_mbs_only_flag))
  655|      0|      updateRCModel();
  656|      0|    else if((img->type==P_SLICE)&&(!active_sps->frame_mbs_only_flag)\
  657|      0|      &&(img->IFLAG==0))
  658|      0|      updateRCModel();
  659|      0|  }
  660|       |
  661|    171|  stats->bit_ctr_parametersets_n=0;
  662|       |
  663|    171|  if (IMG_NUMBER == 0)
  664|      1|    return 0;
  665|    170|  else
  666|    170|    return 1;
  667|    171|}
  668|       |
  669|       |
  670|       |/*!
  671|       | ************************************************************************
  672|       | * \brief
  673|       | *    This function write out a picture
  674|       | * \return
  675|       | *    0 if OK,                                                         \n
  676|       | *    1 in case of error
  677|       | *
  678|       | ************************************************************************
  679|       | */
  680|       |static int writeout_picture(Picture *pic)
  681|    171|{
  682|    171|  Bitstream *currStream;
  683|    171|  int partition, slice;
  684|    171|  Slice *currSlice;
  685|       |
  686|    171|  img->currentPicture=pic;
  687|       |
  688|    342|  for (slice=0; slice<pic->no_slices; slice++)
  689|    171|  {
  690|    171|    currSlice = pic->slices[slice];
  691|    342|    for (partition=0; partition<currSlice->max_part_nr; partition++)
  692|    171|    {
  693|    171|      currStream = (currSlice->partArr[partition]).bitstream;
  694|    171|      assert (currStream->bits_to_go == 8);    //! should always be the case, the 
  695|       |                                               //! byte alignment is done in terminate_slice
  696|    171|      writeUnit (currSlice->partArr[partition].bitstream,partition);
  697|       |
  698|    171|    }           // partition loop
  699|    171|  }           // slice loop
  700|    171|  return 0;   
  701|    171|}
  702|       |
  703|       |
  704|       |void copy_params()
  705|    171|{
  706|    171|  enc_picture->frame_mbs_only_flag = active_sps->frame_mbs_only_flag;
  707|    171|  enc_picture->frame_cropping_flag = active_sps->frame_cropping_flag;
  708|    171|  enc_picture->chroma_format_idc   = active_sps->chroma_format_idc;
  709|       |
  710|    171|  if (active_sps->frame_cropping_flag)
  711|      0|  {
  712|      0|    enc_picture->frame_cropping_rect_left_offset=active_sps->frame_cropping_rect_left_offset; 
  713|      0|    enc_picture->frame_cropping_rect_right_offset=active_sps->frame_cropping_rect_right_offset; 
  714|      0|    enc_picture->frame_cropping_rect_top_offset=active_sps->frame_cropping_rect_top_offset; 
  715|      0|    enc_picture->frame_cropping_rect_bottom_offset=active_sps->frame_cropping_rect_bottom_offset; 
  716|      0|  }
  717|    171|  else
  718|    171|  {
  719|    171|    enc_picture->frame_cropping_rect_left_offset=0; 
  720|    171|    enc_picture->frame_cropping_rect_right_offset=0; 
  721|    171|    enc_picture->frame_cropping_rect_top_offset=0; 
  722|    171|    enc_picture->frame_cropping_rect_bottom_offset=0; 
  723|    171|  }
  724|    171|}
  725|       |
  726|       |/*!
  727|       | ************************************************************************
  728|       | * \brief
  729|       | *    Encodes a frame picture
  730|       | ************************************************************************
  731|       | */
  732|       |void frame_picture (Picture *frame, int rd_pass)
  733|    171|{
  734|       |
  735|    171|  img->structure = FRAME;
  736|    171|  img->PicSizeInMbs = img->FrameSizeInMbs;
  737|       |
  738|    171|  if (rd_pass == 2)
  739|      0|  {
  740|      0|    enc_frame_picture3  = alloc_storable_picture (img->structure, img->width, img->height, img->width_cr, img->height_cr);
  741|      0|    img->ThisPOC=enc_frame_picture3->poc=img->framepoc;
  742|      0|    enc_frame_picture3->top_poc    = img->toppoc;
  743|      0|    enc_frame_picture3->bottom_poc = img->bottompoc;
  744|       |    
  745|      0|    enc_frame_picture3->frame_poc = img->framepoc;
  746|       |    
  747|      0|    enc_frame_picture3->pic_num = img->frame_num;
  748|      0|    enc_frame_picture3->frame_num = img->frame_num;
  749|      0|    enc_frame_picture3->coded_frame = 1;
  750|       |    
  751|      0|    enc_frame_picture3->MbaffFrameFlag = img->MbaffFrameFlag = (input->MbInterlace != FRAME_CODING);
  752|       |    
  753|      0|    enc_picture=enc_frame_picture3;
  754|      0|    copy_params();
  755|      0|  }
  756|    171|  else if (rd_pass == 1)
  757|      0|  {
  758|      0|    enc_frame_picture2  = alloc_storable_picture (img->structure, img->width, img->height, img->width_cr, img->height_cr);
  759|      0|    img->ThisPOC=enc_frame_picture2->poc=img->framepoc;
  760|      0|    enc_frame_picture2->top_poc    = img->toppoc;
  761|      0|    enc_frame_picture2->bottom_poc = img->bottompoc;
  762|       |    
  763|      0|    enc_frame_picture2->frame_poc = img->framepoc;
  764|       |    
  765|      0|    enc_frame_picture2->pic_num = img->frame_num;
  766|      0|    enc_frame_picture2->frame_num = img->frame_num;
  767|      0|    enc_frame_picture2->coded_frame = 1;
  768|       |    
  769|      0|    enc_frame_picture2->MbaffFrameFlag = img->MbaffFrameFlag = (input->MbInterlace != FRAME_CODING);
  770|       |    
  771|      0|    enc_picture=enc_frame_picture2;
  772|      0|    copy_params();
  773|      0|  }
  774|    171|  else
  775|    171|  {
  776|    171|    enc_frame_picture  = alloc_storable_picture (img->structure, img->width, img->height, img->width_cr, img->height_cr);
  777|    171|    img->ThisPOC=enc_frame_picture->poc=img->framepoc;
  778|    171|    enc_frame_picture->top_poc    = img->toppoc;
  779|    171|    enc_frame_picture->bottom_poc = img->bottompoc;
  780|       |    
  781|    171|    enc_frame_picture->frame_poc = img->framepoc;
  782|       |    
  783|    171|    enc_frame_picture->pic_num = img->frame_num;
  784|    171|    enc_frame_picture->frame_num = img->frame_num;
  785|    171|    enc_frame_picture->coded_frame = 1;
  786|       |    
  787|    171|    enc_frame_picture->MbaffFrameFlag = img->MbaffFrameFlag = (input->MbInterlace != FRAME_CODING);
  788|       |    
  789|    171|    enc_picture=enc_frame_picture;
  790|    171|    copy_params();
  791|    171|  }
  792|       |
  793|       |
  794|    171|  stats->em_prev_bits_frm = 0;
  795|    171|  stats->em_prev_bits = &stats->em_prev_bits_frm;
  796|       |
  797|    171|  img->fld_flag = 0;
  798|    171|  code_a_picture(frame);
  799|       |
  800|    171|  frame->bits_per_picture = 8 * ((((img->currentSlice)->partArr[0]).bitstream)->byte_pos);
  801|       |  
  802|    171|  if (img->structure==FRAME)
  803|    171|  {
  804|    171|    find_distortion (snr, img);      
  805|    171|    frame->distortion_y = snr->snr_y;
  806|    171|    frame->distortion_u = snr->snr_u;
  807|    171|    frame->distortion_v = snr->snr_v;
  808|    171|  }
  809|    171|}
  810|       |
  811|       |
  812|       |/*!
  813|       | ************************************************************************
  814|       | * \brief
  815|       | *    Encodes a field picture, consisting of top and bottom field
  816|       | ************************************************************************
  817|       | */
  818|       |void field_picture (Picture *top, Picture *bottom)
  819|      0|{
  820|       |  //Rate control
  821|      0|  int old_pic_type;              // picture type of top field used for rate control    
  822|      0|  int TopFieldBits;
  823|       |  
  824|       |  //Rate control
  825|      0|  old_pic_type = img->type;
  826|       |
  827|      0|  stats->em_prev_bits_fld = 0;
  828|      0|  stats->em_prev_bits = &stats->em_prev_bits_fld;
  829|      0|  img->number *= 2;
  830|      0|  img->buf_cycle *= 2;
  831|      0|  img->height = (input->img_height+img->auto_crop_bottom) / 2; 
  832|      0|  img->height_cr = img->height_cr_frame / 2;
  833|      0|  img->fld_flag = 1;
  834|      0|  img->PicSizeInMbs = img->FrameSizeInMbs/2;
  835|       |  // Top field
  836|       |  
  837|       |//  img->bottom_field_flag = 0;
  838|      0|  enc_top_picture  = alloc_storable_picture (img->structure, img->width, img->height, img->width_cr, img->height_cr);
  839|      0|  enc_top_picture->poc=img->toppoc;
  840|      0|  enc_top_picture->frame_poc = img->toppoc;
  841|      0|  enc_top_picture->pic_num = img->frame_num;
  842|      0|  enc_top_picture->frame_num = img->frame_num;
  843|      0|  enc_top_picture->coded_frame = 0;
  844|      0|  enc_top_picture->MbaffFrameFlag = img->MbaffFrameFlag = FALSE;
  845|      0|  img->ThisPOC = img->toppoc;
  846|       |  
  847|      0|  img->structure = TOP_FIELD;
  848|      0|  enc_picture = enc_top_picture;
  849|      0|  copy_params();
  850|       |
  851|      0|  put_buffer_top ();
  852|      0|  init_field ();
  853|      0|  if (img->type == B_SLICE)       //all I- and P-frames
  854|      0|    nextP_tr_fld--;
  855|       |
  856|       |
  857|      0|  img->fld_flag = 1;
  858|       |//  img->bottom_field_flag = 0;
  859|       | 
  860|       |  //Rate control
  861|      0|  if(input->RCEnable)
  862|      0|  {
  863|      0|    img->BasicUnit=input->basicunit;
  864|       |
  865|      0|    if(input->PicInterlace==FIELD_CODING)
  866|      0|      rc_init_pict(0,1,1); 
  867|      0|    else
  868|      0|      rc_init_pict(0,1,0);
  869|       |
  870|      0|    img->qp  = updateQuantizationParameter(1); 
  871|      0|   }
  872|      0|  img->TopFieldFlag=1;
  873|       |
  874|      0|  code_a_picture(top_pic);
  875|      0|  enc_picture->structure = 1;
  876|       |    
  877|      0|  store_picture_in_dpb(enc_top_picture);
  878|       |
  879|      0|  top->bits_per_picture = 8 * ((((img->currentSlice)->partArr[0]).bitstream)->byte_pos);
  880|       |
  881|       |  //Rate control
  882|      0|  TopFieldBits=top->bits_per_picture;
  883|       |
  884|       |  //  Bottom field
  885|       |//  img->bottom_field_flag = 0;
  886|      0|  enc_bottom_picture  = alloc_storable_picture (img->structure, img->width, img->height, img->width_cr, img->height_cr);
  887|      0|  enc_bottom_picture->poc=img->bottompoc;
  888|      0|  enc_bottom_picture->frame_poc = img->bottompoc;
  889|      0|  enc_bottom_picture->pic_num = img->frame_num;
  890|      0|  enc_bottom_picture->frame_num = img->frame_num;
  891|      0|  enc_bottom_picture->coded_frame = 0;
  892|      0|  enc_bottom_picture->MbaffFrameFlag = img->MbaffFrameFlag = FALSE;
  893|      0|  img->ThisPOC = img->bottompoc;
  894|      0|  img->structure = BOTTOM_FIELD;
  895|      0|  enc_picture = enc_bottom_picture;
  896|      0|  copy_params();
  897|      0|  put_buffer_bot ();
  898|      0|  img->number++;
  899|       |
  900|      0|  init_field ();
  901|       |
  902|      0|  if (img->type == B_SLICE)       //all I- and P-frames
  903|      0|    nextP_tr_fld++;             //check once coding B field
  904|       |
  905|      0| if (img->type == I_SLICE && input->IntraBottom!=1)
  906|      0|    img->type = P_SLICE;
  907|       |
  908|      0|  img->fld_flag = 1;
  909|       |//  img->bottom_field_flag = 1;
  910|       |
  911|       |  //Rate control
  912|      0|  if(input->RCEnable)  setbitscount(TopFieldBits);
  913|      0|  if(input->RCEnable)
  914|      0|  {
  915|      0|    rc_init_pict(0,0,0); 
  916|      0|    img->qp  = updateQuantizationParameter(0); 
  917|      0|  }
  918|      0|  img->TopFieldFlag=0;
  919|       |
  920|      0|  enc_picture->structure = 2;
  921|      0|  code_a_picture(bottom_pic);
  922|       |
  923|      0|  bottom->bits_per_picture = 8 * ((((img->currentSlice)->partArr[0]).bitstream)->byte_pos);
  924|       |
  925|       |  // the distortion for a field coded frame (consisting of top and bottom field)
  926|       |  // lives in the top->distortion varaibles, thye bottom-> are dummies
  927|      0|  distortion_fld (&top->distortion_y, &top->distortion_u, &top->distortion_v);
  928|       |
  929|      0|}
  930|       |
  931|       |
  932|       |/*!
  933|       | ************************************************************************
  934|       | * \brief
  935|       | *    Distortion Field
  936|       | ************************************************************************
  937|       | */
  938|       |static void distortion_fld (float *dis_fld_y, float *dis_fld_u, float *dis_fld_v)
  939|      0|{
  940|       |
  941|      0|  img->number /= 2;
  942|      0|  img->buf_cycle /= 2;
  943|      0|  img->height = (input->img_height+img->auto_crop_bottom);
  944|      0|  img->height_cr = img->height_cr_frame;
  945|      0|  img->total_number_mb =
  946|      0|    (img->width * img->height) / (MB_BLOCK_SIZE * MB_BLOCK_SIZE);
  947|       |
  948|      0|  combine_field ();
  949|       |
  950|      0|  imgY_org = imgY_org_frm;
  951|      0|  imgUV_org = imgUV_org_frm;
  952|       |
  953|      0|  find_distortion (snr, img);   // find snr from original frame picture
  954|       |
  955|      0|  *dis_fld_y = snr->snr_y;
  956|      0|  *dis_fld_u = snr->snr_u;
  957|      0|  *dis_fld_v = snr->snr_v;
  958|      0|}
  959|       |
  960|       |
  961|       |/*!
  962|       | ************************************************************************
  963|       | * \brief
  964|       | *    Picture Structure Decision
  965|       | ************************************************************************
  966|       | */
  967|       |static int picture_structure_decision (Picture *frame, Picture *top, Picture *bot)
  968|      0|{
  969|      0|  double lambda_picture;
  970|      0|  int bframe = (img->type == B_SLICE);
  971|      0|  float snr_frame, snr_field;
  972|      0|  int bit_frame, bit_field;
  973|       |
  974|      0|  lambda_picture = 0.85 * pow (2, img->bitdepth_lambda_scale + ((img->qp - SHIFT_QP) / 3.0)) * (bframe ? 4 : 1);
  975|       |  
  976|      0|  snr_frame = frame->distortion_y + frame->distortion_u + frame->distortion_v;
  977|       |  //! all distrortions of a field picture are accumulated in the top field
  978|      0|  snr_field = top->distortion_y + top->distortion_u + top->distortion_v;
  979|      0|  bit_field = top->bits_per_picture + bot->bits_per_picture;
  980|      0|  bit_frame = frame->bits_per_picture;
  981|       |
  982|      0|  return decide_fld_frame (snr_frame, snr_field, bit_field, bit_frame, lambda_picture);
  983|      0|}
  984|       |
  985|       |
  986|       |/*!
  987|       | ************************************************************************
  988|       | * \brief
  989|       | *    Field Mode Buffer
  990|       | ************************************************************************
  991|       | */
  992|       |static void field_mode_buffer (int bit_field, float snr_field_y, float snr_field_u, float snr_field_v)
  993|      0|{
  994|      0|  put_buffer_frame ();
  995|       |
  996|      0|  snr->snr_y = snr_field_y;
  997|      0|  snr->snr_u = snr_field_u;
  998|      0|  snr->snr_v = snr_field_v;
  999|      0|}
 1000|       |
 1001|       |
 1002|       |/*!
 1003|       | ************************************************************************
 1004|       | * \brief
 1005|       | *    Frame Mode Buffer
 1006|       | ************************************************************************
 1007|       | */
 1008|       |static void frame_mode_buffer (int bit_frame, float snr_frame_y, float snr_frame_u, float snr_frame_v)
 1009|    171|{
 1010|    171|  put_buffer_frame ();
 1011|       |
 1012|    171|  if ((input->PicInterlace != FRAME_CODING)||(input->MbInterlace != FRAME_CODING))
 1013|      0|  {
 1014|      0|    img->height = img->height / 2;
 1015|      0|    img->height_cr = img->height_cr / 2;
 1016|      0|    img->number *= 2;
 1017|       |    
 1018|      0|    put_buffer_top ();
 1019|       |     
 1020|      0|    img->number++;
 1021|      0|    put_buffer_bot ();
 1022|       |    
 1023|      0|    img->number /= 2;         // reset the img->number to field
 1024|      0|    img->height = (input->img_height+img->auto_crop_bottom);
 1025|      0|    img->height_cr = img->height_cr_frame;
 1026|      0|    img->total_number_mb =
 1027|      0|      (img->width * img->height) / (MB_BLOCK_SIZE * MB_BLOCK_SIZE);
 1028|       |    
 1029|      0|    snr->snr_y = snr_frame_y;
 1030|      0|    snr->snr_u = snr_frame_u;
 1031|      0|    snr->snr_v = snr_frame_v;
 1032|      0|    put_buffer_frame ();
 1033|       |    
 1034|      0|  }
 1035|    171|}
 1036|       |
 1037|       |
 1038|       |/*!
 1039|       | ************************************************************************
 1040|       | * \brief
 1041|       | *    mmco initializations should go here
 1042|       | ************************************************************************
 1043|       | */
 1044|       |static void init_dec_ref_pic_marking_buffer()
 1045|    171|{
 1046|    171|  img->dec_ref_pic_marking_buffer=NULL;
 1047|    171|}
 1048|       |
 1049|       |
 1050|       |/*!
 1051|       | ************************************************************************
 1052|       | * \brief
 1053|       | *    Initializes the parameters for a new frame
 1054|       | ************************************************************************
 1055|       | */
 1056|       |static void init_frame ()
 1057|    171|{
 1058|    171|  int i;
 1059|    171|  int prevP_no, nextP_no;
 1060|       |  
 1061|    171|  last_P_no = last_P_no_frm;
 1062|       |
 1063|    171|  img->current_mb_nr = 0;
 1064|    171|  img->current_slice_nr = 0;
 1065|    171|  stats->bit_slice = 0;
 1066|       |
 1067|    171|  img->mb_y = img->mb_x = 0;
 1068|    171|  img->block_y = img->pix_y = img->pix_c_y = 0; 
 1069|    171|  img->block_x = img->pix_x = img->block_c_x = img->pix_c_x = 0;
 1070|       |
 1071|       |  // The 'slice_nr' of each macroblock is set to -1 here, to guarantee the correct encoding 
 1072|       |  // with FMO (if no FMO, encoding is correct without following assignment), 
 1073|       |  // for which MBs may not be encoded with scan order
 1074|   109k|  for(i=0;i< ((img->width/MB_BLOCK_SIZE)*(img->height/MB_BLOCK_SIZE));i++)
 1075|   109k|    img->mb_data[i].slice_nr=-1;
 1076|       |	
 1077|       |  //if (img->type != B_SLICE)
 1078|    171|  if (img->b_frame_to_code == 0)
 1079|     86|  {
 1080|     86|    img->tr = start_tr_in_this_IGOP + IMG_NUMBER * (input->jumpd + 1);
 1081|       |    
 1082|     86|    img->imgtr_last_P_frm = img->imgtr_next_P_frm;
 1083|     86|    img->imgtr_next_P_frm = img->tr;
 1084|       |    
 1085|     86|#ifdef _ADAPT_LAST_GROUP_
 1086|     86|    if (input->last_frame && img->number + 1 == input->no_frames)
 1087|      0|      img->tr = input->last_frame;
 1088|     86|#endif
 1089|       |    
 1090|     86|    if (IMG_NUMBER != 0 && input->successive_Bframe != 0)     // B pictures to encode
 1091|     85|      nextP_tr_frm = img->tr;
 1092|       |    
 1093|       |    //Rate control
 1094|     86|    if(!input->RCEnable)                  // without using rate control
 1095|     86|    {
 1096|     86|      if (img->type == I_SLICE)
 1097|     29|#ifdef _CHANGE_QP_
 1098|     29|        if (input->qp2start > 0 && img->tr >= input->qp2start)
 1099|      0|          img->qp = input->qp02;
 1100|     29|        else
 1101|     29|#endif    
 1102|     29|        img->qp = input->qp0;   // set quant. parameter for I-frame
 1103|     57|      else
 1104|     57|      {
 1105|     57|#ifdef _CHANGE_QP_
 1106|     57|        if (input->qp2start > 0 && img->tr >= input->qp2start)
 1107|      0|          img->qp = input->qpN2;
 1108|     57|        else
 1109|     57|#endif
 1110|     57|          img->qp = input->qpN;
 1111|       |        
 1112|     57|        if (img->type == SP_SLICE)
 1113|      0|        {
 1114|      0|          img->qp = input->qpsp;
 1115|      0|          img->qpsp = input->qpsp_pred;
 1116|      0|        }   
 1117|     57|      }
 1118|     86|    }
 1119|       |
 1120|     86|    img->mb_y_intra = img->mb_y_upd;  //  img->mb_y_intra indicates which GOB to intra code for this frame
 1121|       |    
 1122|     86|    if (input->intra_upd > 0) // if error robustness, find next GOB to update
 1123|      0|    {
 1124|      0|      img->mb_y_upd = (IMG_NUMBER / input->intra_upd) % (img->height / MB_BLOCK_SIZE);
 1125|      0|    }
 1126|     86|  }
 1127|     85|  else
 1128|     85|  {
 1129|     85|    img->p_interval = input->jumpd + 1;
 1130|     85|    prevP_no = start_tr_in_this_IGOP + (IMG_NUMBER - 1) * img->p_interval;
 1131|     85|    nextP_no = start_tr_in_this_IGOP + (IMG_NUMBER) * img->p_interval;
 1132|       |    
 1133|     85|#ifdef _ADAPT_LAST_GROUP_
 1134|     85|    last_P_no[0] = prevP_no;
 1135|    425|    for (i = 1; i < img->buf_cycle; i++)
 1136|    340|      last_P_no[i] = last_P_no[i - 1] - img->p_interval;
 1137|       |    
 1138|     85|    if (input->last_frame && img->number + 1 == input->no_frames)
 1139|      0|    {
 1140|      0|      nextP_no = input->last_frame;
 1141|      0|      img->p_interval = nextP_no - prevP_no;
 1142|      0|    }
 1143|     85|#endif
 1144|       |    
 1145|     85|    img->b_interval =
 1146|     85|      ((double) (input->jumpd + 1) / (input->successive_Bframe + 1.0) );
 1147|       |
 1148|     85|    if (input->PyramidCoding == 3)
 1149|      0|      img->b_interval = 1.0;
 1150|       |
 1151|     85|    if (input->PyramidCoding)
 1152|      0|      img->tr = prevP_no + (int) (img->b_interval  * (double) (1 + gop_structure[img->b_frame_to_code - 1].display_no));      // from prev_P
 1153|     85|    else      
 1154|     85|      img->tr = prevP_no + (int) (img->b_interval * (double) img->b_frame_to_code);      // from prev_P
 1155|       |    
 1156|       |
 1157|     85|    if (img->tr >= nextP_no)
 1158|      0|      img->tr = nextP_no - 1;
 1159|       |    //Rate control
 1160|     85|    if(!input->RCEnable && input->PyramidCoding !=3)                  // without using rate control
 1161|     85|    {    
 1162|     85|#ifdef _CHANGE_QP_
 1163|     85|      if (input->qp2start > 0 && img->tr >= input->qp2start)
 1164|      0|      {
 1165|      0|        img->qp = input->qpB2;
 1166|      0|      }
 1167|     85|      else
 1168|     85|#endif
 1169|     85|      {
 1170|     85|        img->qp = input->qpB;
 1171|     85|      }
 1172|       |
 1173|     85|      if (img->nal_reference_idc)
 1174|      0|      {
 1175|      0|#ifdef _CHANGE_QP_
 1176|      0|        if (input->qp2start > 0 && img->tr >= input->qp2start)
 1177|      0|        {
 1178|      0|          img->qp = Clip3(0,51,input->qpB2 + input->qpBRS2Offset);
 1179|      0|        }
 1180|      0|        else
 1181|      0|#endif
 1182|      0|        {
 1183|      0|          img->qp = Clip3(0,51,input->qpB + input->qpBRSOffset);
 1184|      0|        }
 1185|      0|      }
 1186|     85|    }
 1187|      0|    else if (input->PyramidCoding ==3)  
 1188|      0|    {
 1189|      0|      img->qp =  gop_structure[img->b_frame_to_code - 1].slice_qp;
 1190|       |
 1191|      0|    }
 1192|       |
 1193|     85|  }
 1194|       |  
 1195|    171|  UpdateSubseqInfo (img->layer);        // Tian Dong (Sept 2002)
 1196|    171|  UpdateSceneInformation (0, 0, 0, -1); // JVT-D099, scene information SEI, nothing included by default
 1197|       |
 1198|       |  //! Commented out by StW, needs fixing in SEI.h to keep the trace file clean
 1199|       |  //  PrepareAggregationSEIMessage ();
 1200|       |
 1201|    171|  img->total_number_mb = (img->width * img->height) / (MB_BLOCK_SIZE * MB_BLOCK_SIZE);
 1202|       |
 1203|    171|  img->no_output_of_prior_pics_flag = 0;
 1204|    171|  img->long_term_reference_flag = 0;
 1205|       |
 1206|    171|  init_dec_ref_pic_marking_buffer();
 1207|    171|}
 1208|       |
 1209|       |/*!
 1210|       | ************************************************************************
 1211|       | * \brief
 1212|       | *    Initializes the parameters for a new field
 1213|       | ************************************************************************
 1214|       | */
 1215|       |static void init_field ()
 1216|      0|{
 1217|      0|  int i;
 1218|      0|  int prevP_no, nextP_no;
 1219|       |
 1220|      0|  last_P_no = last_P_no_fld;
 1221|       |
 1222|      0|  img->current_mb_nr = 0;
 1223|      0|  img->current_slice_nr = 0;
 1224|      0|  stats->bit_slice = 0;
 1225|       |
 1226|      0|  input->jumpd *= 2;
 1227|      0|  input->successive_Bframe *= 2;
 1228|      0|  img->number /= 2;
 1229|      0|  img->buf_cycle /= 2;
 1230|       |
 1231|      0|  img->mb_y = img->mb_x = 0;
 1232|      0|  img->block_y = img->pix_y = img->pix_c_y = 0; // define vertical positions
 1233|      0|  img->block_x = img->pix_x = img->block_c_x = img->pix_c_x = 0;        // define horizontal positions
 1234|       |
 1235|      0|  if (!img->b_frame_to_code)
 1236|       |  //if (img->type != B_SLICE)
 1237|      0|    {
 1238|      0|      img->tr = img->number * (input->jumpd + 2) + img->fld_type;
 1239|       |
 1240|      0|      if (!img->fld_type)
 1241|      0|        {
 1242|      0|          img->imgtr_last_P_fld = img->imgtr_next_P_fld;
 1243|      0|          img->imgtr_next_P_fld = img->tr;
 1244|      0|        }
 1245|       |
 1246|      0|#ifdef _ADAPT_LAST_GROUP_
 1247|      0|      if (input->last_frame && img->number + 1 == input->no_frames)
 1248|      0|        img->tr = input->last_frame;
 1249|      0|#endif
 1250|      0|      if (img->number != 0 && input->successive_Bframe != 0)    // B pictures to encode
 1251|      0|        nextP_tr_fld = img->tr;
 1252|       |      
 1253|       |      //Rate control
 1254|      0|      if(!input->RCEnable)                  // without using rate control
 1255|      0|      {
 1256|      0|        if (img->type == I_SLICE)
 1257|      0|      {
 1258|      0|#ifdef _CHANGE_QP_
 1259|      0|        if (input->qp2start > 0 && img->tr >= input->qp2start)
 1260|      0|          img->qp = input->qp02;
 1261|      0|        else
 1262|      0|#endif    
 1263|      0|          img->qp = input->qp0;   // set quant. parameter for I-frame
 1264|      0|      }
 1265|      0|        else
 1266|      0|        {
 1267|      0|#ifdef _CHANGE_QP_
 1268|      0|          if (input->qp2start > 0 && img->tr >= input->qp2start)
 1269|      0|            img->qp = input->qpN2;
 1270|      0|          else
 1271|      0|#endif
 1272|      0|            img->qp = input->qpN;
 1273|      0|          if (img->type == SP_SLICE)
 1274|      0|          {
 1275|      0|            img->qp = input->qpsp;
 1276|      0|            img->qpsp = input->qpsp_pred;
 1277|      0|          }
 1278|      0|        }
 1279|      0|      }
 1280|       |
 1281|      0|      img->mb_y_intra = img->mb_y_upd;  //  img->mb_y_intra indicates which GOB to intra code for this frame
 1282|       |
 1283|      0|      if (input->intra_upd > 0) // if error robustness, find next GOB to update
 1284|      0|        {
 1285|      0|          img->mb_y_upd =
 1286|      0|            (img->number / input->intra_upd) % (img->width / MB_BLOCK_SIZE);
 1287|      0|        }
 1288|      0|    }
 1289|      0|  else
 1290|      0|    {
 1291|      0|      img->p_interval = input->jumpd + 2;
 1292|      0|      prevP_no = (img->number - 1) * img->p_interval + img->fld_type;
 1293|      0|      nextP_no = img->number * img->p_interval + img->fld_type;
 1294|      0|#ifdef _ADAPT_LAST_GROUP_
 1295|      0|      if (!img->fld_type)       // top field
 1296|      0|        {
 1297|      0|          last_P_no[0] = prevP_no + 1;
 1298|      0|          last_P_no[1] = prevP_no;
 1299|      0|          for (i = 1; i <= img->buf_cycle; i++)
 1300|      0|            {
 1301|      0|              last_P_no[2 * i] = last_P_no[2 * i - 2] - img->p_interval;
 1302|      0|              last_P_no[2 * i + 1] = last_P_no[2 * i - 1] - img->p_interval;
 1303|      0|            }
 1304|      0|        }
 1305|      0|      else                      // bottom field
 1306|      0|        {
 1307|      0|          last_P_no[0] = nextP_no - 1;
 1308|      0|          last_P_no[1] = prevP_no;
 1309|      0|          for (i = 1; i <= img->buf_cycle; i++)
 1310|      0|            {
 1311|      0|              last_P_no[2 * i] = last_P_no[2 * i - 2] - img->p_interval;
 1312|      0|              last_P_no[2 * i + 1] = last_P_no[2 * i - 1] - img->p_interval;
 1313|      0|            }
 1314|      0|        }
 1315|       |
 1316|      0|      if (input->last_frame && img->number + 1 == input->no_frames)
 1317|      0|        {
 1318|      0|          nextP_no = input->last_frame;
 1319|      0|          img->p_interval = nextP_no - prevP_no;
 1320|      0|        }
 1321|      0|#endif
 1322|      0|      img->b_interval =
 1323|      0|      ((double) (input->jumpd + 1) / (input->successive_Bframe + 1.0) );
 1324|       |
 1325|      0|      if (input->PyramidCoding == 3)
 1326|      0|        img->b_interval = 1.0;
 1327|       |      
 1328|      0|      if (input->PyramidCoding)
 1329|      0|        img->tr = prevP_no + (int) ((img->b_interval + 1.0) * (double) (1 + gop_structure[img->b_frame_to_code - 1].display_no));      // from prev_P
 1330|      0|      else      
 1331|      0|        img->tr = prevP_no + (int) ((img->b_interval + 1.0) * (double) img->b_frame_to_code);      // from prev_P
 1332|       |      
 1333|       |
 1334|      0|      if (img->tr >= nextP_no)
 1335|      0|        img->tr = nextP_no - 1; // ?????
 1336|       |      //Rate control
 1337|      0|      if(!input->RCEnable && input->PyramidCoding !=3)                  // without using rate control
 1338|      0|      {
 1339|      0|#ifdef _CHANGE_QP_
 1340|      0|        if (input->qp2start > 0 && img->tr >= input->qp2start)
 1341|      0|          img->qp = input->qpB2;
 1342|      0|        else
 1343|      0|#endif
 1344|      0|          img->qp = input->qpB;
 1345|      0|        if (img->nal_reference_idc)
 1346|      0|        {
 1347|      0|#ifdef _CHANGE_QP_
 1348|      0|          if (input->qp2start > 0 && img->tr >= input->qp2start)
 1349|      0|            img->qp = Clip3(0,51,input->qpB2 + input->qpBRS2Offset);
 1350|      0|          else
 1351|      0|#endif
 1352|      0|            img->qp = Clip3(0,51,input->qpB + input->qpBRSOffset);
 1353|       |          
 1354|      0|        }
 1355|      0|      }
 1356|      0|      else if (input->PyramidCoding ==3)  
 1357|      0|      {          
 1358|      0|        img->qp =  gop_structure[img->b_frame_to_code - 1].slice_qp;
 1359|      0|      }
 1360|       |      
 1361|       |
 1362|      0|    }
 1363|      0|  input->jumpd /= 2;
 1364|      0|  input->successive_Bframe /= 2;
 1365|      0|  img->buf_cycle *= 2;
 1366|      0|  img->number = 2 * img->number + img->fld_type;
 1367|      0|  img->total_number_mb = (img->width * img->height) / (MB_BLOCK_SIZE * MB_BLOCK_SIZE);
 1368|      0|}
 1369|       |
 1370|       |
 1371|       |#define Clip(min,max,val) (((val)<(min))?(min):(((val)>(max))?(max):(val)))
 1372|       |
 1373|       |
 1374|       |
 1375|       |
 1376|       |/*!
 1377|       | ************************************************************************
 1378|       | * \brief
 1379|       |*    Generate Full Pel Representation
 1380|       | ************************************************************************
 1381|       | */
 1382|       |static void GenerateFullPelRepresentation (pel_t ** Fourthpel,
 1383|       |                                           pel_t * Fullpel, int xsize,
 1384|       |                                           int ysize)
 1385|     86|{
 1386|     86|  int x, y;
 1387|       |  
 1388|  27.6k|  for (y = 0; y < ysize; y++)
 1389|  14.1M|    for (x = 0; x < xsize; x++)
 1390|  14.0M|      PutPel_11 (Fullpel, y, x, FastPelY_14 (Fourthpel, y * 4, x * 4, ysize, xsize), xsize);
 1391|     86|}
 1392|       |
 1393|       |
 1394|       |/*!
 1395|       | ************************************************************************
 1396|       | * \brief
 1397|       | *    Upsample 4 times, store them in out4x.  Color is simply copied
 1398|       | *
 1399|       | * \par Input:
 1400|       | *    srcy, srcu, srcv, out4y, out4u, out4v
 1401|       | *
 1402|       | * \par Side Effects_
 1403|       | *    Uses (writes) img4Y_tmp.  This should be moved to a static variable
 1404|       | *    in this module
 1405|       | ************************************************************************/
 1406|       |void UnifiedOneForthPix (StorablePicture *s)
 1407|     86|{
 1408|     86|  int is;
 1409|     86|  int i, j, j4;
 1410|     86|  int ie2, je2, jj, maxy;
 1411|       |  
 1412|     86|  imgpel **out4Y;
 1413|     86|  imgpel  *ref11;
 1414|     86|  imgpel  **imgY = s->imgY;
 1415|       |  
 1416|     86|  int img_width =s->size_x;
 1417|     86|  int img_height=s->size_y;
 1418|       |  
 1419|       |  // don't upsample twice
 1420|     86|  if (s->imgY_ups || s->imgY_11)
 1421|      0|    return;
 1422|       |  
 1423|     86|  s->imgY_11 = malloc ((s->size_x * s->size_y) * sizeof (imgpel));
 1424|     86|  if (NULL == s->imgY_11)
 1425|      0|    no_mem_exit("alloc_storable_picture: s->imgY_11");
 1426|       |  
 1427|     86|  get_mem2Dpel (&(s->imgY_ups), (2*IMG_PAD_SIZE + s->size_y)*4, (2*IMG_PAD_SIZE + s->size_x)*4);
 1428|       |  
 1429|     86|  if (input->WeightedPrediction || input->WeightedBiprediction || input->GenerateMultiplePPS)
 1430|      0|  {
 1431|      0|    s->imgY_11_w = malloc ((s->size_x * s->size_y) * sizeof (imgpel));
 1432|      0|    if (NULL == s->imgY_11_w)
 1433|      0|      no_mem_exit("alloc_storable_picture: s->imgY_11_w");
 1434|      0|    get_mem2Dpel (&(s->imgY_ups_w), (2*IMG_PAD_SIZE + s->size_y)*4, (2*IMG_PAD_SIZE + s->size_x)*4);
 1435|      0|  }
 1436|     86|  out4Y = s->imgY_ups;
 1437|     86|  ref11 = s->imgY_11;
 1438|       |  
 1439|  28.2k|  for (j = -IMG_PAD_SIZE; j < s->size_y + IMG_PAD_SIZE; j++)
 1440|  28.2k|  {
 1441|  14.6M|    for (i = -IMG_PAD_SIZE; i < s->size_x + IMG_PAD_SIZE; i++)
 1442|  14.6M|    {
 1443|  14.6M|      jj = max (0, min (s->size_y - 1, j));
 1444|  14.6M|      is =
 1445|  14.6M|        (ONE_FOURTH_TAP[0][0] *
 1446|  14.6M|        (imgY[jj][max (0, min (s->size_x - 1, i))] +
 1447|  14.6M|         imgY[jj][max (0, min (s->size_x - 1, i + 1))]) +
 1448|  14.6M|        ONE_FOURTH_TAP[1][0] *
 1449|  14.6M|        (imgY[jj][max (0, min (s->size_x - 1, i - 1))] +
 1450|  14.6M|         imgY[jj][max (0, min (s->size_x - 1, i + 2))]) +
 1451|  14.6M|        ONE_FOURTH_TAP[2][0] *
 1452|  14.6M|        (imgY[jj][max (0, min (s->size_x - 1, i - 2))] +
 1453|  14.6M|         imgY[jj][max (0, min (s->size_x - 1, i + 3))]));
 1454|  14.6M|      img4Y_tmp[j + IMG_PAD_SIZE][(i + IMG_PAD_SIZE) * 2] = imgY[jj][max (0, min (s->size_x - 1, i))] * 1024;    // 1/1 pix pos
 1455|  14.6M|      img4Y_tmp[j + IMG_PAD_SIZE][(i + IMG_PAD_SIZE) * 2 + 1] = is * 32;  // 1/2 pix pos
 1456|  14.6M|    }
 1457|  28.2k|  }
 1458|       |  
 1459|  89.5k|  for (i = 0; i < (s->size_x + 2 * IMG_PAD_SIZE) * 2; i++)
 1460|  89.4k|  {
 1461|  29.4M|    for (j = 0; j < s->size_y + 2 * IMG_PAD_SIZE; j++)
 1462|  29.3M|    {
 1463|  29.3M|      j4 = j * 4;
 1464|  29.3M|      maxy = s->size_y + 2 * IMG_PAD_SIZE - 1;
 1465|       |      // change for TML4, use 6 TAP vertical filter
 1466|  29.3M|      is =
 1467|  29.3M|        (ONE_FOURTH_TAP[0][0] *
 1468|  29.3M|        (img4Y_tmp[j][i] + img4Y_tmp[min (maxy, j + 1)][i]) +
 1469|  29.3M|         ONE_FOURTH_TAP[1][0] * (img4Y_tmp[max (0, j - 1)][i] +
 1470|  29.3M|         img4Y_tmp[min (maxy, j + 2)][i]) +
 1471|  29.3M|        ONE_FOURTH_TAP[2][0] * (img4Y_tmp[max (0, j - 2)][i] +
 1472|  29.3M|         img4Y_tmp[min (maxy, j + 3)][i])) / 32;
 1473|       |      
 1474|  29.3M|      PutPel_14 (out4Y, (j - IMG_PAD_SIZE) * 4, (i - IMG_PAD_SIZE * 2) * 2, 
 1475|  29.3M|        (pel_t) max (0, min(img->max_imgpel_value , 
 1476|  29.3M|        (int) ((img4Y_tmp[j][i] + 512) / 1024))));  // 1/2 pix
 1477|  29.3M|      PutPel_14 (out4Y, (j - IMG_PAD_SIZE) * 4 + 2, (i - IMG_PAD_SIZE * 2) * 2, 
 1478|  29.3M|        (pel_t) max (0, min(img->max_imgpel_value, 
 1479|  29.3M|        (int) ((is + 512) / 1024))));   // 1/2 pix
 1480|  29.3M|    }
 1481|  89.4k|  }
 1482|       |  
 1483|       |  /* 1/4 pix */
 1484|       |  /* luma */
 1485|     86|  ie2 = (s->size_x + 2 * IMG_PAD_SIZE - 1) * 4;
 1486|     86|  je2 = (s->size_y + 2 * IMG_PAD_SIZE - 1) * 4;
 1487|       |  
 1488|  56.5k|  for (j = 0; j < je2 + 4; j += 2)
 1489|  58.7M|    for (i = 0; i < ie2 + 3; i += 2)
 1490|  58.6M|    {
 1491|       |      /*  '-'  */
 1492|  58.6M|      PutPel_14 (out4Y, j - IMG_PAD_SIZE * 4, i - IMG_PAD_SIZE * 4 + 1,
 1493|  58.6M|        (pel_t) (max (0, min (img->max_imgpel_value,(int) (FastPelY_14 (out4Y, j - IMG_PAD_SIZE * 4,
 1494|  58.6M|        i - IMG_PAD_SIZE * 4, img_height, img_width) + FastPelY_14 (out4Y,
 1495|  58.6M|        j - IMG_PAD_SIZE * 4, min (ie2 + 2, i + 2) - IMG_PAD_SIZE * 4, img_height, img_width)+1) / 2))));
 1496|  58.6M|    }
 1497|   178k|    for (i = 0; i < ie2 + 4; i++)
 1498|   178k|    {
 1499|   117M|      for (j = 0; j < je2 + 3; j += 2)
 1500|   117M|      {
 1501|   117M|        if (i % 2 == 0)
 1502|  58.6M|        {
 1503|       |          /*  '|'  */
 1504|  58.6M|          PutPel_14 (out4Y, j - IMG_PAD_SIZE * 4 + 1, i - IMG_PAD_SIZE * 4,
 1505|  58.6M|            (pel_t) (max (0, min (img->max_imgpel_value, (int) (FastPelY_14 (out4Y, j - IMG_PAD_SIZE * 4,
 1506|  58.6M|            i - IMG_PAD_SIZE * 4, img_height, img_width) + FastPelY_14 (out4Y,
 1507|  58.6M|            min (je2 + 2, j + 2) - IMG_PAD_SIZE * 4, i - IMG_PAD_SIZE * 4, img_height, img_width)+1) / 2))));
 1508|  58.6M|        }
 1509|  58.6M|        else if ((j % 4 == 0 && i % 4 == 1) || (j % 4 == 2 && i % 4 == 3))
 1510|  29.3M|        {
 1511|       |          /*  '/'  */
 1512|  29.3M|          PutPel_14 (out4Y, j - IMG_PAD_SIZE * 4 + 1, i - IMG_PAD_SIZE * 4,
 1513|  29.3M|            (pel_t) (max (0, min (img->max_imgpel_value, (int) (FastPelY_14 (out4Y, j - IMG_PAD_SIZE * 4,
 1514|  29.3M|            min (ie2 + 2, i + 1) - IMG_PAD_SIZE * 4, img_height, img_width) + FastPelY_14 (out4Y,
 1515|  29.3M|            min (je2 + 2, j + 2) - IMG_PAD_SIZE * 4, i - IMG_PAD_SIZE * 4 - 1, img_height, img_width) + 1) / 2))));
 1516|  29.3M|        }
 1517|  29.3M|        else
 1518|  29.3M|        {
 1519|       |          /*  '\'  */
 1520|  29.3M|          PutPel_14 (out4Y, j - IMG_PAD_SIZE * 4 + 1, i - IMG_PAD_SIZE * 4,
 1521|  29.3M|            (pel_t) (max (0, min (img->max_imgpel_value, (int) (FastPelY_14 (out4Y, j - IMG_PAD_SIZE * 4,
 1522|  29.3M|            i - IMG_PAD_SIZE * 4 - 1, img_height, img_width) + FastPelY_14 (out4Y,
 1523|  29.3M|            min (je2 + 2, j + 2) - IMG_PAD_SIZE * 4, 
 1524|  29.3M|            min (ie2 + 2, i + 1) - IMG_PAD_SIZE * 4, img_height, img_width) + 1) / 2))));
 1525|  29.3M|        }
 1526|   117M|      }
 1527|   178k|    }
 1528|       |    
 1529|       |    /*  Chroma: */
 1530|       |    /*    for (j = 0; j < img->height_cr; j++)
 1531|       |    {
 1532|       |    memcpy (outU[j], imgU[j], img->width_cr);       // just copy 1/1 pix, interpolate "online" 
 1533|       |    memcpy (outV[j], imgV[j], img->width_cr);
 1534|       |    }
 1535|       |    */
 1536|       |    // Generate 1/1th pel representation (used for integer pel MV search)
 1537|     86|    GenerateFullPelRepresentation (out4Y, ref11, s->size_x, s->size_y);
 1538|       |    
 1539|     86|}
 1540|       |
 1541|       |
 1542|       |/*!
 1543|       | ************************************************************************
 1544|       | * \brief
 1545|       | *    Find SNR for all three components
 1546|       | ************************************************************************
 1547|       | */
 1548|       |static void find_snr ()
 1549|    171|{
 1550|    171|  int i, j;
 1551|    171|  int64 diff_y=0, diff_u=0, diff_v=0;
 1552|    171|  int impix;
 1553|    171|  int impix_cr;
 1554|    171|  unsigned int max_pix_value_sqd = img->max_imgpel_value * img->max_imgpel_value;
 1555|    171|  unsigned int max_pix_value_sqd_uv = img->max_imgpel_value_uv * img->max_imgpel_value_uv;
 1556|       |
 1557|       |  //  Calculate  PSNR for Y, U and V.
 1558|       |  
 1559|       |  //     Luma.
 1560|    171|  impix = input->img_height * input->img_width;
 1561|    171|  impix_cr = input->img_height_cr * input->img_width_cr;
 1562|       |
 1563|    171|  if (img->fld_flag != 0)
 1564|      0|  {
 1565|       |      
 1566|      0|    diff_y = 0;
 1567|      0|    for (i = 0; i < input->img_width; ++i)
 1568|      0|    {
 1569|      0|      for (j = 0; j < input->img_height; ++j)
 1570|      0|      {
 1571|      0|        diff_y += img->quad[imgY_org[j][i] - imgY_com[j][i]];
 1572|      0|      }
 1573|      0|    }
 1574|       |    
 1575|      0|    if (img->yuv_format != YUV400)
 1576|      0|    {
 1577|       |      //     Chroma.
 1578|      0|      diff_u = 0;
 1579|      0|      diff_v = 0;
 1580|       |      
 1581|      0|      for (i = 0; i < input->img_width_cr; i++)
 1582|      0|      {
 1583|      0|        for (j = 0; j < input->img_height_cr; j++)
 1584|      0|        {
 1585|      0|          diff_u += img->quad[imgUV_org[0][j][i] - imgUV_com[0][j][i]];
 1586|      0|          diff_v += img->quad[imgUV_org[1][j][i] - imgUV_com[1][j][i]];
 1587|      0|        }
 1588|      0|      }
 1589|      0|    }
 1590|      0|  }
 1591|    171|  else
 1592|    171|  { 
 1593|    171|    imgY_org  = imgY_org_frm;
 1594|    171|    imgUV_org = imgUV_org_frm;
 1595|       |
 1596|    171|    if(input->PicInterlace==ADAPTIVE_CODING)
 1597|      0|    {
 1598|      0|      enc_picture = enc_frame_picture;
 1599|      0|    }  
 1600|       |
 1601|    171|    diff_y = 0;
 1602|  87.7k|    for (i = 0; i < input->img_width; ++i)
 1603|  87.5k|    {
 1604|  28.1M|      for (j = 0; j < input->img_height; ++j)
 1605|  28.0M|      {
 1606|  28.0M|        diff_y += img->quad[imgY_org[j][i] - enc_picture->imgY[j][i]];
 1607|  28.0M|      }
 1608|  87.5k|    }
 1609|       |    
 1610|    171|    if (img->yuv_format != YUV400)
 1611|    171|    {
 1612|       |      //     Chroma.
 1613|    171|      diff_u = 0;
 1614|    171|      diff_v = 0;
 1615|       |      
 1616|  43.9k|      for (i = 0; i < input->img_width_cr; i++)
 1617|  43.7k|      {
 1618|  7.04M|        for (j = 0; j < input->img_height_cr; j++)
 1619|  7.00M|        {
 1620|  7.00M|          diff_u += img->quad[imgUV_org[0][j][i] - enc_picture->imgUV[0][j][i]];
 1621|  7.00M|          diff_v += img->quad[imgUV_org[1][j][i] - enc_picture->imgUV[1][j][i]];
 1622|  7.00M|        }
 1623|  43.7k|      }
 1624|    171|    }
 1625|    171|  }
 1626|       |
 1627|    171|#if ZEROSNR
 1628|    171|  if (diff_y == 0)
 1629|      0|    diff_y = 1;
 1630|    171|  if (diff_u == 0)
 1631|      0|    diff_u = 1;
 1632|    171|  if (diff_v == 0)
 1633|      0|    diff_v = 1; 
 1634|    171|#endif
 1635|       |
 1636|       |  //  Collecting SNR statistics
 1637|    171|  if (diff_y != 0)
 1638|    171|  {
 1639|    171|    snr->snr_y = (float) (10 * log10 (max_pix_value_sqd    * (double)((double) impix    / diff_y)));         // luma snr for current frame
 1640|    171|    if (img->yuv_format != YUV400)
 1641|    171|    {
 1642|    171|      snr->snr_u = (float) (10 * log10 (max_pix_value_sqd_uv * (double)((double) impix_cr / diff_u)));   // u croma snr for current frame, 1/4 of luma samples
 1643|    171|      snr->snr_v = (float) (10 * log10 (max_pix_value_sqd_uv * (double)((double) impix_cr / diff_v)));   // v croma snr for current frame, 1/4 of luma samples
 1644|    171|    }
 1645|      0|    else
 1646|      0|    {
 1647|      0|      snr->snr_u = 0;
 1648|      0|      snr->snr_v = 0;
 1649|      0|    }
 1650|    171|  }
 1651|       |  
 1652|       |
 1653|    171|  if (img->number == 0)
 1654|      1|  {
 1655|      1|    snr->snr_y1 = snr->snr_y;  // keep luma snr for first frame
 1656|      1|    snr->snr_u1 = snr->snr_u;  // keep croma u snr for first frame
 1657|      1|    snr->snr_v1 = snr->snr_v;  // keep croma v snr for first frame
 1658|      1|    snr->snr_ya = snr->snr_y1;
 1659|      1|    snr->snr_ua = snr->snr_u1;
 1660|      1|    snr->snr_va = snr->snr_v1;
 1661|      1|    snr->snr_yt[I_SLICE] = 0.0;
 1662|      1|    snr->snr_ut[I_SLICE] = 0.0;
 1663|      1|    snr->snr_vt[I_SLICE] = 0.0;
 1664|      1|    snr->snr_yt[P_SLICE] = 0.0;
 1665|      1|    snr->snr_ut[P_SLICE] = 0.0;
 1666|      1|    snr->snr_vt[P_SLICE] = 0.0;
 1667|      1|    snr->snr_yt[B_SLICE] = 0.0;
 1668|      1|    snr->snr_ut[B_SLICE] = 0.0;
 1669|      1|    snr->snr_vt[B_SLICE] = 0.0;
 1670|      1|  }
 1671|       |  // B pictures
 1672|    170|  else
 1673|    170|  {
 1674|    170|    snr->snr_ya = (float) (snr->snr_ya * (img->number + Bframe_ctr) + snr->snr_y) / (img->number + Bframe_ctr + 1); // average snr lume for all frames inc. first
 1675|    170|    snr->snr_ua = (float) (snr->snr_ua * (img->number + Bframe_ctr) + snr->snr_u) / (img->number + Bframe_ctr + 1); // average snr u croma for all frames inc. first
 1676|    170|    snr->snr_va = (float) (snr->snr_va * (img->number + Bframe_ctr) + snr->snr_v) / (img->number + Bframe_ctr + 1); // average snr v croma for all frames inc. first
 1677|    170|  }
 1678|       |
 1679|    171|  if (img->type == I_SLICE )
 1680|     29|  {
 1681|     29|    snr->snr_yt[I_SLICE] = (float) (snr->snr_yt[I_SLICE] * (Iframe_ctr - 1) + snr->snr_y) / ( Iframe_ctr );  // average luma snr for I coded frames
 1682|     29|    snr->snr_ut[I_SLICE] = (float) (snr->snr_ut[I_SLICE] * (Iframe_ctr - 1) + snr->snr_u) / ( Iframe_ctr );  // average chroma u snr for I coded frames
 1683|     29|    snr->snr_vt[I_SLICE] = (float) (snr->snr_vt[I_SLICE] * (Iframe_ctr - 1) + snr->snr_v) / ( Iframe_ctr );  // average chroma v snr for I coded frames
 1684|     29|  }
 1685|    142|  else  if (img->type == B_SLICE )
 1686|     85|  {
 1687|     85|    snr->snr_yt[B_SLICE] = (float) (snr->snr_yt[B_SLICE] * (Bframe_ctr - 1) + snr->snr_y) / ( Bframe_ctr );  // average luma snr for B coded frames
 1688|     85|    snr->snr_ut[B_SLICE] = (float) (snr->snr_ut[B_SLICE] * (Bframe_ctr - 1) + snr->snr_u) / ( Bframe_ctr );  // average chroma u snr for B coded frames
 1689|     85|    snr->snr_vt[B_SLICE] = (float) (snr->snr_vt[B_SLICE] * (Bframe_ctr - 1) + snr->snr_v) / ( Bframe_ctr );  // average chroma v snr for B coded frames
 1690|     85|  }
 1691|     57|  else
 1692|     57|  {
 1693|     57|    snr->snr_yt[P_SLICE] = (float) (snr->snr_yt[P_SLICE] * (Pframe_ctr - 1) + snr->snr_y) / ( Pframe_ctr );  // average luma snr for P coded frames
 1694|     57|    snr->snr_ut[P_SLICE] = (float) (snr->snr_ut[P_SLICE] * (Pframe_ctr - 1) + snr->snr_u) / ( Pframe_ctr );  // average chroma u snr for P coded frames
 1695|     57|    snr->snr_vt[P_SLICE] = (float) (snr->snr_vt[P_SLICE] * (Pframe_ctr - 1) + snr->snr_v) / ( Pframe_ctr );  // average chroma v snr for P coded frames
 1696|     57|  }
 1697|       |
 1698|    171|}
 1699|       |
 1700|       |/*!
 1701|       | ************************************************************************
 1702|       | * \brief
 1703|       | *    Find distortion for all three components
 1704|       | ************************************************************************
 1705|       | */
 1706|       |static void find_distortion ()
 1707|    171|{
 1708|    171|  int i, j;
 1709|    171|  int64 diff_y, diff_u, diff_v;
 1710|    171|  int impix;
 1711|       |  
 1712|       |  //  Calculate  PSNR for Y, U and V.
 1713|       |  
 1714|       |  //     Luma.
 1715|    171|  impix = input->img_height * input->img_width;
 1716|       |  
 1717|    171|  if (img->structure!=FRAME)
 1718|      0|  {
 1719|       |
 1720|      0|    diff_y = 0;
 1721|      0|    for (i = 0; i < input->img_width; ++i)
 1722|      0|    {
 1723|      0|      for (j = 0; j < input->img_height; ++j)
 1724|      0|      {
 1725|      0|        diff_y += img->quad[abs (imgY_org[j][i] - imgY_com[j][i])];
 1726|      0|      }
 1727|      0|    }
 1728|       |  
 1729|      0|    diff_u = 0;
 1730|      0|    diff_v = 0;
 1731|       |    
 1732|      0|    if (img->yuv_format != YUV400)
 1733|      0|    {
 1734|       |      //     Chroma.
 1735|      0|      for (i = 0; i < input->img_width_cr; i++)
 1736|      0|      {
 1737|      0|        for (j = 0; j < input->img_height_cr; j++)
 1738|      0|        {
 1739|      0|          diff_u += img->quad[abs (imgUV_org[0][j][i] - imgUV_com[0][j][i])];
 1740|      0|          diff_v += img->quad[abs (imgUV_org[1][j][i] - imgUV_com[1][j][i])];
 1741|      0|        }
 1742|      0|      }
 1743|      0|    }
 1744|      0|  }
 1745|    171|  else
 1746|    171|  {
 1747|    171|      imgY_org   = imgY_org_frm;
 1748|    171|      imgUV_org = imgUV_org_frm;
 1749|       |
 1750|    171|      diff_y = 0;
 1751|  87.7k|      for (i = 0; i < input->img_width; ++i)
 1752|  87.5k|      {
 1753|  28.1M|        for (j = 0; j < input->img_height; ++j)
 1754|  28.0M|        {
 1755|  28.0M|          diff_y += img->quad[abs (imgY_org[j][i] - enc_picture->imgY[j][i])];
 1756|  28.0M|        }
 1757|  87.5k|      }
 1758|       |      
 1759|    171|      diff_u = 0;
 1760|    171|      diff_v = 0;
 1761|       |
 1762|    171|      if (img->yuv_format != YUV400)
 1763|    171|      {
 1764|       |        //     Chroma.
 1765|  43.9k|        for (i = 0; i < input->img_width_cr; i++)
 1766|  43.7k|        {
 1767|  7.04M|          for (j = 0; j < input->img_height_cr; j++)
 1768|  7.00M|          {
 1769|  7.00M|            diff_u += img->quad[abs (imgUV_org[0][j][i] - enc_picture->imgUV[0][j][i])];
 1770|  7.00M|            diff_v += img->quad[abs (imgUV_org[1][j][i] - enc_picture->imgUV[1][j][i])];
 1771|  7.00M|          }
 1772|  43.7k|        }
 1773|    171|      }
 1774|    171|  }
 1775|       |  // Calculate real PSNR at find_snr_avg()
 1776|    171|  snr->snr_y = (float) diff_y;
 1777|    171|  snr->snr_u = (float) diff_u;
 1778|    171|  snr->snr_v = (float) diff_v;
 1779|    171|}
 1780|       |
 1781|       |  
 1782|       |  /*!
 1783|       | ************************************************************************
 1784|       | * \brief
 1785|       | *    Just a placebo
 1786|       | ************************************************************************
 1787|       | */
 1788|       |Boolean dummy_slice_too_big (int bits_slice)
 1789|      0|{
 1790|      0|  return FALSE;
 1791|      0|}
 1792|       |
 1793|       |
 1794|       |/*! 
 1795|       |***************************************************************************
 1796|       |// For MB level field/frame coding
 1797|       |***************************************************************************
 1798|       |*/
 1799|       |void copy_rdopt_data (int bot_block)
 1800|      0|{
 1801|      0|  int mb_nr = img->current_mb_nr;
 1802|      0|  Macroblock *currMB = &img->mb_data[mb_nr];
 1803|      0|  int i, j, k, l;
 1804|       |
 1805|      0|  int bframe = (img->type == B_SLICE);
 1806|      0|  int mode;
 1807|      0|  int b8mode, b8pdir;
 1808|       |
 1809|      0|  int list_offset = ((img->MbaffFrameFlag)&&(currMB->mb_field))? img->current_mb_nr%2 ? 4 : 2 : 0;
 1810|       |
 1811|      0|  mode             = rdopt->mode;
 1812|      0|  currMB->mb_type  = rdopt->mb_type;   // copy mb_type 
 1813|      0|  currMB->cbp      = rdopt->cbp;   // copy cbp
 1814|      0|  currMB->cbp_blk  = rdopt->cbp_blk;   // copy cbp_blk
 1815|      0|#if BI_PREDICTION
 1816|      0|  currMB->bi_pred_me  = rdopt->bi_pred_me;   // copy biprediction
 1817|      0|#endif
 1818|      0|  img->i16offset   = rdopt->i16offset;
 1819|       |
 1820|      0|  currMB->prev_qp=rdopt->prev_qp;
 1821|      0|  currMB->prev_delta_qp=rdopt->prev_delta_qp;
 1822|      0|  currMB->qp=rdopt->qp;
 1823|       |
 1824|      0|  currMB->c_ipred_mode = rdopt->c_ipred_mode;
 1825|       |
 1826|      0|  for (i = 0; i < 4+img->num_blk8x8_uv; i++)
 1827|      0|    for (j = 0; j < 4; j++)
 1828|      0|      for (k = 0; k < 2; k++)
 1829|      0|        for (l = 0; l < 65; l++)
 1830|      0|          img->cofAC[i][j][k][l] = rdopt->cofAC[i][j][k][l];
 1831|       |
 1832|      0|  for (i = 0; i < 3; i++)
 1833|      0|    for (k = 0; k < 2; k++)
 1834|      0|      for (l = 0; l < 18; l++)
 1835|      0|        img->cofDC[i][k][l] = rdopt->cofDC[i][k][l];
 1836|       |
 1837|      0|  for (j = 0; j < 4; j++)
 1838|      0|    for (i = 0; i < 4; i++)
 1839|      0|    {
 1840|      0|      enc_picture->ref_idx[LIST_0][img->block_x + i][img->block_y + j] = rdopt->refar[LIST_0][j][i];
 1841|      0|      enc_picture->ref_pic_id [LIST_0][img->block_x+i][img->block_y+j] = enc_picture->ref_pic_num[LIST_0 + list_offset][enc_picture->ref_idx[LIST_0][img->block_x+i][img->block_y+j]];
 1842|      0|      if (bframe)
 1843|      0|      {
 1844|      0|        enc_picture->ref_idx[LIST_1][img->block_x + i][img->block_y + j] = rdopt->refar[LIST_1][j][i];
 1845|      0|        enc_picture->ref_pic_id [LIST_1][img->block_x+i][img->block_y+j] = enc_picture->ref_pic_num[LIST_1 + list_offset][enc_picture->ref_idx[LIST_1][img->block_x+i][img->block_y+j]];
 1846|      0|      }
 1847|      0|    }
 1848|       |    
 1849|       |    //===== reconstruction values =====
 1850|      0|  for (j = 0; j < 16; j++)
 1851|      0|    for (i = 0; i < 16; i++)
 1852|      0|    {
 1853|      0|      enc_picture->imgY[img->pix_y + j][img->pix_x + i] = rdopt->rec_mbY[j][i];
 1854|      0|    }
 1855|       |      
 1856|       |     
 1857|      0|    if (img->yuv_format != YUV400)
 1858|      0|    {
 1859|      0|      for (j = 0; j < img->mb_cr_size_y; j++)
 1860|      0|        for (i = 0; i < img->mb_cr_size_x; i++)
 1861|      0|        {
 1862|      0|          enc_picture->imgUV[0][img->pix_c_y + j][img->pix_c_x + i] = rdopt->rec_mbU[j][i];
 1863|      0|          enc_picture->imgUV[1][img->pix_c_y + j][img->pix_c_x + i] = rdopt->rec_mbV[j][i];
 1864|      0|        }
 1865|      0|    }
 1866|       |
 1867|      0|  for (i = 0; i < 4; i++)
 1868|      0|  {
 1869|      0|    currMB->b8mode[i] = rdopt->b8mode[i];
 1870|      0|    currMB->b8pdir[i] = rdopt->b8pdir[i];
 1871|      0|  }
 1872|       |
 1873|      0|  currMB->luma_transform_size_8x8_flag = rdopt->luma_transform_size_8x8_flag;
 1874|       |//  currMB->NoMbPartLessThan8x8Flag  = rdopt->NoMbPartLessThan8x8Flag;  //DEL-VG-29072004
 1875|       |  
 1876|       |  //==== intra prediction modes ====
 1877|      0|  if (mode == P8x8)
 1878|      0|  {
 1879|      0|    for (k = 0, j = img->block_y; j < img->block_y + 4; j++)
 1880|      0|      for (i = img->block_x; i < img->block_x + 4; i++, k++)
 1881|      0|      {
 1882|      0|        img->ipredmode[i][j]        = rdopt->ipredmode[i][j];
 1883|      0|        currMB->intra_pred_modes[k] = rdopt->intra_pred_modes[k];
 1884|      0|      }
 1885|      0|  }
 1886|      0|  else if (mode != I4MB && mode != I8MB)
 1887|      0|  {
 1888|      0|    for (k = 0, j = img->block_y; j < img->block_y + 4; j++)
 1889|      0|      for (     i = img->block_x; i < img->block_x + 4; i++, k++)
 1890|      0|      {
 1891|      0|        img->ipredmode[i][j]        = DC_PRED;
 1892|      0|        currMB->intra_pred_modes[k] = DC_PRED;
 1893|      0|      }
 1894|      0|  }
 1895|      0|  else if (mode == I4MB || mode == I8MB)
 1896|      0|  {
 1897|      0|    for (k = 0, j = img->block_y; j < img->block_y + 4; j++)
 1898|      0|      for (     i = img->block_x; i < img->block_x + 4; i++, k++)
 1899|      0|      {
 1900|      0|        img->ipredmode[i][j]        = rdopt->ipredmode[i][j];
 1901|      0|        currMB->intra_pred_modes[k] = rdopt->intra_pred_modes[k];
 1902|       |        
 1903|      0|      }
 1904|       |      
 1905|      0|  }
 1906|       |
 1907|      0|  if (img->MbaffFrameFlag)
 1908|      0|  {
 1909|       |    // motion vectors
 1910|      0|    copy_motion_vectors_MB ();
 1911|       |    
 1912|       |    
 1913|      0|    if (!IS_INTRA(currMB))
 1914|      0|    {
 1915|      0|      for (j = 0; j < 4; j++)
 1916|      0|        for (i = 0; i < 4; i++)
 1917|      0|        {
 1918|      0|          b8mode = currMB->b8mode[i/2+2*(j/2)];
 1919|      0|          b8pdir = currMB->b8pdir[i/2+2*(j/2)];
 1920|       |
 1921|      0|          if (b8pdir!=1)
 1922|      0|          {
 1923|      0|            enc_picture->mv[LIST_0][i+img->block_x][j+img->block_y][0] = rdopt->all_mv[i][j][LIST_0][rdopt->refar[LIST_0][j][i]][b8mode][0];
 1924|      0|            enc_picture->mv[LIST_0][i+img->block_x][j+img->block_y][1] = rdopt->all_mv[i][j][LIST_0][rdopt->refar[LIST_0][j][i]][b8mode][1];
 1925|      0|          }
 1926|      0|          else
 1927|      0|          {
 1928|      0|            enc_picture->mv[LIST_0][i+img->block_x][j+img->block_y][0] = 0;
 1929|      0|            enc_picture->mv[LIST_0][i+img->block_x][j+img->block_y][1] = 0;
 1930|      0|          }
 1931|      0|          if (bframe)
 1932|      0|          {
 1933|      0|            if (b8pdir!=0)
 1934|      0|            {
 1935|      0|              enc_picture->mv[LIST_1][i+img->block_x][j+img->block_y][0] = rdopt->all_mv[i][j][LIST_1][rdopt->refar[LIST_1][j][i]][b8mode][0];
 1936|      0|              enc_picture->mv[LIST_1][i+img->block_x][j+img->block_y][1] = rdopt->all_mv[i][j][LIST_1][rdopt->refar[LIST_1][j][i]][b8mode][1];
 1937|      0|            }
 1938|      0|            else
 1939|      0|            {
 1940|      0|              enc_picture->mv[LIST_1][i+img->block_x][j+img->block_y][0] = 0;
 1941|      0|              enc_picture->mv[LIST_1][i+img->block_x][j+img->block_y][1] = 0;
 1942|      0|            }
 1943|      0|          }
 1944|      0|        }
 1945|      0|    }
 1946|      0|    else
 1947|      0|    {
 1948|      0|      for (j = 0; j < 4; j++)
 1949|      0|        for (i = 0; i < 4; i++)
 1950|      0|        {
 1951|      0|          enc_picture->mv[LIST_0][i+img->block_x][j+img->block_y][0] = 0;
 1952|      0|          enc_picture->mv[LIST_0][i+img->block_x][j+img->block_y][1] = 0;
 1953|       |          
 1954|      0|          if (bframe)
 1955|      0|          {
 1956|      0|            enc_picture->mv[LIST_1][i+img->block_x][j+img->block_y][0] = 0;
 1957|      0|            enc_picture->mv[LIST_1][i+img->block_x][j+img->block_y][1] = 0;
 1958|      0|          }
 1959|      0|        }
 1960|      0|    }
 1961|      0|  }
 1962|       |  
 1963|      0|}                             // end of copy_rdopt_data
 1964|       |  
 1965|       |static void copy_motion_vectors_MB ()
 1966|      0|{
 1967|      0|  int i,j,k,l;
 1968|       |
 1969|      0|  for (i = 0; i < 4; i++)
 1970|      0|  {
 1971|      0|    for (j = 0; j < 4; j++)
 1972|      0|    {
 1973|      0|      for (k = 0; k < img->max_num_references; k++)
 1974|      0|      {
 1975|      0|        for (l = 0; l < 9; l++)
 1976|      0|        {
 1977|      0|          img->all_mv[i][j][LIST_0][k][l][0] = rdopt->all_mv[i][j][LIST_0][k][l][0];
 1978|      0|          img->all_mv[i][j][LIST_0][k][l][1] = rdopt->all_mv[i][j][LIST_0][k][l][1];
 1979|       |
 1980|      0|          img->all_mv[i][j][LIST_1][k][l][0] = rdopt->all_mv[i][j][LIST_1][k][l][0];
 1981|      0|          img->all_mv[i][j][LIST_1][k][l][1] = rdopt->all_mv[i][j][LIST_1][k][l][1];
 1982|       |
 1983|      0|#if BI_PREDICTION         
 1984|      0|          if (input->BiPredMotionEstimation && k==1 && img->type==B_SLICE)
 1985|      0|          {
 1986|      0|            img->bipred_mv1[i][j][LIST_0][k][l][0] = rdopt->bipred_mv1[i][j][LIST_0][k][l][0];
 1987|      0|            img->bipred_mv1[i][j][LIST_0][k][l][1] = rdopt->bipred_mv1[i][j][LIST_0][k][l][1];
 1988|       |            
 1989|      0|            img->bipred_mv1[i][j][LIST_1][k][l][0] = rdopt->bipred_mv1[i][j][LIST_1][k][l][0];
 1990|      0|            img->bipred_mv1[i][j][LIST_1][k][l][1] = rdopt->bipred_mv1[i][j][LIST_1][k][l][1];            
 1991|       |
 1992|      0|            img->bipred_mv2[i][j][LIST_0][k][l][0] = rdopt->bipred_mv2[i][j][LIST_0][k][l][0];
 1993|      0|            img->bipred_mv2[i][j][LIST_0][k][l][1] = rdopt->bipred_mv2[i][j][LIST_0][k][l][1];            
 1994|      0|            img->bipred_mv2[i][j][LIST_1][k][l][0] = rdopt->bipred_mv2[i][j][LIST_1][k][l][0];
 1995|      0|            img->bipred_mv2[i][j][LIST_1][k][l][1] = rdopt->bipred_mv2[i][j][LIST_1][k][l][1];            
 1996|      0|          }
 1997|      0|#endif
 1998|       |
 1999|      0|          img->pred_mv[i][j][LIST_0][k][l][0] = rdopt->pred_mv[i][j][LIST_0][k][l][0];
 2000|      0|          img->pred_mv[i][j][LIST_0][k][l][1] = rdopt->pred_mv[i][j][LIST_0][k][l][1];
 2001|       |          
 2002|      0|          img->pred_mv[i][j][LIST_1][k][l][0] = rdopt->pred_mv[i][j][LIST_1][k][l][0];
 2003|      0|          img->pred_mv[i][j][LIST_1][k][l][1] = rdopt->pred_mv[i][j][LIST_1][k][l][1];
 2004|       |          
 2005|      0|        }
 2006|      0|      }
 2007|      0|    }
 2008|      0|  }
 2009|      0|}
 2010|       |  
 2011|       |
 2012|       |static void ReportNALNonVLCBits(int tmp_time, int me_time)
 2013|      1|{
 2014|       |  //! Need to add type (i.e. SPS, PPS, SEI etc).
 2015|      1|    printf ("%04d(NVB)%8d \n", frame_no, stats->bit_ctr_parametersets_n);
 2016|       |
 2017|      1|}
 2018|       |static void ReportFirstframe(int tmp_time,int me_time)
 2019|      1|{
 2020|       |  //Rate control
 2021|      1|  int bits;
 2022|      1|  printf ("%04d(IDR)%8d %1d %2d %7.3f %7.3f %7.3f  %7d   %5d     %3s   %3d\n",
 2023|      1|    frame_no, stats->bit_ctr - stats->bit_ctr_n,0,
 2024|      1|    img->qp, snr->snr_y, snr->snr_u, snr->snr_v, tmp_time, me_time,
 2025|      1|    img->fld_flag ? "FLD" : "FRM", intras);
 2026|       |
 2027|       |  //Rate control
 2028|      1|  if(input->RCEnable)
 2029|      0|  {
 2030|      0|    if((!input->PicInterlace)&&(!input->MbInterlace))
 2031|      0|        bits = stats->bit_ctr-stats->bit_ctr_n; // used for rate control update 
 2032|      0|    else
 2033|      0|    {
 2034|      0|      bits = stats->bit_ctr - Iprev_bits; // used for rate control update 
 2035|      0|      Iprev_bits = stats->bit_ctr;
 2036|      0|    }
 2037|      0|  }
 2038|       |
 2039|      1|  stats->bit_ctr_I = stats->bit_ctr;
 2040|      1|  stats->bit_ctr = 0;
 2041|      1|}
 2042|       |
 2043|       |
 2044|       |static void ReportIntra(int tmp_time, int me_time)
 2045|     28|{
 2046|       |	
 2047|     28|  if (img->currentPicture->idr_flag == 1)
 2048|      0|    printf ("%04d(IDR)%8d %1d %2d %7.3f %7.3f %7.3f  %7d   %5d     %3s   %3d\n",
 2049|      0|    frame_no, stats->bit_ctr - stats->bit_ctr_n, 0,
 2050|      0|    img->qp, snr->snr_y, snr->snr_u, snr->snr_v, tmp_time, me_time,
 2051|      0|    img->fld_flag ? "FLD" : "FRM", intras); 
 2052|     28|  else
 2053|     28|    printf ("%04d(I)  %8d %1d %2d %7.3f %7.3f %7.3f  %7d   %5d     %3s   %3d\n",
 2054|     28|    frame_no, stats->bit_ctr - stats->bit_ctr_n, 0,
 2055|     28|    img->qp, snr->snr_y, snr->snr_u, snr->snr_v, tmp_time, me_time,
 2056|     28|    img->fld_flag ? "FLD" : "FRM", intras);
 2057|       |
 2058|     28|}
 2059|       |
 2060|       |static void ReportSP(int tmp_time, int me_time)
 2061|      0|{
 2062|      0|  printf ("%04d(SP) %8d %1d %2d %7.3f %7.3f %7.3f  %7d   %5d     %3s   %3d\n",
 2063|      0|    frame_no, stats->bit_ctr - stats->bit_ctr_n, active_pps->weighted_pred_flag, img->qp, snr->snr_y,
 2064|      0|    snr->snr_u, snr->snr_v, tmp_time, me_time,
 2065|      0|          img->fld_flag ? "FLD" : "FRM", intras);
 2066|      0|}
 2067|       |
 2068|       |static void ReportRB(int tmp_time, int me_time)
 2069|      0|{
 2070|      0|  printf ("%04d(RB) %8d %1d %2d %7.3f %7.3f %7.3f  %7d   %5d     %3s   %3d %1d\n",
 2071|      0|    frame_no, stats->bit_ctr - stats->bit_ctr_n, active_pps->weighted_bipred_idc, img->qp, snr->snr_y,
 2072|      0|    snr->snr_u, snr->snr_v, tmp_time, me_time,
 2073|      0|    img->fld_flag ? "FLD" : "FRM", intras,img->direct_spatial_mv_pred_flag);
 2074|      0|}
 2075|       |
 2076|       |static void ReportB(int tmp_time, int me_time)
 2077|     85|{
 2078|     85|    printf ("%04d(B)  %8d %1d %2d %7.3f %7.3f %7.3f  %7d   %5d     %3s   %3d %1d\n",
 2079|     85|    frame_no, stats->bit_ctr - stats->bit_ctr_n, active_pps->weighted_bipred_idc,img->qp,
 2080|     85|    snr->snr_y, snr->snr_u, snr->snr_v, tmp_time,me_time,
 2081|     85|    img->fld_flag ? "FLD" : "FRM",intras,img->direct_spatial_mv_pred_flag);
 2082|     85|}
 2083|       |
 2084|       |
 2085|       |static void ReportP(int tmp_time, int me_time)
 2086|     57|{            
 2087|     57|    printf ("%04d(P)  %8d %1d %2d %7.3f %7.3f %7.3f  %7d   %5d     %3s   %3d\n",
 2088|     57|    frame_no, stats->bit_ctr - stats->bit_ctr_n, active_pps->weighted_pred_flag, img->qp, snr->snr_y,
 2089|     57|    snr->snr_u, snr->snr_v, tmp_time, me_time,
 2090|     57|          img->fld_flag ? "FLD" : "FRM", intras);
 2091|       |
 2092|     57|}
 2093|       |
 2094|       |/*!
 2095|       | ************************************************************************
 2096|       | * \brief
 2097|       | *    Padding of automatically added border for picture sizes that are not
 2098|       | *     multiples of macroblock/macroblock pair size
 2099|       | *
 2100|       | * \param org_size_x
 2101|       | *    original image horizontal size (luma)
 2102|       | * \param org_size_y
 2103|       | *    original image vertical size (luma)
 2104|       | * \param img_size_x
 2105|       | *    coded image horizontal size (luma)
 2106|       | * \param img_size_y
 2107|       | *    code image vertical size (luma)
 2108|       | * \param org_size_x_cr
 2109|       | *    original image horizontal size (chroma)
 2110|       | * \param org_size_y_cr
 2111|       | *    original image vertical size (chroma)
 2112|       | * \param img_size_x_cr
 2113|       | *    coded image horizontal size (chroma)
 2114|       | * \param img_size_y_cr
 2115|       | *    code image vertical size (chroma)
 2116|       | ************************************************************************
 2117|       | */
 2118|       |static void PaddAutoCropBorders (int org_size_x, int org_size_y, int img_size_x, int img_size_y,
 2119|       |                                 int org_size_x_cr, int org_size_y_cr, int img_size_x_cr, int img_size_y_cr)
 2120|    171|{
 2121|    171|  int x, y;
 2122|       |  
 2123|       |  //padding right border
 2124|  54.8k|  for (y=0; y<org_size_y; y++)
 2125|  54.7k|    for (x=org_size_x; x<img_size_x; x++)
 2126|      0|      imgY_org_frm [y][x] = imgY_org_frm [y][x-1];
 2127|       |
 2128|       |  //padding bottom border
 2129|    171|  for (y=org_size_y; y<img_size_y; y++)
 2130|      0|    for (x=0; x<img_size_x; x++)
 2131|      0|      imgY_org_frm [y][x] = imgY_org_frm [y-1][x];
 2132|       |
 2133|       |
 2134|    171|  if (img->yuv_format != YUV400)
 2135|    171|  {
 2136|       |    //padding right border
 2137|  27.5k|    for (y=0; y<org_size_y_cr; y++)
 2138|  27.3k|      for (x=org_size_x_cr; x<img_size_x_cr; x++)
 2139|      0|      {
 2140|      0|        imgUV_org_frm [0][y][x] = imgUV_org_frm [0][y][x-1];
 2141|      0|        imgUV_org_frm [1][y][x] = imgUV_org_frm [1][y][x-1];
 2142|      0|      }
 2143|       |     
 2144|       |    //padding bottom border
 2145|    171|    for (y=org_size_y_cr; y<img_size_y_cr; y++)
 2146|      0|      for (x=0; x<img_size_x_cr; x++)
 2147|      0|      {
 2148|      0|        imgUV_org_frm [0][y][x] = imgUV_org_frm [0][y-1][x];
 2149|      0|        imgUV_org_frm [1][y][x] = imgUV_org_frm [1][y-1][x];
 2150|      0|      }
 2151|    171|  }
 2152|    171|}
 2153|       |
 2154|       |
 2155|       |/*!
 2156|       | ************************************************************************
 2157|       | * \brief
 2158|       | *    Calculates the absolute frame number in the source file out
 2159|       | *    of various variables in img-> and input->
 2160|       | * \return
 2161|       | *    frame number in the file to be read
 2162|       | * \par side effects
 2163|       | *    global variable frame_no updated -- dunno, for what this one is necessary
 2164|       | ************************************************************************
 2165|       | */
 2166|       |static int CalculateFrameNumber()
 2167|    171|{
 2168|    171|  if (img->b_frame_to_code)
 2169|     85|  {
 2170|       |
 2171|     85|    if (input->PyramidCoding)
 2172|      0|      frame_no = start_tr_in_this_IGOP + (IMG_NUMBER - 1) * (input->jumpd + 1) + (int) (img->b_interval * (double) (1 + gop_structure[img->b_frame_to_code - 1].display_no));
 2173|     85|    else      
 2174|     85|    frame_no = start_tr_in_this_IGOP + (IMG_NUMBER - 1) * (input->jumpd + 1) + (int) (img->b_interval * (double) img->b_frame_to_code);
 2175|     85|  }
 2176|     86|  else
 2177|     86|    {
 2178|     86|      frame_no = start_tr_in_this_IGOP + IMG_NUMBER * (input->jumpd + 1);
 2179|     86|#ifdef _ADAPT_LAST_GROUP_
 2180|     86|      if (input->last_frame && img->number + 1 == input->no_frames)
 2181|      0|        frame_no = input->last_frame;
 2182|     86|#endif
 2183|     86|    }
 2184|       |
 2185|    171|  return frame_no;
 2186|    171|}
 2187|       |
 2188|       |
 2189|       |/*!
 2190|       | ************************************************************************
 2191|       | * \brief
 2192|       | *    Convert file read buffer to source picture structure
 2193|       | * \param imgX
 2194|       | *    Pointer to image plane
 2195|       | * \param buf
 2196|       | *    Buffer for file output
 2197|       | * \param size
 2198|       | *    image size in pixel
 2199|       | ************************************************************************
 2200|       | */
 2201|       |void buf2img (imgpel** imgX, unsigned char* buf, int size_x, int size_y, int symbol_size_in_bytes)
 2202|    513|{
 2203|    513|  int i,j;
 2204|       |
 2205|    513|  unsigned short tmp16, ui16;
 2206|    513|  unsigned long  tmp32, ui32;
 2207|       |
 2208|    513|  if (symbol_size_in_bytes> sizeof(imgpel))
 2209|      0|  {
 2210|      0|    error ("Source picture has higher bit depth than imgpel data type. Please recompile with larger data type for imgpel.", 500);
 2211|      0|  }
 2212|       |
 2213|    513|  if (( sizeof(char) == sizeof (imgpel)) && ( sizeof(char) == symbol_size_in_bytes))
 2214|      0|  {
 2215|       |    // imgpel == pixel_in_file == 1 byte -> simple copy
 2216|      0|    for(j=0;j<size_y;j++)
 2217|      0|      memcpy(imgX[j], buf+j*size_x, size_x);
 2218|      0|  }
 2219|    513|  else
 2220|    513|  {
 2221|       |    // sizeof (imgpel) > sizeof(char)
 2222|    513|    if (testEndian())
 2223|      0|    {
 2224|       |      // big endian
 2225|      0|      switch (symbol_size_in_bytes)
 2226|      0|      {
 2227|      0|      case 1:
 2228|      0|        {
 2229|      0|          for(j=0;j<size_y;j++)
 2230|      0|            for(i=0;i<size_x;i++)
 2231|      0|            {
 2232|      0|              imgX[j][i]= buf[i+j*size_x];
 2233|      0|            }
 2234|      0|          break;
 2235|      0|        }
 2236|      0|      case 2:
 2237|      0|        {
 2238|      0|          for(j=0;j<size_y;j++)
 2239|      0|            for(i=0;i<size_x;i++)
 2240|      0|            {
 2241|      0|              memcpy(&tmp16, buf+((i+j*size_x)*2), 2);
 2242|      0|              ui16  = (tmp16 >> 8) | ((tmp16&0xFF)<<8);
 2243|      0|              imgX[j][i] = (imgpel) ui16;
 2244|      0|            }
 2245|       |
 2246|      0|          break;
 2247|      0|        }
 2248|      0|      case 4:
 2249|      0|        {
 2250|      0|          for(j=0;j<size_y;j++)
 2251|      0|            for(i=0;i<size_x;i++)
 2252|      0|            {
 2253|      0|              memcpy(&tmp32, buf+((i+j*size_x)*4), 4);
 2254|      0|              ui32  = ((tmp32&0xFF00)<<8) | ((tmp32&0xFF)<<24) | ((tmp32&0xFF0000)>>8) | ((tmp32&0xFF000000)>>24);
 2255|      0|              imgX[j][i] = (imgpel) ui32;
 2256|      0|            }
 2257|      0|        }
 2258|      0|      default:
 2259|      0|        {
 2260|      0|           error ("reading only from formats of 8, 16 or 32 bit allowed on big endian architecture", 500);
 2261|      0|           break;
 2262|      0|        }
 2263|      0|      }
 2264|       |
 2265|      0|    }
 2266|    513|    else
 2267|    513|    {
 2268|       |      // little endian
 2269|   109k|      for (j=0; j < size_y; j++)
 2270|  42.1M|        for (i=0; i < size_x; i++)
 2271|  42.0M|        {
 2272|  42.0M|          imgX[j][i]=0;
 2273|  42.0M|          memcpy(&(imgX[j][i]), buf +((i+j*size_x)*symbol_size_in_bytes), symbol_size_in_bytes);
 2274|  42.0M|        }
 2275|    513|    }
 2276|    513|  }
 2277|    513|}
 2278|       |
 2279|       |
 2280|       |/*!
 2281|       | ************************************************************************
 2282|       | * \brief
 2283|       | *    Reads one new frame from file
 2284|       | *
 2285|       | * \param FrameNoInFile
 2286|       | *    Frame number in the source file
 2287|       | * \param HeaderSize
 2288|       | *    Number of bytes in the source file to be skipped
 2289|       | * \param xs
 2290|       | *    horizontal size of frame in pixels
 2291|       | * \param ys
 2292|       | *    vertical size of frame in pixels
 2293|       | * \param xs_cr
 2294|       | *    horizontal chroma size of frame in pixels
 2295|       | * \param ys_cr
 2296|       | *    vertical chroma size of frame in pixels
 2297|       | ************************************************************************
 2298|       | */
 2299|       |static void ReadOneFrame (int FrameNoInFile, int HeaderSize, int xs, int ys, int xs_cr, int ys_cr)
 2300|    171|{
 2301|    171|  unsigned int symbol_size_in_bytes = img->pic_unit_size_on_disk/8;
 2302|       |  
 2303|    171|  const int imgsize_y = xs*ys;
 2304|    171|  const int imgsize_uv = xs_cr*ys_cr;
 2305|       |
 2306|    171|  const int bytes_y = imgsize_y * symbol_size_in_bytes;
 2307|    171|  const int bytes_uv = imgsize_uv * symbol_size_in_bytes;
 2308|       |
 2309|    171|  const int64 framesize_in_bytes = bytes_y + 2*bytes_uv;
 2310|    171|  unsigned char *buf;
 2311|       |
 2312|    171|  Boolean rgb_input = (input->rgb_input_flag==1 && input->yuv_format==3);
 2313|       |
 2314|       |
 2315|    171|  assert (p_in != -1);
 2316|       |
 2317|       |  // KS: this buffer should actually be allocated only once, but this is still much faster than the previous version
 2318|    171|  if (NULL==(buf = malloc (xs*ys * symbol_size_in_bytes))) no_mem_exit("ReadOneFrame: buf");
 2319|       |
 2320|       |  // skip Header
 2321|    171|  if (lseek (p_in, HeaderSize, SEEK_SET) != HeaderSize)
 2322|      0|  {
 2323|      0|    error ("ReadOneFrame: cannot fseek to (Header size) in p_in", -1);
 2324|      0|  }
 2325|       |
 2326|       |  // skip starting frames
 2327|    171|  if (lseek (p_in, framesize_in_bytes * input->start_frame, SEEK_CUR) == -1) 
 2328|      0|  {
 2329|      0|    snprintf(errortext, ET_SIZE, "ReadOneFrame: cannot advance file pointer in p_in beyond frame %d\n", input->start_frame);
 2330|      0|    error (errortext,-1);
 2331|      0|  } 
 2332|       |
 2333|       |  // seek to current frame 
 2334|    171|  if (lseek (p_in, framesize_in_bytes * FrameNoInFile, SEEK_CUR) == -1) 
 2335|      0|  {
 2336|      0|    snprintf(errortext, ET_SIZE, "ReadOneFrame: cannot advance file pointer in p_in beyond frame %d\n", input->start_frame + FrameNoInFile);
 2337|      0|    error (errortext,-1);
 2338|      0|  }
 2339|       |
 2340|       |  // Here we are at the correct position for the source frame in the file.  Now
 2341|       |  // read it.
 2342|    171|  if (img->pic_unit_size_on_disk%8 == 0)
 2343|    171|  {
 2344|    171|    if(rgb_input)
 2345|      0|      lseek (p_in, framesize_in_bytes/3, SEEK_CUR);
 2346|       |
 2347|    171|    if (read(p_in, buf, bytes_y) != bytes_y)
 2348|      0|    {
 2349|      0|      printf ("ReadOneFrame: cannot read %d bytes from input file, unexpected EOF?, exiting", bytes_y);
 2350|      0|      report_stats_on_error();
 2351|      0|      exit (-1);
 2352|      0|    }
 2353|       |
 2354|    171|    buf2img(imgY_org_frm, buf, xs, ys, symbol_size_in_bytes);
 2355|       |    
 2356|    171|    if (img->yuv_format != YUV400)
 2357|    171|    {
 2358|    171|      if (read(p_in, buf, bytes_uv) != bytes_uv)
 2359|      0|      {
 2360|      0|        printf ("ReadOneFrame: cannot read %d bytes from input file, unexpected EOF?, exiting", bytes_y);
 2361|      0|        report_stats_on_error();
 2362|      0|        exit (-1);
 2363|      0|      }
 2364|    171|      buf2img(imgUV_org_frm[0], buf, xs_cr, ys_cr, symbol_size_in_bytes);
 2365|       |      
 2366|    171|      if(rgb_input)
 2367|      0|        lseek (p_in, -framesize_in_bytes, SEEK_CUR);
 2368|       |      
 2369|    171|      if (read(p_in, buf, bytes_uv) != bytes_uv)
 2370|      0|      {
 2371|      0|        printf ("ReadOneFrame: cannot read %d bytes from input file, unexpected EOF?, exiting", bytes_y);
 2372|      0|        report_stats_on_error();
 2373|      0|        exit (-1);
 2374|      0|      }
 2375|    171|      buf2img(imgUV_org_frm[1], buf, xs_cr, ys_cr, symbol_size_in_bytes);
 2376|       |
 2377|    171|      if(rgb_input)
 2378|      0|        lseek (p_in, framesize_in_bytes*2/3, SEEK_CUR);
 2379|    171|    }
 2380|    171|  }
 2381|      0|  else
 2382|      0|  {
 2383|      0|    printf ("ReadOneFrame (NOT IMPLEMENTED): pic unit size on disk must be divided by 8");
 2384|      0|    exit (-1);
 2385|      0|  }
 2386|    171|  free (buf);
 2387|       |  
 2388|    171|}
 2389|       |
 2390|       |
 2391|       |/*!
 2392|       | ************************************************************************
 2393|       | * \brief
 2394|       | *    point to frame coding variables 
 2395|       | ************************************************************************
 2396|       | */
 2397|       |static void put_buffer_frame()
 2398|    342|{
 2399|    342|  imgY_org  = imgY_org_frm;
 2400|    342|  imgUV_org = imgUV_org_frm;  
 2401|    342|}
 2402|       |
 2403|       |/*!
 2404|       | ************************************************************************
 2405|       | * \brief
 2406|       | *    point to top field coding variables 
 2407|       | ************************************************************************
 2408|       | */
 2409|       |static void put_buffer_top()
 2410|      0|{
 2411|      0|  img->fld_type = 0;
 2412|       |
 2413|      0|  imgY_org = imgY_org_top;
 2414|      0|  imgUV_org = imgUV_org_top;
 2415|      0|}
 2416|       |
 2417|       |/*!
 2418|       | ************************************************************************
 2419|       | * \brief
 2420|       | *    point to bottom field coding variables 
 2421|       | ************************************************************************
 2422|       | */
 2423|       |static void put_buffer_bot()
 2424|      0|{
 2425|      0|  img->fld_type = 1;
 2426|       |
 2427|      0|  imgY_org = imgY_org_bot;
 2428|      0|  imgUV_org = imgUV_org_bot;
 2429|      0|}
 2430|       |
 2431|       |/*!
 2432|       | ************************************************************************
 2433|       | * \brief
 2434|       | *    Writes a NAL unit of a partition or slice
 2435|       | ************************************************************************
 2436|       | */
 2437|       |
 2438|       |static void writeUnit(Bitstream* currStream,int partition)
 2439|    171|{
 2440|    171|  NALU_t *nalu;
 2441|    171|  assert (currStream->bits_to_go == 8);
 2442|    171|  nalu = AllocNALU(img->width*img->height*4);
 2443|    171|  nalu->startcodeprefix_len = 2+(img->current_mb_nr == 0?ZEROBYTES_SHORTSTARTCODE+1:ZEROBYTES_SHORTSTARTCODE);
 2444|       |//printf ("nalu->startcodeprefix_len %d\n", nalu->startcodeprefix_len);
 2445|    171|  nalu->len = currStream->byte_pos +1;            // add one for the first byte of the NALU
 2446|       |//printf ("nalu->len %d\n", nalu->len);
 2447|    171|  memcpy (&nalu->buf[1], currStream->streamBuffer, nalu->len-1);
 2448|    171|  if (img->currentPicture->idr_flag)
 2449|      1|  {
 2450|      1|    nalu->nal_unit_type = NALU_TYPE_IDR;
 2451|      1|    nalu->nal_reference_idc = NALU_PRIORITY_HIGHEST;
 2452|      1|  }
 2453|    170|  else if (img->type == B_SLICE)
 2454|     85|  {
 2455|       |    //different nal header for different partitions
 2456|     85|    if(input->partition_mode == 0)
 2457|     85|    {
 2458|     85|    nalu->nal_unit_type = NALU_TYPE_SLICE;
 2459|     85|    }
 2460|      0|    else
 2461|      0|    {
 2462|      0|      nalu->nal_unit_type = NALU_TYPE_DPA +  partition;
 2463|      0|    }
 2464|       |    
 2465|     85|    if (img->nal_reference_idc !=0)
 2466|      0|    {
 2467|      0|      nalu->nal_reference_idc = NALU_PRIORITY_HIGH;
 2468|      0|    }
 2469|     85|    else
 2470|     85|    {
 2471|     85|      nalu->nal_reference_idc = NALU_PRIORITY_DISPOSABLE;
 2472|     85|    }
 2473|     85|  }
 2474|     85|  else   // non-b frame, non IDR slice
 2475|     85|  {
 2476|       |    //different nal header for different partitions
 2477|     85|    if(input->partition_mode == 0)
 2478|     85|    {
 2479|     85|     nalu->nal_unit_type = NALU_TYPE_SLICE;
 2480|     85|    }
 2481|      0|    else
 2482|      0|    {
 2483|      0|     nalu->nal_unit_type = NALU_TYPE_DPA +  partition;
 2484|      0|    }
 2485|     85|    if (img->nal_reference_idc !=0)
 2486|     85|    {
 2487|     85|      nalu->nal_reference_idc = NALU_PRIORITY_HIGH;
 2488|     85|    }
 2489|      0|    else
 2490|      0|    {
 2491|      0|      nalu->nal_reference_idc = NALU_PRIORITY_DISPOSABLE;
 2492|      0|    }
 2493|     85|  }      
 2494|    171|  nalu->forbidden_bit = 0;
 2495|    171|  stats->bit_ctr += WriteNALU (nalu);
 2496|       |
 2497|    171|  FreeNALU(nalu);
 2498|    171|}
 2499|       |              
 2500|       |/*!
 2501|       | ************************************************************************
 2502|       | * \brief
 2503|       | *    performs multi-pass encoding of same picture using different 
 2504|       | *    coding conditions
 2505|       | ************************************************************************
 2506|       | */
 2507|       |
 2508|       |static void rdPictureCoding()
 2509|      0|{
 2510|      0|  int second_qp = img->qp, rd_qp = img->qp;
 2511|      0|  int previntras = intras;
 2512|      0|  int prevtype = img->type;
 2513|      0|  int skip_encode = 0;
 2514|      0|  pic_parameter_set_rbsp_t *sec_pps;
 2515|       |    
 2516|       |  
 2517|      0|  if (img->type!=I_SLICE && input->GenerateMultiplePPS)
 2518|      0|  {
 2519|      0|    if (img->type==P_SLICE)
 2520|      0|    {
 2521|      0|      if (test_wp_P_slice(0) == 1)
 2522|      0|      {
 2523|      0|        active_pps = &PicParSet[1];
 2524|      0|      }
 2525|      0|      else
 2526|      0|      {
 2527|      0|        skip_encode = input->RDPSliceWeightOnly;
 2528|      0|        active_pps = &PicParSet[0];
 2529|      0|        img->qp-=1;
 2530|      0|      }
 2531|      0|    }
 2532|      0|    else
 2533|      0|    {
 2534|      0|      active_pps = &PicParSet[2];
 2535|      0|    }
 2536|      0|  }
 2537|      0|  else        
 2538|      0|  {
 2539|      0|    img->qp-=1;
 2540|      0|  }
 2541|       |  
 2542|      0|  sec_pps = active_pps;
 2543|      0|  second_qp = img->qp;
 2544|       |  
 2545|      0|  img->write_macroblock = 0;
 2546|       |  
 2547|      0|  if (skip_encode)
 2548|      0|  {
 2549|      0|    img->rd_pass = 0;
 2550|      0|    enc_frame_picture2 = NULL;
 2551|      0|  }
 2552|      0|  else
 2553|      0|  {
 2554|      0|    frame_picture (frame_pic2,1);
 2555|      0|    img->rd_pass=picture_coding_decision(frame_pic, frame_pic2, rd_qp);
 2556|      0|  }
 2557|       |  //      update_rd_picture_contexts (img->rd_pass); 
 2558|      0|  if (img->rd_pass==0)
 2559|      0|  {
 2560|      0|    enc_picture=enc_frame_picture;
 2561|      0|    if (img->type!=I_SLICE && input->GenerateMultiplePPS)
 2562|      0|    { 
 2563|      0|      img->qp=rd_qp;
 2564|      0|      active_pps = &PicParSet[0];
 2565|      0|    }
 2566|      0|    else       
 2567|      0|    {
 2568|      0|      img->qp=rd_qp;
 2569|      0|    }
 2570|      0|    intras = previntras;
 2571|       |    
 2572|      0|  }
 2573|      0|  else
 2574|      0|  {
 2575|      0|    previntras = intras;
 2576|      0|  }
 2577|       |  // Final Encoding pass - note that we should 
 2578|       |  // make this more flexible in a later version.
 2579|       |  
 2580|      0|  if (img->type!=I_SLICE && input->GenerateMultiplePPS)
 2581|      0|  {
 2582|      0|    skip_encode = 0;
 2583|      0|    img->qp    = rd_qp;
 2584|      0|    if (img->type==P_SLICE)
 2585|      0|    {
 2586|      0|      if (test_wp_P_slice(1) == 1)
 2587|      0|      {
 2588|      0|        active_pps = &PicParSet[1];
 2589|      0|      }
 2590|      0|      else
 2591|      0|      {
 2592|      0|        skip_encode = input->RDPSliceWeightOnly;
 2593|      0|        active_pps = &PicParSet[0];
 2594|      0|        img->qp+=1;
 2595|      0|      }
 2596|      0|    }
 2597|      0|    else
 2598|      0|    {
 2599|      0|      if (test_wp_B_slice(0) == 1)
 2600|      0|      {
 2601|      0|        active_pps = &PicParSet[1];
 2602|      0|      }
 2603|      0|      else
 2604|      0|      {
 2605|      0|        skip_encode = input->RDBSliceWeightOnly;
 2606|       |
 2607|      0|        if (img->nal_reference_idc)          
 2608|      0|          img->qp = (rd_qp - 1);
 2609|      0|        else
 2610|      0|          img->qp = (rd_qp + 1);
 2611|      0|      }      
 2612|      0|    }
 2613|      0|  }
 2614|      0|  else 
 2615|      0|  {
 2616|      0|    active_pps = &PicParSet[0];
 2617|      0|    img->qp    = (rd_qp + 1);
 2618|      0|  }
 2619|       |  
 2620|      0|  if (img->type == P_SLICE && input->GenerateMultiplePPS && (intras * 100 )/img->FrameSizeInMbs >=75)
 2621|      0|  {
 2622|      0|    img->type=I_SLICE;
 2623|      0|    active_pps = &PicParSet[0];
 2624|      0|  }
 2625|       |  
 2626|      0|  img->write_macroblock = 0;
 2627|       |  
 2628|      0|  if (skip_encode)
 2629|      0|  {
 2630|      0|    enc_frame_picture3 = NULL;
 2631|      0|    img->qp = rd_qp;
 2632|      0|  }
 2633|      0|  else
 2634|      0|  {
 2635|      0|    frame_picture (frame_pic3,2);
 2636|       |    
 2637|      0|    if (img->rd_pass==0)
 2638|      0|      img->rd_pass  = 2*picture_coding_decision(frame_pic , frame_pic3, rd_qp);
 2639|      0|    else
 2640|      0|      img->rd_pass +=   picture_coding_decision(frame_pic2, frame_pic3, rd_qp);
 2641|      0|  }
 2642|       |
 2643|       |  //update_rd_picture_contexts (img->rd_pass); 
 2644|      0|  if (img->rd_pass==0)
 2645|      0|  {
 2646|      0|    enc_picture = enc_frame_picture;
 2647|      0|    img->type   = prevtype;
 2648|      0|    active_pps  = &PicParSet[0];
 2649|      0|    img->qp     = rd_qp;
 2650|      0|    intras      = previntras;
 2651|      0|  }
 2652|      0|  else if (img->rd_pass==1)
 2653|      0|  {
 2654|      0|    enc_picture = enc_frame_picture2;
 2655|      0|    img->type   = prevtype;
 2656|      0|    active_pps  = sec_pps;
 2657|      0|    img->qp     = second_qp;
 2658|      0|    intras      = previntras;
 2659|      0|  }       
 2660|      0|}
 2661|       |

/home/xzp/speccpu2006-v1.0.1/benchspec/CPU2006/464.h264ref/run/build_base_ql_riscv_llvm17.0000/intrarefresh.c:
    1|       |
    2|       |/*!
    3|       | *****************************************************************************
    4|       | *
    5|       | * \file intrarefresh.c
    6|       | *
    7|       | * \brief
    8|       | *    Encoder support for pseudo-random intra macroblock refresh
    9|       | *
   10|       | * \date
   11|       | *    16 June 2002
   12|       | *
   13|       | * \author
   14|       | *    Stephan Wenger   stewe@cs.tu-berlin.de
   15|       | *****************************************************************************/
   16|       |
   17|       |#include <stdlib.h>
   18|       |#include <assert.h>
   19|       |
   20|       |#include "global.h"
   21|       |
   22|       |static int *RefreshPattern;
   23|       |static int *IntraMBs;
   24|       |static int WalkAround = 0;
   25|       |static int NumberOfMBs = 0;
   26|       |static int NumberIntraPerPicture;
   27|       | 
   28|       |/*!
   29|       | ************************************************************************
   30|       | * \brief
   31|       | *    RandomIntraInit: Initializes Random Intra module.  Should be called
   32|       | *    only after initialization (or changes) of the picture size or the
   33|       | *    random intra refresh value.  In version jm2.1 it is impossible to
   34|       | *    change those values on-the-fly, hence RandomIntraInit should be
   35|       | *    called immediately after the parsing of the config file
   36|       | *
   37|       | * \par Input:
   38|       | *    xsize, ysize: size of the picture (in MBs)
   39|       | *    refresh     : refresh rate in MBs per picture
   40|       | ************************************************************************
   41|       | */
   42|       |
   43|       |void RandomIntraInit(int xsize, int ysize, int refresh)
   44|      1|{
   45|      1|  int i, pos;
   46|       |
   47|      1|  #if defined(SPEC_CPU)
   48|      1|  spec_srand(1);
   49|       |  #else
   50|       |  srand (1);      // A fixed random initializer to make things reproducible
   51|       |  #endif /* SPEC_CPU */
   52|      1|  NumberOfMBs = xsize * ysize;
   53|      1|  NumberIntraPerPicture = refresh;
   54|       |
   55|      1|  #if defined(SPEC_CPU)
   56|      1|  RefreshPattern = malloc (sizeof (int) * (NumberOfMBs + 1));
   57|       |  #else
   58|       |  RefreshPattern = malloc (sizeof (int) * NumberOfMBs);
   59|       |  #endif /* SPEC_CPU */
   60|      1|  if (RefreshPattern == NULL) no_mem_exit("RandomIntraInit: RefreshPattern");
   61|       |
   62|      1|  #if defined(SPEC_CPU)
   63|      1|  IntraMBs = malloc (sizeof (int) * (refresh + 1));
   64|       |  #else
   65|       |  IntraMBs = malloc (sizeof (int) * refresh);
   66|       |  #endif /* SPEC_CPU */
   67|      1|  if (IntraMBs == NULL) no_mem_exit("RandomIntraInit: IntraMBs");
   68|       |
   69|    641|  for (i= 0; i<NumberOfMBs; i++)
   70|    640|    RefreshPattern[i] = -1;
   71|       |
   72|    641|  for (i=0; i<NumberOfMBs; i++)
   73|    640|  {
   74|    640|    do
   75|  4.20k|    {
   76|  4.20k|      #if defined(SPEC_CPU)
   77|  4.20k|      pos = ((int) (spec_rand() * (double) RAND_MAX)) % NumberOfMBs;
   78|       |      #else
   79|       |      pos = rand() % NumberOfMBs;
   80|       |      #endif
   81|  4.20k|    } while (RefreshPattern [pos] != -1);
   82|    640|    RefreshPattern [pos] = i;
   83|    640|  }
   84|       |/*
   85|       |for (i=0; i<NumberOfMBs; i++) printf ("%d\t", RefreshPattern[i]);
   86|       |getchar();
   87|       |*/
   88|      1|}
   89|       |
   90|       |/*!
   91|       | ************************************************************************
   92|       | * \brief
   93|       | *    RandomIntra: Code an MB as Intra?
   94|       | *
   95|       | * \par Input
   96|       | *    MacroblockNumberInScanOrder
   97|       | * \par Output
   98|       | *    1 if an MB should be forced to Intra, according the the 
   99|       | *      RefreshPattern
  100|       | *    0 otherwise
  101|       | *
  102|       | ************************************************************************
  103|       | */
  104|       |
  105|       |int RandomIntra (int mb)
  106|   109k|{
  107|   109k|  int i;
  108|       |
  109|   109k|  for (i=0; i<NumberIntraPerPicture; i++)
  110|      0|    if (IntraMBs[i] == mb)
  111|      0|      return 1;
  112|   109k|  return 0;
  113|   109k|}
  114|       |
  115|       |
  116|       |/*!
  117|       | ************************************************************************
  118|       | * \brief
  119|       | *    RandomIntraNewPicture: Selects new set of MBs for forced Intra
  120|       | *
  121|       | * \par
  122|       | *    This function should be called exactly once per picture, and 
  123|       | *    requires a finished initialization 
  124|       | *
  125|       | ************************************************************************
  126|       | */
  127|       |
  128|       |void RandomIntraNewPicture ()
  129|    171|{
  130|    171|  int i, j;
  131|       |
  132|    171|  WalkAround += NumberIntraPerPicture;
  133|    171|  for (j=0,i=WalkAround; j<NumberIntraPerPicture; j++, i++)
  134|      0|    IntraMBs[j] = RefreshPattern [i%NumberOfMBs];
  135|    171|}
  136|       |
  137|       |void RandomIntraUninit()
  138|      1|{
  139|      1|  free(RefreshPattern);
  140|      1|  free(IntraMBs);
  141|      1|}

/home/xzp/speccpu2006-v1.0.1/benchspec/CPU2006/464.h264ref/run/build_base_ql_riscv_llvm17.0000/leaky_bucket.c:
    1|       |
    2|       |/*!
    3|       | ***************************************************************************
    4|       | * \file leaky_bucket.c
    5|       | *
    6|       | * \brief
    7|       | *    calculate Leaky Buffer parameters
    8|       | *
    9|       | * \author
   10|       | *    Main contributors (see contributors.h for copyright, address and affiliation details)
   11|       | *    - Shankar Regunathan                   <shanre@microsoft.com>
   12|       | ***************************************************************************
   13|       | */
   14|       |#include <stdlib.h>
   15|       |
   16|       |#include "contributors.h"
   17|       |#include "global.h"
   18|       |
   19|       |#ifdef _LEAKYBUCKET_
   20|       |
   21|       |long Bit_Buffer[10000];
   22|       |unsigned long total_frame_buffer = 0;
   23|       |
   24|       |
   25|       |/*!
   26|       | ***********************************************************************
   27|       | * \brief
   28|       | *   Function to get Leaky Bucket rates from rate file
   29|       | * \param NumberLeakyBuckets
   30|       | *    Number of Leaky Bucket Parameters
   31|       | * \param Rmin
   32|       | *    Rate values for each Bucket.
   33|       | * \return
   34|       | *    returns 1 if successful; else returns zero.
   35|       | * \para SideEffects
   36|       | *     None.
   37|       | * \para Notes
   38|       | *     Failure if LeakyBucketRate is missing or if it does not have
   39|       | *     the correct number of entries.
   40|       | * \author
   41|       | *    Shankar Regunathan                   shanre@microsoft.com
   42|       | *  \date 
   43|       | *      December 06, 2001.
   44|       | ***********************************************************************
   45|       | */
   46|       |
   47|       |int get_LeakyBucketRate(unsigned long NumberLeakyBuckets, unsigned long *Rmin)
   48|      1|{
   49|      1|  FILE *f;
   50|      1|  unsigned long i, buf;
   51|       |  
   52|      1|  if((f = fopen(input->LeakyBucketRateFile, "r")) == NULL)
   53|      0|  {
   54|      0|    printf(" LeakyBucketRate File does not exist; using rate calculated from avg. rate \n");
   55|      0|    return 0;
   56|      0|  }
   57|       |  
   58|      3|  for(i=0; i<NumberLeakyBuckets; i++) 
   59|      3|  {
   60|      3|    if(1 != fscanf(f, "%ld", &buf)) 
   61|      1|    {
   62|      1|      printf(" Leaky BucketRateFile does not have valid entries;\n using rate calculated from avg. rate \n");
   63|      1|      fclose (f);
   64|      1|      return 0;
   65|      1|    }
   66|      2|    Rmin[i] = buf;
   67|      2|  }
   68|      0|  fclose (f);
   69|      0|  return 1;
   70|      1|}
   71|       |/*!
   72|       | ***********************************************************************
   73|       | * \brief
   74|       | *   Writes one unsigned long word in big endian order to a file. 
   75|       | * \param dw
   76|       | *    Value to be written
   77|       | * \param fp
   78|       | *    File pointer
   79|       | * \return
   80|       | *    None.
   81|       | * \para SideEffects
   82|       | *     None.
   83|       | * \author
   84|       | *    Shankar Regunathan                   shanre@microsoft.com
   85|       | *  \date 
   86|       | *      December 06, 2001.
   87|       | ***********************************************************************
   88|       | */
   89|       |
   90|       |void PutBigDoubleWord(unsigned long dw, FILE *fp)
   91|     25|{
   92|     25|  fputc((dw >> 0x18) & 0xFF, fp);
   93|     25|  fputc((dw >> 0x10) & 0xFF, fp);
   94|     25|  fputc((dw >> 0x08) & 0xFF, fp);
   95|     25|  fputc(dw & 0xFF, fp);
   96|     25|}
   97|       |
   98|       |/*!
   99|       | ***********************************************************************
  100|       | * \brief
  101|       | *   Stores the Leaky BucketParameters in file input->LeakyBucketParamFile.
  102|       | * \param NumberLeakyBuckets
  103|       | *    Number of LeakyBuckets.
  104|       | * \param Rmin
  105|       | *    Rate values of the buckets.
  106|       | * \param Bmin
  107|       | *    Minimum buffer values of the buckets.
  108|       | *  \param Fmin
  109|       | *     Minimum initial buffer fullness of the buckets
  110|       | * \return
  111|       | *    None.
  112|       | * \para
  113|       | *    Returns error if LeakyBucketParamFile cannot be opened.
  114|       | * \para SideEffects
  115|       | *     Prints the LeakyBucket Parameters in standard output.
  116|       | * \author
  117|       | *    Shankar Regunathan                   shanre@microsoft.com
  118|       | *  \date 
  119|       | *      December 06, 2001.
  120|       | ***********************************************************************
  121|       | */
  122|       |
  123|       |
  124|       |void write_buffer(unsigned long NumberLeakyBuckets, unsigned long Rmin[], unsigned long Bmin[], unsigned long Fmin[])
  125|      1|{
  126|      1|  FILE *outf;
  127|      1|  unsigned long iBucket;
  128|       |        
  129|      1|  if ((outf=fopen(input->LeakyBucketParamFile,"wb"))==NULL)
  130|      0|  {
  131|      0|    snprintf(errortext, ET_SIZE, "Error open file %s  \n",input->LeakyBucketParamFile);
  132|      0|    error(errortext,1);
  133|      0|  }
  134|       |
  135|      1|  PutBigDoubleWord(NumberLeakyBuckets, outf);
  136|      1|  printf(" Number Leaky Buckets: %ld \n     Rmin     Bmin     Fmin \n", NumberLeakyBuckets);
  137|      9|  for(iBucket =0; iBucket < NumberLeakyBuckets; iBucket++) 
  138|      8|  {
  139|       |    //assert(Rmin[iBucket]<4294967296); //Overflow should be corrected already.
  140|       |    //assert(Bmin[iBucket]<4294967296);
  141|       |    //assert(Fmin[iBucket]<4294967296);
  142|      8|    PutBigDoubleWord(Rmin[iBucket], outf);
  143|      8|    PutBigDoubleWord(Bmin[iBucket], outf);
  144|      8|    PutBigDoubleWord(Fmin[iBucket], outf);
  145|      8|    printf(" %8ld %8ld %8ld \n", Rmin[iBucket], Bmin[iBucket], Fmin[iBucket]);
  146|      8|  }
  147|      1|  fclose(outf);
  148|      1|}
  149|       |
  150|       |/*!
  151|       | ***********************************************************************
  152|       | * \brief
  153|       | *    Sorts the rate array in ascending order. 
  154|       | * \param NumberLeakyBuckets
  155|       | *    Number of LeakyBuckets.
  156|       | * \param Rmin
  157|       | *    Rate values of the buckets.
  158|       | * \return
  159|       | *    None.
  160|       | * \author
  161|       | *    Shankar Regunathan                   shanre@microsoft.com
  162|       | *  \date 
  163|       | *      December 06, 2001.
  164|       | ***********************************************************************
  165|       | */
  166|       |
  167|       |
  168|       |void Sort(unsigned long NumberLeakyBuckets, unsigned long *Rmin)
  169|      1|{
  170|      1|  unsigned long i, j;
  171|      1|  unsigned long temp;
  172|      8|  for(i=0; i< NumberLeakyBuckets-1; i++) 
  173|      7|  {
  174|     35|    for(j=i+1; j<NumberLeakyBuckets; j++) 
  175|     28|    {
  176|     28|      if(Rmin[i] > Rmin[j]) {
  177|      0|        temp = Rmin[i];
  178|      0|        Rmin[i] = Rmin[j];
  179|      0|        Rmin[j] = temp;
  180|      0|      }
  181|     28|    }
  182|      7|  }
  183|      1|}
  184|       |
  185|       |/*!
  186|       | ***********************************************************************
  187|       | * \brief
  188|       | *    Main Routine to calculate Leaky Buffer parameters
  189|       | * \param NumberLeakyBuckets
  190|       | *    None.
  191|       | * \return
  192|       | *    None.
  193|       | * \author
  194|       | *    Shankar Regunathan                   shanre@microsoft.com
  195|       | *  \date 
  196|       | *      December 06, 2001.
  197|       | ***********************************************************************
  198|       | */
  199|       |
  200|       |void calc_buffer()
  201|      1|{    
  202|      1|  unsigned long AvgRate, TotalRate, NumberLeakyBuckets;
  203|      1|  long *buffer_frame, minB;
  204|      1|  unsigned long iBucket, iFrame,  FrameIndex = 0;
  205|      1|  long maxBuffer, actualBuffer, InitFullness, iChannelRate;
  206|      1|  unsigned long *Rmin, *Bmin, *Fmin;
  207|       |   
  208|      1|  fprintf(stdout,"-------------------------------------------------------------------------------\n");
  209|      1|  printf(" Total Frames:  %ld (%d) \n", total_frame_buffer, input->no_frames);
  210|      1|  NumberLeakyBuckets = (unsigned long) input->NumberLeakyBuckets;
  211|      1|  buffer_frame = calloc(total_frame_buffer+1, sizeof(long));
  212|      1|  if(!buffer_frame)
  213|      0|    no_mem_exit("init_buffer: buffer_frame");
  214|      1|  Rmin = calloc(NumberLeakyBuckets, sizeof(unsigned long));
  215|      1|  if(!Rmin)
  216|      0|    no_mem_exit("init_buffer: Rmin");    
  217|      1|  Bmin = calloc(NumberLeakyBuckets, sizeof(unsigned long));
  218|      1|  if(!Bmin)
  219|      0|    no_mem_exit("init_buffer: Bmin");
  220|      1|  Fmin = calloc(NumberLeakyBuckets, sizeof(unsigned long));
  221|      1|  if(!Fmin)
  222|      0|    no_mem_exit("init_buffer: Fmin");
  223|       |
  224|      1|  TotalRate = 0;
  225|    172|  for(iFrame=0; iFrame < total_frame_buffer; iFrame++) 
  226|    171|  {
  227|    171|    TotalRate += (unsigned long) Bit_Buffer[iFrame];
  228|    171|  }
  229|      1|  AvgRate = (unsigned long) ((float) TotalRate/ total_frame_buffer);
  230|       |  
  231|      1|  if(1 != get_LeakyBucketRate(NumberLeakyBuckets, Rmin))
  232|      1|  { /* if rate file is not present, use default calculated from avg.rate */
  233|      9|    for(iBucket=0; iBucket < NumberLeakyBuckets; iBucket++) 
  234|      8|    {
  235|      8|      if(iBucket == 0)
  236|      1|        Rmin[iBucket] = (unsigned long)((float) AvgRate * img->framerate)/(input->jumpd+1); /* convert bits/frame to bits/second */
  237|      7|      else
  238|      7|        Rmin[iBucket] = (unsigned long) ((float) Rmin[iBucket-1] + (AvgRate/4) * (img->framerate) / (input->jumpd+1));    
  239|      8|    }
  240|      1|  }
  241|      1|  Sort(NumberLeakyBuckets, Rmin);   
  242|       |
  243|      1|  maxBuffer = AvgRate * 20; /* any initialization is good. */        
  244|      9|  for(iBucket=0; iBucket< NumberLeakyBuckets; iBucket++) 
  245|      8|  {           
  246|      8|    iChannelRate = (long) (Rmin[iBucket] * (input->jumpd+1)/(img->framerate)); /* converts bits/second to bits/frame */
  247|       |    /* To calculate initial buffer size */
  248|      8|    InitFullness = maxBuffer; /* set Initial Fullness to be buffer size */
  249|      8|    buffer_frame[0] = InitFullness;
  250|      8|    minB = maxBuffer; 
  251|       |    
  252|  1.37k|    for(iFrame=0; iFrame<total_frame_buffer ; iFrame++) 
  253|  1.36k|    {        
  254|  1.36k|      buffer_frame[iFrame] = buffer_frame[iFrame] - Bit_Buffer[iFrame];
  255|  1.36k|      if(buffer_frame[iFrame] < minB) 
  256|     25|      {
  257|     25|        minB = buffer_frame[iFrame];
  258|     25|        FrameIndex = iFrame;
  259|     25|      }
  260|       |      
  261|  1.36k|      buffer_frame[iFrame+1] = buffer_frame[iFrame] + iChannelRate;
  262|  1.36k|      if(buffer_frame[iFrame+1] > maxBuffer)
  263|    831|        buffer_frame[iFrame+1] = maxBuffer;
  264|  1.36k|    }
  265|      8|    actualBuffer = (maxBuffer - minB);
  266|       |
  267|       |    /* To calculate initial buffer Fullness */
  268|      8|    InitFullness = Bit_Buffer[0];
  269|      8|    buffer_frame[0] = InitFullness;
  270|     58|    for(iFrame=0; iFrame < FrameIndex+1; iFrame++) 
  271|     56|    {
  272|     56|      buffer_frame[iFrame] = buffer_frame[iFrame] - Bit_Buffer[iFrame];
  273|     56|      if(buffer_frame[iFrame] < 0) {
  274|     10|        InitFullness -= buffer_frame[iFrame];
  275|     10|        buffer_frame[iFrame] = 0;
  276|     10|      }
  277|     56|      buffer_frame[iFrame+1] = buffer_frame[iFrame] + iChannelRate;
  278|     56|      if(buffer_frame[iFrame+1] > actualBuffer)
  279|      6|        break;
  280|     56|    }       
  281|      8|    Bmin[iBucket] = (unsigned long) actualBuffer;
  282|      8|    Fmin[iBucket] = (unsigned long) InitFullness;
  283|      8|  }
  284|       |
  285|      1|  write_buffer(NumberLeakyBuckets, Rmin, Bmin, Fmin);
  286|       |
  287|      1|  free(buffer_frame);
  288|      1|  free(Rmin);
  289|      1|  free(Bmin);
  290|      1|  free(Fmin);
  291|      1|  return;
  292|      1|}
  293|       |#endif
  294|       |

/home/xzp/speccpu2006-v1.0.1/benchspec/CPU2006/464.h264ref/run/build_base_ql_riscv_llvm17.0000/lencod.c:
    1|       |
    2|       |/*!
    3|       | ***********************************************************************
    4|       | *  \mainpage
    5|       | *     This is the H.264/AVC encoder reference software. For detailed documentation
    6|       | *     see the comments in each file.
    7|       | *
    8|       | *  \author
    9|       | *     The main contributors are listed in contributors.h
   10|       | *
   11|       | *  \version
   12|       | *     JM 9.3 (FRExt)
   13|       | *
   14|       | *  \note
   15|       | *     tags are used for document system "doxygen"
   16|       | *     available at http://www.doxygen.org
   17|       | */
   18|       |/*!
   19|       | *  \file
   20|       | *     lencod.c
   21|       | *  \brief
   22|       | *     H.264/AVC reference encoder project main()
   23|       | *  \author
   24|       | *   Main contributors (see contributors.h for copyright, address and affiliation details)
   25|       | *   - Inge Lille-Langoy               <inge.lille-langoy@telenor.com>
   26|       | *   - Rickard Sjoberg                 <rickard.sjoberg@era.ericsson.se>
   27|       | *   - Stephan Wenger                  <stewe@cs.tu-berlin.de>
   28|       | *   - Jani Lainema                    <jani.lainema@nokia.com>
   29|       | *   - Byeong-Moon Jeon                <jeonbm@lge.com>
   30|       | *   - Yoon-Seong Soh                  <yunsung@lge.com>
   31|       | *   - Thomas Stockhammer              <stockhammer@ei.tum.de>
   32|       | *   - Detlev Marpe                    <marpe@hhi.de>
   33|       | *   - Guido Heising                   <heising@hhi.de>
   34|       | *   - Valeri George                   <george@hhi.de>
   35|       | *   - Karsten Suehring                <suehring@hhi.de>
   36|       | *   - Alexis Michael Tourapis         <alexismt@ieee.org>
   37|       | ***********************************************************************
   38|       | */
   39|       |
   40|       |#include "contributors.h"
   41|       |
   42|       |#include <stdlib.h>
   43|       |#include <string.h>
   44|       |#include <time.h>
   45|       |#include <sys/timeb.h>
   46|       |
   47|       |#ifdef WIN32
   48|       |#include <io.h>
   49|       |#else
   50|       |#include <unistd.h>
   51|       |#endif
   52|       |
   53|       |#include "global.h"
   54|       |
   55|       |#include "configfile.h"
   56|       |#include "leaky_bucket.h"
   57|       |#include "memalloc.h"
   58|       |#include "intrarefresh.h"
   59|       |#include "fmo.h"
   60|       |#include "sei.h"
   61|       |#include "parset.h"
   62|       |#include "image.h"
   63|       |#include "output.h"
   64|       |#include "fast_me.h"
   65|       |#include "ratectl.h"
   66|       |#include "explicit_gop.h"
   67|       |
   68|      1|#define JM      "9 (FRExt)"
   69|      2|#define VERSION "9.3"
   70|      1|#define EXT_VERSION "(FRExt)"
   71|       |
   72|       |#if defined(SPEC_CPU)
   73|       |Picture *top_pic;
   74|       |Picture *bottom_pic;
   75|       |Picture *frame_pic;
   76|       |Picture *frame_pic2;
   77|       |Picture *frame_pic3;
   78|       |
   79|       |// global picture format dependend buffers, mem allocation in image.c
   80|       |imgpel **imgY_org;           //!< Reference luma image
   81|       |imgpel ***imgUV_org;         //!< Reference chroma image
   82|       |int    **img4Y_tmp;          //!< for quarter pel interpolation
   83|       |
   84|       |unsigned int log2_max_frame_num_minus4;
   85|       |unsigned int log2_max_pic_order_cnt_lsb_minus4;
   86|       |
   87|       |int  me_tot_time,me_time;
   88|       |pic_parameter_set_rbsp_t *active_pps;
   89|       |seq_parameter_set_rbsp_t *active_sps;
   90|       |
   91|       |// B pictures
   92|       |// motion vector : forward, backward, direct
   93|       |int  mb_adaptive;       //!< For MB level field/frame coding tools
   94|       |int  MBPairIsField;     //!< For MB level field/frame coding tools
   95|       |
   96|       |
   97|       |//Weighted prediction
   98|       |int ***wp_weight;  // weight in [list][index][component] order
   99|       |int ***wp_offset;  // offset in [list][index][component] order
  100|       |int ****wbp_weight;  // weight in [list][fwd_index][bwd_idx][component] order
  101|       |int luma_log_weight_denom;
  102|       |int chroma_log_weight_denom;
  103|       |int wp_luma_round;
  104|       |int wp_chroma_round;
  105|       |
  106|       |// global picture format dependend buffers, 
  107|       |// mem allocation in image.c (field picture)
  108|       |imgpel   **imgY_org_top;
  109|       |imgpel   **imgY_org_bot;
  110|       |
  111|       |imgpel  ***imgUV_org_top;
  112|       |imgpel  ***imgUV_org_bot;
  113|       |
  114|       |imgpel   **imgY_org_frm;
  115|       |imgpel  ***imgUV_org_frm;
  116|       |
  117|       |imgpel   **imgY_com;           //!< Encoded luma images
  118|       |imgpel  ***imgUV_com;          //!< Encoded croma images
  119|       |
  120|       |short   ***direct_ref_idx;     //!< direct mode reference index buffer
  121|       |short    **direct_pdir;        //!< direct mode reference index buffer
  122|       |
  123|       |// Buffers for rd optimization with packet losses, Dim. Kontopodis
  124|       |byte **pixel_map;   //!< Shows the latest reference frame that is reliable for each pixel
  125|       |byte **refresh_map; //!< Stores the new values for pixel_map  
  126|       |int intras;         //!< Counts the intra updates in each frame.
  127|       |
  128|       |int  Iframe_ctr, Pframe_ctr,Bframe_ctr;
  129|       |int  frame_no, nextP_tr_fld, nextP_tr_frm;
  130|       |int  tot_time;
  131|       |
  132|       |char errortext[ET_SIZE]; //!< buffer for error message for exit with error()
  133|       |
  134|       |// Residue Color Transform
  135|       |int resTrans_R[16][16], resTrans_G[16][16], resTrans_B[16][16];
  136|       |int rec_resR[16][16], rec_resG[16][16], rec_resB[16][16];
  137|       |int mprRGB[3][16][16];
  138|       |int dc_level[2][4][4], dc_level_temp[2][4][4];
  139|       |int cbp_chroma_block[2][4][4], cbp_chroma_block_temp[2][4][4];
  140|       |int b8_ipredmode8x8[4][4], b8_intra_pred_modes8x8[16];
  141|       |
  142|       |#endif /* SPEC_CPU */
  143|       |
  144|       |#if defined(SPEC_CPU)
  145|       |int Bytes_After_Header;
  146|       |#endif
  147|       |
  148|       |#if defined(SPEC_CPU)
  149|       |int QP,QP2; // added by SPEC because QP is defined in ratectl.c and image.c
  150|       |
  151|       |GOP_DATA *gop_structure;
  152|       |RD_DATA *rdopt;
  153|       |RD_DATA rddata_top_frame_mb, rddata_bot_frame_mb; //!< For MB level field/frame coding tools
  154|       |RD_DATA rddata_top_field_mb, rddata_bot_field_mb; //!< For MB level field/frame coding tools
  155|       |#endif /* SPEC_CPU */
  156|       |
  157|       |#if defined(SPEC_CPU)
  158|       |// files
  159|       |FILE *p_stat;                    //!< status file for the last encoding session
  160|       |FILE *p_log;                     //!< SNR file
  161|       |FILE *p_trace;                   //!< Trace file
  162|       |int  p_in;                       //!< original YUV file handle
  163|       |int  p_dec;                      //!< decoded image file handle
  164|       |
  165|       |
  166|       |int glob_remapping_of_pic_nums_idc_l0[20];
  167|       |int glob_abs_diff_pic_num_minus1_l0[20];
  168|       |int glob_long_term_pic_idx_l0[20];
  169|       |int glob_remapping_of_pic_nums_idc_l1[20];
  170|       |int glob_abs_diff_pic_num_minus1_l1[20];
  171|       |int glob_long_term_pic_idx_l1[20];
  172|       |
  173|       |int rpc_bytes_to_go;
  174|       |int rpc_bits_to_go;
  175|       |#endif /* SPEC_CPU */
  176|       |
  177|       |InputParameters inputs,      *input = &inputs;
  178|       |ImageParameters images,      *img   = &images;
  179|       |StatParameters  statistics,  *stats = &statistics;
  180|       |SNRParameters   snrs,        *snr   = &snrs;
  181|       |Decoders decoders, *decs=&decoders;
  182|       |
  183|       |
  184|       |#ifdef _ADAPT_LAST_GROUP_
  185|       |int initial_Bframes = 0;
  186|       |#endif
  187|       |
  188|       |Boolean In2ndIGOP = FALSE;
  189|       |int    start_frame_no_in_this_IGOP = 0;
  190|       |int    start_tr_in_this_IGOP = 0;
  191|       |int    FirstFrameIn2ndIGOP=0;
  192|       |int    cabac_encoding = 0;
  193|       |int    frame_statistic_start;
  194|       |extern ColocatedParams *Co_located;
  195|       |
  196|       |void Init_Motion_Search_Module ();
  197|       |void Clear_Motion_Search_Module ();
  198|       |void report_frame_statistic();
  199|       |
  200|       |/*!
  201|       | ***********************************************************************
  202|       | * \brief
  203|       | *    Main function for encoder.
  204|       | * \param argc
  205|       | *    number of command line arguments
  206|       | * \param argv
  207|       | *    command line arguments
  208|       | * \return
  209|       | *    exit code
  210|       | ***********************************************************************
  211|       | */
  212|       |int main(int argc,char **argv)
  213|      1|{
  214|      1|  int M,N,n,np,nb;           //Rate control
  215|       |
  216|      1|  p_dec = p_in = -1;
  217|       |
  218|      1|  p_stat = p_log = p_trace = NULL;
  219|       |
  220|      1|  frame_statistic_start = 1;
  221|       |
  222|      1|  Configure (argc, argv);
  223|       |
  224|      1|  Init_QMatrix();
  225|       |
  226|      1|  Init_QOffsetMatrix();
  227|       |
  228|      1|  AllocNalPayloadBuffer();
  229|       |
  230|      1|  init_poc();
  231|      1|  GenerateParameterSets();
  232|       |
  233|      1|  init_img();
  234|       |
  235|      1|  frame_pic = malloc_picture();
  236|       |
  237|      1|  if (input->RDPictureDecision)
  238|      0|  {
  239|      0|    frame_pic2 = malloc_picture();
  240|      0|    frame_pic3 = malloc_picture();
  241|      0|  }
  242|       |
  243|      1|  if (input->PicInterlace != FRAME_CODING)
  244|      0|  {
  245|      0|    top_pic = malloc_picture();
  246|      0|    bottom_pic = malloc_picture();
  247|      0|  }
  248|      1|  init_rdopt ();
  249|       |
  250|      1|  if (input->PyramidCoding )
  251|      0|  {
  252|      0|      init_gop_structure();
  253|      0|      if (input->PyramidCoding == 3)
  254|      0|      {
  255|      0|        interpret_gop_structure();
  256|      0|      }
  257|      0|      else
  258|      0|      {
  259|      0|        create_pyramid();
  260|      0|      }
  261|      0|  }
  262|       |
  263|      1|  init_dpb(input);
  264|      1|  init_out_buffer();
  265|       |
  266|      1|  enc_picture = enc_frame_picture = enc_top_picture = enc_bottom_picture = NULL;
  267|       |
  268|      1|  init_global_buffers();
  269|       |
  270|      1|  create_context_memory ();
  271|       |
  272|      1|  Init_Motion_Search_Module ();
  273|       |
  274|      1|  information_init();
  275|       |
  276|       |  //Rate control 
  277|      1|  if(input->RCEnable)
  278|      0|    rc_init_seq();
  279|       |
  280|      1|  if(input->FMEnable)
  281|      0|    DefineThreshold();
  282|       |
  283|       |  // Init frame type counter. Only supports single slice per frame.
  284|      1|  Iframe_ctr=0;
  285|      1|  Pframe_ctr=0;
  286|       |
  287|       |  // B pictures
  288|      1|  Bframe_ctr=0;
  289|      1|  tot_time=0;                 // time for total encoding session
  290|       |
  291|      1|#ifdef _ADAPT_LAST_GROUP_
  292|      1|  if (input->last_frame > 0)
  293|      0|    input->no_frames = 1 + (input->last_frame + input->jumpd) / (input->jumpd + 1);
  294|      1|  initial_Bframes = input->successive_Bframe;
  295|      1|#endif
  296|       |
  297|      1|  PatchInputNoFrames();
  298|       |
  299|       |  // Write sequence header (with parameter sets)
  300|      1|  stats->bit_ctr_parametersets = 0;
  301|      1|  stats->bit_slice = start_sequence();
  302|      1|  stats->bit_ctr_parametersets += stats->bit_ctr_parametersets_n;
  303|      1|  start_frame_no_in_this_IGOP = 0;
  304|       |
  305|     87|  for (img->number=0; img->number < input->no_frames; img->number++)
  306|     86|  {
  307|     86|    img->nal_reference_idc = 1;
  308|       |
  309|       |    //much of this can go in init_frame() or init_field()?
  310|       |    //poc for this frame or field
  311|     86|    img->toppoc = (input->intra_period && input->idr_enable ? IMG_NUMBER % input->intra_period : IMG_NUMBER) * (2*(input->jumpd+1)); 
  312|       |
  313|     86|    if ((input->PicInterlace==FRAME_CODING)&&(input->MbInterlace==FRAME_CODING))
  314|     86|      img->bottompoc = img->toppoc;     //progressive
  315|      0|    else 
  316|      0|      img->bottompoc = img->toppoc+1;   //hard coded
  317|       |
  318|     86|    img->framepoc = min (img->toppoc, img->bottompoc);
  319|       |
  320|       |    //frame_num for this frame
  321|       |    //if (input->BRefPictures== 0 || input->successive_Bframe == 0 || img-> number < 2)
  322|     86|    if ((input->BRefPictures== 0 &&  input->PyramidCoding == 0) || input->successive_Bframe == 0 || img-> number < 2)// ||  input->PyramidCoding == 0)
  323|     86|      img->frame_num = (input->intra_period && input->idr_enable ? IMG_NUMBER % input->intra_period : IMG_NUMBER) % (1 << (log2_max_frame_num_minus4 + 4)); 
  324|      0|    else 
  325|      0|    {
  326|      0|      img->frame_num ++;
  327|      0|      if (input->intra_period && input->idr_enable)
  328|      0|      {
  329|      0|        if (0== (img->number % input->intra_period))
  330|      0|        {
  331|      0|          img->frame_num=0;
  332|      0|        }
  333|      0|      }
  334|      0|      img->frame_num %= (1 << (log2_max_frame_num_minus4 + 4)); 
  335|      0|    }
  336|       |    
  337|       |    //the following is sent in the slice header
  338|     86|    img->delta_pic_order_cnt[0]=0;
  339|       |
  340|     86|    if (input->BRefPictures)
  341|      0|    {
  342|      0|      if (img->number)
  343|      0|      {
  344|      0|        img->delta_pic_order_cnt[0]=+2 * input->successive_Bframe;
  345|      0|      }
  346|      0|    }
  347|       |
  348|     86|    SetImgType();
  349|       |
  350|     86|#ifdef _ADAPT_LAST_GROUP_
  351|     86|    if (input->successive_Bframe && input->last_frame && IMG_NUMBER+1 == input->no_frames)
  352|      0|    {                                           
  353|      0|      int bi = (int)((float)(input->jumpd+1)/(input->successive_Bframe+1.0)+0.499999);
  354|       |      
  355|      0|      input->successive_Bframe = (input->last_frame-(img->number-1)*(input->jumpd+1))/bi-1;
  356|       |
  357|       |      //about to code the last ref frame, adjust deltapoc         
  358|      0|      img->delta_pic_order_cnt[0]= -2*(initial_Bframes - input->successive_Bframe);
  359|      0|      img->toppoc += img->delta_pic_order_cnt[0];
  360|      0|      img->bottompoc += img->delta_pic_order_cnt[0];
  361|      0|    }
  362|     86|#endif
  363|       |
  364|       |     //Rate control
  365|     86|    if (img->type == I_SLICE)
  366|     29|    {
  367|     29|      if(input->RCEnable)
  368|      0|      {
  369|      0|        if (input->intra_period == 0)
  370|      0|        {
  371|      0|          n = input->no_frames + (input->no_frames - 1) * input->successive_Bframe;
  372|       |          
  373|       |          /* number of P frames */
  374|      0|          np = input->no_frames-1; 
  375|       |          
  376|       |          /* number of B frames */
  377|      0|          nb = (input->no_frames - 1) * input->successive_Bframe;
  378|      0|        }else
  379|      0|        {
  380|      0|          N = input->intra_period*(input->successive_Bframe+1);
  381|      0|          M = input->successive_Bframe+1;
  382|      0|          n = (img->number==0) ? N - ( M - 1) : N;
  383|       |          
  384|       |          /* last GOP may contain less frames */
  385|      0|          if(img->number/input->intra_period >= input->no_frames / input->intra_period)
  386|      0|          {
  387|      0|            if (img->number != 0)
  388|      0|              n = (input->no_frames - img->number) + (input->no_frames - img->number - 1) * input->successive_Bframe + input->successive_Bframe;
  389|      0|            else
  390|      0|              n = input->no_frames  + (input->no_frames - 1) * input->successive_Bframe;
  391|      0|          }
  392|       |          
  393|       |          /* number of P frames */
  394|      0|          if (img->number == 0)
  395|      0|            np = (n + 2 * (M - 1)) / M - 1; /* first GOP */
  396|      0|          else
  397|      0|            np = (n + (M - 1)) / M - 1;
  398|       |          
  399|       |          /* number of B frames */
  400|      0|          nb = n - np - 1;
  401|      0|        }
  402|      0|        rc_init_GOP(np,nb);
  403|      0|      }
  404|     29|    }
  405|       |
  406|       |
  407|       |    // which layer the image belonged to?
  408|     86|    if ( IMG_NUMBER % (input->NumFramesInELSubSeq+1) == 0 )
  409|     86|      img->layer = 0;
  410|      0|    else
  411|      0|      img->layer = 1;
  412|       |
  413|     86|    encode_one_frame(); // encode one I- or P-frame
  414|       |
  415|     86|    if (input->ReportFrameStats)
  416|      0|      report_frame_statistic();
  417|       |    
  418|     86|    img->nb_references += 1;
  419|     86|    img->nb_references = min(img->nb_references, img->buf_cycle); // Tian Dong. PLUS1, +1, June 7, 2002
  420|       |
  421|     86|    encode_enhancement_layer();
  422|       |    
  423|     86|    process_2nd_IGOP();
  424|     86|  }
  425|       |  // terminate sequence
  426|      1|  terminate_sequence();
  427|       |
  428|      1|  flush_dpb();
  429|       |
  430|      1|  close(p_in);
  431|      1|  if (-1!=p_dec)
  432|      0|    close(p_dec);
  433|      1|  if (p_trace)
  434|      0|    fclose(p_trace);
  435|       |
  436|      1|  Clear_Motion_Search_Module ();
  437|       |
  438|      1|  RandomIntraUninit();
  439|      1|  FmoUninit();
  440|       |  
  441|      1|  if (input->PyramidCoding)
  442|      0|    clear_gop_structure ();
  443|       |
  444|       |  // free structure for rd-opt. mode decision
  445|      1|  clear_rdopt ();
  446|       |
  447|      1|#ifdef _LEAKYBUCKET_
  448|      1|  calc_buffer();
  449|      1|#endif
  450|       |
  451|       |  // report everything
  452|      1|  report();
  453|       |
  454|      1|  free_picture (frame_pic);
  455|       |  
  456|      1|  if (input->RDPictureDecision)
  457|      0|  {
  458|      0|    free_picture (frame_pic2);
  459|      0|    free_picture (frame_pic3);
  460|      0|  }
  461|       |
  462|      1|  if (top_pic)
  463|      0|    free_picture (top_pic);
  464|      1|  if (bottom_pic)
  465|      0|    free_picture (bottom_pic);
  466|       |
  467|      1|  free_dpb();
  468|      1|  free_colocated(Co_located);
  469|      1|  uninit_out_buffer();
  470|       |
  471|      1|  free_global_buffers();
  472|       |
  473|       |  // free image mem
  474|      1|  free_img ();
  475|      1|  free_context_memory ();
  476|      1|  FreeNalPayloadBuffer();
  477|      1|  FreeParameterSets();
  478|      1|  return 0;                         //encode JM73_FME version
  479|      1|}
  480|       |/*!
  481|       | ***********************************************************************
  482|       | * \brief
  483|       | *    Terminates and reports statistics on error.
  484|       | * 
  485|       | ***********************************************************************
  486|       | */
  487|       |void report_stats_on_error()
  488|      0|{
  489|      0|  input->no_frames=img->number-1;
  490|      0|  terminate_sequence();
  491|       |
  492|      0|  flush_dpb();
  493|       |  
  494|      0|  close(p_in);
  495|      0|  if (-1!=p_dec)
  496|      0|    close(p_dec);
  497|       |
  498|      0|  if (p_trace)
  499|      0|    fclose(p_trace);
  500|       |  
  501|      0|  Clear_Motion_Search_Module ();
  502|       |  
  503|      0|  RandomIntraUninit();
  504|      0|  FmoUninit();
  505|       |  
  506|      0|  if (input->PyramidCoding)
  507|      0|    clear_gop_structure ();
  508|       |  
  509|       |  // free structure for rd-opt. mode decision
  510|      0|  clear_rdopt ();
  511|       |  
  512|      0|#ifdef _LEAKYBUCKET_
  513|      0|  calc_buffer();
  514|      0|#endif
  515|       |
  516|      0|  if (input->ReportFrameStats)
  517|      0|    report_frame_statistic();
  518|       |  
  519|       |  // report everything
  520|      0|  report();
  521|       |  
  522|      0|  free_picture (frame_pic);
  523|      0|  if (top_pic)
  524|      0|    free_picture (top_pic);
  525|      0|  if (bottom_pic)
  526|      0|    free_picture (bottom_pic);
  527|       |  
  528|      0|  free_dpb();
  529|      0|  free_colocated(Co_located);
  530|      0|  uninit_out_buffer();
  531|       |  
  532|      0|  free_global_buffers();
  533|       |  
  534|       |  // free image mem
  535|      0|  free_img ();
  536|      0|  free_context_memory ();
  537|      0|  FreeNalPayloadBuffer();
  538|      0|  FreeParameterSets();
  539|      0|}
  540|       |
  541|       |/*!
  542|       | ***********************************************************************
  543|       | * \brief
  544|       | *    Initializes the POC structure with appropriate parameters.
  545|       | * 
  546|       | ***********************************************************************
  547|       | */
  548|       |void init_poc()
  549|      1|{
  550|       |  //the following should probably go in sequence parameters
  551|       |  // frame poc's increase by 2, field poc's by 1
  552|       |
  553|      1|  img->pic_order_cnt_type=input->pic_order_cnt_type;
  554|       |
  555|      1|  img->delta_pic_order_always_zero_flag=0;
  556|      1|  img->num_ref_frames_in_pic_order_cnt_cycle= 1;
  557|       |
  558|      1|  if (input->BRefPictures)
  559|      0|  {
  560|      0|    img->offset_for_non_ref_pic  =  0;
  561|      0|    img->offset_for_ref_frame[0] =   2;
  562|      0|  }
  563|      1|  else
  564|      1|  {
  565|      1|    img->offset_for_non_ref_pic  =  -2*(input->successive_Bframe);
  566|      1|    img->offset_for_ref_frame[0] =   2*(input->successive_Bframe+1);
  567|      1|  }
  568|       |
  569|      1|  if ((input->PicInterlace==FRAME_CODING)&&(input->MbInterlace==FRAME_CODING))
  570|      1|    img->offset_for_top_to_bottom_field=0;
  571|      0|  else    
  572|      0|    img->offset_for_top_to_bottom_field=1;
  573|       |
  574|      1|  if ((input->PicInterlace==FRAME_CODING)&&(input->MbInterlace==FRAME_CODING))
  575|      1|  {
  576|      1|    img->pic_order_present_flag=0;
  577|      1|    img->delta_pic_order_cnt_bottom = 0;
  578|      1|  }
  579|      0|  else    
  580|      0|  {
  581|      0|    img->pic_order_present_flag=1;
  582|      0|    img->delta_pic_order_cnt_bottom = 1;
  583|      0|  }
  584|      1|}
  585|       |
  586|       |
  587|       |/*!
  588|       | ***********************************************************************
  589|       | * \brief
  590|       | *    Initializes the img->nz_coeff
  591|       | * \par Input:
  592|       | *    none
  593|       | * \par  Output:
  594|       | *    none
  595|       | * \ side effects
  596|       | *    sets omg->nz_coef[][][][] to -1
  597|       | ***********************************************************************
  598|       | */
  599|       |void CAVLC_init()
  600|      1|{
  601|      1|  unsigned int i, k, l;
  602|       |
  603|      1|  for (i=0;i < img->PicSizeInMbs; i++)
  604|      0|    for (k=0;k<4;k++)
  605|      0|      for (l=0;l < (4 + (unsigned int)img->num_blk8x8_uv);l++)
  606|      0|        img->nz_coeff[i][k][l]=0;
  607|       |
  608|       |
  609|      1|}
  610|       |
  611|       |
  612|       |/*!
  613|       | ***********************************************************************
  614|       | * \brief
  615|       | *    Initializes the Image structure with appropriate parameters.
  616|       | * \par Input:
  617|       | *    Input Parameters struct inp_par *inp
  618|       | * \par  Output:
  619|       | *    Image Parameters struct img_par *img
  620|       | ***********************************************************************
  621|       | */
  622|       |void init_img()
  623|      1|{
  624|      1|  int i,j;
  625|      1|  int byte_abs_range;
  626|       |
  627|      1|  static int mb_width_cr[4] = {0,8, 8,16};
  628|      1|  static int mb_height_cr[4]= {0,8,16,16};
  629|       |
  630|      1|  img->yuv_format = input->yuv_format;
  631|       |
  632|       |  //pel bitdepth init
  633|      1|  img->bitdepth_luma   = input->BitDepthLuma;
  634|       |  
  635|      1|  if((img->bitdepth_luma > img->bitdepth_chroma) || img->yuv_format == YUV400)
  636|      1|    img->pic_unit_size_on_disk = (img->bitdepth_luma > 8)? 16:8;
  637|      0|  else
  638|      0|    img->pic_unit_size_on_disk = (img->bitdepth_chroma > 8)? 16:8;
  639|       |
  640|      1|  img->bitdepth_luma_qp_scale   = 6*(img->bitdepth_luma   - 8);
  641|      1|  img->bitdepth_lambda_scale    = 2*(img->bitdepth_luma   - 8);
  642|       |
  643|      1|  img->dc_pred_value = 1<<(img->bitdepth_luma - 1);
  644|      1|  img->max_imgpel_value = (1<<img->bitdepth_luma) - 1;
  645|       |
  646|      1|  if (img->yuv_format != YUV400)  
  647|      1|  {
  648|      1|    img->bitdepth_chroma     = input->BitDepthChroma;
  649|      1|    img->max_imgpel_value_uv = (1<<img->bitdepth_chroma) - 1;
  650|      1|    img->num_blk8x8_uv       = (1<<img->yuv_format)&(~(0x1));
  651|      1|    img->num_cdc_coeff       = img->num_blk8x8_uv<<1;
  652|      1|    img->mb_cr_size_x        = (img->yuv_format==YUV420 || img->yuv_format==YUV422)? 8:16;
  653|      1|    img->mb_cr_size_y        = (img->yuv_format==YUV444 || img->yuv_format==YUV422)? 16:8;
  654|       |
  655|      1|    img->bitdepth_chroma_qp_scale = 6*(img->bitdepth_chroma - 8);
  656|      1|    if(img->residue_transform_flag)
  657|      0|      img->bitdepth_chroma_qp_scale += 6;
  658|       |
  659|      1|    img->chroma_qp_offset[0] = active_pps->cb_qp_index_offset;
  660|      1|    img->chroma_qp_offset[1] = active_pps->cr_qp_index_offset;
  661|      1|  }
  662|      0|  else
  663|      0|  {
  664|      0|    img->bitdepth_chroma     = 0;
  665|      0|    img->max_imgpel_value_uv = 0;
  666|      0|    img->num_blk8x8_uv       = 0;
  667|      0|    img->num_cdc_coeff       = 0;
  668|      0|    img->mb_cr_size_x        = 0;
  669|      0|    img->mb_cr_size_y        = 0;
  670|       |    
  671|      0|    img->bitdepth_chroma_qp_scale = 0;
  672|      0|    img->bitdepth_chroma_qp_scale = 0;
  673|       |    
  674|      0|    img->chroma_qp_offset[0] = 0;
  675|      0|    img->chroma_qp_offset[1] = 0;
  676|      0|  }
  677|       |
  678|      1|  img->num_ref_frames = active_sps->num_ref_frames;
  679|      1|  img->max_num_references   = active_sps->frame_mbs_only_flag ? active_sps->num_ref_frames : 2 * active_sps->num_ref_frames;
  680|       |
  681|       |
  682|      1|  img->buf_cycle = input->num_ref_frames;
  683|       |
  684|      1|  img->DeblockCall = 0;
  685|       |
  686|       |//  img->framerate=INIT_FRAME_RATE;   // The basic frame rate (of the original sequence)
  687|      1|  img->framerate=(float) input->FrameRate;   // The basic frame rate (of the original sequence)
  688|       |
  689|       |
  690|      1|  get_mem_mv (&(img->pred_mv));
  691|      1|  get_mem_mv (&(img->all_mv));
  692|       |
  693|      1|#if BI_PREDICTION
  694|      1|  if (input->BiPredMotionEstimation)
  695|      0|  {
  696|      0|    get_mem_mv (&(img->bipred_mv1));
  697|      0|    get_mem_mv (&(img->bipred_mv2));
  698|      0|  }
  699|      1|#endif
  700|       |
  701|      1|  get_mem_ACcoeff (&(img->cofAC));
  702|      1|  get_mem_DCcoeff (&(img->cofDC));
  703|       |
  704|       |  
  705|      1|  if(input->MbInterlace)
  706|      0|  {
  707|      0|    get_mem_mv (&(rddata_top_frame_mb.pred_mv));
  708|      0|    get_mem_mv (&(rddata_top_frame_mb.all_mv));
  709|       |
  710|      0|    get_mem_mv (&(rddata_bot_frame_mb.pred_mv));
  711|      0|    get_mem_mv (&(rddata_bot_frame_mb.all_mv));
  712|       |
  713|      0|    get_mem_mv (&(rddata_top_field_mb.pred_mv));
  714|      0|    get_mem_mv (&(rddata_top_field_mb.all_mv));
  715|       |
  716|      0|    get_mem_mv (&(rddata_bot_field_mb.pred_mv));
  717|      0|    get_mem_mv (&(rddata_bot_field_mb.all_mv));
  718|      0|#if BI_PREDICTION
  719|      0|    if (input->BiPredMotionEstimation)
  720|      0|    {
  721|      0|      get_mem_mv (&(rddata_top_frame_mb.bipred_mv1));
  722|      0|      get_mem_mv (&(rddata_top_frame_mb.bipred_mv2));
  723|      0|      get_mem_mv (&(rddata_bot_frame_mb.bipred_mv1));
  724|      0|      get_mem_mv (&(rddata_bot_frame_mb.bipred_mv2));
  725|      0|      get_mem_mv (&(rddata_top_field_mb.bipred_mv1));
  726|      0|      get_mem_mv (&(rddata_top_field_mb.bipred_mv2));
  727|      0|      get_mem_mv (&(rddata_bot_field_mb.bipred_mv1));
  728|      0|      get_mem_mv (&(rddata_bot_field_mb.bipred_mv2));
  729|      0|    }
  730|      0|#endif
  731|       |
  732|      0|    get_mem_ACcoeff (&(rddata_top_frame_mb.cofAC));
  733|      0|    get_mem_DCcoeff (&(rddata_top_frame_mb.cofDC));
  734|       |
  735|      0|    get_mem_ACcoeff (&(rddata_bot_frame_mb.cofAC));
  736|      0|    get_mem_DCcoeff (&(rddata_bot_frame_mb.cofDC));
  737|       |
  738|      0|    get_mem_ACcoeff (&(rddata_top_field_mb.cofAC));
  739|      0|    get_mem_DCcoeff (&(rddata_top_field_mb.cofDC));
  740|       |
  741|      0|    get_mem_ACcoeff (&(rddata_bot_field_mb.cofAC));
  742|      0|    get_mem_DCcoeff (&(rddata_bot_field_mb.cofDC));
  743|      0|  }
  744|       |
  745|      1|  if(img->max_imgpel_value > img->max_imgpel_value_uv)
  746|      0|    byte_abs_range = (img->max_imgpel_value + 1) * 2;
  747|      1|  else
  748|      1|    byte_abs_range = (img->max_imgpel_value_uv + 1) * 2;
  749|       |
  750|      1|  if ((img->quad = (int*)calloc (byte_abs_range, sizeof(int))) == NULL)
  751|      0|    no_mem_exit ("init_img: img->quad");
  752|      1|  img->quad+=byte_abs_range/2;
  753|    257|  for (i=0; i < byte_abs_range/2; ++i)
  754|    256|  {
  755|    256|    img->quad[i]=img->quad[-i]=i*i;
  756|    256|  }
  757|       |
  758|      1|  img->width    = (input->img_width+img->auto_crop_right);
  759|      1|  img->height   = (input->img_height+img->auto_crop_bottom);
  760|      1|  if (img->yuv_format != YUV400)
  761|      1|  {
  762|      1|    img->width_cr = img->width/(16/mb_width_cr[img->yuv_format]);
  763|      1|    img->height_cr= img->height/(16/mb_height_cr[img->yuv_format]);
  764|       |
  765|      1|    input->img_width_cr  = input->img_width/(16/mb_width_cr[img->yuv_format]);
  766|      1|    input->img_height_cr = input->img_height/(16/mb_height_cr[img->yuv_format]);
  767|      1|  }
  768|      0|  else
  769|      0|  {
  770|      0|    img->width_cr = 0;
  771|      0|    img->height_cr= 0;
  772|       |
  773|      0|    input->img_width_cr  = 0;
  774|      0|    input->img_height_cr = 0;
  775|      0|  }
  776|      1|  img->height_cr_frame = img->height_cr;
  777|       |  
  778|      1|  img->PicWidthInMbs    = (input->img_width+img->auto_crop_right)/MB_BLOCK_SIZE;
  779|      1|  img->FrameHeightInMbs = (input->img_height+img->auto_crop_bottom)/MB_BLOCK_SIZE;
  780|      1|  img->FrameSizeInMbs   = img->PicWidthInMbs * img->FrameHeightInMbs;
  781|       |
  782|      1|  img->PicHeightInMapUnits = ( active_sps->frame_mbs_only_flag ? img->FrameHeightInMbs : img->FrameHeightInMbs/2 );
  783|       |
  784|      1|  if(((img->mb_data) = (Macroblock *) calloc(img->FrameSizeInMbs,sizeof(Macroblock))) == NULL)
  785|      0|    no_mem_exit("init_img: img->mb_data");
  786|       |
  787|      1|  if(input->UseConstrainedIntraPred)
  788|      0|  {
  789|      0|    if(((img->intra_block) = (int*)calloc(img->FrameSizeInMbs,sizeof(int))) == NULL)
  790|      0|      no_mem_exit("init_img: img->intra_block");
  791|      0|  }
  792|       |
  793|      1|  get_mem2Dint(&(img->ipredmode), img->width/BLOCK_SIZE, img->height/BLOCK_SIZE);        //need two extra rows at right and bottom
  794|      1|  get_mem2Dint(&(img->ipredmode8x8), img->width/BLOCK_SIZE, img->height/BLOCK_SIZE);     // help storage for ipredmode 8x8, inserted by YV
  795|       | 
  796|      1|  get_mem2Dint(&(rddata_top_frame_mb.ipredmode), img->width/BLOCK_SIZE, img->height/BLOCK_SIZE);
  797|       |  
  798|      1|  if(input->MbInterlace) 
  799|      0|  {
  800|      0|    get_mem2Dint(&(rddata_bot_frame_mb.ipredmode), img->width/BLOCK_SIZE, img->height/BLOCK_SIZE);
  801|      0|    get_mem2Dint(&(rddata_top_field_mb.ipredmode), img->width/BLOCK_SIZE, img->height/BLOCK_SIZE);
  802|      0|    get_mem2Dint(&(rddata_bot_field_mb.ipredmode), img->width/BLOCK_SIZE, img->height/BLOCK_SIZE);
  803|      0|  }
  804|       |  // CAVLC mem
  805|      1|  get_mem3Dint(&(img->nz_coeff), img->FrameSizeInMbs, 4, 4+img->num_blk8x8_uv);
  806|       |
  807|      1|  CAVLC_init();
  808|       |
  809|    129|  for (i=0; i < img->width/BLOCK_SIZE; i++)
  810|  10.3k|    for (j=0; j < img->height/BLOCK_SIZE; j++)
  811|  10.2k|    {
  812|  10.2k|      img->ipredmode[i][j]=-1;
  813|  10.2k|      img->ipredmode8x8[i][j]=-1;
  814|  10.2k|    }
  815|       |
  816|      1|  img->mb_y_upd=0;
  817|       |
  818|      1|  RandomIntraInit (img->width/16, img->height/16, input->RandomIntraMBRefresh);
  819|       |
  820|      1|  InitSEIMessages();  // Tian Dong (Sept 2002)
  821|       |
  822|       |  // Initialize filtering parameters. If sending parameters, the offsets are 
  823|       |  // multiplied by 2 since inputs are taken in "div 2" format.
  824|       |  // If not sending parameters, all fields are cleared 
  825|      1|  if (input->LFSendParameters)
  826|      0|  {
  827|      0|    input->LFAlphaC0Offset <<= 1;
  828|      0|    input->LFBetaOffset <<= 1;
  829|      0|  }
  830|      1|  else
  831|      1|  {
  832|      1|    input->LFDisableIdc = 0;
  833|      1|    input->LFAlphaC0Offset = 0;
  834|      1|    input->LFBetaOffset = 0;
  835|      1|  }
  836|      1|}
  837|       |
  838|       |/*!
  839|       | ***********************************************************************
  840|       | * \brief
  841|       | *    Free the Image structures
  842|       | * \par Input:
  843|       | *    Image Parameters struct img_par *img
  844|       | ***********************************************************************
  845|       | */
  846|       |void free_img ()
  847|      1|{
  848|      1|  CloseSEIMessages(); // Tian Dong (Sept 2002)
  849|      1|  free_mem_mv (img->pred_mv);
  850|      1|  free_mem_mv (img->all_mv);
  851|       |
  852|      1|#if BI_PREDICTION
  853|      1|  if (input->BiPredMotionEstimation)
  854|      0|  {
  855|      0|    free_mem_mv (img->bipred_mv1);
  856|      0|    free_mem_mv (img->bipred_mv2);
  857|      0|  }
  858|      1|#endif
  859|       |
  860|      1|  free_mem_ACcoeff (img->cofAC);
  861|      1|  free_mem_DCcoeff (img->cofDC);
  862|       |
  863|      1|  if(input->MbInterlace)
  864|      0|  {
  865|      0|    free_mem_mv (rddata_top_frame_mb.pred_mv);
  866|      0|    free_mem_mv (rddata_top_frame_mb.all_mv);
  867|       |
  868|      0|    free_mem_mv (rddata_bot_frame_mb.pred_mv);
  869|      0|    free_mem_mv (rddata_bot_frame_mb.all_mv);
  870|       |
  871|      0|    free_mem_mv (rddata_top_field_mb.pred_mv);
  872|      0|    free_mem_mv (rddata_top_field_mb.all_mv);
  873|       |
  874|      0|    free_mem_mv (rddata_bot_field_mb.pred_mv);
  875|      0|    free_mem_mv (rddata_bot_field_mb.all_mv);
  876|       |
  877|      0|#if BI_PREDICTION
  878|      0|    if (input->BiPredMotionEstimation)
  879|      0|    {
  880|      0|      free_mem_mv (rddata_top_frame_mb.bipred_mv1);
  881|      0|      free_mem_mv (rddata_top_frame_mb.bipred_mv2);
  882|      0|      free_mem_mv (rddata_bot_frame_mb.bipred_mv1);
  883|      0|      free_mem_mv (rddata_bot_frame_mb.bipred_mv2);
  884|      0|      free_mem_mv (rddata_top_field_mb.bipred_mv1);
  885|      0|      free_mem_mv (rddata_top_field_mb.bipred_mv2);
  886|      0|      free_mem_mv (rddata_bot_field_mb.bipred_mv1);
  887|      0|      free_mem_mv (rddata_bot_field_mb.bipred_mv2);
  888|      0|    }
  889|      0|#endif
  890|       |
  891|      0|    free_mem_ACcoeff (rddata_top_frame_mb.cofAC);
  892|      0|    free_mem_DCcoeff (rddata_top_frame_mb.cofDC);
  893|       |
  894|      0|    free_mem_ACcoeff (rddata_bot_frame_mb.cofAC);
  895|      0|    free_mem_DCcoeff (rddata_bot_frame_mb.cofDC);
  896|       |
  897|      0|    free_mem_ACcoeff (rddata_top_field_mb.cofAC);
  898|      0|    free_mem_DCcoeff (rddata_top_field_mb.cofDC);
  899|       |
  900|      0|    free_mem_ACcoeff (rddata_bot_field_mb.cofAC);
  901|      0|    free_mem_DCcoeff (rddata_bot_field_mb.cofDC);
  902|      0|  }
  903|       |
  904|      1|  if(img->max_imgpel_value > img->max_imgpel_value_uv)
  905|      0|    free (img->quad-(img->max_imgpel_value + 1));
  906|      1|  else
  907|      1|    free (img->quad-(img->max_imgpel_value_uv + 1));
  908|       |
  909|      1|  if(input->MbInterlace) 
  910|      0|  {
  911|      0|    free_mem2Dint(rddata_bot_frame_mb.ipredmode);
  912|      0|    free_mem2Dint(rddata_top_field_mb.ipredmode);
  913|      0|    free_mem2Dint(rddata_bot_field_mb.ipredmode);
  914|      0|  }
  915|       |
  916|      1|}
  917|       |
  918|       |
  919|       |
  920|       |/*!
  921|       | ************************************************************************
  922|       | * \brief
  923|       | *    Allocates the picture structure along with its dependent
  924|       | *    data structures
  925|       | * \return
  926|       | *    Pointer to a Picture
  927|       | ************************************************************************
  928|       | */
  929|       |
  930|       |Picture *malloc_picture()
  931|      1|{
  932|      1|  Picture *pic;
  933|      1|  if ((pic = calloc (1, sizeof (Picture))) == NULL) no_mem_exit ("malloc_picture: Picture structure");
  934|       |  //! Note: slice structures are allocated as needed in code_a_picture
  935|      1|  return pic;
  936|      1|}
  937|       |
  938|       |/*!
  939|       | ************************************************************************
  940|       | * \brief
  941|       | *    Frees a picture
  942|       | * \param
  943|       | *    pic: POinter to a Picture to be freed
  944|       | ************************************************************************
  945|       | */
  946|       |
  947|       |
  948|       |void free_picture(Picture *pic)
  949|      1|{
  950|      1|  if (pic != NULL)
  951|      1|  {
  952|      1|    free_slice_list(pic);
  953|      1|    free (pic);
  954|      1|  }
  955|      1|}
  956|       |
  957|       |
  958|       |/*!
  959|       | ************************************************************************
  960|       | * \brief
  961|       | *    Reports frame statistical data to a stats file
  962|       | ************************************************************************
  963|       | */
  964|       |void report_frame_statistic()
  965|      0|{
  966|      0|  FILE *p_stat_frm = NULL;
  967|      0|  static int   last_mode_use[NUM_PIC_TYPE][MAXMODE];
  968|      0|  static int   last_b8_mode_0[NUM_PIC_TYPE][2];
  969|      0|  static int   last_mode_chroma_use[4];
  970|      0|  static int   last_bit_ctr_n = 0;
  971|      0|  int i;
  972|      0|  char name[20];
  973|      0|  int bitcounter;
  974|       |  
  975|      0|#ifndef WIN32
  976|      0|  time_t now;
  977|      0|  struct tm *l_time;
  978|      0|  char string[1000];
  979|       |#else
  980|       |  char timebuf[128];
  981|       |#endif
  982|       |  
  983|       |
  984|       |  // write to log file
  985|      0|  if ((p_stat_frm=fopen("stat_frame.dat","r"))==0)                      // check if file exist
  986|      0|  {
  987|      0|    if ((p_stat_frm=fopen("stat_frame.dat","a"))==NULL)            // append new statistic at the end
  988|      0|    {
  989|      0|      snprintf(errortext, ET_SIZE, "Error open file %s  \n","stat_frame.dat.dat");
  990|      0|      error(errortext, 500);
  991|      0|    }
  992|      0|    else                                            // Create header for new log file
  993|      0|    {
  994|      0|      fprintf(p_stat_frm," --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- \n");
  995|      0|      fprintf(p_stat_frm,"|            Encoder statistics. This file is generated during first encoding session, new sessions will be appended                                                                                                                                                                                                                                                                                                                                                              |\n");
  996|      0|      fprintf(p_stat_frm," --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- \n");
  997|      0|    }
  998|      0|  }
  999|      0|  else
 1000|      0|  {
 1001|      0|    fclose (p_stat_frm);
 1002|      0|    if ((p_stat_frm=fopen("stat_frame.dat","a"))==NULL)            // File exist,just open for appending
 1003|      0|    {
 1004|      0|      snprintf(errortext, ET_SIZE, "Error open file %s  \n","stat_frame.dat.dat");
 1005|      0|      error(errortext, 500);
 1006|      0|    }
 1007|      0|  }
 1008|       |  
 1009|      0|  if (frame_statistic_start)
 1010|      0|  {
 1011|      0|    fprintf(p_stat_frm,"|  ver   | Date  | Time  |    Sequence        |Frm | QP |P/MbInt|   Bits   |  SNRY  |  SNRU  |  SNRV  |  I4  |  I8  | I16  | IC0  | IC1  | IC2  | IC3  | PI4  | PI8  | PI16 |  P0  |  P1  |  P2  |  P3  | P1*8*| P1*4*| P2*8*| P2*4*| P3*8*| P3*4*|  P8  | P8:4 | P4*8*| P4*4*| P8:5 | P8:6 | P8:7 | BI4  | BI8  | BI16 |  B0  |  B1  |  B2  |  B3  | B0*8*| B0*4*| B1*8*| B1*4*| B2*8*| B2*4*| B3*8*| B3*4*|  B8  | B8:0 |B80*8*|B80*4*| B8:4 | B4*8*| B4*4*| B8:5 | B8:6 | B8:7 |\n");
 1012|      0|    fprintf(p_stat_frm," --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- \n");
 1013|      0|  }
 1014|       |  
 1015|       |
 1016|       |  //report
 1017|      0|  fprintf(p_stat_frm,"|%4s/%s", VERSION, EXT_VERSION); 
 1018|       |  
 1019|       |#ifdef WIN32
 1020|       |  _strdate( timebuf );
 1021|       |  fprintf(p_stat_frm,"| %1.5s |",timebuf );
 1022|       |  
 1023|       |  _strtime( timebuf);
 1024|       |  fprintf(p_stat_frm," % 1.5s |",timebuf);
 1025|       |#else
 1026|      0|  now = time ((time_t *) NULL); // Get the system time and put it into 'now' as 'calender time'
 1027|      0|  time (&now);
 1028|      0|  l_time = localtime (&now);
 1029|      0|  strftime (string, sizeof string, "%d-%b-%Y", l_time);
 1030|      0|  fprintf(p_stat_frm,"| %1.5s |",string );
 1031|       |  
 1032|      0|  strftime (string, sizeof string, "%H:%M:%S", l_time);
 1033|      0|  fprintf(p_stat_frm," %1.5s |",string );
 1034|      0|#endif
 1035|       |  
 1036|      0|  for (i=0;i<20;i++)
 1037|      0|    name[i]=input->infile[i+max(0,(int) (strlen(input->infile)-20))]; // write last part of path, max 20 chars
 1038|      0|  fprintf(p_stat_frm,"%20.20s|",name);
 1039|       |  
 1040|      0|  fprintf(p_stat_frm,"%3d |",frame_no);
 1041|       |
 1042|      0|  fprintf(p_stat_frm,"%3d |",img->qp);
 1043|       |
 1044|      0|  fprintf(p_stat_frm,"  %d/%d  |",input->PicInterlace, input->MbInterlace);
 1045|       |  
 1046|       |  
 1047|      0|  if (img->frame_num == 0)
 1048|      0|  {
 1049|      0|    bitcounter = stats->bit_ctr_I;
 1050|      0|  }
 1051|      0|  else
 1052|      0|  {
 1053|      0|    bitcounter = stats->bit_ctr_n - last_bit_ctr_n;
 1054|      0|    last_bit_ctr_n = stats->bit_ctr_n;
 1055|      0|  }
 1056|       |
 1057|       |
 1058|       |  //report bitrate
 1059|      0|  fprintf(p_stat_frm, " %9d|", bitcounter);
 1060|       |  
 1061|       |  //report snr's
 1062|      0|  fprintf(p_stat_frm, " %2.4f| %2.4f| %2.4f|", snr->snr_y, snr->snr_u, snr->snr_v);
 1063|       |  
 1064|       |  //report modes
 1065|       |  //I-Modes
 1066|      0|  fprintf(p_stat_frm, " %5d|",stats->mode_use[I_SLICE][I4MB] - last_mode_use[I_SLICE][I4MB]);
 1067|      0|  fprintf(p_stat_frm, " %5d|",stats->mode_use[I_SLICE][I8MB] - last_mode_use[I_SLICE][I8MB]);
 1068|      0|  fprintf(p_stat_frm, " %5d|",stats->mode_use[I_SLICE][I16MB] - last_mode_use[I_SLICE][I16MB]);
 1069|       |  
 1070|       |  //chroma intra mode
 1071|      0|  fprintf(p_stat_frm, " %5d|",stats->intra_chroma_mode[0] - last_mode_chroma_use[0]);
 1072|      0|  fprintf(p_stat_frm, " %5d|",stats->intra_chroma_mode[1] - last_mode_chroma_use[1]);
 1073|      0|  fprintf(p_stat_frm, " %5d|",stats->intra_chroma_mode[2] - last_mode_chroma_use[2]);
 1074|      0|  fprintf(p_stat_frm, " %5d|",stats->intra_chroma_mode[3] - last_mode_chroma_use[3]);
 1075|       |  
 1076|       |  //P-Modes
 1077|      0|  fprintf(p_stat_frm, " %5d|",stats->mode_use[P_SLICE][I4MB] - last_mode_use[P_SLICE][I4MB]);
 1078|      0|  fprintf(p_stat_frm, " %5d|",stats->mode_use[P_SLICE][I8MB] - last_mode_use[P_SLICE][I8MB]);
 1079|      0|  fprintf(p_stat_frm, " %5d|",stats->mode_use[P_SLICE][I16MB] - last_mode_use[P_SLICE][I16MB]);
 1080|      0|  fprintf(p_stat_frm, " %5d|",stats->mode_use[P_SLICE][0   ] - last_mode_use[P_SLICE][0   ]);
 1081|       |  
 1082|      0|  fprintf(p_stat_frm, " %5d|",stats->mode_use[P_SLICE][1   ] - last_mode_use[P_SLICE][1   ]);
 1083|      0|  fprintf(p_stat_frm, " %5d|",stats->mode_use[P_SLICE][2   ] - last_mode_use[P_SLICE][2   ]);
 1084|      0|  fprintf(p_stat_frm, " %5d|",stats->mode_use[P_SLICE][3   ] - last_mode_use[P_SLICE][3   ]);
 1085|      0|  fprintf(p_stat_frm, " %5d|",stats->mode_use_transform_8x8[0][1]);
 1086|      0|  fprintf(p_stat_frm, " %5d|",stats->mode_use_transform_4x4[0][1]);
 1087|      0|  fprintf(p_stat_frm, " %5d|",stats->mode_use_transform_8x8[0][2]);
 1088|      0|  fprintf(p_stat_frm, " %5d|",stats->mode_use_transform_4x4[0][2]);
 1089|      0|  fprintf(p_stat_frm, " %5d|",stats->mode_use_transform_8x8[0][3]);
 1090|      0|  fprintf(p_stat_frm, " %5d|",stats->mode_use_transform_4x4[0][3]);
 1091|       |  
 1092|      0|  fprintf(p_stat_frm, " %5d|",stats->mode_use[P_SLICE][P8x8] - last_mode_use[P_SLICE][P8x8]);
 1093|       |//  fprintf(p_stat_frm, " %5d|",stats->b8_mode_0_use[P_SLICE][0]  - last_b8_mode_0[P_SLICE ][0]);
 1094|      0|  fprintf(p_stat_frm, " %5d|",stats->mode_use[P_SLICE][4   ] - last_mode_use[P_SLICE][4   ]);
 1095|      0|  fprintf(p_stat_frm, " %5d|",stats->mode_use_transform_8x8[0][4]);
 1096|      0|  fprintf(p_stat_frm, " %5d|",stats->mode_use_transform_4x4[0][4]);
 1097|      0|  fprintf(p_stat_frm, " %5d|",stats->mode_use[P_SLICE][5   ] - last_mode_use[P_SLICE][5   ]);
 1098|      0|  fprintf(p_stat_frm, " %5d|",stats->mode_use[P_SLICE][6   ] - last_mode_use[P_SLICE][6   ]);
 1099|      0|  fprintf(p_stat_frm, " %5d|",stats->mode_use[P_SLICE][7   ] - last_mode_use[P_SLICE][7   ]);
 1100|       |  
 1101|       |  //B-Modes
 1102|      0|  fprintf(p_stat_frm, " %5d|",stats->mode_use[B_SLICE][I4MB] - last_mode_use[B_SLICE][I4MB]);
 1103|      0|  fprintf(p_stat_frm, " %5d|",stats->mode_use[B_SLICE][I8MB] - last_mode_use[B_SLICE][I8MB]);
 1104|      0|  fprintf(p_stat_frm, " %5d|",stats->mode_use[B_SLICE][I16MB] - last_mode_use[B_SLICE][I16MB]);
 1105|      0|  fprintf(p_stat_frm, " %5d|",stats->mode_use[B_SLICE][0   ] - last_mode_use[B_SLICE][0   ]);
 1106|       |  /*
 1107|       |  fprintf(p_stat_frm, " %5d|",stats->mode_use[B_SLICE][1   ] - last_mode_use[B_SLICE][1   ]);
 1108|       |  fprintf(p_stat_frm, " %5d|",stats->mode_use[B_SLICE][2   ] - last_mode_use[B_SLICE][2   ]);
 1109|       |  fprintf(p_stat_frm, " %5d|",stats->mode_use[B_SLICE][3   ] - last_mode_use[B_SLICE][3   ]);
 1110|       |  */
 1111|      0|  fprintf(p_stat_frm, " %5d|",stats->mode_use[B_SLICE][1   ] - last_mode_use[B_SLICE][1   ]);
 1112|      0|  fprintf(p_stat_frm, " %5d|",stats->mode_use[B_SLICE][2   ] - last_mode_use[B_SLICE][2   ]);
 1113|      0|  fprintf(p_stat_frm, " %5d|",stats->mode_use[B_SLICE][3   ] - last_mode_use[B_SLICE][3   ]);
 1114|      0|  fprintf(p_stat_frm, " %5d|",stats->mode_use_transform_8x8[1][0]);
 1115|      0|  fprintf(p_stat_frm, " %5d|",stats->mode_use_transform_4x4[1][0]);
 1116|      0|  fprintf(p_stat_frm, " %5d|",stats->mode_use_transform_8x8[1][1]);
 1117|      0|  fprintf(p_stat_frm, " %5d|",stats->mode_use_transform_4x4[1][1]);
 1118|      0|  fprintf(p_stat_frm, " %5d|",stats->mode_use_transform_8x8[1][2]);
 1119|      0|  fprintf(p_stat_frm, " %5d|",stats->mode_use_transform_4x4[1][2]);
 1120|      0|  fprintf(p_stat_frm, " %5d|",stats->mode_use_transform_8x8[1][3]);
 1121|      0|  fprintf(p_stat_frm, " %5d|",stats->mode_use_transform_4x4[1][3]);
 1122|       |  
 1123|      0|  fprintf(p_stat_frm, " %5d|",stats->mode_use[B_SLICE][P8x8] - last_mode_use[B_SLICE][P8x8]);
 1124|      0|  fprintf(p_stat_frm, " %5d|",(stats->b8_mode_0_use [B_SLICE][0]+stats->b8_mode_0_use [B_SLICE][1]) - (last_b8_mode_0[B_SLICE][0]+last_b8_mode_0[B_SLICE][1]));
 1125|      0|  fprintf(p_stat_frm, " %5d|",stats->b8_mode_0_use [B_SLICE][1] - last_b8_mode_0[B_SLICE][1]);
 1126|      0|  fprintf(p_stat_frm, " %5d|",stats->b8_mode_0_use [B_SLICE][0] - last_b8_mode_0[B_SLICE][0]);
 1127|      0|  fprintf(p_stat_frm, " %5d|",stats->mode_use[B_SLICE][4   ] - last_mode_use[B_SLICE][4   ]);
 1128|      0|  fprintf(p_stat_frm, " %5d|",stats->mode_use_transform_8x8[1][4]);
 1129|      0|  fprintf(p_stat_frm, " %5d|",stats->mode_use_transform_4x4[1][4]);
 1130|      0|  fprintf(p_stat_frm, " %5d|",stats->mode_use[B_SLICE][5   ] - last_mode_use[B_SLICE][5   ]);
 1131|      0|  fprintf(p_stat_frm, " %5d|",stats->mode_use[B_SLICE][6   ] - last_mode_use[B_SLICE][6   ]);
 1132|      0|  fprintf(p_stat_frm, " %5d|",stats->mode_use[B_SLICE][7   ] - last_mode_use[B_SLICE][7   ]);
 1133|       |
 1134|      0|  fprintf(p_stat_frm, "\n");
 1135|       |  
 1136|       |  //save the last results
 1137|      0|  last_mode_use[I_SLICE][I4MB] = stats->mode_use[I_SLICE][I4MB];
 1138|      0|  last_mode_use[I_SLICE][I8MB] = stats->mode_use[I_SLICE][I8MB];
 1139|      0|  last_mode_use[I_SLICE][I16MB] = stats->mode_use[I_SLICE][I16MB];
 1140|      0|  for(i=0; i<MAXMODE; i++)
 1141|      0|  {
 1142|      0|    last_mode_use[P_SLICE][i] = stats->mode_use[P_SLICE][i];
 1143|      0|    last_mode_use[B_SLICE][i] = stats->mode_use[B_SLICE][i];
 1144|      0|    stats->mode_use_transform_8x8[0][i] = 0;
 1145|      0|    stats->mode_use_transform_8x8[1][i] = 0;
 1146|      0|    stats->mode_use_transform_4x4[0][i] = 0;
 1147|      0|    stats->mode_use_transform_4x4[1][i] = 0;
 1148|      0|  }
 1149|       |//  last_b8_mode_0[P_SLICE][0] = stats->b8_mode_0_use[P_SLICE];
 1150|      0|  last_b8_mode_0[B_SLICE][0] = stats->b8_mode_0_use[B_SLICE][0];
 1151|      0|  last_b8_mode_0[B_SLICE][1] = stats->b8_mode_0_use[B_SLICE][1];
 1152|       |  
 1153|      0|  for(i=0;i<4;i++)
 1154|      0|    last_mode_chroma_use[i]=stats->intra_chroma_mode[i];
 1155|       |
 1156|      0|  frame_statistic_start = 0;
 1157|      0|  fclose(p_stat_frm);
 1158|      0|}
 1159|       |
 1160|       |
 1161|       |/*!
 1162|       | ************************************************************************
 1163|       | * \brief
 1164|       | *    Reports the gathered information to appropriate outputs
 1165|       | * \par Input:
 1166|       | *    struct inp_par *inp,                                            \n
 1167|       | *    struct img_par *img,                                            \n
 1168|       | *    struct stat_par *stats,                                          \n
 1169|       | *    struct stat_par *stats                                           \n
 1170|       | *
 1171|       | * \par Output:
 1172|       | *    None
 1173|       | ************************************************************************
 1174|       | */
 1175|       |void report()
 1176|      1|{
 1177|      1|  int bit_use[NUM_PIC_TYPE][2] ;
 1178|      1|  int i,j;
 1179|      1|  char name[20];
 1180|      1|  int total_bits;
 1181|      1|  float frame_rate;
 1182|      1|  float mean_motion_info_bit_use[2];
 1183|       |
 1184|      1|#ifndef WIN32
 1185|      1|  time_t now;
 1186|      1|  struct tm *l_time;
 1187|      1|  char string[1000];
 1188|       |#else
 1189|       |  char timebuf[128];
 1190|       |#endif
 1191|      1|  bit_use[I_SLICE][0] = Iframe_ctr;
 1192|      1|  bit_use[P_SLICE][0] = max(Pframe_ctr,1);
 1193|      1|  bit_use[B_SLICE][0] = Bframe_ctr;
 1194|       |
 1195|       |  //  Accumulate bit usage for inter and intra frames
 1196|      6|  for (j=0;j<NUM_PIC_TYPE;j++)
 1197|      5|  {
 1198|      5|    bit_use[j][1] = 0;
 1199|      5|  }
 1200|       |
 1201|      6|  for (j=0;j<NUM_PIC_TYPE;j++)
 1202|      5|  {
 1203|     80|    for(i=0; i<MAXMODE; i++)
 1204|     75|      bit_use[j][1] += stats->bit_use_mode    [j][i]; 
 1205|       |
 1206|      5|    bit_use[j][1]+=stats->bit_use_header[j];
 1207|      5|    bit_use[j][1]+=stats->bit_use_mb_type[j];
 1208|      5|    bit_use[j][1]+=stats->tmp_bit_use_cbp[j];
 1209|      5|    bit_use[j][1]+=stats->bit_use_coeffY[j];
 1210|      5|    bit_use[j][1]+=stats->bit_use_coeffC[j];
 1211|      5|    bit_use[j][1]+=stats->bit_use_delta_quant[j];
 1212|      5|    bit_use[j][1]+=stats->bit_use_stuffingBits[j];
 1213|      5|  }
 1214|       |
 1215|      1|  frame_rate = (img->framerate *(float)(input->successive_Bframe + 1)) / (float) (input->jumpd+1);
 1216|       |
 1217|       |//! Currently adding NVB bits on P rate. Maybe additional stats info should be created instead and added in log file
 1218|      1|  stats->bitrate_I = (stats->bit_ctr_I)*(frame_rate)/(float) (input->no_frames + Bframe_ctr);
 1219|      1|  stats->bitrate_P = (stats->bit_ctr_P)*(frame_rate)/(float) (input->no_frames + Bframe_ctr);
 1220|      1|  stats->bitrate_B = (stats->bit_ctr_B)*(frame_rate)/(float) (input->no_frames + Bframe_ctr);    
 1221|       |
 1222|      1|  fprintf(stdout,"-------------------------------------------------------------------------------\n");
 1223|      1|  fprintf(stdout,  " Freq. for encoded bitstream       : %1.0f\n",img->framerate/(float)(input->jumpd+1));
 1224|      1|  if(input->hadamard)
 1225|      1|  {
 1226|      1|    if(input->hadamardqpel)
 1227|      0|      fprintf(stdout," Hadamard transform                : Used for QPel\n");
 1228|      1|    else
 1229|      1|      fprintf(stdout," Hadamard transform                : Used\n");    
 1230|      1|  }
 1231|      0|  else
 1232|      0|    fprintf(stdout," Hadamard transform                : Not used\n");
 1233|       |
 1234|      1|  fprintf(stdout,  " Image format                      : %dx%d\n",input->img_width,input->img_height);
 1235|       |
 1236|      1|  if(input->intra_upd)
 1237|      0|    fprintf(stdout," Error robustness                  : On\n");
 1238|      1|  else
 1239|      1|    fprintf(stdout," Error robustness                  : Off\n");
 1240|      1|  fprintf(stdout,  " Search range                      : %d\n",input->search_range);
 1241|       |
 1242|      1|  fprintf(stdout,  " Total number of references        : %d\n",input->num_ref_frames);
 1243|      1|  fprintf(stdout,  " References for P slices           : %d\n",input->P_List0_refs? input->P_List0_refs:input->num_ref_frames);
 1244|      1|  if(input->successive_Bframe != 0)
 1245|      1|  {
 1246|      1|    fprintf(stdout," List0 references for B slices     : %d\n",input->B_List0_refs? input->B_List0_refs:input->num_ref_frames);
 1247|      1|    fprintf(stdout," List1 references for B slices     : %d\n",input->B_List1_refs? input->B_List1_refs:input->num_ref_frames);
 1248|      1|  }
 1249|       |
 1250|      1|  fprintf(stdout,  " Total encoding time for the seq.  : %.3f sec \n",tot_time*0.001);
 1251|      1|  fprintf(stdout,  " Total ME time for sequence        : %.3f sec \n",me_tot_time*0.001);
 1252|       |
 1253|       |  // B pictures
 1254|      1|  fprintf(stdout,  " Sequence type                     :" );
 1255|       |
 1256|      1|  if(input->successive_Bframe>0 && input->PyramidCoding) 
 1257|      0|  {
 1258|      0|    fprintf(stdout, " Pyramid (QP: I %d, P %d, B %d) \n",
 1259|      0|    input->qp0, input->qpN, input->qpB);
 1260|      0|  }
 1261|      1|  else if(input->successive_Bframe>0) 
 1262|      1|  {
 1263|      1|    char seqtype[80];
 1264|      1|    int i,j;
 1265|       |
 1266|      1|    strcpy (seqtype,"I");
 1267|       |
 1268|      3|    for (j=0;j<2;j++)
 1269|      2|    {
 1270|      4|      for (i=0;i<input->successive_Bframe;i++)
 1271|      2|      {
 1272|      2|        if (input->BRefPictures)
 1273|      0|          strncat(seqtype,"-RB",max (0, (int) (79-strlen(seqtype))));
 1274|      2|        else
 1275|      2|          strncat(seqtype,"-B",max (0, (int) (79-strlen(seqtype))));
 1276|      2|      }
 1277|      2|      strncat(seqtype,"-P",max (0, (int) (79-strlen(seqtype))));
 1278|      2|    }
 1279|      1|    if (input->BRefPictures)
 1280|      0|      fprintf(stdout, " %s (QP: I %d, P %d, RB %d) \n", seqtype,input->qp0, input->qpN, Clip3(0,51,input->qpB+input->qpBRSOffset));
 1281|      1|    else
 1282|      1|      fprintf(stdout, " %s (QP: I %d, P %d, B %d) \n", seqtype,input->qp0, input->qpN, input->qpB);
 1283|      1|  }
 1284|      0|  else if(input->successive_Bframe==0 && input->sp_periodicity==0) fprintf(stdout, " IPPP (QP: I %d, P %d) \n",   input->qp0, input->qpN);
 1285|       |
 1286|      0|  else fprintf(stdout, " I-P-P-SP-P (QP: I %d, P %d, SP (%d, %d)) \n",  input->qp0, input->qpN, input->qpsp, input->qpsp_pred);
 1287|       |
 1288|       |  // report on entropy coding  method
 1289|      1|  if (input->symbol_mode == UVLC)
 1290|      0|    fprintf(stdout," Entropy coding method             : CAVLC\n");
 1291|      1|  else
 1292|      1|    fprintf(stdout," Entropy coding method             : CABAC\n");
 1293|       |
 1294|      1|  fprintf(stdout,  " Profile/Level IDC                 : (%d,%d)\n",input->ProfileIDC,input->LevelIDC);
 1295|      1|#ifdef _FULL_SEARCH_RANGE_
 1296|      1|  if (input->full_search == 2)
 1297|      1|    fprintf(stdout," Search range restrictions         : none\n");
 1298|      0|  else if (input->full_search == 1)
 1299|      0|    fprintf(stdout," Search range restrictions         : older reference frames\n");
 1300|      0|  else
 1301|      0|    fprintf(stdout," Search range restrictions         : smaller blocks and older reference frames\n");
 1302|      1|#endif
 1303|       |
 1304|      1|  if (input->rdopt)
 1305|      1|    fprintf(stdout," RD-optimized mode decision        : used\n");
 1306|      0|  else
 1307|      0|    fprintf(stdout," RD-optimized mode decision        : not used\n");
 1308|       |
 1309|      1|  switch(input->partition_mode)
 1310|      1|    {
 1311|      1|    case PAR_DP_1:
 1312|      1|      fprintf(stdout," Data Partitioning Mode            : 1 partition \n");
 1313|      1|      break;
 1314|      0|    case PAR_DP_3:
 1315|      0|      fprintf(stdout," Data Partitioning Mode            : 3 partitions \n");
 1316|      0|      break;
 1317|      0|    default:
 1318|      0|      fprintf(stdout," Data Partitioning Mode            : not supported\n");
 1319|      0|      break;
 1320|      1|    }
 1321|       |
 1322|      1|    switch(input->of_mode)
 1323|      1|    {
 1324|      1|    case PAR_OF_ANNEXB:
 1325|      1|      fprintf(stdout," Output File Format                : H.264 Bit Stream File Format \n");
 1326|      1|      break;
 1327|      0|    case PAR_OF_RTP:
 1328|      0|      fprintf(stdout," Output File Format                : RTP Packet File Format \n");
 1329|      0|      break;
 1330|      0|    default:
 1331|      0|      fprintf(stdout," Output File Format                : not supported\n");
 1332|      0|      break;
 1333|      1|    }
 1334|       |  // Residue Color Transform
 1335|      1|  if(input->residue_transform_flag)
 1336|      0|    fprintf(stdout," Residue Color Transform           : used\n");
 1337|      1|  else
 1338|      1|    fprintf(stdout," Residue Color Transform           : not used\n");
 1339|       |
 1340|       |
 1341|      1|  fprintf(stdout,"------------------ Average data all frames  -----------------------------------\n");
 1342|      1|  fprintf(stdout," SNR Y(dB)                         : %5.2f\n",snr->snr_ya);
 1343|      1|  fprintf(stdout," SNR U(dB)                         : %5.2f\n",snr->snr_ua);
 1344|      1|  fprintf(stdout," SNR V(dB)                         : %5.2f\n",snr->snr_va);
 1345|       |  
 1346|      1|  if(Bframe_ctr!=0)
 1347|      1|  {
 1348|      1|    fprintf(stdout, " Total bits                        : %d (I %5d, P %5d, B %d NVB %d) \n",
 1349|      1|      total_bits=stats->bit_ctr_P + stats->bit_ctr_I + stats->bit_ctr_B + stats->bit_ctr_parametersets, stats->bit_ctr_I, stats->bit_ctr_P, stats->bit_ctr_B,stats->bit_ctr_parametersets);
 1350|       |    
 1351|      1|    frame_rate = (img->framerate *(float)(input->successive_Bframe + 1)) / (float) (input->jumpd+1);
 1352|      1|    stats->bitrate= ((float) total_bits * frame_rate)/((float) (input->no_frames + Bframe_ctr));
 1353|       |    
 1354|      1|    fprintf(stdout, " Bit rate (kbit/s)  @ %2.2f Hz     : %5.2f\n", frame_rate, stats->bitrate/1000);
 1355|       |    
 1356|      1|  }
 1357|      0|  else if (input->sp_periodicity==0)
 1358|      0|  {
 1359|      0|    fprintf(stdout, " Total bits                        : %d (I %5d, P %5d, NVB %d) \n",
 1360|      0|      total_bits=stats->bit_ctr_P + stats->bit_ctr_I + stats->bit_ctr_parametersets, stats->bit_ctr_I, stats->bit_ctr_P, stats->bit_ctr_parametersets);
 1361|       |    
 1362|       |    
 1363|      0|    frame_rate = img->framerate / ( (float) (input->jumpd + 1) );
 1364|      0|    stats->bitrate= ((float) total_bits * frame_rate)/((float) input->no_frames );
 1365|       |    
 1366|      0|    fprintf(stdout, " Bit rate (kbit/s)  @ %2.2f Hz     : %5.2f\n", frame_rate, stats->bitrate/1000);
 1367|      0|  }
 1368|      0|  else
 1369|      0|  {
 1370|      0|    fprintf(stdout, " Total bits                        : %d (I %5d, P %5d, NVB %d) \n",
 1371|      0|      total_bits=stats->bit_ctr_P + stats->bit_ctr_I + stats->bit_ctr_parametersets, stats->bit_ctr_I, stats->bit_ctr_P, stats->bit_ctr_parametersets);
 1372|       |    
 1373|       |    
 1374|      0|    frame_rate = img->framerate / ( (float) (input->jumpd + 1) );
 1375|      0|    stats->bitrate= ((float) total_bits * frame_rate)/((float) input->no_frames );
 1376|       |    
 1377|      0|    fprintf(stdout, " Bit rate (kbit/s)  @ %2.2f Hz     : %5.2f\n", frame_rate, stats->bitrate/1000);
 1378|      0|  }
 1379|       |  
 1380|      1|  fprintf(stdout, " Bits to avoid Startcode Emulation : %d \n", stats->bit_ctr_emulationprevention);
 1381|      1|  fprintf(stdout, " Bits for parameter sets           : %d \n", stats->bit_ctr_parametersets);
 1382|       |  
 1383|      1|  fprintf(stdout,"-------------------------------------------------------------------------------\n");
 1384|      1|  fprintf(stdout,"Exit JM %s encoder ver %s ", JM, VERSION);
 1385|      1|  fprintf(stdout,"\n");
 1386|       |
 1387|       |#if !defined(SPEC_CPU)
 1388|       |  // status file
 1389|       |  if ((p_stat=fopen("stats.dat","wt"))==0)
 1390|       |  {
 1391|       |    snprintf(errortext, ET_SIZE, "Error open file %s", "stats.dat");
 1392|       |    error(errortext, 500);
 1393|       |  }
 1394|       |  fprintf(p_stat," -------------------------------------------------------------- \n");
 1395|       |  fprintf(p_stat,"  This file contains statistics for the last encoded sequence   \n");
 1396|       |  fprintf(p_stat," -------------------------------------------------------------- \n");
 1397|       |  fprintf(p_stat,   " Sequence                     : %s\n",input->infile);
 1398|       |  fprintf(p_stat,   " No.of coded pictures         : %4d\n",input->no_frames+Bframe_ctr);
 1399|       |  fprintf(p_stat,   " Freq. for encoded bitstream  : %4.0f\n",frame_rate);
 1400|       |
 1401|       |  fprintf(p_stat,   " I Slice Bitrate(kb/s)        : %6.2f\n", stats->bitrate_I/1000);
 1402|       |  fprintf(p_stat,   " P Slice Bitrate(kb/s)        : %6.2f\n", stats->bitrate_P/1000);
 1403|       |  // B pictures
 1404|       |  if(input->successive_Bframe != 0)
 1405|       |    fprintf(p_stat,   " B Slice Bitrate(kb/s)        : %6.2f\n", stats->bitrate_B/1000);
 1406|       |  fprintf(p_stat,   " Total Bitrate(kb/s)          : %6.2f\n", stats->bitrate/1000);
 1407|       |
 1408|       |  if(input->hadamard)
 1409|       |  {
 1410|       |    if(input->hadamardqpel)
 1411|       |      fprintf(p_stat," Hadamard transform           : Used for QPel\n");
 1412|       |    else
 1413|       |      fprintf(p_stat," Hadamard transform           : Used\n");
 1414|       |  }  
 1415|       |  else
 1416|       |    fprintf(p_stat," Hadamard transform           : Not used\n");
 1417|       |
 1418|       |  fprintf(p_stat,  " Image format                 : %dx%d\n",input->img_width,input->img_height);
 1419|       |
 1420|       |  if(input->intra_upd)
 1421|       |    fprintf(p_stat," Error robustness             : On\n");
 1422|       |  else
 1423|       |    fprintf(p_stat," Error robustness             : Off\n");
 1424|       |
 1425|       |  fprintf(p_stat,  " Search range                 : %d\n",input->search_range);
 1426|       |
 1427|       |  fprintf(p_stat,   " Total number of references   : %d\n",input->num_ref_frames);
 1428|       |  fprintf(p_stat,   " References for P slices      : %d\n",input->P_List0_refs? input->P_List0_refs:input->num_ref_frames);
 1429|       |  if(input->successive_Bframe != 0)
 1430|       |  {
 1431|       |    fprintf(p_stat, " List0 refs for B slices      : %d\n",input->B_List0_refs? input->B_List0_refs:input->num_ref_frames);
 1432|       |    fprintf(p_stat, " List1 refs for B slices      : %d\n",input->B_List1_refs? input->B_List1_refs:input->num_ref_frames);
 1433|       |  }
 1434|       |
 1435|       |  if (input->symbol_mode == UVLC)
 1436|       |    fprintf(p_stat,   " Entropy coding method        : CAVLC\n");
 1437|       |  else
 1438|       |    fprintf(p_stat,   " Entropy coding method        : CABAC\n");
 1439|       |
 1440|       |    fprintf(p_stat,   " Profile/Level IDC            : (%d,%d)\n",input->ProfileIDC,input->LevelIDC);
 1441|       |  if(input->MbInterlace)
 1442|       |    fprintf(p_stat, " MB Field Coding : On \n");
 1443|       |
 1444|       |#ifdef _FULL_SEARCH_RANGE_
 1445|       |  if (input->full_search == 2)
 1446|       |    fprintf(p_stat," Search range restrictions    : none\n");
 1447|       |  else if (input->full_search == 1)
 1448|       |    fprintf(p_stat," Search range restrictions    : older reference frames\n");
 1449|       |  else
 1450|       |    fprintf(p_stat," Search range restrictions    : smaller blocks and older reference frames\n");
 1451|       |#endif
 1452|       |  if (input->rdopt)
 1453|       |    fprintf(p_stat," RD-optimized mode decision   : used\n");
 1454|       |  else
 1455|       |    fprintf(p_stat," RD-optimized mode decision   : not used\n");
 1456|       |
 1457|       |  fprintf(p_stat," ---------------------|----------------|---------------|\n");
 1458|       |  fprintf(p_stat,"     Item             |     Intra      |   All frames  |\n");
 1459|       |  fprintf(p_stat," ---------------------|----------------|---------------|\n");
 1460|       |  fprintf(p_stat," SNR Y(dB)            |");
 1461|       |  fprintf(p_stat," %5.2f          |",snr->snr_y1);
 1462|       |  fprintf(p_stat," %5.2f         |\n",snr->snr_ya);
 1463|       |  fprintf(p_stat," SNR U/V (dB)         |");
 1464|       |  fprintf(p_stat," %5.2f/%5.2f    |",snr->snr_u1,snr->snr_v1);
 1465|       |  fprintf(p_stat," %5.2f/%5.2f   |\n",snr->snr_ua,snr->snr_va);
 1466|       |
 1467|       |  // QUANT.
 1468|       |  fprintf(p_stat," Average quant        |");
 1469|       |  fprintf(p_stat," %5d          |",absm(input->qp0));
 1470|       |  fprintf(p_stat," %5.2f         |\n",(float)stats->quant1/max(1.0,(float)stats->quant0));
 1471|       |
 1472|       |  fprintf(p_stat,"\n ---------------------|----------------|---------------|---------------|\n");
 1473|       |  fprintf(p_stat,"     SNR              |        I       |       P       |       B       |\n");
 1474|       |  fprintf(p_stat," ---------------------|----------------|---------------|---------------|\n");
 1475|       |  fprintf(p_stat," SNR Y(dB)            |      %5.3f    |     %5.3f    |     %5.3f    |\n",
 1476|       |                snr->snr_yt[I_SLICE],snr->snr_yt[P_SLICE],snr->snr_yt[B_SLICE]);
 1477|       |  fprintf(p_stat," SNR U(dB)            |      %5.3f    |     %5.3f    |     %5.3f    |\n",
 1478|       |                snr->snr_ut[I_SLICE],snr->snr_ut[P_SLICE],snr->snr_ut[B_SLICE]);
 1479|       |  fprintf(p_stat," SNR V(dB)            |      %5.3f    |     %5.3f    |     %5.3f    |\n",
 1480|       |                snr->snr_vt[I_SLICE],snr->snr_vt[P_SLICE],snr->snr_vt[B_SLICE]);
 1481|       |
 1482|       |
 1483|       |  // MODE
 1484|       |  fprintf(p_stat,"\n ---------------------|----------------|\n");
 1485|       |  fprintf(p_stat,"   Intra              |   Mode used    |\n");
 1486|       |  fprintf(p_stat," ---------------------|----------------|\n");
 1487|       |
 1488|       |  fprintf(p_stat," Mode 0  intra 4x4    |  %5d         |\n",stats->mode_use[I_SLICE][I4MB ]);
 1489|       |  fprintf(p_stat," Mode 1  intra 8x8    |  %5d         |\n",stats->mode_use[I_SLICE][I8MB ]);
 1490|       |  fprintf(p_stat," Mode 2+ intra 16x16  |  %5d         |\n",stats->mode_use[I_SLICE][I16MB]);
 1491|       |
 1492|       |  
 1493|       |  fprintf(p_stat,"\n ---------------------|----------------|-----------------|\n");
 1494|       |  fprintf(p_stat,"   Inter              |   Mode used    | MotionInfo bits |\n");
 1495|       |  fprintf(p_stat," ---------------------|----------------|-----------------|");
 1496|       |  fprintf(p_stat,"\n Mode  0  (copy)      |  %5d         |    %8.2f     |",stats->mode_use[P_SLICE][0   ],(float)stats->bit_use_mode[P_SLICE][0   ]/(float)bit_use[P_SLICE][0]);
 1497|       |  fprintf(p_stat,"\n Mode  1  (16x16)     |  %5d         |    %8.2f     |",stats->mode_use[P_SLICE][1   ],(float)stats->bit_use_mode[P_SLICE][1   ]/(float)bit_use[P_SLICE][0]);
 1498|       |  fprintf(p_stat,"\n Mode  2  (16x8)      |  %5d         |    %8.2f     |",stats->mode_use[P_SLICE][2   ],(float)stats->bit_use_mode[P_SLICE][2   ]/(float)bit_use[P_SLICE][0]);
 1499|       |  fprintf(p_stat,"\n Mode  3  (8x16)      |  %5d         |    %8.2f     |",stats->mode_use[P_SLICE][3   ],(float)stats->bit_use_mode[P_SLICE][3   ]/(float)bit_use[P_SLICE][0]);
 1500|       |  fprintf(p_stat,"\n Mode  4  (8x8)       |  %5d         |    %8.2f     |",stats->mode_use[P_SLICE][P8x8],(float)stats->bit_use_mode[P_SLICE][P8x8]/(float)bit_use[P_SLICE][0]);
 1501|       |  fprintf(p_stat,"\n Mode  5  intra 4x4   |  %5d         |-----------------|",stats->mode_use[P_SLICE][I4MB]);
 1502|       |  fprintf(p_stat,"\n Mode  6  intra 8x8   |  %5d         |",stats->mode_use[P_SLICE][I8MB]);
 1503|       |  fprintf(p_stat,"\n Mode  7+ intra 16x16 |  %5d         |",stats->mode_use[P_SLICE][I16MB]);
 1504|       |  mean_motion_info_bit_use[0] = (float)(stats->bit_use_mode[P_SLICE][0] + stats->bit_use_mode[P_SLICE][1] + stats->bit_use_mode[P_SLICE][2] 
 1505|       |                                      + stats->bit_use_mode[P_SLICE][3] + stats->bit_use_mode[P_SLICE][P8x8])/(float) bit_use[P_SLICE][0]; 
 1506|       |
 1507|       |  // B pictures
 1508|       |  if(input->successive_Bframe!=0 && Bframe_ctr!=0)
 1509|       |  {
 1510|       | 
 1511|       |    fprintf(p_stat,"\n\n ---------------------|----------------|-----------------|\n");
 1512|       |    fprintf(p_stat,"   B frame            |   Mode used    | MotionInfo bits |\n");
 1513|       |    fprintf(p_stat," ---------------------|----------------|-----------------|");
 1514|       |    fprintf(p_stat,"\n Mode  0  (copy)      |  %5d         |    %8.2f     |",stats->mode_use[B_SLICE][0   ],(float)stats->bit_use_mode[B_SLICE][0   ]/(float)Bframe_ctr);
 1515|       |    fprintf(p_stat,"\n Mode  1  (16x16)     |  %5d         |    %8.2f     |",stats->mode_use[B_SLICE][1   ],(float)stats->bit_use_mode[B_SLICE][1   ]/(float)Bframe_ctr);
 1516|       |    fprintf(p_stat,"\n Mode  2  (16x8)      |  %5d         |    %8.2f     |",stats->mode_use[B_SLICE][2   ],(float)stats->bit_use_mode[B_SLICE][2   ]/(float)Bframe_ctr);
 1517|       |    fprintf(p_stat,"\n Mode  3  (8x16)      |  %5d         |    %8.2f     |",stats->mode_use[B_SLICE][3   ],(float)stats->bit_use_mode[B_SLICE][3   ]/(float)Bframe_ctr);
 1518|       |    fprintf(p_stat,"\n Mode  4  (8x8)       |  %5d         |    %8.2f     |",stats->mode_use[B_SLICE][P8x8],(float)stats->bit_use_mode[B_SLICE][P8x8]/(float)Bframe_ctr);
 1519|       |    fprintf(p_stat,"\n Mode  5  intra 4x4   |  %5d         |-----------------|",stats->mode_use[B_SLICE][I4MB]);
 1520|       |    fprintf(p_stat,"\n Mode  6  intra 8x8   |  %5d         |",stats->mode_use[B_SLICE][I8MB]);
 1521|       |    fprintf(p_stat,"\n Mode  7+ intra 16x16 |  %5d         |",stats->mode_use[B_SLICE][I16MB]);
 1522|       |    mean_motion_info_bit_use[1] = (float)(stats->bit_use_mode[B_SLICE][0] + stats->bit_use_mode[B_SLICE][1] + stats->bit_use_mode[B_SLICE][2] 
 1523|       |                                      + stats->bit_use_mode[B_SLICE][3] + stats->bit_use_mode[B_SLICE][P8x8])/(float) Bframe_ctr; 
 1524|       |
 1525|       |  }
 1526|       |
 1527|       |  fprintf(p_stat,"\n\n ---------------------|----------------|----------------|----------------|\n");
 1528|       |  fprintf(p_stat,"  Bit usage:          |      Intra     |      Inter     |    B frame     |\n");
 1529|       |  fprintf(p_stat," ---------------------|----------------|----------------|----------------|\n");
 1530|       |
 1531|       |  fprintf(p_stat," Header               |");
 1532|       |  fprintf(p_stat," %10.2f     |",(float) stats->bit_use_header[I_SLICE]/bit_use[I_SLICE][0]);
 1533|       |  fprintf(p_stat," %10.2f     |",(float) stats->bit_use_header[P_SLICE]/bit_use[P_SLICE][0]);
 1534|       |  if(input->successive_Bframe!=0 && Bframe_ctr!=0)
 1535|       |    fprintf(p_stat," %10.2f     |",(float) stats->bit_use_header[B_SLICE]/Bframe_ctr);
 1536|       |  else fprintf(p_stat," %10.2f     |", 0.);
 1537|       |  fprintf(p_stat,"\n");
 1538|       |
 1539|       |  fprintf(p_stat," Mode                 |");
 1540|       |  fprintf(p_stat," %10.2f     |",(float)stats->bit_use_mb_type[I_SLICE]/bit_use[I_SLICE][0]);
 1541|       |  fprintf(p_stat," %10.2f     |",(float)stats->bit_use_mb_type[P_SLICE]/bit_use[P_SLICE][0]);
 1542|       |  if(input->successive_Bframe!=0 && Bframe_ctr!=0)
 1543|       |    fprintf(p_stat," %10.2f     |",(float)stats->bit_use_mb_type[B_SLICE]/Bframe_ctr);
 1544|       |  else fprintf(p_stat," %10.2f     |", 0.);
 1545|       |  fprintf(p_stat,"\n");
 1546|       |
 1547|       |  fprintf(p_stat," Motion Info          |");
 1548|       |  fprintf(p_stat,"        ./.     |");
 1549|       |  fprintf(p_stat," %10.2f     |",mean_motion_info_bit_use[0]);
 1550|       |  if(input->successive_Bframe!=0 && Bframe_ctr!=0)
 1551|       |    fprintf(p_stat," %10.2f     |",mean_motion_info_bit_use[1]);
 1552|       |  else fprintf(p_stat," %10.2f     |", 0.);
 1553|       |  fprintf(p_stat,"\n");
 1554|       |
 1555|       |  fprintf(p_stat," CBP Y/C              |");
 1556|       |  fprintf(p_stat," %10.2f     |", (float)stats->tmp_bit_use_cbp[I_SLICE]/bit_use[I_SLICE][0]);
 1557|       |  fprintf(p_stat," %10.2f     |", (float)stats->tmp_bit_use_cbp[P_SLICE]/bit_use[P_SLICE][0]);
 1558|       |  if(input->successive_Bframe!=0 && bit_use[B_SLICE][0]!=0)
 1559|       |    fprintf(p_stat," %10.2f     |", (float)stats->tmp_bit_use_cbp[B_SLICE]/bit_use[B_SLICE][0]);
 1560|       |  else fprintf(p_stat," %10.2f     |", 0.);
 1561|       |  fprintf(p_stat,"\n");
 1562|       |
 1563|       |  if(input->successive_Bframe!=0 && Bframe_ctr!=0)
 1564|       |    fprintf(p_stat," Coeffs. Y            | %10.2f     | %10.2f     | %10.2f     |\n",
 1565|       |    (float)stats->bit_use_coeffY[I_SLICE]/bit_use[I_SLICE][0], (float)stats->bit_use_coeffY[P_SLICE]/bit_use[P_SLICE][0], (float)stats->bit_use_coeffY[B_SLICE]/Bframe_ctr);
 1566|       |  else
 1567|       |    fprintf(p_stat," Coeffs. Y            | %10.2f     | %10.2f     | %10.2f     |\n",
 1568|       |      (float)stats->bit_use_coeffY[I_SLICE]/bit_use[I_SLICE][0], (float)stats->bit_use_coeffY[P_SLICE]/(float)bit_use[P_SLICE][0], 0.);
 1569|       |
 1570|       |  if(input->successive_Bframe!=0 && Bframe_ctr!=0)
 1571|       |    fprintf(p_stat," Coeffs. C            | %10.2f     | %10.2f     | %10.2f     |\n",
 1572|       |      (float)stats->bit_use_coeffC[I_SLICE]/bit_use[I_SLICE][0], (float)stats->bit_use_coeffC[P_SLICE]/bit_use[P_SLICE][0], (float)stats->bit_use_coeffC[B_SLICE]/Bframe_ctr);
 1573|       |  else
 1574|       |    fprintf(p_stat," Coeffs. C            | %10.2f     | %10.2f     | %10.2f     |\n",
 1575|       |      (float)stats->bit_use_coeffC[I_SLICE]/bit_use[I_SLICE][0], (float)stats->bit_use_coeffC[P_SLICE]/bit_use[P_SLICE][0], 0.);
 1576|       |
 1577|       |  if(input->successive_Bframe!=0 && Bframe_ctr!=0)
 1578|       |    fprintf(p_stat," Delta quant          | %10.2f     | %10.2f     | %10.2f     |\n",
 1579|       |      (float)stats->bit_use_delta_quant[I_SLICE]/bit_use[I_SLICE][0], (float)stats->bit_use_delta_quant[P_SLICE]/bit_use[P_SLICE][0], (float)stats->bit_use_delta_quant[B_SLICE]/Bframe_ctr);
 1580|       |  else
 1581|       |    fprintf(p_stat," Delta quant          | %10.2f     | %10.2f     | %10.2f     |\n",
 1582|       |      (float)stats->bit_use_delta_quant[I_SLICE]/bit_use[I_SLICE][0], (float)stats->bit_use_delta_quant[P_SLICE]/bit_use[P_SLICE][0], 0.);
 1583|       |
 1584|       |  if(input->successive_Bframe!=0 && Bframe_ctr!=0)
 1585|       |    fprintf(p_stat," Stuffing Bits        | %10.2f     | %10.2f     | %10.2f     |\n",
 1586|       |      (float)stats->bit_use_stuffingBits[I_SLICE]/bit_use[I_SLICE][0], (float)stats->bit_use_stuffingBits[P_SLICE]/bit_use[P_SLICE][0], (float)stats->bit_use_stuffingBits[B_SLICE]/Bframe_ctr);
 1587|       |  else
 1588|       |    fprintf(p_stat," Stuffing Bits        | %10.2f     | %10.2f     | %10.2f     |\n",
 1589|       |      (float)stats->bit_use_stuffingBits[I_SLICE]/bit_use[I_SLICE][0], (float)stats->bit_use_stuffingBits[P_SLICE]/bit_use[P_SLICE][0], 0.);
 1590|       |
 1591|       |
 1592|       |
 1593|       |  fprintf(p_stat," ---------------------|----------------|----------------|----------------|\n");
 1594|       |
 1595|       |  fprintf(p_stat," average bits/frame   |");
 1596|       |
 1597|       |  fprintf(p_stat," %10.2f     |", (float) bit_use[I_SLICE][1]/(float) bit_use[I_SLICE][0] );
 1598|       |  fprintf(p_stat," %10.2f     |", (float) bit_use[P_SLICE][1]/(float) bit_use[P_SLICE][0] );
 1599|       |
 1600|       |  if(input->successive_Bframe!=0 && Bframe_ctr!=0)
 1601|       |    fprintf(p_stat," %10.2f     |", (float) bit_use[B_SLICE][1]/ (float) Bframe_ctr );
 1602|       |  else fprintf(p_stat," %10.2f     |", 0.);
 1603|       |
 1604|       |  fprintf(p_stat,"\n");
 1605|       |  fprintf(p_stat," ---------------------|----------------|----------------|----------------|\n");
 1606|       |
 1607|       |  fclose(p_stat);
 1608|       |#endif /* SPEC_CPU */
 1609|       |
 1610|       |#if !defined(SPEC_CPU)
 1611|       |  // write to log file
 1612|       |  if ((p_log=fopen("log.dat","r"))==0)                      // check if file exist
 1613|       |  {
 1614|       |    if ((p_log=fopen("log.dat","a"))==NULL)            // append new statistic at the end
 1615|       |    {
 1616|       |      snprintf(errortext, ET_SIZE, "Error open file %s  \n","log.dat");
 1617|       |      error(errortext, 500);
 1618|       |    }
 1619|       |    else                                            // Create header for new log file
 1620|       |    {
 1621|       |      fprintf(p_log," ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- \n");
 1622|       |      fprintf(p_log,"|            Encoder statistics. This file is generated during first encoding session, new sessions will be appended                                                                                                                                                            |\n");
 1623|       |      fprintf(p_log," ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- \n");
 1624|       |      fprintf(p_log,"|    ver    | Date  | Time  |    Sequence        | #Img |P/MbInt| QPI| QPP| QPB| Format  |Iperiod| #B | Hdmd | S.R |#Ref | Freq |Coding|RD-opt|Intra upd|8x8Tr|SNRY 1|SNRU 1|SNRV 1|SNRY N|SNRU N|SNRV N|#Bitr I|#Bitr P|#Bitr B|#Bitr IPB|     Total Time   |      Me Time     |\n");
 1625|       |      fprintf(p_log," ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- \n");
 1626|       |    }
 1627|       |  }
 1628|       |  else
 1629|       |  {
 1630|       |    fclose (p_log);
 1631|       |    if ((p_log=fopen("log.dat","a"))==NULL)            // File exist,just open for appending
 1632|       |    {
 1633|       |      snprintf(errortext, ET_SIZE, "Error open file %s  \n","log.dat");
 1634|       |      error(errortext, 500);
 1635|       |    }
 1636|       |  }
 1637|       |  fprintf(p_log,"|%s/%-4s", VERSION, EXT_VERSION);
 1638|       |
 1639|       |#ifdef WIN32
 1640|       |  _strdate( timebuf );
 1641|       |  fprintf(p_log,"| %1.5s |",timebuf );
 1642|       |
 1643|       |  _strtime( timebuf);
 1644|       |  fprintf(p_log," % 1.5s |",timebuf);
 1645|       |#else
 1646|       |  now = time ((time_t *) NULL); // Get the system time and put it into 'now' as 'calender time'
 1647|       |  time (&now);
 1648|       |  l_time = localtime (&now);
 1649|       |  strftime (string, sizeof string, "%d-%b-%Y", l_time);
 1650|       |  fprintf(p_log,"| %1.5s |",string );
 1651|       |
 1652|       |  strftime (string, sizeof string, "%H:%M:%S", l_time);
 1653|       |  fprintf(p_log," %1.5s |",string );
 1654|       |#endif
 1655|       |
 1656|       |  for (i=0;i<20;i++)
 1657|       |    name[i]=input->infile[i+max(0,((int)strlen(input->infile))-20)]; // write last part of path, max 20 chars
 1658|       |  fprintf(p_log,"%20.20s|",name);
 1659|       |
 1660|       |  fprintf(p_log,"%5d |",input->no_frames);
 1661|       |  fprintf(p_log,"  %d/%d  |",input->PicInterlace, input->MbInterlace);
 1662|       |  fprintf(p_log," %-3d|",input->qp0);
 1663|       |  fprintf(p_log," %-3d|",input->qpN);
 1664|       |  fprintf(p_log," %-3d|",input->qpB);
 1665|       |
 1666|       |  fprintf(p_log,"%4dx%-4d|",input->img_width,input->img_height);
 1667|       |
 1668|       |  fprintf(p_log,"  %3d  |",input->intra_period);
 1669|       |  fprintf(p_log,"%3d |",input->successive_Bframe); 
 1670|       |
 1671|       |
 1672|       |  if (input->hadamard==1)
 1673|       |    fprintf(p_log,"  ON  |");
 1674|       |  else
 1675|       |    fprintf(p_log,"  OFF |");
 1676|       |
 1677|       |  fprintf(p_log," %3d |",input->search_range );
 1678|       |
 1679|       |  fprintf(p_log," %2d  |",input->num_ref_frames);
 1680|       |
 1681|       |
 1682|       |//  fprintf(p_log," %3d  |",img->framerate/(input->jumpd+1));
 1683|       |    fprintf(p_log," %3.2f|",(img->framerate *(float) (input->successive_Bframe + 1)) / (float)(input->jumpd+1));
 1684|       |
 1685|       |  if (input->symbol_mode == UVLC)
 1686|       |    fprintf(p_log," CAVLC|");
 1687|       |  else
 1688|       |    fprintf(p_log," CABAC|");
 1689|       |
 1690|       |  fprintf(p_log,"   %d  |",input->rdopt);
 1691|       |  
 1692|       |  if (input->intra_upd==1)
 1693|       |    fprintf(p_log,"   ON    |");
 1694|       |  else
 1695|       |    fprintf(p_log,"   OFF   |");
 1696|       |
 1697|       |  fprintf(p_log,"  %d  |",input->AllowTransform8x8);
 1698|       |  
 1699|       |  fprintf(p_log,"%-5.3f|",snr->snr_y1);
 1700|       |  fprintf(p_log,"%-5.3f|",snr->snr_u1);
 1701|       |  fprintf(p_log,"%-5.3f|",snr->snr_v1);
 1702|       |  fprintf(p_log,"%-5.3f|",snr->snr_ya);
 1703|       |  fprintf(p_log,"%-5.3f|",snr->snr_ua);
 1704|       |  fprintf(p_log,"%-5.3f|",snr->snr_va);
 1705|       |/*
 1706|       |  fprintf(p_log,"%-5.3f|",snr->snr_yt[I_SLICE]);
 1707|       |  fprintf(p_log,"%-5.3f|",snr->snr_ut[I_SLICE]);
 1708|       |  fprintf(p_log,"%-5.3f|",snr->snr_vt[I_SLICE]);
 1709|       |  fprintf(p_log,"%-5.3f|",snr->snr_yt[P_SLICE]);
 1710|       |  fprintf(p_log,"%-5.3f|",snr->snr_ut[P_SLICE]);
 1711|       |  fprintf(p_log,"%-5.3f|",snr->snr_vt[P_SLICE]);
 1712|       |  fprintf(p_log,"%-5.3f|",snr->snr_yt[B_SLICE]);
 1713|       |  fprintf(p_log,"%-5.3f|",snr->snr_ut[B_SLICE]);
 1714|       |  fprintf(p_log,"%-5.3f|",snr->snr_vt[B_SLICE]);
 1715|       |*/
 1716|       |  fprintf(p_log,"%7.0f|",stats->bitrate_I);
 1717|       |  fprintf(p_log,"%7.0f|",stats->bitrate_P);
 1718|       |  fprintf(p_log,"%7.0f|",stats->bitrate_B);
 1719|       |  fprintf(p_log,"%9.0f|",stats->bitrate);
 1720|       |
 1721|       |  fprintf(p_log,"   %12d   |", tot_time);
 1722|       |  fprintf(p_log,"   %12d   |\n", me_tot_time);
 1723|       |
 1724|       |  fclose(p_log);
 1725|       |#endif /* SPEC_CPU */
 1726|       |
 1727|       |#if !defined(SPEC_CPU)
 1728|       |  p_log=fopen("data.txt","a");
 1729|       |
 1730|       |  if(input->successive_Bframe != 0 && Bframe_ctr != 0) // B picture used
 1731|       |  {
 1732|       |    fprintf(p_log, "%3d %2d %2d %2.2f %2.2f %2.2f %5d "
 1733|       |          "%2.2f %2.2f %2.2f %5d "
 1734|       |        "%2.2f %2.2f %2.2f %5d %5d %.3f\n",
 1735|       |        input->no_frames, input->qp0, input->qpN,
 1736|       |        snr->snr_y1,
 1737|       |        snr->snr_u1,
 1738|       |        snr->snr_v1,
 1739|       |        stats->bit_ctr_I,
 1740|       |        0.0,
 1741|       |        0.0,
 1742|       |        0.0,
 1743|       |        0,
 1744|       |        snr->snr_ya,
 1745|       |        snr->snr_ua,
 1746|       |        snr->snr_va,
 1747|       |        (stats->bit_ctr_I+stats->bit_ctr)/(input->no_frames+Bframe_ctr),
 1748|       |        stats->bit_ctr_B/Bframe_ctr,
 1749|       |        (double)0.001*tot_time/(input->no_frames+Bframe_ctr));
 1750|       |  }
 1751|       |  else
 1752|       |  {
 1753|       |    if (input->no_frames!=0)
 1754|       |    fprintf(p_log, "%3d %2d %2d %2.2f %2.2f %2.2f %5d "
 1755|       |          "%2.2f %2.2f %2.2f %5d "
 1756|       |        "%2.2f %2.2f %2.2f %5d %5d %.3f\n",
 1757|       |        input->no_frames, input->qp0, input->qpN,
 1758|       |        snr->snr_y1,
 1759|       |        snr->snr_u1,
 1760|       |        snr->snr_v1,
 1761|       |        stats->bit_ctr_I,
 1762|       |        0.0,
 1763|       |        0.0,
 1764|       |        0.0,
 1765|       |        0,
 1766|       |        snr->snr_ya,
 1767|       |        snr->snr_ua,
 1768|       |        snr->snr_va,
 1769|       |        (stats->bit_ctr_I+stats->bit_ctr)/input->no_frames,
 1770|       |        0,
 1771|       |        (double)0.001*tot_time/input->no_frames);
 1772|       |  }
 1773|       |
 1774|       |  fclose(p_log);
 1775|       |#endif /* SPEC_CPU */
 1776|       |
 1777|      1|  if (input->ReportFrameStats)
 1778|      0|  {
 1779|      0|    if ((p_log=fopen("stat_frame.dat","a"))==NULL)            // append new statistic at the end
 1780|      0|    {
 1781|      0|      snprintf(errortext, ET_SIZE, "Error open file %s  \n","stat_frame.dat.dat");
 1782|       |      //    error(errortext, 500);
 1783|      0|    }
 1784|      0|    else
 1785|      0|    {
 1786|      0|      fprintf(p_log," --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- \n");
 1787|      0|      fclose(p_log);  
 1788|      0|    }
 1789|      0|  }
 1790|      1|}
 1791|       |
 1792|       |
 1793|       |/*!
 1794|       | ************************************************************************
 1795|       | * \brief
 1796|       | *    Prints the header of the protocol.
 1797|       | * \par Input:
 1798|       | *    struct inp_par *inp
 1799|       | * \par Output:
 1800|       | *    none
 1801|       | ************************************************************************
 1802|       | */
 1803|       |void information_init()
 1804|      1|{
 1805|      1|  char yuv_types[4][10]= {"YUV 4:0:0","YUV 4:2:0","YUV 4:2:2","YUV 4:4:4"};
 1806|       |
 1807|      1|  printf("------------------------------- JM %s %s --------------------------------\n",VERSION, EXT_VERSION);
 1808|      1|  printf(" Input YUV file                    : %s \n",input->infile);
 1809|      1|  printf(" Output H.264 bitstream            : %s \n",input->outfile);
 1810|      1|  if (p_dec != -1)
 1811|      0|   printf(" Output YUV file                   : %s \n",input->ReconFile);
 1812|      1|  printf(" YUV Format                        : %s \n", &yuv_types[img->yuv_format][0]);//img->yuv_format==YUV422?"YUV 4:2:2":(img->yuv_format==YUV444)?"YUV 4:4:4":"YUV 4:2:0");
 1813|      1|  printf(" Frames to be encoded I-P/B        : %d/%d\n", input->no_frames, (input->successive_Bframe*(input->no_frames-1)));
 1814|      1|  printf(" PicInterlace / MbInterlace        : %d/%d\n", input->PicInterlace, input->MbInterlace);
 1815|      1|  printf(" Transform8x8Mode                  : %d\n", input->AllowTransform8x8);
 1816|      1|  printf("-------------------------------------------------------------------------------\n");
 1817|      1|  printf("  Frame  Bit/pic WP QP   SnrY    SnrU    SnrV    Time(ms) MET(ms) Frm/Fld   I D\n");
 1818|      1|  printf("-------------------------------------------------------------------------------\n");
 1819|      1|}
 1820|       | 
 1821|       |/*!
 1822|       | ************************************************************************
 1823|       | * \brief
 1824|       | *    memory allocation for original picture buffers
 1825|       | ************************************************************************
 1826|       | */
 1827|       |int init_orig_buffers()
 1828|      1|{
 1829|      1|  int memory_size = 0;
 1830|       |  
 1831|       |  // allocate memory for reference frame buffers: imgY_org_frm, imgUV_org_frm
 1832|      1|  memory_size += get_mem2Dpel(&imgY_org_frm, img->height, img->width);
 1833|       |
 1834|      1|  if (img->yuv_format != YUV400)
 1835|      1|    memory_size += get_mem3Dpel(&imgUV_org_frm, 2, img->height_cr, img->width_cr);
 1836|       |
 1837|       |
 1838|      1|  if(!active_sps->frame_mbs_only_flag)
 1839|      0|  {
 1840|       |    // allocate memory for reference frame buffers: imgY_org, imgUV_org
 1841|      0|    init_top_bot_planes(imgY_org_frm, img->height, img->width, &imgY_org_top, &imgY_org_bot);
 1842|       |
 1843|      0|    if (img->yuv_format != YUV400)
 1844|      0|    {
 1845|      0|      if(((imgUV_org_top) = (imgpel***)calloc(2,sizeof(imgpel**))) == NULL)
 1846|      0|        no_mem_exit("init_global_buffers: imgUV_org_top");
 1847|      0|      if(((imgUV_org_bot) = (imgpel***)calloc(2,sizeof(imgpel**))) == NULL)
 1848|      0|        no_mem_exit("init_global_buffers: imgUV_org_bot");
 1849|       |
 1850|      0|      memory_size += 4*(sizeof(imgpel**));
 1851|       |
 1852|      0|      memory_size += init_top_bot_planes(imgUV_org_frm[0], img->height_cr, img->width_cr, &(imgUV_org_top[0]), &(imgUV_org_bot[0]));
 1853|      0|      memory_size += init_top_bot_planes(imgUV_org_frm[1], img->height_cr, img->width_cr, &(imgUV_org_top[1]), &(imgUV_org_bot[1]));
 1854|      0|    }
 1855|      0|  }
 1856|      1|  return memory_size;
 1857|      1|}
 1858|       |
 1859|       |/*!
 1860|       | ************************************************************************
 1861|       | * \brief
 1862|       | *    Dynamic memory allocation of frame size related global buffers
 1863|       | *    buffers are defined in global.h, allocated memory must be freed in
 1864|       | *    void free_global_buffers()
 1865|       | * \par Input:
 1866|       | *    Input Parameters struct inp_par *inp,                            \n
 1867|       | *    Image Parameters struct img_par *img
 1868|       | * \return Number of allocated bytes
 1869|       | ************************************************************************
 1870|       | */
 1871|       |int init_global_buffers()
 1872|      1|{
 1873|      1|  int j,memory_size=0;
 1874|      1|#ifdef _ADAPT_LAST_GROUP_
 1875|      1|  extern int *last_P_no_frm;
 1876|      1|  extern int *last_P_no_fld;
 1877|       |
 1878|      1|  if ((last_P_no_frm = (int*)malloc(2*img->max_num_references*sizeof(int))) == NULL)
 1879|      0|    no_mem_exit("init_global_buffers: last_P_no");
 1880|      1|  if(!active_sps->frame_mbs_only_flag)
 1881|      0|    if ((last_P_no_fld = (int*)malloc(4*img->max_num_references*sizeof(int))) == NULL)
 1882|      0|      no_mem_exit("init_global_buffers: last_P_no");
 1883|      1|#endif
 1884|       |
 1885|      1|  memory_size += init_orig_buffers(); 
 1886|       |    
 1887|       |
 1888|      1|  if (input->WeightedPrediction || input->WeightedBiprediction || input->GenerateMultiplePPS)
 1889|      0|  {
 1890|       |    // Currently only use up to 20 references. Need to use different indicator such as maximum num of references in list
 1891|      0|    memory_size += get_mem3Dint(&wp_weight,6,MAX_REFERENCE_PICTURES,3);
 1892|      0|    memory_size += get_mem3Dint(&wp_offset,6,MAX_REFERENCE_PICTURES,3);
 1893|       |    
 1894|      0|    memory_size += get_mem4Dint(&wbp_weight, 6, MAX_REFERENCE_PICTURES, MAX_REFERENCE_PICTURES, 3);
 1895|      0|  }
 1896|       |
 1897|       |  // allocate memory for reference frames of each block: refFrArr
 1898|       |
 1899|      1|  if(input->successive_Bframe!=0 || input->BRefPictures> 0)
 1900|      1|  {    
 1901|      1|    memory_size += get_mem3Dshort(&direct_ref_idx, 2, img->width/BLOCK_SIZE, img->height/BLOCK_SIZE);
 1902|      1|    memory_size += get_mem2Dshort(&direct_pdir, img->width/BLOCK_SIZE, img->height/BLOCK_SIZE);
 1903|      1|  }
 1904|       |
 1905|       |  // allocate memory for temp quarter pel luma frame buffer: img4Y_tmp
 1906|       |  // int img4Y_tmp[576][704];  (previously int imgY_tmp in global.h)
 1907|      1|  memory_size += get_mem2Dint(&img4Y_tmp, img->height+2*IMG_PAD_SIZE, (img->width+2*IMG_PAD_SIZE)*4);
 1908|       |
 1909|      1|  if (input->rdopt==2)
 1910|      0|  {
 1911|      0|    memory_size += get_mem2Dint(&decs->resY, MB_BLOCK_SIZE, MB_BLOCK_SIZE);
 1912|      0|    if ((decs->decref = (imgpel****) calloc(input->NoOfDecoders,sizeof(imgpel***))) == NULL) 
 1913|      0|      no_mem_exit("init_global_buffers: decref");
 1914|      0|    for (j=0 ; j<input->NoOfDecoders; j++)
 1915|      0|    {
 1916|      0|      memory_size += get_mem3Dpel(&decs->decref[j], img->max_num_references+1, img->height, img->width);
 1917|      0|    }
 1918|      0|    memory_size += get_mem2Dpel(&decs->RefBlock, BLOCK_SIZE,BLOCK_SIZE);
 1919|      0|    memory_size += get_mem3Dpel(&decs->decY, input->NoOfDecoders, img->height, img->width);
 1920|      0|    memory_size += get_mem3Dpel(&decs->decY_best, input->NoOfDecoders, img->height, img->width);
 1921|      0|    memory_size += get_mem2D(&decs->status_map, img->height/MB_BLOCK_SIZE,img->width/MB_BLOCK_SIZE);
 1922|      0|    memory_size += get_mem2D(&decs->dec_mb_mode, img->width/MB_BLOCK_SIZE,img->height/MB_BLOCK_SIZE);
 1923|      0|  }
 1924|      1|  if (input->RestrictRef)
 1925|      0|  {
 1926|      0|    memory_size += get_mem2D(&pixel_map, img->height,img->width);
 1927|      0|    memory_size += get_mem2D(&refresh_map, img->height/8,img->width/8);
 1928|      0|  }
 1929|       |
 1930|      1|  if(!active_sps->frame_mbs_only_flag)
 1931|      0|  {
 1932|      0|    memory_size += get_mem2Dpel(&imgY_com, img->height, img->width);
 1933|       |
 1934|      0|    if (img->yuv_format != YUV400)
 1935|      0|    {
 1936|      0|      memory_size += get_mem3Dpel(&imgUV_com, 2, img->height_cr, img->width_cr);
 1937|      0|    }
 1938|      0|  }
 1939|       |
 1940|      1|  if(input->FMEnable)
 1941|      0|    memory_size += get_mem_FME();
 1942|       |
 1943|      1|  if (input->RCEnable)
 1944|      0|  {
 1945|      0|    rc_alloc();
 1946|      0|  }
 1947|       |
 1948|      1|  return (memory_size);
 1949|      1|}
 1950|       |
 1951|       |
 1952|       |/*!
 1953|       | ************************************************************************
 1954|       | * \brief
 1955|       | *    Free allocated memory of original picture buffers
 1956|       | ************************************************************************
 1957|       | */
 1958|       |void free_orig_planes()
 1959|      1|{
 1960|      1|  free_mem2Dpel(imgY_org_frm);      // free ref frame buffers
 1961|       |
 1962|      1|  if (img->yuv_format != YUV400)
 1963|      1|    free_mem3Dpel(imgUV_org_frm, 2);
 1964|       |
 1965|       |
 1966|      1|  if(!active_sps->frame_mbs_only_flag)
 1967|      0|  {
 1968|      0|    free_top_bot_planes(imgY_org_top, imgY_org_bot);
 1969|       |
 1970|      0|    if (img->yuv_format != YUV400)
 1971|      0|    {
 1972|      0|      free_top_bot_planes(imgUV_org_top[0], imgUV_org_bot[0]);
 1973|      0|      free_top_bot_planes(imgUV_org_top[1], imgUV_org_bot[1]);
 1974|      0|      free (imgUV_org_top);
 1975|      0|      free (imgUV_org_bot);
 1976|      0|    }
 1977|      0|  }
 1978|      1|}
 1979|       |
 1980|       |
 1981|       |/*!
 1982|       | ************************************************************************
 1983|       | * \brief
 1984|       | *    Free allocated memory of frame size related global buffers
 1985|       | *    buffers are defined in global.h, allocated memory is allocated in
 1986|       | *    int get_mem4global_buffers()
 1987|       | * \par Input:
 1988|       | *    Input Parameters struct inp_par *inp,                             \n
 1989|       | *    Image Parameters struct img_par *img
 1990|       | * \par Output:
 1991|       | *    none
 1992|       | ************************************************************************
 1993|       | */
 1994|       |void free_global_buffers()
 1995|      1|{
 1996|      1|  int  i,j;
 1997|       |
 1998|      1|#ifdef _ADAPT_LAST_GROUP_
 1999|      1|  extern int *last_P_no_frm;
 2000|      1|  extern int *last_P_no_fld;
 2001|      1|  free (last_P_no_frm);
 2002|      1|  free (last_P_no_fld);
 2003|      1|#endif
 2004|       |
 2005|      1|  free_orig_planes();
 2006|       |
 2007|      1|  if (input->WeightedPrediction || input->WeightedBiprediction || input->GenerateMultiplePPS)
 2008|      0|  {
 2009|      0|    free_mem3Dint(wp_weight,6);
 2010|      0|    free_mem3Dint(wp_offset,6);
 2011|      0|    free_mem4Dint(wbp_weight,6,MAX_REFERENCE_PICTURES);
 2012|      0|  }
 2013|       |
 2014|      1|  if(input->successive_Bframe!=0 || input->BRefPictures> 0)
 2015|      1|  {
 2016|      1|    free_mem3Dshort(direct_ref_idx,2);
 2017|      1|    free_mem2Dshort(direct_pdir);
 2018|      1|  } // end if B frame
 2019|       |
 2020|       |
 2021|      1|  free_mem2Dint(img4Y_tmp);    // free temp quarter pel frame buffer
 2022|       |
 2023|       |  // free mem, allocated in init_img()
 2024|       |  // free intra pred mode buffer for blocks
 2025|      1|  free_mem2Dint(img->ipredmode);
 2026|      1|  free_mem2Dint(img->ipredmode8x8);
 2027|      1|  free(img->mb_data);
 2028|       |
 2029|      1|  free_mem2Dint(rddata_top_frame_mb.ipredmode);
 2030|       |  
 2031|      1|  if(input->UseConstrainedIntraPred)
 2032|      0|  {
 2033|      0|    free (img->intra_block);
 2034|      0|  }
 2035|       |
 2036|      1|  if (input->rdopt==2)
 2037|      0|  {
 2038|      0|    free(decs->resY[0]);
 2039|      0|    free(decs->resY);
 2040|      0|    free(decs->RefBlock[0]);
 2041|      0|    free(decs->RefBlock);
 2042|      0|    for (j=0; j<input->NoOfDecoders; j++)
 2043|      0|    {
 2044|      0|      free(decs->decY[j][0]);
 2045|      0|      free(decs->decY[j]);
 2046|      0|      free(decs->decY_best[j][0]);
 2047|      0|      free(decs->decY_best[j]);
 2048|      0|      for (i=0; i<img->max_num_references+1; i++)
 2049|      0|      {
 2050|      0|        free(decs->decref[j][i][0]);
 2051|      0|        free(decs->decref[j][i]);
 2052|      0|      }
 2053|      0|      free(decs->decref[j]);
 2054|      0|    }
 2055|      0|    free(decs->decY);
 2056|      0|    free(decs->decY_best);
 2057|      0|    free(decs->decref);
 2058|      0|    free(decs->status_map[0]);
 2059|      0|    free(decs->status_map);
 2060|      0|    free(decs->dec_mb_mode[0]);
 2061|      0|    free(decs->dec_mb_mode);
 2062|      0|  }
 2063|      1|  if (input->RestrictRef)
 2064|      0|  {
 2065|      0|    free(pixel_map[0]);
 2066|      0|    free(pixel_map);
 2067|      0|    free(refresh_map[0]);
 2068|      0|    free(refresh_map);
 2069|      0|  }
 2070|       |
 2071|      1|  if(!active_sps->frame_mbs_only_flag)
 2072|      0|  {
 2073|      0|    free_mem2Dpel(imgY_com);
 2074|      0|    if (img->yuv_format != YUV400)
 2075|      0|    {
 2076|      0|      free_mem3Dpel(imgUV_com,2);
 2077|      0|    }
 2078|      0|  }
 2079|       |
 2080|      1|  free_mem3Dint(img->nz_coeff, img->FrameSizeInMbs);
 2081|       |
 2082|      1|  if(input->FMEnable)
 2083|      0|  {
 2084|      0|    free_mem_FME();
 2085|      0|  }
 2086|       |
 2087|      1|  if (input->RCEnable)
 2088|      0|  {
 2089|      0|    rc_free();
 2090|      0|  }
 2091|       |
 2092|      1|}
 2093|       |
 2094|       |/*!
 2095|       | ************************************************************************
 2096|       | * \brief
 2097|       | *    Allocate memory for mv
 2098|       | * \par Input:
 2099|       | *    Image Parameters struct img_par *img                             \n
 2100|       | *    int****** mv
 2101|       | * \return memory size in bytes
 2102|       | ************************************************************************
 2103|       | */
 2104|       |int get_mem_mv (short ******* mv)
 2105|      2|{
 2106|      2|  int i, j, k, l, m;
 2107|       |
 2108|      2|  if ((*mv = (short******)calloc(4,sizeof(short*****))) == NULL)
 2109|      0|    no_mem_exit ("get_mem_mv: mv");
 2110|     10|  for (i=0; i<4; i++)
 2111|      8|  {
 2112|      8|    if (((*mv)[i] = (short*****)calloc(4,sizeof(short****))) == NULL)
 2113|      0|      no_mem_exit ("get_mem_mv: mv");
 2114|     40|    for (j=0; j<4; j++)
 2115|     32|    {
 2116|     32|      if (((*mv)[i][j] = (short****)calloc(2,sizeof(short***))) == NULL)
 2117|      0|        no_mem_exit ("get_mem_mv: mv");
 2118|     96|      for (k=0; k<2; k++)
 2119|     64|      {
 2120|     64|        if (((*mv)[i][j][k] = (short***)calloc(img->max_num_references,sizeof(short**))) == NULL)
 2121|      0|          no_mem_exit ("get_mem_mv: mv");
 2122|    384|        for (l=0; l<img->max_num_references; l++)
 2123|    320|        {
 2124|    320|          if (((*mv)[i][j][k][l] = (short**)calloc(9,sizeof(short*))) == NULL)
 2125|      0|            no_mem_exit ("get_mem_mv: mv");
 2126|  3.20k|          for (m=0; m<9; m++)
 2127|  2.88k|            if (((*mv)[i][j][k][l][m] = (short*)calloc(2,sizeof(short))) == NULL)
 2128|      0|              no_mem_exit ("get_mem_mv: mv");
 2129|    320|        }
 2130|     64|      }
 2131|     32|    }
 2132|      8|  }
 2133|      2|  return 4*4*img->max_num_references*9*2*sizeof(short);
 2134|      2|}
 2135|       |
 2136|       |
 2137|       |/*!
 2138|       | ************************************************************************
 2139|       | * \brief
 2140|       | *    Free memory from mv
 2141|       | * \par Input:
 2142|       | *    int****** mv
 2143|       | ************************************************************************
 2144|       | */
 2145|       |void free_mem_mv (short****** mv)
 2146|      2|{
 2147|      2|  int i, j, k, l, m;
 2148|       |
 2149|     10|  for (i=0; i<4; i++)
 2150|      8|  {
 2151|     40|    for (j=0; j<4; j++)
 2152|     32|    {
 2153|     96|      for (k=0; k<2; k++)
 2154|     64|      {
 2155|    384|        for (l=0; l<img->max_num_references; l++)
 2156|    320|        {
 2157|  3.20k|          for (m=0; m<9; m++)
 2158|  2.88k|          {
 2159|  2.88k|            free (mv[i][j][k][l][m]);
 2160|  2.88k|          }
 2161|    320|          free (mv[i][j][k][l]);
 2162|    320|        }
 2163|     64|        free (mv[i][j][k]);
 2164|     64|      }
 2165|     32|      free (mv[i][j]);
 2166|     32|    }
 2167|      8|    free (mv[i]);
 2168|      8|  }
 2169|      2|  free (mv);
 2170|      2|}
 2171|       |
 2172|       |
 2173|       |
 2174|       |
 2175|       |
 2176|       |/*!
 2177|       | ************************************************************************
 2178|       | * \brief
 2179|       | *    Allocate memory for AC coefficients
 2180|       | ************************************************************************
 2181|       | */
 2182|       |int get_mem_ACcoeff (int***** cofAC)
 2183|      4|{
 2184|      4|  int i, j, k;
 2185|      4|  int num_blk8x8 = 4 + img->num_blk8x8_uv;
 2186|       |
 2187|      4|  if ((*cofAC = (int****)calloc (num_blk8x8, sizeof(int***))) == NULL)              no_mem_exit ("get_mem_ACcoeff: cofAC");
 2188|     28|  for (k=0; k<num_blk8x8; k++)
 2189|     24|  {
 2190|     24|    if (((*cofAC)[k] = (int***)calloc (4, sizeof(int**))) == NULL)         no_mem_exit ("get_mem_ACcoeff: cofAC");
 2191|    120|    for (j=0; j<4; j++)
 2192|     96|    {
 2193|     96|      if (((*cofAC)[k][j] = (int**)calloc (2, sizeof(int*))) == NULL)      no_mem_exit ("get_mem_ACcoeff: cofAC");
 2194|    288|      for (i=0; i<2; i++)
 2195|    192|      {
 2196|    192|        if (((*cofAC)[k][j][i] = (int*)calloc (65, sizeof(int))) == NULL)  no_mem_exit ("get_mem_ACcoeff: cofAC"); // 18->65 for ABT
 2197|    192|      }
 2198|     96|    }
 2199|     24|  }
 2200|      4|  return num_blk8x8*4*2*65*sizeof(int);// 18->65 for ABT
 2201|      4|}
 2202|       |
 2203|       |/*!
 2204|       | ************************************************************************
 2205|       | * \brief
 2206|       | *    Allocate memory for DC coefficients
 2207|       | ************************************************************************
 2208|       | */
 2209|       |int get_mem_DCcoeff (int**** cofDC)
 2210|      2|{
 2211|      2|  int j, k;
 2212|       |
 2213|      2|  if ((*cofDC = (int***)calloc (3, sizeof(int**))) == NULL)           no_mem_exit ("get_mem_DCcoeff: cofDC");
 2214|      8|  for (k=0; k<3; k++)
 2215|      6|  {
 2216|      6|    if (((*cofDC)[k] = (int**)calloc (2, sizeof(int*))) == NULL)      no_mem_exit ("get_mem_DCcoeff: cofDC");
 2217|     18|    for (j=0; j<2; j++)
 2218|     12|    {
 2219|     12|      if (((*cofDC)[k][j] = (int*)calloc (65, sizeof(int))) == NULL)  no_mem_exit ("get_mem_DCcoeff: cofDC"); // 18->65 for ABT
 2220|     12|    }
 2221|      6|  }
 2222|      2|  return 3*2*65*sizeof(int); // 18->65 for ABT
 2223|      2|}
 2224|       |
 2225|       |
 2226|       |/*!
 2227|       | ************************************************************************
 2228|       | * \brief
 2229|       | *    Free memory of AC coefficients
 2230|       | ************************************************************************
 2231|       | */
 2232|       |void free_mem_ACcoeff (int**** cofAC)
 2233|      4|{
 2234|      4|  int i, j, k;
 2235|       |
 2236|     28|  for (k=0; k<4+img->num_blk8x8_uv; k++)
 2237|     24|  {
 2238|    120|    for (i=0; i<4; i++)
 2239|     96|    {
 2240|    288|      for (j=0; j<2; j++)
 2241|    192|      {
 2242|    192|        free (cofAC[k][i][j]);
 2243|    192|      }
 2244|     96|      free (cofAC[k][i]);
 2245|     96|    }
 2246|     24|    free (cofAC[k]);
 2247|     24|  }
 2248|      4|  free (cofAC);
 2249|      4|}
 2250|       |
 2251|       |/*!
 2252|       | ************************************************************************
 2253|       | * \brief
 2254|       | *    Free memory of DC coefficients
 2255|       | ************************************************************************
 2256|       | */
 2257|       |void free_mem_DCcoeff (int*** cofDC)
 2258|      2|{
 2259|      2|  int i, j;
 2260|       |
 2261|      8|  for (j=0; j<3; j++)
 2262|      6|  {
 2263|     18|    for (i=0; i<2; i++)
 2264|     12|    {
 2265|     12|      free (cofDC[j][i]);
 2266|     12|    }
 2267|      6|    free (cofDC[j]);
 2268|      6|  }
 2269|      2|  free (cofDC);
 2270|      2|}
 2271|       |
 2272|       |
 2273|       |/*!
 2274|       | ************************************************************************
 2275|       | * \brief
 2276|       | *    form frame picture from two field pictures 
 2277|       | ************************************************************************
 2278|       | */
 2279|       |void combine_field()
 2280|      0|{
 2281|      0|  int i;
 2282|       |
 2283|      0|  for (i=0; i<img->height / 2; i++)
 2284|      0|  {
 2285|      0|    memcpy(imgY_com[i*2], enc_top_picture->imgY[i], img->width*sizeof(imgpel));     // top field
 2286|      0|    memcpy(imgY_com[i*2 + 1], enc_bottom_picture->imgY[i], img->width*sizeof(imgpel)); // bottom field
 2287|      0|  }
 2288|       |
 2289|      0|  if (img->yuv_format != YUV400)
 2290|      0|  {
 2291|      0|    for (i=0; i<img->height_cr / 2; i++)
 2292|      0|    {
 2293|      0|      memcpy(imgUV_com[0][i*2],     enc_top_picture->imgUV[0][i],    img->width_cr*sizeof(imgpel));
 2294|      0|      memcpy(imgUV_com[0][i*2 + 1], enc_bottom_picture->imgUV[0][i], img->width_cr*sizeof(imgpel));
 2295|      0|      memcpy(imgUV_com[1][i*2],     enc_top_picture->imgUV[1][i],    img->width_cr*sizeof(imgpel));
 2296|      0|      memcpy(imgUV_com[1][i*2 + 1], enc_bottom_picture->imgUV[1][i], img->width_cr*sizeof(imgpel));
 2297|      0|    }
 2298|      0|  }
 2299|      0|}
 2300|       |
 2301|       |/*!
 2302|       | ************************************************************************
 2303|       | * \brief
 2304|       | *    RD decision of frame and field coding 
 2305|       | ************************************************************************
 2306|       | */
 2307|       |int decide_fld_frame(float snr_frame_Y, float snr_field_Y, int bit_field, int bit_frame, double lambda_picture)
 2308|      0|{
 2309|      0|  double cost_frame, cost_field;
 2310|       |
 2311|      0|  cost_frame = bit_frame * lambda_picture + snr_frame_Y;
 2312|      0|  cost_field = bit_field * lambda_picture + snr_field_Y;
 2313|       |
 2314|      0|  if (cost_field > cost_frame)
 2315|      0|    return (0);
 2316|      0|  else
 2317|      0|    return (1);
 2318|      0|}
 2319|       |
 2320|       |/*!
 2321|       | ************************************************************************
 2322|       | * \brief
 2323|       | *    Do some initializaiton work for encoding the 2nd IGOP
 2324|       | ************************************************************************
 2325|       | */
 2326|       |void process_2nd_IGOP()
 2327|     86|{
 2328|     86|  Boolean FirstIGOPFinished = FALSE;
 2329|     86|  if ( img->number == input->no_frames-1 )
 2330|      1|    FirstIGOPFinished = TRUE;
 2331|     86|  if (input->NumFrameIn2ndIGOP==0) return;
 2332|      0|  if (!FirstIGOPFinished || In2ndIGOP) return;
 2333|      0|  In2ndIGOP = TRUE;
 2334|       |
 2335|       |//  img->number = -1;
 2336|      0|  start_frame_no_in_this_IGOP = input->no_frames;
 2337|      0|  start_tr_in_this_IGOP = (input->no_frames-1)*(input->jumpd+1) +1;
 2338|      0|  input->no_frames = input->no_frames + input->NumFrameIn2ndIGOP;
 2339|       |
 2340|       |/*  reset_buffers();
 2341|       |
 2342|       |  frm->picbuf_short[0]->used=0;
 2343|       |  frm->picbuf_short[0]->picID=-1;
 2344|       |  frm->picbuf_short[0]->lt_picID=-1;
 2345|       |  frm->short_used = 0; */
 2346|      0|  img->nb_references = 0;
 2347|      0|}
 2348|       |
 2349|       |
 2350|       |/*!
 2351|       | ************************************************************************
 2352|       | * \brief
 2353|       | *    Set the image type for I,P and SP pictures (not B!)
 2354|       | ************************************************************************
 2355|       | */
 2356|       |void SetImgType()
 2357|     86|{
 2358|     86|  if (input->intra_period == 0)
 2359|      0|  {
 2360|      0|    if (IMG_NUMBER == 0)
 2361|      0|    {
 2362|      0|      img->type = I_SLICE;        // set image type for first image to I-frame
 2363|      0|    }
 2364|      0|    else
 2365|      0|    {
 2366|      0|      img->type = P_SLICE;        // P-frame
 2367|       |
 2368|      0|      if (input->sp_periodicity)
 2369|      0|      {
 2370|      0|        if ((IMG_NUMBER % input->sp_periodicity) ==0)
 2371|      0|        {
 2372|      0|          img->type=SP_SLICE;
 2373|      0|        }
 2374|      0|      }
 2375|      0|    }
 2376|      0|  }
 2377|     86|  else
 2378|     86|  {
 2379|     86|    if ((IMG_NUMBER%input->intra_period) == 0)
 2380|     29|    {
 2381|     29|      img->type = I_SLICE;
 2382|     29|    }
 2383|     57|    else
 2384|     57|    {
 2385|     57|      img->type = P_SLICE;        // P-frame
 2386|     57|      if (input->sp_periodicity)
 2387|      0|      {
 2388|      0|        if ((IMG_NUMBER % input->sp_periodicity) ==0)
 2389|      0|            img->type=SP_SLICE;
 2390|      0|      }
 2391|     57|    }
 2392|     86|  }
 2393|     86|}
 2394|       |
 2395|       | 

/home/xzp/speccpu2006-v1.0.1/benchspec/CPU2006/464.h264ref/run/build_base_ql_riscv_llvm17.0000/loopFilter.c:
    1|       |
    2|       |/*!
    3|       | *************************************************************************************
    4|       | * \file loopFilter.c
    5|       | *
    6|       | * \brief
    7|       | *    Filter to reduce blocking artifacts on a macroblock level.
    8|       | *    The filter strengh is QP dependent.
    9|       | *
   10|       | * \author
   11|       | *    Contributors:
   12|       | *    - Peter List       Peter.List@t-systems.de:  Original code                                 (13-Aug-2001)
   13|       | *    - Jani Lainema     Jani.Lainema@nokia.com:   Some bug fixing, removal of recusiveness      (16-Aug-2001)
   14|       | *    - Peter List       Peter.List@t-systems.de:  inplace filtering and various simplifications (10-Jan-2002)
   15|       | *    - Anthony Joch     anthony@ubvideo.com:      Simplified switching between filters and 
   16|       | *                                                 non-recursive default filter.                 (08-Jul-2002)
   17|       | *    - Cristina Gomila  cristina.gomila@thomson.net: Simplification of the chroma deblocking
   18|       | *                                                    from JVT-E089                              (21-Nov-2002)
   19|       | *************************************************************************************
   20|       | */
   21|       |
   22|       |#include <stdlib.h>
   23|       |#include <assert.h>
   24|       |
   25|       |#include "global.h"
   26|       |
   27|       |#include "image.h"
   28|       |#include "mb_access.h"
   29|       |
   30|       |extern const byte QP_SCALE_CR[52] ;
   31|       |
   32|       |byte mixedModeEdgeFlag, fieldModeFilteringFlag;
   33|       |
   34|       |/*********************************************************************************************************/
   35|       |
   36|  34.1M|#define  IClip( Min, Max, Val) (((Val)<(Min))? (Min):(((Val)>(Max))? (Max):(Val)))
   37|       |
   38|       |// NOTE: to change the tables below for instance when the QP doubling is changed from 6 to 8 values 
   39|       |//       send an e-mail to Peter.List@t-systems.com to get a little programm that calculates them automatically 
   40|       |
   41|       |byte ALPHA_TABLE[52]  = {0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,4,4,5,6,  7,8,9,10,12,13,15,17,  20,22,25,28,32,36,40,45,  50,56,63,71,80,90,101,113,  127,144,162,182,203,226,255,255} ;
   42|       |byte  BETA_TABLE[52]  = {0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,2,2,2,3,  3,3,3, 4, 4, 4, 6, 6,   7, 7, 8, 8, 9, 9,10,10,  11,11,12,12,13,13, 14, 14,   15, 15, 16, 16, 17, 17, 18, 18} ;
   43|       |byte CLIP_TAB[52][5]  =
   44|       |{
   45|       |  { 0, 0, 0, 0, 0},{ 0, 0, 0, 0, 0},{ 0, 0, 0, 0, 0},{ 0, 0, 0, 0, 0},{ 0, 0, 0, 0, 0},{ 0, 0, 0, 0, 0},{ 0, 0, 0, 0, 0},{ 0, 0, 0, 0, 0},
   46|       |  { 0, 0, 0, 0, 0},{ 0, 0, 0, 0, 0},{ 0, 0, 0, 0, 0},{ 0, 0, 0, 0, 0},{ 0, 0, 0, 0, 0},{ 0, 0, 0, 0, 0},{ 0, 0, 0, 0, 0},{ 0, 0, 0, 0, 0},
   47|       |  { 0, 0, 0, 0, 0},{ 0, 0, 0, 1, 1},{ 0, 0, 0, 1, 1},{ 0, 0, 0, 1, 1},{ 0, 0, 0, 1, 1},{ 0, 0, 1, 1, 1},{ 0, 0, 1, 1, 1},{ 0, 1, 1, 1, 1},
   48|       |  { 0, 1, 1, 1, 1},{ 0, 1, 1, 1, 1},{ 0, 1, 1, 1, 1},{ 0, 1, 1, 2, 2},{ 0, 1, 1, 2, 2},{ 0, 1, 1, 2, 2},{ 0, 1, 1, 2, 2},{ 0, 1, 2, 3, 3},
   49|       |  { 0, 1, 2, 3, 3},{ 0, 2, 2, 3, 3},{ 0, 2, 2, 4, 4},{ 0, 2, 3, 4, 4},{ 0, 2, 3, 4, 4},{ 0, 3, 3, 5, 5},{ 0, 3, 4, 6, 6},{ 0, 3, 4, 6, 6},
   50|       |  { 0, 4, 5, 7, 7},{ 0, 4, 5, 8, 8},{ 0, 4, 6, 9, 9},{ 0, 5, 7,10,10},{ 0, 6, 8,11,11},{ 0, 6, 8,13,13},{ 0, 7,10,14,14},{ 0, 8,11,16,16},
   51|       |  { 0, 9,12,18,18},{ 0,10,13,20,20},{ 0,11,15,23,23},{ 0,13,17,25,25}
   52|       |} ;
   53|       |
   54|       |  
   55|       |char chroma_edge[2][4][4] = //[dir][edge][yuv_format]
   56|       |{ { {-1, 0, 0, 0},
   57|       |    {-1,-1,-1, 1},
   58|       |    {-1, 1, 1, 2},
   59|       |    {-1,-1,-1, 3}},
   60|       |
   61|       |  { {-1, 0, 0, 0},
   62|       |    {-1,-1, 1, 1},
   63|       |    {-1, 1, 2, 2},
   64|       |    {-1,-1, 3, 3}}};
   65|       |
   66|       |  
   67|       |void GetStrength(byte Strength[16],ImageParameters *img,int MbQAddr,int dir,int edge, int mvlimit);
   68|       |void EdgeLoop(imgpel** Img, byte Strength[16],ImageParameters *img, int MbQAddr, int AlphaC0Offset, int BetaOffset, int dir, int edge, int width, int yuv, int uv);
   69|       |void DeblockMb(ImageParameters *img, imgpel **imgY, imgpel ***imgUV, int MbQAddr) ;
   70|       |
   71|       |
   72|       |/*!
   73|       | *****************************************************************************************
   74|       | * \brief
   75|       | *    Filter all macroblocks in order of increasing macroblock address.
   76|       | *****************************************************************************************
   77|       | */
   78|       |void DeblockFrame(ImageParameters *img, imgpel **imgY, imgpel ***imgUV)
   79|    171|{
   80|    171|  unsigned i;
   81|       |
   82|   109k|  for (i=0; i<img->PicSizeInMbs; i++)
   83|   109k|  {
   84|   109k|    DeblockMb( img, imgY, imgUV, i ) ;
   85|   109k|  }
   86|    171|} 
   87|       |
   88|       |
   89|       |/*!
   90|       | *****************************************************************************************
   91|       | * \brief
   92|       | *    Deblocking filter for one macroblock.
   93|       | *****************************************************************************************
   94|       | */
   95|       |
   96|       |void DeblockMb(ImageParameters *img, imgpel **imgY, imgpel ***imgUV, int MbQAddr)
   97|   109k|{
   98|   109k|  int           EdgeCondition;
   99|   109k|  int           dir,edge;
  100|   109k|  byte          Strength[16];
  101|   109k|  int           mb_x, mb_y;
  102|       |
  103|   109k|  int           filterNon8x8LumaEdgesFlag[4] = {1,1,1,1};
  104|   109k|  int           filterLeftMbEdgeFlag;
  105|   109k|  int           filterTopMbEdgeFlag;
  106|   109k|  int           fieldModeMbFlag;
  107|   109k|  int           mvlimit=4;
  108|   109k|  int           i, StrengthSum;
  109|   109k|  Macroblock    *MbQ;
  110|       |
  111|   109k|  int           edge_cr;  //ADD-VG-15052004
  112|       |  
  113|   109k|  img->DeblockCall = 1;
  114|   109k|  get_mb_pos (MbQAddr, &mb_x, &mb_y);
  115|   109k|  filterLeftMbEdgeFlag  = (mb_x != 0);
  116|   109k|  filterTopMbEdgeFlag   = (mb_y != 0);
  117|       |
  118|   109k|  MbQ  = &(img->mb_data[MbQAddr]) ; // current Mb
  119|       |
  120|   109k|  if (MbQ->mb_type == I8MB)
  121|      0|    assert(MbQ->luma_transform_size_8x8_flag);
  122|       |  
  123|   109k|  filterNon8x8LumaEdgesFlag[1] = 
  124|   109k|  filterNon8x8LumaEdgesFlag[3] = !(MbQ->luma_transform_size_8x8_flag);
  125|       |    
  126|   109k|  if (img->MbaffFrameFlag && mb_y==16 && MbQ->mb_field)
  127|      0|    filterTopMbEdgeFlag = 0;
  128|       |
  129|   109k|  fieldModeMbFlag       = (img->structure!=FRAME) || (img->MbaffFrameFlag && MbQ->mb_field);
  130|   109k|  if (fieldModeMbFlag)
  131|      0|    mvlimit = 2;
  132|       |
  133|       |  // return, if filter is disabled
  134|   109k|  if (MbQ->LFDisableIdc==1) {
  135|      0|    img->DeblockCall = 0;
  136|      0|    return;
  137|      0|  }
  138|       |
  139|   109k|  if (MbQ->LFDisableIdc==2)
  140|      0|  {
  141|       |    // don't filter at slice boundaries
  142|      0|    filterLeftMbEdgeFlag = MbQ->mbAvailA;
  143|       |    // if this the bottom of a frame macroblock pair then always filter the top edge
  144|      0|    if (img->MbaffFrameFlag && !MbQ->mb_field && (MbQAddr % 2)) filterTopMbEdgeFlag  = 1;
  145|      0|    else                                                      filterTopMbEdgeFlag  = MbQ->mbAvailB;
  146|      0|  }
  147|       |
  148|   109k|  img->current_mb_nr = MbQAddr;
  149|   109k|  CheckAvailabilityOfNeighbors();
  150|       |
  151|   328k|  for( dir=0 ; dir<2 ; dir++ )                                             // vertical edges, than horicontal edges
  152|   218k|  {
  153|   218k|    EdgeCondition = (dir && filterTopMbEdgeFlag) || (!dir && filterLeftMbEdgeFlag); // can not filter beyond picture boundaries
  154|  1.09M|    for( edge=0 ; edge<4 ; edge++ )                                            // first 4 vertical strips of 16 pel
  155|   875k|    {                                                                                         // then  4 horicontal
  156|   875k|      if( edge || EdgeCondition )
  157|   866k|      {
  158|   866k|        edge_cr = chroma_edge[dir][edge][img->yuv_format];
  159|       |        
  160|   866k|        GetStrength(Strength,img,MbQAddr,dir,edge, mvlimit); // Strength for 4 blks in 1 stripe
  161|   866k|        StrengthSum = Strength[0];
  162|  13.8M|        for (i = 1; i < 16; i++) StrengthSum += Strength[i];
  163|   866k|        if( StrengthSum )                      // only if one of the 16 Strength bytes is != 0
  164|   272k|        {
  165|   272k|          if (filterNon8x8LumaEdgesFlag[edge])
  166|   272k|            EdgeLoop( imgY, Strength, img, MbQAddr, MbQ->LFAlphaC0Offset, MbQ->LFBetaOffset, dir, edge, img->width, 0, 0) ; 
  167|   272k|          if( (imgUV != NULL) && (edge_cr >= 0))
  168|   160k|          {
  169|   160k|            EdgeLoop( imgUV[0], Strength, img, MbQAddr, MbQ->LFAlphaC0Offset, MbQ->LFBetaOffset, dir, edge_cr, img->width_cr, 1 , 0) ; 
  170|   160k|            EdgeLoop( imgUV[1], Strength, img, MbQAddr, MbQ->LFAlphaC0Offset, MbQ->LFBetaOffset, dir, edge_cr, img->width_cr, 1 , 1) ; 
  171|   160k|          }
  172|   272k|        }
  173|       |
  174|   866k|        if (dir && !edge && !MbQ->mb_field && mixedModeEdgeFlag) {
  175|       |          // this is the extra horizontal edge between a frame macroblock pair and a field above it
  176|      0|          img->DeblockCall = 2;
  177|      0|          GetStrength(Strength,img,MbQAddr,dir,4, mvlimit); // Strength for 4 blks in 1 stripe
  178|      0|          if( *((int*)Strength) )                      // only if one of the 4 Strength bytes is != 0
  179|      0|          {
  180|      0|            if (filterNon8x8LumaEdgesFlag[edge])
  181|      0|              EdgeLoop( imgY, Strength, img, MbQAddr, MbQ->LFAlphaC0Offset, MbQ->LFBetaOffset, dir, 4, img->width, 0, 0) ; 
  182|      0|            if( (imgUV != NULL) && (edge_cr >= 0))
  183|      0|            {
  184|      0|              EdgeLoop( imgUV[0], Strength, img, MbQAddr, MbQ->LFAlphaC0Offset, MbQ->LFBetaOffset, dir, 4, img->width_cr, 1, 0) ; 
  185|      0|              EdgeLoop( imgUV[1], Strength, img, MbQAddr, MbQ->LFAlphaC0Offset, MbQ->LFBetaOffset, dir, 4, img->width_cr, 1, 1) ; 
  186|      0|            }
  187|      0|          }
  188|      0|          img->DeblockCall = 1;
  189|      0|        }
  190|       |        
  191|   866k|      }
  192|   875k|    }//end edge
  193|   218k|  }//end loop dir
  194|   109k|  img->DeblockCall = 0;   
  195|       |
  196|   109k|}
  197|       |
  198|       |  /*!
  199|       | *********************************************************************************************
  200|       | * \brief
  201|       | *    returns a buffer of 16 Strength values for one stripe in a mb (for different Frame types)
  202|       | *********************************************************************************************
  203|       | */
  204|       |
  205|       |int  ININT_STRENGTH[4] = {0x04040404, 0x03030303, 0x03030303, 0x03030303} ; 
  206|       |byte BLK_NUM[2][4][4]  = {{{0,4,8,12},{1,5,9,13},{2,6,10,14},{3,7,11,15}},{{0,1,2,3},{4,5,6,7},{8,9,10,11},{12,13,14,15}}} ;
  207|       |byte BLK_4_TO_8[16]    = {0,0,1,1,0,0,1,1,2,2,3,3,2,2,3,3} ;
  208|       |#define ANY_INTRA (MbP->mb_type==I4MB||MbP->mb_type==I16MB||MbP->mb_type==IPCM||MbQ->mb_type==I4MB||MbQ->mb_type==I16MB||MbQ->mb_type==IPCM)
  209|       |
  210|       |void GetStrength(byte Strength[16],ImageParameters *img,int MbQAddr,int dir,int edge, int mvlimit)
  211|   866k|{
  212|   866k|  int    blkP, blkQ, idx;
  213|   866k|  int    blk_x, blk_x2, blk_y, blk_y2 ;
  214|   866k|  short  ***list0_mv = enc_picture->mv[LIST_0];
  215|   866k|  short  ***list1_mv = enc_picture->mv[LIST_1];
  216|   866k|  short  **list0_refIdxArr = enc_picture->ref_idx[LIST_0];
  217|   866k|  short  **list1_refIdxArr = enc_picture->ref_idx[LIST_1];
  218|   866k|  int64  **list0_refPicIdArr = enc_picture->ref_pic_id[LIST_0];
  219|   866k|  int64  **list1_refPicIdArr = enc_picture->ref_pic_id[LIST_1];
  220|   866k|  int    xQ, xP, yQ, yP;
  221|   866k|  int    mb_x, mb_y;
  222|   866k|  Macroblock    *MbQ;
  223|   866k|  Macroblock    *MbP;
  224|   866k|  PixelPos pixP;
  225|       |
  226|   866k|  MbQ = &(img->mb_data[MbQAddr]);
  227|       |
  228|  14.7M|  for( idx=0 ; idx<16 ; idx++ )
  229|  13.8M|  {                                                                
  230|  13.8M|    xQ = dir ? idx : edge << 2;
  231|  13.8M|    yQ = dir ? (edge < 4 ? edge << 2 : 1) : idx;
  232|  13.8M|    getNeighbour(MbQAddr, xQ - (1 - dir), yQ - dir, 1, &pixP);
  233|  13.8M|    xP = pixP.x;
  234|  13.8M|    yP = pixP.y;
  235|  13.8M|    MbP = &(img->mb_data[pixP.mb_addr]);
  236|  13.8M|    mixedModeEdgeFlag = MbQ->mb_field != MbP->mb_field;
  237|       |
  238|  13.8M|    blkQ = ((yQ>>2)<<2) + (xQ>>2);
  239|  13.8M|    blkP = ((yP>>2)<<2) + (xP>>2);
  240|       |
  241|  13.8M|    if ((img->type==SP_SLICE)||(img->type==SI_SLICE) )
  242|      0|    {
  243|      0|      Strength[idx] = (edge == 0 && (((!img->MbaffFrameFlag && (img->structure==FRAME)) ||
  244|      0|      (img->MbaffFrameFlag && !MbP->mb_field && !MbQ->mb_field)) ||
  245|      0|      ((img->MbaffFrameFlag || (img->structure!=FRAME)) && !dir))) ? 4 : 3;
  246|      0|    }
  247|  13.8M|    else
  248|  13.8M|    {
  249|       |      // Start with Strength=3. or Strength=4 for Mb-edge
  250|  13.8M|      Strength[idx] = (edge == 0 && (((!img->MbaffFrameFlag && (img->structure==FRAME)) ||
  251|  3.35M|        (img->MbaffFrameFlag && !MbP->mb_field && !MbQ->mb_field)) ||
  252|  10.5M|        ((img->MbaffFrameFlag || (img->structure!=FRAME)) && !dir))) ? 4 : 3;
  253|       |
  254|  13.8M|      if(  !(MbP->mb_type==I4MB || MbP->mb_type==I16MB || MbP->mb_type==IPCM || MbP->mb_type==I8MB)
  255|  13.8M|        && !(MbQ->mb_type==I4MB || MbQ->mb_type==I16MB || MbQ->mb_type==IPCM || MbQ->mb_type==I8MB) )
  256|  10.3M|      {
  257|  10.3M|        if( ((MbQ->cbp_blk &  (1 << blkQ )) != 0) || ((MbP->cbp_blk &  (1 << blkP)) != 0) )
  258|  56.3k|          Strength[idx] = 2 ;
  259|  10.3M|        else
  260|  10.3M|        {                                                     // if no coefs, but vector difference >= 1 set Strength=1 
  261|       |          // if this is a mixed mode edge then one set of reference pictures will be frame and the
  262|       |          // other will be field
  263|  10.3M|          if (mixedModeEdgeFlag)
  264|      0|          {
  265|      0|            (Strength[idx] = 1);
  266|      0|          }
  267|  10.3M|          else
  268|  10.3M|          {
  269|  10.3M|          get_mb_block_pos (MbQAddr, &mb_x, &mb_y);
  270|  10.3M|          blk_y  = (mb_y<<2) + (blkQ >> 2) ;
  271|  10.3M|          blk_x  = (mb_x<<2) + (blkQ  & 3) ;
  272|  10.3M|          blk_y2 = pixP.pos_y >> 2;
  273|  10.3M|          blk_x2 = pixP.pos_x >> 2;
  274|       |//            if( (img->type == B_SLICE) )
  275|  10.3M|          {
  276|  10.3M|              int64 ref_p0,ref_p1,ref_q0,ref_q1;      
  277|  10.3M|              ref_p0 = list0_refIdxArr[blk_x][blk_y]<0 ? -1 : list0_refPicIdArr[blk_x][blk_y];
  278|  10.3M|              ref_q0 = list0_refIdxArr[blk_x2][blk_y2]<0 ? -1 : list0_refPicIdArr[blk_x2][blk_y2];
  279|  10.3M|              ref_p1 = list1_refIdxArr[blk_x][blk_y]<0 ? -1 : list1_refPicIdArr[blk_x][blk_y];
  280|  10.3M|              ref_q1 = list1_refIdxArr[blk_x2][blk_y2]<0 ? -1 : list1_refPicIdArr[blk_x2][blk_y2];
  281|  10.3M|              if ( ((ref_p0==ref_q0) && (ref_p1==ref_q1)) ||
  282|  10.3M|                ((ref_p0==ref_q1) && (ref_p1==ref_q0))) 
  283|  9.97M|              {
  284|  9.97M|                Strength[idx]=0;
  285|       |                // L0 and L1 reference pictures of p0 are different; q0 as well
  286|  9.97M|                if (ref_p0 != ref_p1) 
  287|  9.94M|                { 
  288|       |                  // compare MV for the same reference picture
  289|  9.94M|                  if (ref_p0==ref_q0) 
  290|  9.94M|                  {
  291|  9.94M|                    Strength[idx] =  (abs( list0_mv[blk_x][blk_y][0] - list0_mv[blk_x2][blk_y2][0]) >= 4) |
  292|  9.94M|                      (abs( list0_mv[blk_x][blk_y][1] - list0_mv[blk_x2][blk_y2][1]) >= mvlimit) |
  293|  9.94M|                      (abs( list1_mv[blk_x][blk_y][0] - list1_mv[blk_x2][blk_y2][0]) >= 4) |
  294|  9.94M|                      (abs( list1_mv[blk_x][blk_y][1] - list1_mv[blk_x2][blk_y2][1]) >= mvlimit);
  295|  9.94M|                  }
  296|  1.36k|                  else 
  297|  1.36k|                  {
  298|  1.36k|                    Strength[idx] =  (abs( list0_mv[blk_x][blk_y][0] - list1_mv[blk_x2][blk_y2][0]) >= 4) |
  299|  1.36k|                      (abs( list0_mv[blk_x][blk_y][1] - list1_mv[blk_x2][blk_y2][1]) >= mvlimit) |
  300|  1.36k|                      (abs( list1_mv[blk_x][blk_y][0] - list0_mv[blk_x2][blk_y2][0]) >= 4) |
  301|  1.36k|                      (abs( list1_mv[blk_x][blk_y][1] - list0_mv[blk_x2][blk_y2][1]) >= mvlimit);
  302|  1.36k|                  } 
  303|  9.94M|                }
  304|  31.9k|                else 
  305|  31.9k|                { // L0 and L1 reference pictures of p0 are the same; q0 as well
  306|       |                
  307|  31.9k|                  Strength[idx] =  ((abs( list0_mv[blk_x][blk_y][0] - list0_mv[blk_x2][blk_y2][0]) >= 4) |
  308|  31.9k|                    (abs( list0_mv[blk_x][blk_y][1] - list0_mv[blk_x2][blk_y2][1]) >= mvlimit ) |
  309|  31.9k|                    (abs( list1_mv[blk_x][blk_y][0] - list1_mv[blk_x2][blk_y2][0]) >= 4) |
  310|  31.9k|                    (abs( list1_mv[blk_x][blk_y][1] - list1_mv[blk_x2][blk_y2][1]) >= mvlimit))
  311|  31.9k|                    &&
  312|  31.9k|                    ((abs( list0_mv[blk_x][blk_y][0] - list1_mv[blk_x2][blk_y2][0]) >= 4) |
  313|    720|                    (abs( list0_mv[blk_x][blk_y][1] - list1_mv[blk_x2][blk_y2][1]) >= mvlimit) |
  314|    720|                    (abs( list1_mv[blk_x][blk_y][0] - list0_mv[blk_x2][blk_y2][0]) >= 4) |
  315|    720|                    (abs( list1_mv[blk_x][blk_y][1] - list0_mv[blk_x2][blk_y2][1]) >= mvlimit));
  316|  31.9k|                }       
  317|  9.97M|              }
  318|   343k|              else 
  319|   343k|              {
  320|   343k|                Strength[idx] = 1;        
  321|   343k|              } 
  322|  10.3M|            }
  323|       |/*            else  
  324|       |          { // P slice
  325|       |              int64 ref_p0,ref_q0;      
  326|       |              ref_p0 = list0_refIdxArr[blk_x][blk_y]<0 ? -1 : list0_refPicIdArr[blk_x][blk_y];
  327|       |              ref_q0 = list0_refIdxArr[blk_x2][blk_y2]<0 ? -1 : list0_refPicIdArr[blk_x2][blk_y2];
  328|       |              Strength[idx] =  (ref_p0 != ref_q0 ) |
  329|       |                (abs( list0_mv[blk_x][blk_y][0] - list0_mv[blk_x2][blk_y2][0]) >= 4 ) |
  330|       |                (abs( list0_mv[blk_x][blk_y][1] - list0_mv[blk_x2][blk_y2][1]) >= mvlimit );
  331|       |              } */
  332|  10.3M|          }
  333|  10.3M|        }
  334|  10.3M|      }
  335|  13.8M|    }
  336|  13.8M|  }
  337|   866k|}
  338|       |
  339|  5.13M|#define CQPOF(qp, uv) (Clip3(0, 51, qp + img->chroma_qp_offset[uv]))
  340|       |
  341|       |/*!
  342|       | *****************************************************************************************
  343|       | * \brief
  344|       | *    Filters one edge of 16 (luma) or 8 (chroma) pel
  345|       | *****************************************************************************************
  346|       | */
  347|       |void EdgeLoop(imgpel** Img, byte Strength[16],ImageParameters *img, int MbQAddr, int AlphaC0Offset, int BetaOffset,
  348|       |              int dir, int edge, int width, int yuv, int uv)
  349|   593k|{
  350|   593k|  int      pel, ap = 0, aq = 0, Strng ;
  351|   593k|  int      incP, incQ;
  352|   593k|  int      C0, c0, Delta, dif, AbsDelta ;
  353|   593k|  int      L2 = 0, L1, L0, R0, R1, R2 = 0, RL0, L3, R3 ;
  354|   593k|  int      Alpha = 0, Beta = 0 ;
  355|   593k|  byte*    ClipTab = NULL;   
  356|   593k|  int      small_gap;
  357|   593k|  int      indexA, indexB;
  358|   593k|  int      PelNum;
  359|   593k|  int      StrengthIdx;
  360|   593k|  imgpel   *SrcPtrP, *SrcPtrQ;
  361|   593k|  int      QP;
  362|   593k|  int      xP, xQ, yP, yQ;
  363|   593k|  Macroblock *MbQ, *MbP;
  364|   593k|  PixelPos pixP, pixQ;
  365|   593k|  int      bitdepth_scale;
  366|   593k|  int      pelnum_cr[2][4] =  {{0,8,16,16}, {0,8, 8,16}};  //[dir:0=vert, 1=hor.][yuv_format]
  367|       |
  368|   593k|  if (!yuv)
  369|   272k|    bitdepth_scale = 1<<(img->bitdepth_luma - 8);
  370|   321k|  else
  371|   321k|    bitdepth_scale = 1<<(img->bitdepth_chroma - 8);
  372|       |  
  373|   593k|  PelNum = yuv ? pelnum_cr[dir][img->yuv_format] : 16 ;
  374|       |
  375|  7.52M|  for( pel=0 ; pel<PelNum ; pel++ )
  376|  6.93M|  {
  377|  6.93M|    xQ = dir ? pel : edge << 2;
  378|  6.93M|    yQ = dir ? (edge < 4 ? edge << 2 : 1) : pel;
  379|  6.93M|    getNeighbour(MbQAddr, xQ, yQ, 1-yuv, &pixQ);
  380|  6.93M|    getNeighbour(MbQAddr, xQ - (1 - dir), yQ - dir, 1-yuv, &pixP);
  381|  6.93M|    xP = pixP.x;
  382|  6.93M|    yP = pixP.y;
  383|  6.93M|    MbQ = &(img->mb_data[MbQAddr]);
  384|  6.93M|    MbP = &(img->mb_data[pixP.mb_addr]);
  385|  6.93M|    fieldModeFilteringFlag = MbQ->mb_field || MbP->mb_field;
  386|  6.93M|    StrengthIdx = (yuv&&(PelNum==8)) ? ((MbQ->mb_field && !MbP->mb_field) ? pel<<1 :((pel>>1)<<2)+(pel%2)) : pel;
  387|       |
  388|  6.93M|    if (pixP.available || (MbQ->LFDisableIdc== 0)) {
  389|  6.93M|      incQ = dir ? ((fieldModeFilteringFlag && !MbQ->mb_field) ? 2 * width : width) : 1;
  390|  6.93M|      incP = dir ? ((fieldModeFilteringFlag && !MbP->mb_field) ? 2 * width : width) : 1;
  391|  6.93M|      SrcPtrQ = &(Img[pixQ.pos_y][pixQ.pos_x]);
  392|  6.93M|      SrcPtrP = &(Img[pixP.pos_y][pixP.pos_x]);
  393|       |
  394|       |      // Average QP of the two blocks
  395|  6.93M|      QP  = yuv ? (QP_SCALE_CR[CQPOF(MbP->qp,uv)] + QP_SCALE_CR[CQPOF(MbQ->qp,uv)] + 1) >> 1 : (MbP->qp + MbQ->qp + 1) >> 1;
  396|       |
  397|  6.93M|      indexA = IClip(0, MAX_QP, QP + AlphaC0Offset);
  398|  6.93M|      indexB = IClip(0, MAX_QP, QP + BetaOffset);
  399|       |    
  400|  6.93M|      Alpha  =ALPHA_TABLE[indexA] * bitdepth_scale;
  401|  6.93M|      Beta   =BETA_TABLE[indexB]  * bitdepth_scale;
  402|  6.93M|      ClipTab=CLIP_TAB[indexA]; 
  403|       |
  404|  6.93M|      L0  = SrcPtrP[0] ;
  405|  6.93M|      R0  = SrcPtrQ[0] ;
  406|  6.93M|      L1  = SrcPtrP[-incP] ;
  407|  6.93M|      R1  = SrcPtrQ[ incQ] ;
  408|  6.93M|      L2  = SrcPtrP[-incP*2] ;
  409|  6.93M|      R2  = SrcPtrQ[ incQ*2] ;
  410|  6.93M|      L3  = SrcPtrP[-incP*3] ;
  411|  6.93M|      R3  = SrcPtrQ[ incQ*3] ;
  412|       |
  413|  6.93M|      if( (Strng = Strength[StrengthIdx]) )
  414|  6.76M|      {
  415|  6.76M|        AbsDelta  = abs( Delta = R0 - L0 )  ;
  416|       |      
  417|  6.76M|        if( AbsDelta < Alpha )
  418|  6.67M|        {
  419|  6.67M|          C0  = ClipTab[ Strng ] * bitdepth_scale;
  420|  6.67M|          if( ((abs( R0 - R1) - Beta )  & (abs(L0 - L1) - Beta )) < 0  ) 
  421|  6.45M|          {
  422|  6.45M|            if( !yuv)
  423|  4.08M|            {
  424|  4.08M|              aq  = (abs( R0 - R2) - Beta ) < 0  ;
  425|  4.08M|              ap  = (abs( L0 - L2) - Beta ) < 0  ;
  426|  4.08M|            }
  427|       |          
  428|  6.45M|            RL0             = L0 + R0 ;
  429|       |          
  430|  6.45M|            if(Strng == 4 )    // INTRA strong filtering
  431|  1.77M|            {
  432|  1.77M|              if( yuv)  // Chroma
  433|   880k|              {
  434|   880k|                SrcPtrQ[0] = ((R1 << 1) + R0 + L1 + 2) >> 2; 
  435|   880k|                SrcPtrP[0] = ((L1 << 1) + L0 + R1 + 2) >> 2;                                           
  436|   880k|              }
  437|   890k|              else  // Luma
  438|   890k|              {
  439|   890k|                small_gap = (AbsDelta < ((Alpha >> 2) + 2));
  440|       |              
  441|   890k|                aq &= small_gap;
  442|   890k|                ap &= small_gap;
  443|       |              
  444|   890k|                SrcPtrQ[0]   = aq ? ( L1 + ((R1 + RL0) << 1) +  R2 + 4) >> 3 : ((R1 << 1) + R0 + L1 + 2) >> 2 ;
  445|   890k|                SrcPtrP[0]   = ap ? ( R1 + ((L1 + RL0) << 1) +  L2 + 4) >> 3 : ((L1 << 1) + L0 + R1 + 2) >> 2 ;
  446|       |              
  447|   890k|                SrcPtrQ[ incQ] =   aq  ? ( R2 + R0 + R1 + L0 + 2) >> 2 : R1;
  448|   890k|                SrcPtrP[-incP] =   ap  ? ( L2 + L1 + L0 + R0 + 2) >> 2 : L1;
  449|       |              
  450|   890k|                SrcPtrQ[ incQ*2] = aq ? (((R3 + R2) <<1) + R2 + R1 + RL0 + 4) >> 3 : R2;
  451|   890k|                SrcPtrP[-incP*2] = ap ? (((L3 + L2) <<1) + L2 + L1 + RL0 + 4) >> 3 : L2;
  452|   890k|              }
  453|  1.77M|            }
  454|  4.68M|            else                                                                                   // normal filtering
  455|  4.68M|            {
  456|  4.68M|              c0               = yuv? (C0+1):(C0 + ap + aq) ;
  457|  4.68M|              dif              = IClip( -c0, c0, ( (Delta << 2) + (L1 - R1) + 4) >> 3 ) ;
  458|  4.68M|              if(!yuv)
  459|  3.19M|              {
  460|  3.19M|                SrcPtrP[0]  = IClip(0, img->max_imgpel_value , L0 + dif) ;
  461|  3.19M|                SrcPtrQ[0]  = IClip(0, img->max_imgpel_value , R0 - dif) ;
  462|  3.19M|              } 
  463|  1.49M|              else 
  464|  1.49M|              {
  465|  1.49M|                SrcPtrP[0]  = IClip(0, img->max_imgpel_value_uv , L0 + dif) ;
  466|  1.49M|                SrcPtrQ[0]  = IClip(0, img->max_imgpel_value_uv , R0 - dif) ;
  467|  1.49M|              }
  468|       |            
  469|  4.68M|              if( !yuv )
  470|  3.19M|              {
  471|  3.19M|                if( ap )
  472|  3.12M|                  SrcPtrP[-incP] += IClip( -C0,  C0, ( L2 + ((RL0 + 1) >> 1) - (L1<<1)) >> 1 ) ;
  473|  3.19M|                if( aq  )
  474|  3.11M|                  SrcPtrQ[ incQ] += IClip( -C0,  C0, ( R2 + ((RL0 + 1) >> 1) - (R1<<1)) >> 1 ) ;
  475|  3.19M|              } ;
  476|  4.68M|            } ;
  477|  6.45M|          } ; 
  478|  6.67M|        } ;
  479|  6.76M|      } ;
  480|  6.93M|    } ;
  481|  6.93M|  }
  482|   593k|}
  483|       |

/home/xzp/speccpu2006-v1.0.1/benchspec/CPU2006/464.h264ref/run/build_base_ql_riscv_llvm17.0000/macroblock.c:
    1|       |
    2|       |/*!
    3|       | *************************************************************************************
    4|       | * \file macroblock.c
    5|       | *
    6|       | * \brief
    7|       | *    Process one macroblock
    8|       | *
    9|       | * \author
   10|       | *    Main contributors (see contributors.h for copyright, address and affiliation details)
   11|       | *    - Inge Lille-Langoy               <inge.lille-langoy@telenor.com>
   12|       | *    - Rickard Sjoberg                 <rickard.sjoberg@era.ericsson.se>
   13|       | *    - Jani Lainema                    <jani.lainema@nokia.com>
   14|       | *    - Sebastian Purreiter             <sebastian.purreiter@mch.siemens.de>
   15|       | *    - Detlev Marpe                    <marpe@hhi.de>
   16|       | *    - Thomas Wedi                     <wedi@tnt.uni-hannover.de>
   17|       | *    - Ragip Kurceren                  <ragip.kurceren@nokia.com>
   18|       | *    - Alexis Michael Tourapis         <alexismt@ieee.org>
   19|       | *************************************************************************************
   20|       | */
   21|       |
   22|       |#include "contributors.h"
   23|       |
   24|       |#include <stdlib.h>
   25|       |#include <assert.h>
   26|       |#include <limits.h>
   27|       |
   28|       |#include "global.h"
   29|       |
   30|       |#include "elements.h"
   31|       |#include "macroblock.h"
   32|       |#include "refbuf.h"
   33|       |#include "fmo.h"
   34|       |#include "vlc.h"
   35|       |#include "image.h"
   36|       |#include "mb_access.h"
   37|       |#include "ratectl.h"              // head file for rate control
   38|       |#include "cabac.h"
   39|       |#include "transform8x8.h"
   40|       |
   41|       |//Rate control
   42|       |int predict_error,dq;
   43|       |extern int DELTA_QP,DELTA_QP2;
   44|       |extern int QP,QP2;
   45|       |
   46|       | /*!
   47|       | ************************************************************************
   48|       | * \brief
   49|       | *    updates the coordinates for the next macroblock to be processed
   50|       | *
   51|       | * \param mb_addr
   52|       | *    MB address in scan order
   53|       | ************************************************************************
   54|       | */
   55|       |
   56|       |void set_MB_parameters (int mb_addr)
   57|   109k|{
   58|   109k|  img->current_mb_nr = mb_addr;
   59|       |  
   60|   109k|  get_mb_block_pos(mb_addr, &img->mb_x, &img->mb_y);
   61|       |  
   62|   109k|  img->block_x = img->mb_x << 2;
   63|   109k|  img->block_y = img->mb_y << 2;
   64|       |
   65|   109k|  img->pix_x   = img->block_x << 2;
   66|   109k|  img->pix_y   = img->block_y << 2;
   67|       |
   68|   109k|  img->opix_x   = img->pix_x;
   69|       |
   70|   109k|  if (img->MbaffFrameFlag)
   71|      0|  {
   72|      0|    if (img->mb_data[mb_addr].mb_field)
   73|      0|    {
   74|       |
   75|      0|      imgY_org  = (mb_addr % 2) ? imgY_org_bot  : imgY_org_top;
   76|      0|      imgUV_org = (mb_addr % 2) ? imgUV_org_bot : imgUV_org_top;
   77|      0|      img->opix_y   = (img->mb_y >> 1 ) << 4;
   78|      0|    }
   79|      0|    else
   80|      0|    {
   81|      0|      imgY_org  = imgY_org_frm;
   82|      0|      imgUV_org = imgUV_org_frm;
   83|      0|      img->opix_y   = img->block_y << 2;
   84|      0|    }
   85|      0|  }
   86|   109k|  else
   87|   109k|  {
   88|   109k|    img->opix_y   = img->block_y << 2;
   89|   109k|  }
   90|       |
   91|   109k|  if (img->yuv_format != YUV400)
   92|   109k|  {
   93|   109k|    img->pix_c_x = img->pix_x / (16/img->mb_cr_size_x);
   94|   109k|    img->pix_c_y = img->pix_y / (16/img->mb_cr_size_y);
   95|       |    
   96|   109k|    img->opix_c_x = img->opix_x / (16/img->mb_cr_size_x);
   97|   109k|    img->opix_c_y = img->opix_y / (16/img->mb_cr_size_y);
   98|   109k|  }
   99|       |  
  100|       |
  101|       |//  printf ("set_MB_parameters: mb %d,  mb_x %d,  mb_y %d\n", mb_addr, img->mb_x, img->mb_y);
  102|   109k|}
  103|       |
  104|       |
  105|       |int clip1a(int a)
  106|      0|{
  107|      0|  return ((a)>img->max_imgpel_value?img->max_imgpel_value:((a)<0?0:(a)));
  108|      0|}
  109|       |
  110|       |int clip1a_chr(int a)
  111|      0|{
  112|      0|  return ((a)>img->max_imgpel_value_uv?img->max_imgpel_value_uv:((a)<0?0:(a)));
  113|      0|}
  114|       |
  115|       |/*!
  116|       | ************************************************************************
  117|       | * \brief
  118|       | *    updates the coordinates and statistics parameter for the
  119|       | *    next macroblock
  120|       | ************************************************************************
  121|       | */
  122|       |void proceed2nextMacroblock()
  123|   109k|{
  124|       |#if TRACE
  125|       |  int use_bitstream_backing = (input->slice_mode == FIXED_RATE || input->slice_mode == CALLBACK);
  126|       |#endif
  127|   109k|  Macroblock *currMB = &img->mb_data[img->current_mb_nr];
  128|   109k|  int*        bitCount = currMB->bitcounter;
  129|   109k|  int i;
  130|       |  
  131|       |#if TRACE
  132|       |
  133|       |  if (p_trace)
  134|       |  {
  135|       |    fprintf(p_trace, "\n*********** Pic: %i (I/P) MB: %i Slice: %i **********\n\n", frame_no, img->current_mb_nr, img->current_slice_nr);
  136|       |    if(use_bitstream_backing)
  137|       |      fprintf(p_trace, "\n*********** Pic: %i (I/P) MB: %i Slice: %i **********\n\n", frame_no, img->current_mb_nr, img->current_slice_nr);
  138|       |   // Write out the tracestring for each symbol
  139|       |    for (i=0; i<currMB->currSEnr; i++)
  140|       |      trace2out(&(img->MB_SyntaxElements[i]));
  141|       |  }
  142|       |#endif
  143|       |
  144|       |  // Update the statistics
  145|   109k|  stats->bit_use_mb_type[img->type]      += bitCount[BITS_MB_MODE];
  146|   109k|  stats->bit_use_coeffY[img->type]       += bitCount[BITS_COEFF_Y_MB] ;
  147|   109k|  stats->tmp_bit_use_cbp[img->type]      += bitCount[BITS_CBP_MB];
  148|   109k|  stats->bit_use_coeffC[img->type]       += bitCount[BITS_COEFF_UV_MB];
  149|   109k|  stats->bit_use_delta_quant[img->type]  += bitCount[BITS_DELTA_QUANT_MB];
  150|       |
  151|   109k|  if (IS_INTRA(currMB))
  152|  26.7k|  {
  153|  26.7k|    ++stats->intra_chroma_mode[currMB->c_ipred_mode];
  154|       |
  155|  26.7k|    if ((currMB->cbp&15) != 0)
  156|  6.74k|    {
  157|  6.74k|      if (currMB->luma_transform_size_8x8_flag)
  158|      0|        ++stats->mode_use_transform_8x8[img->type][currMB->mb_type];
  159|  6.74k|      else
  160|  6.74k|        ++stats->mode_use_transform_4x4[img->type][currMB->mb_type];
  161|  6.74k|    }
  162|  26.7k|  }
  163|       |
  164|   109k|   ++stats->mode_use[img->type][currMB->mb_type];
  165|   109k|   stats->bit_use_mode[img->type][currMB->mb_type]+= bitCount[BITS_INTER_MB];
  166|       | 
  167|   109k|   if (img->type != I_SLICE)
  168|  90.8k|   {
  169|  90.8k|     if (currMB->mb_type == P8x8)
  170|  1.83k|     {
  171|  9.18k|       for(i=0;i<4;i++)
  172|  7.34k|       {
  173|  7.34k|         if (currMB->b8mode[i] > 0)
  174|  6.63k|           ++stats->mode_use[img->type][currMB->b8mode[i]];
  175|    708|         else
  176|    708|           ++stats->b8_mode_0_use[img->type][currMB->luma_transform_size_8x8_flag];
  177|       |         
  178|  7.34k|         if (currMB->b8mode[i]==4)
  179|  4.71k|         {
  180|  4.71k|           if ((currMB->luma_transform_size_8x8_flag && (currMB->cbp&15) != 0) || input->AllowTransform8x8 == 2)
  181|      0|             ++stats->mode_use_transform_8x8[img->type][4];
  182|  4.71k|           else
  183|  4.71k|             ++stats->mode_use_transform_4x4[img->type][4];
  184|  4.71k|         }
  185|  7.34k|       }
  186|  1.83k|     }
  187|  89.0k|     else if (currMB->mb_type >= 0 && currMB->mb_type <=3 && ((currMB->cbp&15) != 0))
  188|  1.03k|     {
  189|  1.03k|       if (currMB->luma_transform_size_8x8_flag)
  190|      0|         ++stats->mode_use_transform_8x8[img->type][currMB->mb_type];
  191|  1.03k|       else
  192|  1.03k|         ++stats->mode_use_transform_4x4[img->type][currMB->mb_type];
  193|  1.03k|     }
  194|  90.8k|   }
  195|       |  
  196|       |  // Statistics
  197|   109k|  if ((img->type == P_SLICE)||(img->type==SP_SLICE) )
  198|  36.4k|  {
  199|  36.4k|    ++stats->quant0;
  200|  36.4k|    stats->quant1 += currMB->qp;      // to find average quant for inter frames
  201|  36.4k|  }
  202|   109k|}
  203|       |
  204|       |/*!
  205|       | ************************************************************************
  206|       | * \brief
  207|       | *    initializes the current macroblock
  208|       | ************************************************************************
  209|       | */
  210|       |void start_macroblock(int mb_addr, int mb_field)
  211|   109k|{
  212|   109k|  int i,j,k,l;
  213|   109k|  int use_bitstream_backing = (input->slice_mode == FIXED_RATE || input->slice_mode == CALLBACK);
  214|   109k|  Macroblock *currMB = &img->mb_data[mb_addr];
  215|   109k|  Slice *curr_slice = img->currentSlice;
  216|   109k|  DataPartition *dataPart;
  217|   109k|  Bitstream *currStream;
  218|   109k|  EncodingEnvironmentPtr eep;
  219|   109k|  int max_qp_delta = 25 + img->bitdepth_luma_qp_scale/2;
  220|   109k|  int min_qp_delta = (26 + img->bitdepth_luma_qp_scale/2);
  221|       |  
  222|   109k|  currMB->mb_field = mb_field;
  223|       |  
  224|   109k|  enc_picture->mb_field[mb_addr] = mb_field;
  225|       |
  226|   109k|  set_MB_parameters (mb_addr);
  227|       |
  228|   109k|  if(use_bitstream_backing)
  229|      0|  {
  230|       |    // Keep the current state of the bitstreams
  231|      0|    if(!img->cod_counter)
  232|      0|      for (i=0; i<curr_slice->max_part_nr; i++)
  233|      0|      {
  234|      0|        dataPart = &(curr_slice->partArr[i]);
  235|      0|        currStream = dataPart->bitstream;
  236|      0|        currStream->stored_bits_to_go   = currStream->bits_to_go;
  237|      0|        currStream->stored_byte_pos   = currStream->byte_pos;
  238|      0|        currStream->stored_byte_buf   = currStream->byte_buf;
  239|       |
  240|      0|        if (input->symbol_mode ==CABAC)
  241|      0|        {
  242|      0|          eep = &(dataPart->ee_cabac);
  243|      0|          eep->ElowS            = eep->Elow;
  244|      0|          eep->ErangeS           = eep->Erange;
  245|      0|          eep->EbufferS         = eep->Ebuffer;
  246|      0|          eep->Ebits_to_goS     = eep->Ebits_to_go;
  247|      0|          eep->Ebits_to_followS = eep->Ebits_to_follow;
  248|      0|          eep->EcodestrmS       = eep->Ecodestrm;
  249|      0|          eep->Ecodestrm_lenS   = eep->Ecodestrm_len;
  250|      0|          eep->CS               = eep->C;
  251|      0|          eep->BS               = eep->B;
  252|      0|          eep->ES               = eep->E;
  253|      0|        }
  254|      0|      }
  255|      0|  }
  256|       |
  257|       |  // Save the slice number of this macroblock. When the macroblock below
  258|       |  // is coded it will use this to decide if prediction for above is possible
  259|   109k|  currMB->slice_nr = img->current_slice_nr;
  260|       |
  261|       |  // Initialize delta qp change from last macroblock. Feature may be used for future rate control
  262|       |  // Rate control
  263|   109k|  currMB->qpsp       = img->qpsp;
  264|   109k|  if(input->RCEnable)
  265|      0|  {
  266|      0|    int prev_mb = FmoGetPreviousMBNr(img->current_mb_nr);
  267|      0|    if (prev_mb>-1)
  268|      0|    {
  269|      0|      currMB->prev_qp = img->mb_data[prev_mb].qp;
  270|      0|      currMB->prev_delta_qp = img->mb_data[prev_mb].delta_qp;
  271|      0|    }
  272|      0|    else
  273|      0|    {
  274|      0|      currMB->prev_qp = curr_slice->qp;
  275|      0|      currMB->prev_delta_qp = 0;
  276|      0|    }
  277|       |    /*frame layer rate control*/
  278|      0|    if(input->basicunit==img->Frame_Total_Number_MB)
  279|      0|    {
  280|      0|      currMB->delta_qp = 0;
  281|      0|      currMB->qp       = img->qp;
  282|      0|    }
  283|       |/*basic unit layer rate control*/
  284|      0|    else
  285|      0|    {
  286|       |/*each I or B frame has only one QP*/
  287|      0|     if((img->type==I_SLICE)||(img->type==B_SLICE))
  288|      0|     {
  289|      0|       currMB->delta_qp = 0;
  290|      0|       currMB->qp       = img->qp;
  291|      0|     }
  292|      0|     else if(img->type==P_SLICE)
  293|      0|     {
  294|       |
  295|      0|       if (!img->write_macroblock) //write macroblock
  296|      0|       {
  297|      0|         if (!currMB->mb_field)  //frame macroblock
  298|      0|         {
  299|      0|           if (img->current_mb_nr == 0) //first macroblock
  300|      0|           {
  301|       |// Initialize delta qp change from last macroblock. Feature may be used for future rate control
  302|      0|             currMB->delta_qp = 0;
  303|      0|             currMB->qp       = img->qp;
  304|      0|             DELTA_QP = DELTA_QP2 = currMB->delta_qp;
  305|      0|             QP = QP2 = currMB->qp;
  306|      0|           }
  307|      0|           else
  308|      0|           {
  309|      0|             if (!((input->MbInterlace) && img->bot_MB)) //top macroblock
  310|      0|             {
  311|      0|               if (img->mb_data[img->current_mb_nr-1].prev_cbp == 1)
  312|      0|               {
  313|      0|                 currMB->delta_qp = 0;
  314|      0|                 currMB->qp       = img->qp;
  315|      0|               }
  316|      0|               else
  317|      0|               {
  318|      0|                 currMB->qp = img->mb_data[img->current_mb_nr-1].prev_qp;
  319|      0|                 currMB->delta_qp = currMB->qp - img->mb_data[img->current_mb_nr-1].qp;
  320|      0|                 img->qp = currMB->qp;
  321|      0|               }
  322|      0|               DELTA_QP = DELTA_QP2 = currMB->delta_qp;
  323|      0|               QP = QP2 = currMB->qp;
  324|      0|             }
  325|      0|             else //bottom macroblock
  326|      0|             {
  327|       |// Initialize delta qp change from last macroblock. Feature may be used for future rate control
  328|      0|               currMB->delta_qp = 0;
  329|      0|               currMB->qp       = img->qp;       // needed in loop filter (even if constant QP is used)
  330|      0|             }
  331|      0|           }
  332|      0|         }
  333|      0|         else  //field macroblock
  334|      0|         {
  335|      0|           if (!img->bot_MB) //top macroblock 
  336|      0|           {
  337|      0|             currMB->delta_qp = DELTA_QP2;
  338|      0|             currMB->qp   = img->qp    = QP2;
  339|      0|           }
  340|      0|           else//bottom macroblock
  341|      0|           {
  342|      0|             currMB->qp = img->qp;
  343|      0|             currMB->delta_qp = 0;
  344|      0|           }
  345|       |           
  346|      0|         }
  347|       |         
  348|      0|       }
  349|      0|       else 
  350|      0|       {
  351|      0|         if (!img->bot_MB) //write top macroblock
  352|      0|         {
  353|      0|           if (img->write_macroblock_frame)
  354|      0|           {
  355|      0|             currMB->delta_qp = DELTA_QP;
  356|      0|             img->qp = currMB->qp = QP;
  357|      0|           }
  358|      0|           else
  359|      0|           {
  360|      0|             currMB->delta_qp = DELTA_QP2;
  361|      0|             img->qp = currMB->qp = QP2;
  362|      0|           }
  363|      0|         }
  364|      0|         else //write bottom macroblock
  365|      0|         {
  366|      0|           currMB->delta_qp = 0;
  367|      0|           currMB->qp = img->qp;
  368|      0|         }
  369|      0|       }
  370|       |
  371|       |       /*compute the quantization parameter for each basic unit of P frame*/
  372|       |
  373|      0|       if(!((input->MbInterlace)&&img->bot_MB))
  374|      0|       {
  375|      0|         if(!currMB->mb_field)
  376|      0|         {
  377|       |           
  378|      0|           if((img->NumberofCodedMacroBlocks>0)\
  379|      0|             &&(img->NumberofCodedMacroBlocks%img->BasicUnit==0))
  380|      0|           {
  381|       |             
  382|       |             /*frame coding*/
  383|      0|             if(active_sps->frame_mbs_only_flag)
  384|      0|             {
  385|      0|               updateRCModel();
  386|      0|               img->BasicUnitQP=updateQuantizationParameter(img->TopFieldFlag);
  387|      0|             }
  388|       |             /*adaptive field/frame coding*/
  389|      0|             else if((input->PicInterlace==ADAPTIVE_CODING)&&(!input->MbInterlace)&&(img->IFLAG==0))
  390|      0|             {
  391|      0|               updateRCModel();
  392|      0|               img->BasicUnitQP=updateQuantizationParameter(img->TopFieldFlag);
  393|      0|             }
  394|       |             /*field coding*/
  395|      0|             else if((input->PicInterlace==FIELD_CODING)&&(!input->MbInterlace)&&(img->IFLAG==0))
  396|      0|             {
  397|      0|               updateRCModel();
  398|      0|               img->BasicUnitQP=updateQuantizationParameter(img->TopFieldFlag);
  399|      0|             }
  400|       |             /*mb adaptive f/f coding, field coding*/
  401|      0|             else if((input->MbInterlace)&&(img->IFLAG==0)&&(img->FieldControl==1))
  402|      0|             {
  403|      0|               updateRCModel();
  404|      0|               img->BasicUnitQP=updateQuantizationParameter(img->TopFieldFlag);
  405|      0|             }
  406|       |             /*mb adaptive f/f coding, frame coding*/
  407|      0|             else if((input->MbInterlace)&&(img->IFLAG==0)&&(img->FieldControl==0))
  408|      0|             {
  409|      0|               updateRCModel();
  410|      0|               img->BasicUnitQP=updateQuantizationParameter(img->TopFieldFlag);
  411|      0|             } 
  412|       |             
  413|       |             
  414|      0|           }
  415|       |           
  416|       |           
  417|      0|           if(img->current_mb_nr==0)
  418|      0|             img->BasicUnitQP=img->qp;
  419|       |
  420|      0|           currMB->predict_qp=img->BasicUnitQP;
  421|       |           
  422|      0|           if(currMB->predict_qp>currMB->qp + max_qp_delta)
  423|      0|             currMB->predict_qp=currMB->qp + max_qp_delta;
  424|      0|           else if(currMB->predict_qp<currMB->qp - min_qp_delta)
  425|      0|             currMB->predict_qp=currMB->qp - min_qp_delta; 
  426|       |           
  427|       |//           currMB->prev_qp = currMB->predict_qp;
  428|       |           
  429|      0|           dq = currMB->delta_qp + currMB->predict_qp-currMB->qp;
  430|      0|           if(dq < -min_qp_delta) 
  431|      0|           {
  432|      0|             dq = -min_qp_delta;
  433|      0|             predict_error = dq-currMB->delta_qp;
  434|      0|             img->qp = img->qp+predict_error;
  435|      0|             currMB->delta_qp = -min_qp_delta;
  436|      0|           }
  437|      0|           else if(dq > max_qp_delta)
  438|      0|           {
  439|      0|             dq = max_qp_delta;
  440|      0|             predict_error = dq - currMB->delta_qp;
  441|      0|             img->qp = img->qp + predict_error;
  442|      0|             currMB->delta_qp = max_qp_delta;
  443|      0|           }
  444|      0|           else
  445|      0|           {
  446|      0|             currMB->delta_qp = dq;
  447|      0|             predict_error=currMB->predict_qp-currMB->qp;
  448|      0|             img->qp = currMB->predict_qp;
  449|      0|           }
  450|      0|           currMB->qp =  img->qp;
  451|      0|           if (input->MbInterlace)
  452|      0|           {
  453|      0|             DELTA_QP = DELTA_QP2 = currMB->delta_qp;
  454|      0|             QP = QP2     = currMB->qp;
  455|      0|             DELTA_QP2 = currMB->delta_qp;
  456|      0|           }
  457|      0|           currMB->predict_error=predict_error;
  458|      0|         }
  459|      0|         else
  460|      0|           predict_error=currMB->predict_error;
  461|      0|       }
  462|      0|       else
  463|      0|         currMB->prev_qp=img->qp;
  464|      0|       }
  465|      0|    }   
  466|      0|  }
  467|   109k|  else
  468|   109k|  {
  469|   109k|    Slice* currSlice = img->currentSlice;
  470|       |  	
  471|   109k|    int prev_mb = FmoGetPreviousMBNr(img->current_mb_nr);
  472|   109k|    if (prev_mb>-1)
  473|   109k|    {
  474|   109k|      currMB->prev_qp = img->mb_data[prev_mb].qp;
  475|   109k|      currMB->prev_delta_qp = img->mb_data[prev_mb].delta_qp;
  476|   109k|    }
  477|    171|    else
  478|    171|    {
  479|    171|      currMB->prev_qp = currSlice->qp;
  480|    171|      currMB->prev_delta_qp = 0;
  481|    171|    }
  482|       |
  483|   109k|    currMB->qp       = currSlice->qp ;
  484|       |  
  485|   109k|    currMB->delta_qp = currMB->qp - currMB->prev_qp;
  486|   109k|    DELTA_QP = DELTA_QP2 = currMB->delta_qp;
  487|   109k|    QP = QP2 = currMB->qp;
  488|       |    
  489|   109k|  }
  490|       |  // Initialize counter for MB symbols
  491|   109k|  currMB->currSEnr=0;
  492|       |
  493|       |  // loop filter parameter
  494|   109k|  if (active_pps->deblocking_filter_control_present_flag)
  495|      0|  {
  496|      0|    currMB->LFDisableIdc    = img->LFDisableIdc;
  497|      0|    currMB->LFAlphaC0Offset = img->LFAlphaC0Offset;
  498|      0|    currMB->LFBetaOffset    = img->LFBetaOffset;
  499|      0|  }
  500|   109k|  else
  501|   109k|  {
  502|   109k|    currMB->LFDisableIdc    = 0;
  503|   109k|    currMB->LFAlphaC0Offset = 0;
  504|   109k|    currMB->LFBetaOffset    = 0;
  505|   109k|  }
  506|       |
  507|       |  // If MB is next to a slice boundary, mark neighboring blocks unavailable for prediction
  508|   109k|  CheckAvailabilityOfNeighbors();
  509|       |
  510|   109k|  if (input->symbol_mode == CABAC)
  511|   109k|    CheckAvailabilityOfNeighborsCABAC();
  512|       |  
  513|       |  // Reset vectors before doing motion search in motion_search().
  514|       |
  515|   328k|  for (l=0; l<2; l++)
  516|   218k|  {
  517|  1.09M|    for (j=0; j < BLOCK_MULTIPLE; j++)
  518|  4.37M|      for (i=0; i < BLOCK_MULTIPLE; i++)
  519|  10.5M|        for (k=0; k < 2; k++)
  520|  7.00M|          enc_picture->mv[l][img->block_x+i][img->block_y+j][k]=0;
  521|   218k|  }
  522|       |
  523|       |  //initialize reference index 
  524|   547k|  for (j=0; j < BLOCK_MULTIPLE; j++)
  525|   437k|  {
  526|  2.18M|    for (i=0; i < BLOCK_MULTIPLE; i++)
  527|  5.25M|      for (l=0; l<2; l++)
  528|  3.50M|      {
  529|  3.50M|        enc_picture->ref_idx[l][img->block_x+i][img->block_y + j] =-1;
  530|  3.50M|        enc_picture->ref_pic_id[l][img->block_x+i][img->block_y+j] = -1;
  531|  3.50M|      }
  532|   437k|    }
  533|       |  
  534|       |  // Reset syntax element entries in MB struct
  535|   109k|  currMB->mb_type   = 0;
  536|   109k|  currMB->cbp_blk   = 0;
  537|   109k|  currMB->cbp       = 0;
  538|       |
  539|   328k|  for (l=0; l < 2; l++)
  540|  1.09M|    for (j=0; j < BLOCK_MULTIPLE; j++)
  541|  4.37M|      for (i=0; i < BLOCK_MULTIPLE; i++)
  542|  10.5M|        for (k=0; k < 2; k++)
  543|  7.00M|          currMB->mvd[l][j][i][k] = 0;
  544|       | 
  545|   109k|  currMB->cbp_bits   = 0;
  546|   109k|  currMB->c_ipred_mode = DC_PRED_8; //GB
  547|       |
  548|  1.86M|  for (i=0; i < (BLOCK_MULTIPLE*BLOCK_MULTIPLE); i++)
  549|  1.75M|    currMB->intra_pred_modes[i] = DC_PRED;
  550|       |
  551|  1.86M|  for (i=0; i < 16; i++)
  552|  1.75M|    currMB->intra_pred_modes8x8[i] = DC_PRED;
  553|       |  
  554|       |  //initialize the whole MB as INTRA coded
  555|       |  //Blocks ar set to notINTRA in write_one_macroblock
  556|   109k|  if (input->UseConstrainedIntraPred)
  557|      0|  {
  558|      0|    img->intra_block[img->current_mb_nr] = 1;
  559|      0|  }
  560|       |
  561|       |  // store filtering parameters for this MB; For now, we are using the
  562|       |  // same offset throughout the sequence
  563|   109k|  currMB->lf_disable = img->LFDisableIdc;
  564|   109k|  currMB->lf_alpha_c0_offset = img->LFAlphaC0Offset;
  565|   109k|  currMB->lf_beta_offset = img->LFBetaOffset;
  566|       |
  567|       |
  568|       |  // Initialize bitcounters for this macroblock
  569|   109k|  if(img->current_mb_nr == 0) // No slice header to account for
  570|    171|  {
  571|    171|    currMB->bitcounter[BITS_HEADER] = 0;
  572|    171|  }
  573|   109k|  else if (currMB->slice_nr == img->mb_data[img->current_mb_nr-1].slice_nr) // current MB belongs to the
  574|       |  // same slice as the last MB
  575|   109k|  {
  576|   109k|    currMB->bitcounter[BITS_HEADER] = 0;
  577|   109k|  }
  578|       |
  579|   109k|  currMB->bitcounter[BITS_MB_MODE] = 0;
  580|   109k|  currMB->bitcounter[BITS_COEFF_Y_MB] = 0;
  581|   109k|  currMB->bitcounter[BITS_INTER_MB] = 0;
  582|   109k|  currMB->bitcounter[BITS_CBP_MB] = 0;
  583|   109k|  currMB->bitcounter[BITS_DELTA_QUANT_MB] = 0;
  584|   109k|  currMB->bitcounter[BITS_COEFF_UV_MB] = 0;
  585|       |
  586|   109k|#ifdef _FAST_FULL_ME_
  587|   109k|  if(!input->FMEnable)
  588|   109k|    ResetFastFullIntegerSearch ();
  589|   109k|#endif
  590|   109k|}
  591|       |
  592|       |/*!
  593|       | ************************************************************************
  594|       | * \brief
  595|       | *    terminates processing of the current macroblock depending
  596|       | *    on the chosen slice mode
  597|       | ************************************************************************
  598|       | */
  599|       |void terminate_macroblock(Boolean *end_of_slice, Boolean *recode_macroblock)
  600|   109k|{
  601|   109k|  int i;
  602|   109k|  Slice *currSlice = img->currentSlice;
  603|   109k|  Macroblock    *currMB    = &img->mb_data[img->current_mb_nr];
  604|   109k|  SyntaxElement *currSE    = &img->MB_SyntaxElements[currMB->currSEnr];
  605|   109k|  int *partMap = assignSE2partition[input->partition_mode];
  606|   109k|  DataPartition *dataPart;
  607|   109k|  Bitstream *currStream;
  608|   109k|  int rlc_bits=0;
  609|   109k|  EncodingEnvironmentPtr eep;
  610|   109k|  int use_bitstream_backing = (input->slice_mode == FIXED_RATE || input->slice_mode == CALLBACK);
  611|   109k|  int new_slice;
  612|   109k|  static int skip = FALSE;
  613|       |
  614|       |	 
  615|       |  // if previous mb in the same slice group has different slice number as the current, it's the
  616|       |  // the start of new slice
  617|   109k|  new_slice=0;
  618|   109k|  if ( (img->current_mb_nr==0) || (FmoGetPreviousMBNr(img->current_mb_nr)<0) )
  619|    171|    new_slice=1;
  620|   109k|  else if( img->mb_data[FmoGetPreviousMBNr(img->current_mb_nr)].slice_nr != img->current_slice_nr )
  621|      0|    new_slice=1;
  622|       |	
  623|       |  
  624|   109k|  *recode_macroblock=FALSE;
  625|       |
  626|   109k|  switch(input->slice_mode)
  627|   109k|  {
  628|   109k|  case NO_SLICES:
  629|   109k|    currSlice->num_mb++;
  630|   109k|    *recode_macroblock = FALSE;
  631|   109k|    if ((currSlice->num_mb) == img->total_number_mb) // maximum number of MBs reached
  632|    171|      *end_of_slice = TRUE;
  633|       |
  634|       |    // if it's end of current slice group, slice ends too
  635|   109k|    *end_of_slice |= (img->current_mb_nr == FmoGetLastCodedMBOfSliceGroup (FmoMB2SliceGroup (img->current_mb_nr)));
  636|       |		
  637|   109k|    break;
  638|      0|  case FIXED_MB:
  639|       |    // For slice mode one, check if a new slice boundary follows
  640|      0|    currSlice->num_mb++;
  641|      0|    *recode_macroblock = FALSE;
  642|       |    //! Check end-of-slice group condition first
  643|      0|    *end_of_slice = (img->current_mb_nr == FmoGetLastCodedMBOfSliceGroup (FmoMB2SliceGroup (img->current_mb_nr)));
  644|       |    //! Now check maximum # of MBs in slice
  645|      0|    *end_of_slice |= (currSlice->num_mb >= input->slice_argument);
  646|       |		
  647|      0|    break;
  648|       |
  649|       |    // For slice modes two and three, check if coding of this macroblock
  650|       |    // resulted in too many bits for this slice. If so, indicate slice
  651|       |    // boundary before this macroblock and code the macroblock again
  652|      0|  case FIXED_RATE:
  653|       |     // in case of skip MBs check if there is a slice boundary
  654|       |     // only for UVLC (img->cod_counter is always 0 in case of CABAC)
  655|      0|     if(img->cod_counter)
  656|      0|     {
  657|       |       // write out the skip MBs to know how many bits we need for the RLC
  658|      0|       currSE->value1 = img->cod_counter;
  659|      0|       currSE->value2 = 0;
  660|      0|       currSE->mapping = ue_linfo;
  661|      0|       currSE->type = SE_MBTYPE;
  662|      0|       dataPart = &(currSlice->partArr[partMap[currSE->type]]);
  663|       |
  664|      0|       dataPart->writeSyntaxElement(  currSE, dataPart);
  665|      0|       rlc_bits=currSE->len;
  666|       |
  667|      0|       currStream = dataPart->bitstream;
  668|       |       // save the bitstream as it would be if we write the skip MBs
  669|      0|       currStream->bits_to_go_skip  = currStream->bits_to_go;
  670|      0|       currStream->byte_pos_skip    = currStream->byte_pos;
  671|      0|       currStream->byte_buf_skip    = currStream->byte_buf;
  672|       |       // restore the bitstream
  673|      0|       currStream->bits_to_go = currStream->stored_bits_to_go;
  674|      0|       currStream->byte_pos = currStream->stored_byte_pos;
  675|      0|       currStream->byte_buf = currStream->stored_byte_buf;
  676|      0|       skip = TRUE;
  677|      0|     }
  678|       |     //! Check if the last coded macroblock fits into the size of the slice
  679|       |     //! But only if this is not the first macroblock of this slice
  680|      0|     if (!new_slice)
  681|      0|     {
  682|      0|       if(slice_too_big(rlc_bits))
  683|      0|       {
  684|      0|         *recode_macroblock = TRUE;
  685|      0|         *end_of_slice = TRUE;
  686|      0|       }
  687|      0|       else if(!img->cod_counter)
  688|      0|         skip = FALSE;
  689|      0|     }
  690|       |     // maximum number of MBs
  691|       |		 
  692|       |     // check if current slice group is finished
  693|      0|     if ((*recode_macroblock == FALSE) && (img->current_mb_nr == FmoGetLastCodedMBOfSliceGroup (FmoMB2SliceGroup (img->current_mb_nr)))) 
  694|      0|     {
  695|      0|       *end_of_slice = TRUE;
  696|      0|       if(!img->cod_counter)
  697|      0|         skip = FALSE;
  698|      0|     }
  699|       |   
  700|       |     //! (first MB OR first MB in a slice) AND bigger that maximum size of slice
  701|      0|     if (new_slice && slice_too_big(rlc_bits))
  702|      0|     {
  703|      0|       *end_of_slice = TRUE;
  704|      0|       if(!img->cod_counter)
  705|      0|         skip = FALSE;
  706|      0|     }
  707|      0|     if (!*recode_macroblock)
  708|      0|       currSlice->num_mb++;
  709|      0|     break;
  710|       |
  711|      0|  case  CALLBACK:
  712|      0|    if (img->current_mb_nr > 0 && !new_slice)
  713|      0|    {
  714|      0|      if (currSlice->slice_too_big(rlc_bits))
  715|      0|      {
  716|      0|        *recode_macroblock = TRUE;
  717|      0|        *end_of_slice = TRUE;
  718|      0|      }
  719|      0|    }
  720|       |
  721|      0|    if ( (*recode_macroblock == FALSE) && (img->current_mb_nr == FmoGetLastCodedMBOfSliceGroup (FmoMB2SliceGroup (img->current_mb_nr)))) 
  722|      0|      *end_of_slice = TRUE;
  723|      0|    break;
  724|       |
  725|      0|  default:
  726|      0|    snprintf(errortext, ET_SIZE, "Slice Mode %d not supported", input->slice_mode);
  727|      0|    error(errortext, 600);
  728|   109k|  }
  729|       |
  730|   109k|  if(*recode_macroblock == TRUE)
  731|      0|  {
  732|       |    // Restore everything
  733|      0|    for (i=0; i<currSlice->max_part_nr; i++)
  734|      0|    {
  735|      0|      dataPart = &(currSlice->partArr[i]);
  736|      0|      currStream = dataPart->bitstream;
  737|      0|      currStream->bits_to_go = currStream->stored_bits_to_go;
  738|      0|      currStream->byte_pos  = currStream->stored_byte_pos;
  739|      0|      currStream->byte_buf  = currStream->stored_byte_buf;
  740|      0|      if (input->symbol_mode == CABAC)
  741|      0|      {
  742|      0|        eep = &(dataPart->ee_cabac);
  743|      0|        eep->Elow            = eep->ElowS;
  744|      0|        eep->Erange           = eep->ErangeS;
  745|      0|        eep->Ebuffer         = eep->EbufferS;
  746|      0|        eep->Ebits_to_go     = eep->Ebits_to_goS;
  747|      0|        eep->Ebits_to_follow = eep->Ebits_to_followS;
  748|      0|        eep->Ecodestrm       = eep->EcodestrmS;
  749|      0|        eep->Ecodestrm_len   = eep->Ecodestrm_lenS;
  750|      0|        eep->C               = eep->CS;
  751|      0|        eep->B               = eep->BS;
  752|      0|        eep->E               = eep->ES;       
  753|      0|      }
  754|      0|    }
  755|      0|  }
  756|       |
  757|   109k|  if(*end_of_slice == TRUE  && skip == TRUE) //! TO 4.11.2001 Skip MBs at the end of this slice
  758|      0|  { 
  759|       |    //! only for Slice Mode 2 or 3
  760|       |    // If we still have to write the skip, let's do it!
  761|      0|    if(img->cod_counter && *recode_macroblock == TRUE) //! MB that did not fit in this slice
  762|      0|    { 
  763|       |      // If recoding is true and we have had skip, 
  764|       |      // we have to reduce the counter in case of recoding
  765|      0|      img->cod_counter--;
  766|      0|      if(img->cod_counter)
  767|      0|      {
  768|      0|        currSE->value1 = img->cod_counter;
  769|      0|        currSE->value2 = 0;
  770|      0|        currSE->mapping = ue_linfo;
  771|      0|        currSE->type = SE_MBTYPE;
  772|      0|        dataPart = &(currSlice->partArr[partMap[currSE->type]]);
  773|      0|        dataPart->writeSyntaxElement(  currSE, dataPart);
  774|      0|        rlc_bits=currSE->len;
  775|      0|        currMB->bitcounter[BITS_MB_MODE]+=rlc_bits;
  776|      0|        img->cod_counter = 0;
  777|      0|      }
  778|      0|    }
  779|      0|    else //! MB that did not fit in this slice anymore is not a Skip MB
  780|      0|    {
  781|      0|      dataPart = &(currSlice->partArr[partMap[SE_MBTYPE]]);       
  782|      0|      currStream = dataPart->bitstream;
  783|       |        // update the bitstream
  784|      0|      currStream->bits_to_go = currStream->bits_to_go_skip;
  785|      0|      currStream->byte_pos  = currStream->byte_pos_skip;
  786|      0|      currStream->byte_buf  = currStream->byte_buf_skip;
  787|       |
  788|       |      // update the statistics
  789|      0|      img->cod_counter = 0;
  790|      0|      skip = FALSE;
  791|      0|    }
  792|      0|  }
  793|       |  
  794|       |  //! TO 4.11.2001 Skip MBs at the end of this slice for Slice Mode 0 or 1
  795|   109k|  if(*end_of_slice == TRUE && img->cod_counter && !use_bitstream_backing)
  796|      0|  {
  797|      0|    currSE->value1 = img->cod_counter;
  798|      0|    currSE->value2 = 0;
  799|      0|    currSE->mapping = ue_linfo;
  800|      0|    currSE->type = SE_MBTYPE;
  801|      0|    dataPart = &(currSlice->partArr[partMap[currSE->type]]);
  802|      0|    dataPart->writeSyntaxElement(  currSE, dataPart);
  803|      0|     currMB->currSEnr ++;
  804|       |#if TRACE
  805|       |    snprintf(currSE->tracestring, TRACESTRING_SIZE, "Final MB runlength = %3d",img->cod_counter); 
  806|       |#endif
  807|       |   
  808|      0|    rlc_bits=currSE->len;
  809|      0|    currMB->bitcounter[BITS_MB_MODE]+=rlc_bits;
  810|      0|    img->cod_counter = 0;
  811|      0|  }
  812|   109k|}
  813|       |
  814|       |/*!
  815|       | *****************************************************************************
  816|       | *
  817|       | * \brief 
  818|       | *    For Slice Mode 2: Checks if one partition of one slice exceeds the 
  819|       | *    allowed size
  820|       | * 
  821|       | * \return
  822|       | *    FALSE if all Partitions of this slice are smaller than the allowed size
  823|       | *    TRUE is at least one Partition exceeds the limit
  824|       | *
  825|       | * \par Side effects
  826|       | *    none
  827|       | *
  828|       | * \date
  829|       | *    4 November 2001
  830|       | *
  831|       | * \author
  832|       | *    Tobias Oelbaum      drehvial@gmx.net
  833|       | *****************************************************************************/
  834|       | 
  835|       | int slice_too_big(int rlc_bits)
  836|      0| {
  837|      0|   Slice *currSlice = img->currentSlice;
  838|      0|   DataPartition *dataPart;
  839|      0|   Bitstream *currStream;
  840|      0|   EncodingEnvironmentPtr eep;
  841|      0|   int i;
  842|      0|   int size_in_bytes;
  843|       |  
  844|       |   //! UVLC
  845|      0|   if (input->symbol_mode == UVLC)
  846|      0|   {
  847|      0|     for (i=0; i<currSlice->max_part_nr; i++)
  848|      0|     {
  849|      0|       dataPart = &(currSlice->partArr[i]);
  850|      0|       currStream = dataPart->bitstream;
  851|      0|       size_in_bytes = currStream->byte_pos /*- currStream->tmp_byte_pos*/;
  852|       |
  853|      0|       if (currStream->bits_to_go < 8)
  854|      0|         size_in_bytes++;
  855|      0|       if (currStream->bits_to_go < rlc_bits)
  856|      0|         size_in_bytes++;
  857|      0|       if(size_in_bytes > input->slice_argument)
  858|      0|         return TRUE;
  859|      0|     }
  860|      0|   }
  861|       |    
  862|       |   //! CABAC
  863|      0|   if (input->symbol_mode ==CABAC)
  864|      0|   {
  865|      0|     for (i=0; i<currSlice->max_part_nr; i++)
  866|      0|     {
  867|      0|        dataPart= &(currSlice->partArr[i]);
  868|      0|        eep = &(dataPart->ee_cabac);
  869|       |      
  870|      0|       if( arienco_bits_written(eep) > (input->slice_argument*8))
  871|      0|          return TRUE;
  872|      0|     }
  873|      0|   }
  874|      0|   return FALSE;
  875|      0| }
  876|       |
  877|       |/*!
  878|       | ************************************************************************
  879|       | * \brief
  880|       | *    Predict one component of a 4x4 Luma block
  881|       | ************************************************************************
  882|       | */
  883|       |void
  884|       |OneComponentLumaPrediction4x4 (int*   mpred,      //  --> array of prediction values (row by row)
  885|       |                               int    pic_pix_x,  // <--  absolute horizontal coordinate of 4x4 block
  886|       |                               int    pic_pix_y,  // <--  absolute vertical   coordinate of 4x4 block
  887|       |                               short* mv,         // <--  motion vector
  888|       |                               short  ref,        // <--  reference frame 
  889|       |                               StorablePicture **list)
  890|  30.7M|{
  891|  30.7M|  pel_t** ref_pic;
  892|  30.7M|  int     pix_add = 4;
  893|  30.7M|  int     j0      = (pic_pix_y << 2) + mv[1], j1=j0+pix_add, j2=j1+pix_add, j3=j2+pix_add;
  894|  30.7M|  int     i0      = (pic_pix_x << 2) + mv[0], i1=i0+pix_add, i2=i1+pix_add, i3=i2+pix_add;
  895|       |  
  896|  30.7M|  pel_t (*get_pel) (pel_t**, int, int, int, int) = UMVPelY_14;
  897|       |
  898|  30.7M|  int img_width =list[ref]->size_x;
  899|  30.7M|  int img_height=list[ref]->size_y;
  900|       |
  901|  30.7M|  ref_pic   = list[ref]->imgY_ups;
  902|       |  
  903|  30.7M|  *mpred++ = get_pel (ref_pic, j0, i0, img_height, img_width);
  904|  30.7M|  *mpred++ = get_pel (ref_pic, j0, i1, img_height, img_width);
  905|  30.7M|  *mpred++ = get_pel (ref_pic, j0, i2, img_height, img_width);
  906|  30.7M|  *mpred++ = get_pel (ref_pic, j0, i3, img_height, img_width);
  907|  30.7M|  *mpred++ = get_pel (ref_pic, j1, i0, img_height, img_width);
  908|  30.7M|  *mpred++ = get_pel (ref_pic, j1, i1, img_height, img_width);
  909|  30.7M|  *mpred++ = get_pel (ref_pic, j1, i2, img_height, img_width);
  910|  30.7M|  *mpred++ = get_pel (ref_pic, j1, i3, img_height, img_width);
  911|  30.7M|  *mpred++ = get_pel (ref_pic, j2, i0, img_height, img_width);
  912|  30.7M|  *mpred++ = get_pel (ref_pic, j2, i1, img_height, img_width);
  913|  30.7M|  *mpred++ = get_pel (ref_pic, j2, i2, img_height, img_width);
  914|  30.7M|  *mpred++ = get_pel (ref_pic, j2, i3, img_height, img_width);
  915|  30.7M|  *mpred++ = get_pel (ref_pic, j3, i0, img_height, img_width);
  916|  30.7M|  *mpred++ = get_pel (ref_pic, j3, i1, img_height, img_width);
  917|  30.7M|  *mpred++ = get_pel (ref_pic, j3, i2, img_height, img_width);
  918|  30.7M|  *mpred++ = get_pel (ref_pic, j3, i3, img_height, img_width);
  919|       |
  920|  30.7M|}
  921|       |
  922|       |/*!
  923|       | ************************************************************************
  924|       | * \brief
  925|       | *    copy foward/backward prediction values of one component of a 4x4 Luma block
  926|       | ************************************************************************
  927|       | */
  928|       |
  929|       |void
  930|       |copyblock4x4 (int*   mpred,      //  --> array of prediction values (row by row)
  931|       |              int block[BLOCK_SIZE][BLOCK_SIZE])        
  932|      0|{
  933|      0|  *mpred++ = block[0][0];
  934|      0|  *mpred++ = block[1][0];
  935|      0|  *mpred++ = block[2][0];
  936|      0|  *mpred++ = block[3][0];
  937|      0|  *mpred++ = block[0][1];
  938|      0|  *mpred++ = block[1][1];
  939|      0|  *mpred++ = block[2][1];
  940|      0|  *mpred++ = block[3][1];
  941|      0|  *mpred++ = block[0][2];
  942|      0|  *mpred++ = block[1][2];
  943|      0|  *mpred++ = block[2][2];
  944|      0|  *mpred++ = block[3][2];
  945|      0|  *mpred++ = block[0][3];
  946|      0|  *mpred++ = block[1][3];
  947|      0|  *mpred++ = block[2][3];
  948|      0|  *mpred++ = block[3][3];
  949|      0|}
  950|       |
  951|       |/*!
  952|       | ************************************************************************
  953|       | * \brief
  954|       | *    Predict one 4x4 Luma block
  955|       | ************************************************************************
  956|       | */
  957|       |void
  958|       |LumaPrediction4x4 (int   block_x,    // <--  relative horizontal block coordinate of 4x4 block
  959|       |                   int   block_y,    // <--  relative vertical   block coordinate of 4x4 block
  960|       |                   int   p_dir,      // <--  prediction direction (0=forward, 1=backward, 2=bidir)
  961|       |                   int   fw_mode,    // <--  forward  prediction mode (1-7, 0=DIRECT if bw_mode=0)
  962|       |                   int   bw_mode,    // <--  backward prediction mode (1-7, 0=DIRECT if fw_mode=0)
  963|       |                   short fw_ref_idx, // <--  reference frame for forward prediction (-1: Intra4x4 pred. with fw_mode)
  964|       |                   short bw_ref_idx  )    
  965|  21.9M|{
  966|  21.9M|  static int fw_pred[16];
  967|  21.9M|  static int bw_pred[16];
  968|       |
  969|  21.9M|  int  i, j;
  970|  21.9M|  int  block_x4  = block_x+4;
  971|  21.9M|  int  block_y4  = block_y+4;
  972|  21.9M|  int  pic_opix_x = img->opix_x + block_x;
  973|  21.9M|  int  pic_opix_y = img->opix_y + block_y;
  974|  21.9M|  int  bx        = block_x >> 2;
  975|  21.9M|  int  by        = block_y >> 2;
  976|  21.9M|  int* fpred     = fw_pred;
  977|  21.9M|  int* bpred     = bw_pred;
  978|  21.9M|  Macroblock*    currMB     = &img->mb_data[img->current_mb_nr];
  979|       |
  980|  21.9M|  int  apply_weights = ( (active_pps->weighted_pred_flag && (img->type== P_SLICE || img->type == SP_SLICE)) ||
  981|  21.9M|                         (active_pps->weighted_bipred_idc && (img->type== B_SLICE)));  
  982|  21.9M|  short****** mv_array = img->all_mv;
  983|       |
  984|  21.9M|  int  list_offset   = ((img->MbaffFrameFlag)&&(currMB->mb_field))? img->current_mb_nr%2 ? 4 : 2 : 0;
  985|       |
  986|  21.9M|#if BI_PREDICTION
  987|  21.9M|  if (currMB->bi_pred_me && fw_ref_idx == 0 && bw_ref_idx == 0 && p_dir == 2 && fw_mode==1 && bw_mode==1)
  988|      0|  {
  989|      0|    mv_array = currMB->bi_pred_me == 1? img->bipred_mv1 : img->bipred_mv2 ;
  990|      0|  }
  991|  21.9M|#endif
  992|       |
  993|  21.9M|  if ((p_dir==0)||(p_dir==2))
  994|  17.5M|  {
  995|  17.5M|    OneComponentLumaPrediction4x4 (fw_pred, pic_opix_x, pic_opix_y, mv_array[bx][by][LIST_0][fw_ref_idx][fw_mode], fw_ref_idx, listX[0+list_offset]);   
  996|  17.5M|  }
  997|       |
  998|  21.9M|  if ((p_dir==1)||(p_dir==2))
  999|  13.2M|  { 
 1000|  13.2M|    OneComponentLumaPrediction4x4 (bw_pred, pic_opix_x, pic_opix_y, mv_array[bx][by][LIST_1][bw_ref_idx][bw_mode], bw_ref_idx, listX[1+list_offset]);   
 1001|  13.2M|  }
 1002|       |
 1003|  21.9M|  if (apply_weights)
 1004|      0|  {
 1005|       |
 1006|      0|    if (p_dir==2)
 1007|      0|    {
 1008|      0|      for   (j=block_y; j<block_y4; j++)
 1009|      0|        for (i=block_x; i<block_x4; i++)  
 1010|      0|          img->mpr[i][j] = clip1a(((wbp_weight[0][fw_ref_idx][bw_ref_idx][0] * *fpred++ + 
 1011|      0|                                    wbp_weight[1][fw_ref_idx][bw_ref_idx][0] * *bpred++ + 
 1012|      0|                                    2*wp_luma_round) >> (luma_log_weight_denom + 1)) + 
 1013|      0|                                    ((wp_offset[0][fw_ref_idx][0] + wp_offset[1][bw_ref_idx][0] + 1)>>1)); 
 1014|      0|    }
 1015|      0|    else if (p_dir==0)
 1016|      0|    {
 1017|      0|      for   (j=block_y; j<block_y4; j++)
 1018|      0|        for (i=block_x; i<block_x4; i++)  
 1019|      0|          img->mpr[i][j] = clip1a(((wp_weight[0][fw_ref_idx][0] * *fpred++  + wp_luma_round) >> luma_log_weight_denom) +
 1020|      0|                                    wp_offset[0][fw_ref_idx][0] );
 1021|      0|    }
 1022|      0|    else // p_dir==1
 1023|      0|    {
 1024|      0|      for   (j=block_y; j<block_y4; j++)
 1025|      0|        for (i=block_x; i<block_x4; i++)  
 1026|      0|          img->mpr[i][j] = clip1a(((wp_weight[1][bw_ref_idx][0] * *bpred++  + wp_luma_round) >> luma_log_weight_denom) +
 1027|      0|                                    wp_offset[1][bw_ref_idx][0] );
 1028|      0|    }
 1029|       |
 1030|       |
 1031|      0|  }
 1032|  21.9M|  else
 1033|  21.9M|  {
 1034|  21.9M|    if (p_dir==2)
 1035|  8.78M|    {
 1036|  43.9M|      for   (j=block_y; j<block_y4; j++)
 1037|   175M|        for (i=block_x; i<block_x4; i++)  
 1038|   140M|          img->mpr[i][j] = (*fpred++ + *bpred++ + 1) / 2; 
 1039|  8.78M|    }
 1040|  13.1M|    else if (p_dir==0)
 1041|  8.72M|    {
 1042|  43.6M|      for   (j=block_y; j<block_y4; j++)
 1043|   174M|        for (i=block_x; i<block_x4; i++)  img->mpr[i][j] = *fpred++;
 1044|  8.72M|    }
 1045|  4.44M|    else // p_dir==1
 1046|  4.44M|    {
 1047|  22.2M|      for   (j=block_y; j<block_y4; j++)
 1048|  88.9M|        for (i=block_x; i<block_x4; i++)  img->mpr[i][j] = *bpred++;
 1049|  4.44M|    }
 1050|  21.9M|  }
 1051|  21.9M|}
 1052|       |#if BI_PREDICTION
 1053|       |/*!
 1054|       |************************************************************************
 1055|       |* \brief
 1056|       |*    Predict one 4x4 Luma block
 1057|       |************************************************************************
 1058|       |*/
 1059|       |void
 1060|       |LumaPrediction4x4Bi (int  block_x,    // <--  relative horizontal block coordinate of 4x4 block
 1061|       |                   int  block_y,    // <--  relative vertical   block coordinate of 4x4 block
 1062|       |                   int  p_dir,      // <--  prediction direction (0=forward, 1=backward, 2=bidir)
 1063|       |                   int  fw_mode,    // <--  forward  prediction mode (1-7, 0=DIRECT if bw_mode=0)
 1064|       |                   int  bw_mode,    // <--  backward prediction mode (1-7, 0=DIRECT if fw_mode=0)
 1065|       |                   short  fw_ref_idx, // <--  reference frame for forward prediction (-1: Intra4x4 pred. with fw_mode)
 1066|       |                   short  bw_ref_idx,
 1067|       |                   int  list)    
 1068|      0|{
 1069|      0|  static int fw_pred[16];
 1070|      0|  static int bw_pred[16];
 1071|       |
 1072|      0|  int  i, j;
 1073|      0|  int  block_x4  = block_x+4;
 1074|      0|  int  block_y4  = block_y+4;
 1075|      0|  int  pic_opix_x = img->opix_x + block_x;
 1076|      0|  int  pic_opix_y = img->opix_y + block_y;
 1077|      0|  int  bx        = block_x >> 2;
 1078|      0|  int  by        = block_y >> 2;
 1079|      0|  int* fpred     = fw_pred;
 1080|      0|  int* bpred     = bw_pred;
 1081|      0|  Macroblock*    currMB     = &img->mb_data[img->current_mb_nr];
 1082|       |
 1083|       |   
 1084|      0|  int  apply_weights = ( (active_pps->weighted_pred_flag && (img->type == P_SLICE || img->type == SP_SLICE)) ||
 1085|      0|                         (active_pps->weighted_bipred_idc && (img->type == B_SLICE)));  
 1086|       |
 1087|      0|  int  list_offset   = ((img->MbaffFrameFlag)&&(currMB->mb_field))? img->current_mb_nr%2 ? 4 : 2 : 0;
 1088|       |
 1089|      0|  short   ******bipred_mv = list ? img->bipred_mv1 : img->bipred_mv2;
 1090|       |
 1091|      0|  if ((p_dir==0)||(p_dir==2))
 1092|      0|  {
 1093|       |      //OneComponentLumaPrediction4x4 (fw_pred, pic_opix_x, pic_opix_y, bipred_mv[bx][by][LIST_0][fw_ref_idx][fw_mode], fw_ref_idx, listX[0+list_offset]);   
 1094|      0|      OneComponentLumaPrediction4x4 (fw_pred, pic_opix_x, pic_opix_y, bipred_mv[bx][by][LIST_0][fw_ref_idx][fw_mode], fw_ref_idx, listX[0+list_offset]);   
 1095|      0|  }
 1096|       |
 1097|      0|  if ((p_dir==1)||(p_dir==2))
 1098|      0|  { 
 1099|      0|      OneComponentLumaPrediction4x4 (bw_pred, pic_opix_x, pic_opix_y, bipred_mv[bx][by][LIST_1][bw_ref_idx][bw_mode], bw_ref_idx, listX[1+list_offset]);   
 1100|      0|  }
 1101|       |
 1102|      0|  if (apply_weights)
 1103|      0|  {
 1104|      0|    if (p_dir==2)
 1105|      0|    {
 1106|      0|      for   (j=block_y; j<block_y4; j++)
 1107|      0|        for (i=block_x; i<block_x4; i++)  
 1108|      0|          img->mpr[i][j] = clip1a(((wbp_weight[0][fw_ref_idx][bw_ref_idx][0] * *fpred++ + 
 1109|      0|                                    wbp_weight[1][fw_ref_idx][bw_ref_idx][0] * *bpred++ + 
 1110|      0|                                    2*wp_luma_round) >> (luma_log_weight_denom + 1)) + 
 1111|      0|                                    ((wp_offset[0][fw_ref_idx][0] + wp_offset[1][bw_ref_idx][0] + 1)>>1)); 
 1112|      0|    }
 1113|      0|    else if (p_dir==0)
 1114|      0|    {
 1115|      0|      for   (j=block_y; j<block_y4; j++)
 1116|      0|        for (i=block_x; i<block_x4; i++)                   
 1117|      0|          img->mpr[i][j] = clip1a(((wp_weight[0][fw_ref_idx][0] * *fpred++  + wp_luma_round) >> luma_log_weight_denom) +
 1118|      0|          + wp_offset[0][fw_ref_idx][0] );        
 1119|      0|    }
 1120|      0|    else // p_dir==1
 1121|      0|    {
 1122|      0|      for   (j=block_y; j<block_y4; j++)
 1123|      0|        for (i=block_x; i<block_x4; i++)  
 1124|      0|          img->mpr[i][j] = clip1a(((wp_weight[1][bw_ref_idx][0] * *bpred++  + wp_luma_round) >> luma_log_weight_denom) +
 1125|      0|          wp_offset[1][bw_ref_idx][0] );
 1126|      0|    }
 1127|      0|  }
 1128|      0|  else
 1129|      0|  {
 1130|      0|    if (p_dir==2)
 1131|      0|    {
 1132|      0|      for   (j=block_y; j<block_y4; j++)
 1133|      0|        for (i=block_x; i<block_x4; i++)  
 1134|      0|          img->mpr[i][j] = (*fpred++ + *bpred++ + 1) / 2; 
 1135|      0|    }
 1136|      0|    else if (p_dir==0)
 1137|      0|    {
 1138|      0|      for   (j=block_y; j<block_y4; j++)
 1139|      0|        for (i=block_x; i<block_x4; i++)  img->mpr[i][j] = *fpred++;
 1140|      0|    }
 1141|      0|    else // p_dir==1
 1142|      0|    {
 1143|      0|      for   (j=block_y; j<block_y4; j++)
 1144|      0|        for (i=block_x; i<block_x4; i++)  img->mpr[i][j] = *bpred++;
 1145|      0|    }
 1146|      0|  }
 1147|      0|}
 1148|       |#endif
 1149|       |
 1150|       |
 1151|       |/*!
 1152|       | ************************************************************************
 1153|       | * \brief
 1154|       | *    Residual Coding of an 8x8 Luma block (not for intra)
 1155|       | ************************************************************************
 1156|       | */
 1157|       |int                                       //  ==> coefficient cost
 1158|       |LumaResidualCoding8x8 (int   *cbp,         //  --> cbp (updated according to processed 8x8 luminance block)
 1159|       |                       int64 *cbp_blk,     //  --> block cbp (updated according to processed 8x8 luminance block)
 1160|       |                       int   block8x8,     // <--  block number of 8x8 block
 1161|       |                       short p_dir,        // <--  prediction direction
 1162|       |                       int   fw_mode,      // <--  forward  prediction mode (1-7, 0=DIRECT)
 1163|       |                       int   bw_mode,      // <--  backward prediction mode (1-7, 0=DIRECT)
 1164|       |                       short fw_refframe,  // <--  reference frame for forward prediction
 1165|       |                       short bw_refframe   // <--  reference frame for backward prediction
 1166|       |                       )
 1167|  3.96M|{
 1168|  3.96M|  int    block_y, block_x, pic_pix_y, pic_pix_x, i, j, nonzero = 0, cbp_blk_mask;
 1169|  3.96M|  int    coeff_cost = 0;
 1170|  3.96M|  int    mb_y       = (block8x8 / 2) << 3;
 1171|  3.96M|  int    mb_x       = (block8x8 % 2) << 3;
 1172|  3.96M|  int    cbp_mask   = 1 << block8x8;
 1173|  3.96M|  int    bxx, byy;                   // indexing curr_blk
 1174|  3.96M|  int    scrFlag = 0;                // 0=noSCR, 1=strongSCR, 2=jmSCR
 1175|  3.96M|  int    skipped    = (fw_mode == 0 && bw_mode == 0 && (img->type != B_SLICE));
 1176|  3.96M|  Macroblock* currMB      = &img->mb_data[img->current_mb_nr];
 1177|       |  //set transform size
 1178|  3.96M|  int    need_8x8_transform = currMB->luma_transform_size_8x8_flag;
 1179|       |  // Residue Color Transform
 1180|  3.96M|  int residue_R, residue_G, residue_B, temp;
 1181|       |
 1182|  3.96M|  if (img->type==B_SLICE)
 1183|  2.79M|    scrFlag = 1;
 1184|       |
 1185|       |  //===== loop over 4x4 blocks =====
 1186|  11.9M|  for (byy=0, block_y=mb_y; block_y<mb_y+8; byy+=4, block_y+=4)
 1187|  7.93M|  {
 1188|  7.93M|    pic_pix_y = img->opix_y + block_y;
 1189|       |
 1190|  23.8M|    for (bxx=0, block_x=mb_x; block_x<mb_x+8; bxx+=4, block_x+=4)
 1191|  15.8M|    {
 1192|  15.8M|      pic_pix_x = img->opix_x + block_x;
 1193|       |      
 1194|  15.8M|      cbp_blk_mask = (block_x>>2) + block_y;
 1195|       |
 1196|       |      // Residue Color Transform
 1197|  15.8M|	  if(img->residue_transform_flag)
 1198|      0|    {
 1199|      0|        ChromaPrediction4x4 (0, block_x, block_y, p_dir, fw_mode, bw_mode, fw_refframe, bw_refframe);
 1200|      0|        for (j=0; j<4; j++)
 1201|      0|        for (i=0; i<4; i++)
 1202|      0|          mprRGB[1][i+block_x][j+block_y] = img->mpr[i+block_x][j+block_y];
 1203|       |
 1204|      0|        ChromaPrediction4x4 (1, block_x, block_y, p_dir, fw_mode, bw_mode, fw_refframe, bw_refframe);
 1205|      0|        for (j=0; j<4; j++)
 1206|      0|        for (i=0; i<4; i++)
 1207|      0|          mprRGB[2][i+block_x][j+block_y] = img->mpr[i+block_x][j+block_y];
 1208|      0|	  }
 1209|       |
 1210|       |      //===== prediction of 4x4 block =====
 1211|  15.8M|      LumaPrediction4x4 (block_x, block_y, p_dir, fw_mode, bw_mode, fw_refframe, bw_refframe);
 1212|       |
 1213|       |      // Residue Color Transform
 1214|  15.8M|	  if(img->residue_transform_flag)
 1215|      0|      for (j=0; j<4; j++)
 1216|      0|      for (i=0; i<4; i++)
 1217|      0|        mprRGB[0][i+block_x][j+block_y] = img->mpr[i+block_x][j+block_y];
 1218|       |
 1219|       |      //===== get displaced frame difference ======
 1220|  15.8M|      if(!img->residue_transform_flag)
 1221|  15.8M|      {
 1222|  15.8M|        if(!need_8x8_transform)
 1223|  15.8M|        {
 1224|       |
 1225|       |        //===== get displaced frame difference ======                
 1226|  79.3M|        for (j=0; j<4; j++)
 1227|   317M|          for (i=0; i<4; i++)
 1228|   253M|          {
 1229|   253M|            img->m7[i][j] = imgY_org[pic_pix_y+j][pic_pix_x+i] - img->mpr[i+block_x][j+block_y];
 1230|   253M|          }
 1231|       |
 1232|       |          //===== DCT, Quantization, inverse Quantization, IDCT, Reconstruction =====      
 1233|  15.8M|          if (img->NoResidueDirect != 1 && !skipped  )
 1234|  13.6M|          {
 1235|       |            //===== DCT, Quantization, inverse Quantization, IDCT, Reconstruction =====
 1236|  13.6M|            if (img->type!=SP_SLICE)  nonzero = dct_luma   (block_x, block_y, &coeff_cost, 0);
 1237|      0|            else                      nonzero = dct_luma_sp(block_x, block_y, &coeff_cost);
 1238|  13.6M|            if (nonzero)
 1239|   316k|            {
 1240|   316k|              (*cbp_blk) |= 1 << cbp_blk_mask;  // one bit for every 4x4 block
 1241|   316k|              (*cbp)     |= cbp_mask;           // one bit for the 4x4 blocks of an 8x8 block
 1242|   316k|            }
 1243|  13.6M|          }
 1244|  15.8M|        }
 1245|      0|        else
 1246|      0|        {
 1247|      0|          for (j=0; j<4; j++)
 1248|      0|          for (i=0; i<4; i++)
 1249|      0|          {
 1250|      0|            img->m7[i+bxx][j+byy] = imgY_org[pic_pix_y+j][pic_pix_x+i] - img->mpr[i+block_x][j+block_y];
 1251|      0|          }
 1252|      0|        }
 1253|  15.8M|      } 
 1254|      0|      else 
 1255|      0|      {
 1256|       |	    /* Forward Residue Transform */
 1257|      0|        for (j=0; j<4; j++)
 1258|      0|        for (i=0; i<4; i++)
 1259|      0|        {
 1260|      0|          residue_B = imgUV_org[0][pic_pix_y+j][pic_pix_x+i] - mprRGB[1][i+block_x][j+block_y];
 1261|      0|          residue_G = imgY_org[pic_pix_y+j][pic_pix_x+i] - mprRGB[0][i+block_x][j+block_y];
 1262|      0|          residue_R = imgUV_org[1][pic_pix_y+j][pic_pix_x+i] - mprRGB[2][i+block_x][j+block_y];
 1263|       |
 1264|      0|          resTrans_R[i+block_x][j+block_y] = residue_R-residue_B;
 1265|      0|          temp = residue_B+(resTrans_R[i+block_x][j+block_y]>>1);
 1266|      0|          resTrans_B[i+block_x][j+block_y] = residue_G-temp;
 1267|      0|          resTrans_G[i+block_x][j+block_y] = temp+(resTrans_B[i+block_x][j+block_y]>>1);
 1268|       |
 1269|      0|          if(!need_8x8_transform)
 1270|      0|            img->m7[i][j] = resTrans_G[i+block_x][j+block_y];
 1271|      0|          else
 1272|      0|            img->m7[i+bxx][j+byy] = resTrans_G[i+block_x][j+block_y];
 1273|      0|        }
 1274|       |
 1275|       |        // Residue Color Transform
 1276|       |        //===== DCT, Quantization, inverse Quantization, IDCT, Reconstruction =====      
 1277|      0|        if (img->NoResidueDirect != 1 && !skipped && !need_8x8_transform )
 1278|      0|        {
 1279|       |          //===== DCT, Quantization, inverse Quantization, IDCT, Reconstruction =====
 1280|      0|          if (img->type!=SP_SLICE)  nonzero = dct_luma   (block_x, block_y, &coeff_cost, 0);
 1281|      0|          else                      nonzero = dct_luma_sp(block_x, block_y, &coeff_cost);
 1282|       |          
 1283|      0|          for (j=0; j<4; j++)
 1284|      0|            for (i=0; i<4; i++)
 1285|      0|              rec_resG[i+block_x][j+block_y] = img->m7[i][j];
 1286|       |            
 1287|      0|          if (nonzero)
 1288|      0|          {
 1289|      0|            (*cbp_blk) |= 1 << cbp_blk_mask;  // one bit for every 4x4 block
 1290|      0|            (*cbp)     |= cbp_mask;           // one bit for the 4x4 blocks of an 8x8 block
 1291|      0|          }
 1292|      0|        }
 1293|      0|      }
 1294|  15.8M|    }
 1295|  7.93M|  }
 1296|       |
 1297|  3.96M|  if(need_8x8_transform)
 1298|      0|  {
 1299|      0|    if (img->NoResidueDirect != 1 && !skipped)
 1300|      0|    {
 1301|      0|      if (img->type!=SP_SLICE)
 1302|      0|        nonzero = dct_luma8x8   (block8x8, &coeff_cost, 0);
 1303|       |
 1304|       |      // Residue Color Transform
 1305|      0|      if(img->residue_transform_flag)
 1306|      0|      {
 1307|      0|        for (j=0; j<8; j++)
 1308|      0|          for (i=0; i<8; i++)
 1309|      0|            rec_resG[mb_x+i][mb_y+j] = img->m7[i][j];
 1310|      0|      }
 1311|       |
 1312|      0|      if (nonzero)
 1313|      0|      {
 1314|      0|        (*cbp_blk) |= 51 << (4*block8x8-2*(block8x8%2)); // corresponds to 110011, as if all four 4x4 blocks contain coeff, shifted to block position
 1315|      0|        (*cbp)     |= cbp_mask;           // one bit for the 4x4 blocks of an 8x8 block
 1316|      0|      }
 1317|      0|    }
 1318|      0|  }
 1319|       |
 1320|       |  /*
 1321|       |  The purpose of the action below is to prevent that single or 'expensive' coefficients are coded.
 1322|       |  With 4x4 transform there is larger chance that a single coefficient in a 8x8 or 16x16 block may be nonzero.
 1323|       |  A single small (level=1) coefficient in a 8x8 block will cost: 3 or more bits for the coefficient,
 1324|       |  4 bits for EOBs for the 4x4 blocks,possibly also more bits for CBP.  Hence the total 'cost' of that single
 1325|       |  coefficient will typically be 10-12 bits which in a RD consideration is too much to justify the distortion improvement.
 1326|       |  The action below is to watch such 'single' coefficients and set the reconstructed block equal to the prediction according
 1327|       |  to a given criterium.  The action is taken only for inter luma blocks.
 1328|       |
 1329|       |  Notice that this is a pure encoder issue and hence does not have any implication on the standard.
 1330|       |  coeff_cost is a parameter set in dct_luma() and accumulated for each 8x8 block.  If level=1 for a coefficient,
 1331|       |  coeff_cost is increased by a number depending on RUN for that coefficient.The numbers are (see also dct_luma()): 3,2,2,1,1,1,0,0,...
 1332|       |  when RUN equals 0,1,2,3,4,5,6, etc.
 1333|       |  If level >1 coeff_cost is increased by 9 (or any number above 3). The threshold is set to 3. This means for example:
 1334|       |  1: If there is one coefficient with (RUN,level)=(0,1) in a 8x8 block this coefficient is discarded.
 1335|       |  2: If there are two coefficients with (RUN,level)=(1,1) and (4,1) the coefficients are also discarded
 1336|       |  sum_cnt_nonz is the accumulation of coeff_cost over a whole macro block.  If sum_cnt_nonz is 5 or less for the whole MB,
 1337|       |  all nonzero coefficients are discarded for the MB and the reconstructed block is set equal to the prediction.
 1338|       |  */
 1339|       |
 1340|  3.96M|  if (img->NoResidueDirect != 1 && !skipped && coeff_cost <= _LUMA_COEFF_COST_ &&
 1341|  3.96M|      ((img->qp + img->bitdepth_luma_qp_scale)!=0 || img->lossless_qpprime_flag==0))
 1342|  3.31M|  {
 1343|  3.31M|    coeff_cost  = 0;
 1344|  3.31M|    (*cbp)     &=  (63 - cbp_mask);
 1345|  3.31M|    (*cbp_blk) &= ~(51 << (4*block8x8-2*(block8x8%2)));
 1346|       |
 1347|  29.8M|    for (i=mb_x; i<mb_x+8; i++)
 1348|   239M|    for (j=mb_y; j<mb_y+8; j++)
 1349|   212M|    {
 1350|       |      // Residue Color Transform
 1351|   212M|      if(!img->residue_transform_flag)
 1352|   212M|        enc_picture->imgY[img->pix_y+j][img->pix_x+i] = img->mpr[i][j];
 1353|      0|      else
 1354|      0|        rec_resG[i][j] = 0;
 1355|   212M|    }
 1356|  3.31M|    if (img->type==SP_SLICE)
 1357|      0|    {
 1358|      0|      for (i=mb_x; i < mb_x+BLOCK_SIZE*2; i+=BLOCK_SIZE)
 1359|      0|        for (j=mb_y; j < mb_y+BLOCK_SIZE*2; j+=BLOCK_SIZE)
 1360|      0|          copyblock_sp(i,j);
 1361|      0|    }
 1362|  3.31M|  }
 1363|       |
 1364|  3.96M|  return coeff_cost;
 1365|  3.96M|}
 1366|       |
 1367|       |
 1368|       |/*!
 1369|       | ************************************************************************
 1370|       | * \brief
 1371|       | *    Set mode parameters and reference frames for an 8x8 block
 1372|       | ************************************************************************
 1373|       | */
 1374|       |void
 1375|       |SetModesAndRefframe (int b8, short* p_dir, int* fw_mode, int* bw_mode, short* fw_ref, short* bw_ref)
 1376|  14.3M|{
 1377|  14.3M|  Macroblock* currMB = &img->mb_data[img->current_mb_nr];
 1378|  14.3M|  int         j      = 2*(b8/2);
 1379|  14.3M|  int         i      = 2*(b8%2);
 1380|       |
 1381|  14.3M|  *fw_mode = *bw_mode = *fw_ref = *bw_ref = -1;
 1382|       |
 1383|  14.3M|  *p_dir  = currMB->b8pdir[b8];
 1384|       |
 1385|  14.3M|  if (img->type!=B_SLICE)
 1386|  5.42M|  {
 1387|  5.42M|    *fw_ref = enc_picture->ref_idx[LIST_0][img->block_x+i][img->block_y+j];
 1388|  5.42M|    *bw_ref = 0;
 1389|  5.42M|    *fw_mode  = currMB->b8mode[b8];
 1390|  5.42M|    *bw_mode  = 0;
 1391|  5.42M|  }
 1392|  8.91M|  else
 1393|  8.91M|  {
 1394|  8.91M|    if (currMB->b8pdir[b8]==-1)
 1395|  3.34M|    {
 1396|  3.34M|      *fw_ref   = -1;
 1397|  3.34M|      *bw_ref   = -1;
 1398|  3.34M|      *fw_mode  =  0;
 1399|  3.34M|      *bw_mode  =  0;
 1400|  3.34M|    }
 1401|  5.57M|    else if (currMB->b8pdir[b8]==0)
 1402|  1.90M|    {
 1403|  1.90M|      *fw_ref   = enc_picture->ref_idx[LIST_0][img->block_x+i][img->block_y+j];
 1404|  1.90M|      *bw_ref   = 0;
 1405|  1.90M|      *fw_mode  = currMB->b8mode[b8];
 1406|  1.90M|      *bw_mode  = 0;
 1407|  1.90M|    }
 1408|  3.67M|    else if (currMB->b8pdir[b8]==1)
 1409|  1.81M|    {
 1410|  1.81M|      *fw_ref   = 0;
 1411|  1.81M|      *bw_ref   = enc_picture->ref_idx[LIST_1][img->block_x+i][img->block_y+j];
 1412|  1.81M|      *fw_mode  = 0;
 1413|  1.81M|      *bw_mode  = currMB->b8mode[b8];
 1414|  1.81M|    }
 1415|  1.85M|    else
 1416|  1.85M|    {
 1417|  1.85M|      *fw_ref   = enc_picture->ref_idx[LIST_0][img->block_x+i][img->block_y+j];
 1418|  1.85M|      *bw_ref   = enc_picture->ref_idx[LIST_1][img->block_x+i][img->block_y+j];
 1419|  1.85M|      *fw_mode  = currMB->b8mode[b8];
 1420|  1.85M|      *bw_mode  = currMB->b8mode[b8];
 1421|  1.85M|    }
 1422|  8.91M|  }
 1423|  14.3M|}
 1424|       |
 1425|       |
 1426|       |/*!
 1427|       | ************************************************************************
 1428|       | * \brief
 1429|       | *    Residual Coding of a Luma macroblock (not for intra)
 1430|       | ************************************************************************
 1431|       | */
 1432|       |void
 1433|       |LumaResidualCoding ()
 1434|   573k|{
 1435|   573k|  int i,j,block8x8,b8_x,b8_y;
 1436|   573k|  int fw_mode, bw_mode;
 1437|   573k|  short p_dir, refframe;
 1438|   573k|  int sum_cnt_nonz;
 1439|   573k|  Macroblock *currMB = &img->mb_data[img->current_mb_nr];
 1440|       |
 1441|   573k|  currMB->cbp     = 0 ;
 1442|   573k|  currMB->cbp_blk = 0 ;
 1443|   573k|  sum_cnt_nonz    = 0 ;
 1444|       |
 1445|  2.86M|  for (block8x8=0; block8x8<4; block8x8++)
 1446|  2.29M|  {
 1447|  2.29M|    short bw_ref;
 1448|  2.29M|    SetModesAndRefframe (block8x8, &p_dir, &fw_mode, &bw_mode, &refframe, &bw_ref);
 1449|       |    
 1450|  2.29M|    sum_cnt_nonz += LumaResidualCoding8x8 (&(currMB->cbp), &(currMB->cbp_blk), block8x8,
 1451|  2.29M|                                           p_dir, fw_mode, bw_mode, refframe, bw_ref);
 1452|  2.29M|  }
 1453|       |
 1454|   573k|  if (sum_cnt_nonz <= _LUMA_MB_COEFF_COST_ &&
 1455|   573k|      ((img->qp + img->bitdepth_luma_qp_scale)!=0 || img->lossless_qpprime_flag==0))
 1456|   545k|  {
 1457|   545k|     currMB->cbp     &= 0xfffff0 ;
 1458|   545k|     currMB->cbp_blk &= 0xff0000 ;
 1459|  9.27M|     for (i=0; i < MB_BLOCK_SIZE; i++)
 1460|  8.73M|     {
 1461|   148M|       for (j=0; j < MB_BLOCK_SIZE; j++)
 1462|   139M|       {
 1463|   139M|         if(!img->residue_transform_flag)
 1464|   139M|           enc_picture->imgY[img->pix_y+j][img->pix_x+i]=img->mpr[i][j];
 1465|      0|         else
 1466|      0|           rec_resG[i][j] = 0;
 1467|   139M|       }
 1468|  8.73M|     }
 1469|   545k|     if (img->type==SP_SLICE)
 1470|      0|     {
 1471|      0|       for(block8x8=0;block8x8<4;block8x8++)
 1472|      0|       {
 1473|      0|         b8_x=(block8x8&1)<<3;
 1474|      0|         b8_y=(block8x8&2)<<2;
 1475|      0|         for (i=0;i<8;i+=4)
 1476|      0|           for (j=0;j<8;j+=4)
 1477|      0|             copyblock_sp(b8_x+i,b8_y+j);
 1478|      0|       }
 1479|      0|     }
 1480|   545k|   }
 1481|   573k|}
 1482|       |
 1483|       |
 1484|       |/*!
 1485|       | ************************************************************************
 1486|       | * \brief
 1487|       | *    Makes the decision if 8x8 tranform will be used (for RD-off)
 1488|       | ************************************************************************
 1489|       | */
 1490|       |int
 1491|       |TransformDecision (int block_check, int *cost)
 1492|      0|{
 1493|      0|  int    block_y, block_x, pic_pix_y, pic_pix_x, i, j, k;
 1494|      0|  int    mb_y, mb_x, block8x8;
 1495|      0|  int    fw_mode, bw_mode;
 1496|      0|  short  p_dir, fw_ref, bw_ref;
 1497|      0|  int    num_blks;
 1498|      0|  int    cost8x8=0, cost4x4=0;
 1499|      0|  int    diff[64], *diff_ptr;
 1500|       |
 1501|      0|  if(block_check==-1)
 1502|      0|  {
 1503|      0|    block8x8=0;
 1504|      0|    num_blks=4;
 1505|      0|  }
 1506|      0|  else
 1507|      0|  {
 1508|      0|    block8x8=block_check;
 1509|      0|    num_blks=block_check+1;
 1510|      0|  }
 1511|       |
 1512|      0|  for (; block8x8<num_blks; block8x8++)
 1513|      0|  {
 1514|      0|    SetModesAndRefframe (block8x8, &p_dir, &fw_mode, &bw_mode, &fw_ref, &bw_ref);
 1515|       |
 1516|      0|    mb_y = (block8x8 / 2) << 3;
 1517|      0|    mb_x = (block8x8 % 2) << 3;
 1518|       |    //===== loop over 4x4 blocks =====
 1519|      0|    k=0;
 1520|      0|    for (block_y=mb_y; block_y<mb_y+8; block_y+=4)
 1521|      0|    {
 1522|      0|      pic_pix_y = img->opix_y + block_y;
 1523|       |      
 1524|      0|      for (block_x=mb_x; block_x<mb_x+8; block_x+=4)
 1525|      0|      {
 1526|      0|        pic_pix_x = img->opix_x + block_x;
 1527|       |
 1528|       |        //===== prediction of 4x4 block =====
 1529|      0|        LumaPrediction4x4 (block_x, block_y, p_dir, fw_mode, bw_mode, fw_ref, bw_ref);
 1530|       |
 1531|       |        //===== get displaced frame difference ======
 1532|      0|        diff_ptr=&diff[k];
 1533|      0|        for (j=0; j<4; j++)
 1534|      0|          for (i=0; i<4; i++, k++)
 1535|      0|          {
 1536|      0|              diff[k] = imgY_org[pic_pix_y+j][pic_pix_x+i] - img->mpr[i+block_x][j+block_y];
 1537|      0|          }
 1538|      0|        cost4x4 += SATD (diff_ptr, input->hadamard);
 1539|      0|      }
 1540|      0|    }
 1541|      0|    cost8x8 += SATD8X8 (diff, input->hadamard);
 1542|      0|  }
 1543|       |
 1544|      0|  if(input->AllowTransform8x8==2) //always allow 8x8 transform
 1545|      0|  {
 1546|      0|    return 1;
 1547|      0|  }
 1548|      0|  else
 1549|      0|  {
 1550|      0|    if(cost8x8<cost4x4)
 1551|      0|    {
 1552|      0|      return 1;
 1553|      0|    }
 1554|      0|    else
 1555|      0|    {
 1556|      0|      *cost = (*cost-cost8x8+cost4x4);
 1557|      0|      return 0;
 1558|      0|    }
 1559|      0|  }
 1560|      0|}
 1561|       |
 1562|       |/*!
 1563|       | ************************************************************************
 1564|       | * \brief
 1565|       | *    Predict one component of a chroma 4x4 block
 1566|       | ************************************************************************
 1567|       | */
 1568|       |void
 1569|       |OneComponentChromaPrediction4x4 (int*        mpred,      //!< array to store prediction values
 1570|       |                                 int         block_c_x,  //!< horizontal pixel coordinate of 4x4 block
 1571|       |                                 int         block_c_y,  //!< vertical   pixel coordinate of 4x4 block
 1572|       |                                 short****** mv,         //!< motion vector array
 1573|       |                                 int         list_idx,   //!< reference picture list
 1574|       |                                 short       ref,        //!< reference index
 1575|       |                                 int         blocktype,  //!< block type
 1576|       |                                 int         uv)         //!< chroma component
 1577|  6.62M|{
 1578|  6.62M|  int     i, j, ii, jj, ii0, jj0, ii1, jj1, if0, if1, jf0, jf1;
 1579|  6.62M|  short*  mvb;
 1580|  6.62M|  pel_t** refimage;
 1581|  6.62M|  int     f1_x = 64/img->mb_cr_size_x;
 1582|  6.62M|  int     f2_x=f1_x-1;
 1583|       |
 1584|  6.62M|  int     f1_y = 64/img->mb_cr_size_y;
 1585|  6.62M|  int     f2_y=f1_y-1;
 1586|       |
 1587|  6.62M|  int     f3=f1_x*f1_y, f4=f3>>1;
 1588|       |
 1589|  6.62M|  int     list_offset;
 1590|  6.62M|  int     max_y_cr;
 1591|       |
 1592|  6.62M|  StorablePicture **list;
 1593|       |
 1594|  6.62M|  int curr_mb_field = ((img->MbaffFrameFlag)&&(img->mb_data[img->current_mb_nr].mb_field));
 1595|       |  // find out the correct list offsets
 1596|  6.62M|  if (curr_mb_field)
 1597|      0|  {
 1598|      0|    if(img->current_mb_nr%2)
 1599|      0|      list_offset = 4; // top field mb
 1600|      0|    else
 1601|      0|      list_offset = 2; // bottom field mb
 1602|      0|    max_y_cr = img->height_cr/2-1;
 1603|      0|  }
 1604|  6.62M|  else
 1605|  6.62M|  {
 1606|  6.62M|    list_offset = 0;  // no mb aff or frame mb
 1607|  6.62M|    max_y_cr = img->height_cr-1;
 1608|  6.62M|  }
 1609|       |
 1610|       |
 1611|  6.62M|  list      = listX[list_idx + list_offset];
 1612|       |
 1613|  6.62M|  refimage  = list[ref]->imgUV[uv];
 1614|       |
 1615|  33.1M|  for (j=0; j<4; j++)
 1616|   132M|    for (i=0; i<4; i++)
 1617|   105M|    {
 1618|   105M|      mvb  = mv [(i+block_c_x)/(img->mb_cr_size_x/4)][(j+block_c_y)/(img->mb_cr_size_y/4)][list_idx][ref][blocktype];
 1619|       |
 1620|   105M|      ii   = (i+block_c_x+img->opix_c_x)*f1_x + mvb[0];
 1621|   105M|      jj   = (j+block_c_y+img->opix_c_y)*f1_y + mvb[1];
 1622|       |
 1623|   105M|      jj  += list[ref]->chroma_vector_adjustment;
 1624|       |
 1625|   105M|      ii0  = max (0, min (img->width_cr -1, ii/f1_x));
 1626|   105M|      jj0  = max (0, min (max_y_cr,         jj/f1_y));
 1627|   105M|      ii1  = max (0, min (img->width_cr -1, (ii+f2_x)/f1_x));
 1628|   105M|      jj1  = max (0, min (max_y_cr,         (jj+f2_y)/f1_y));
 1629|       |
 1630|   105M|      if1  = (ii&f2_x);  if0 = f1_x-if1;
 1631|   105M|      jf1  = (jj&f2_y);  jf0 = f1_y-jf1;
 1632|       |      
 1633|   105M|      *mpred++ = (if0 * jf0 * refimage[jj0][ii0] +
 1634|   105M|                  if1 * jf0 * refimage[jj0][ii1] +
 1635|   105M|                  if0 * jf1 * refimage[jj1][ii0] +
 1636|   105M|                  if1 * jf1 * refimage[jj1][ii1] + f4) / f3;
 1637|   105M|    }
 1638|  6.62M|}
 1639|       |
 1640|       |
 1641|       |/*!
 1642|       | ************************************************************************
 1643|       | * \brief
 1644|       | *    Predict an intra chroma 4x4 block
 1645|       | ************************************************************************
 1646|       | */
 1647|       |void IntraChromaPrediction4x4 (int  uv,       // <-- colour component
 1648|       |                               int  block_x,  // <-- relative horizontal block coordinate of 4x4 block
 1649|       |                               int  block_y)  // <-- relative vertical   block coordinate of 4x4 block
 1650|  6.72M|{
 1651|  6.72M|  int mode = img->mb_data[img->current_mb_nr].c_ipred_mode;
 1652|  6.72M|  int i, j;
 1653|       |
 1654|       |  //===== prediction =====
 1655|  33.6M|  for (j=block_y; j<block_y+4; j++)
 1656|   134M|  for (i=block_x; i<block_x+4; i++)
 1657|   107M|  {
 1658|   107M|    img->mpr[i][j] = img->mprr_c[uv][mode][i][j];
 1659|   107M|  }
 1660|  6.72M|}
 1661|       |
 1662|       |
 1663|       |
 1664|       |/*!
 1665|       | ************************************************************************
 1666|       | * \brief
 1667|       | *    Predict one chroma 4x4 block
 1668|       | ************************************************************************
 1669|       | */
 1670|       |void
 1671|       |ChromaPrediction4x4 (int   uv,           // <-- colour component
 1672|       |                     int   block_x,      // <-- relative horizontal block coordinate of 4x4 block
 1673|       |                     int   block_y,      // <-- relative vertical   block coordinate of 4x4 block
 1674|       |                     int   p_dir,        // <-- prediction direction
 1675|       |                     int   fw_mode,      // <-- forward  prediction mode (1-7, 0=DIRECT if bw_mode=0)
 1676|       |                     int   bw_mode,      // <-- backward prediction mode (1-7, 0=DIRECT if fw_mode=0)
 1677|       |                     short fw_ref_idx,   // <-- reference frame for forward prediction (if (<0) -> intra prediction)
 1678|       |                     short bw_ref_idx)   // <-- reference frame for backward prediction 
 1679|  12.0M|{
 1680|  12.0M|  static int fw_pred[16];
 1681|  12.0M|  static int bw_pred[16];
 1682|       |
 1683|  12.0M|  int  i, j;
 1684|  12.0M|  int  block_x4  = block_x+4;
 1685|  12.0M|  int  block_y4  = block_y+4;
 1686|  12.0M|  int* fpred     = fw_pred;
 1687|  12.0M|  int* bpred     = bw_pred;
 1688|  12.0M|  short****** mv_array = img->all_mv;
 1689|       |
 1690|  12.0M|  Macroblock*    currMB     = &img->mb_data[img->current_mb_nr];
 1691|       |
 1692|  12.0M|  int  apply_weights = ( (active_pps->weighted_pred_flag && (img->type == P_SLICE || img->type == SP_SLICE)) ||
 1693|  12.0M|                         (active_pps->weighted_bipred_idc && (img->type == B_SLICE)));  
 1694|       |
 1695|  12.0M|#if BI_PREDICTION
 1696|  12.0M|  if (currMB->bi_pred_me && fw_ref_idx == 0 && bw_ref_idx == 0 && p_dir == 2 && fw_mode==1 && bw_mode==1)
 1697|      0|    mv_array = currMB->bi_pred_me == 1? img->bipred_mv1 : img->bipred_mv2 ;
 1698|  12.0M|#endif
 1699|       |
 1700|       |  //===== INTRA PREDICTION =====
 1701|  12.0M|  if (p_dir==-1)
 1702|  6.72M|  {
 1703|  6.72M|    IntraChromaPrediction4x4 (uv, block_x, block_y);
 1704|  6.72M|    return;
 1705|  6.72M|  }
 1706|       |  
 1707|       |  //===== INTER PREDICTION =====
 1708|  5.31M|  if ((p_dir==0) || (p_dir==2))
 1709|  4.07M|  {
 1710|  4.07M|    OneComponentChromaPrediction4x4 (fw_pred, block_x, block_y, mv_array, LIST_0, fw_ref_idx, fw_mode, uv);
 1711|  4.07M|  }
 1712|  5.31M|  if ((p_dir==1) || (p_dir==2))
 1713|  2.54M|  {
 1714|  2.54M|    OneComponentChromaPrediction4x4 (bw_pred, block_x, block_y, mv_array, LIST_1, bw_ref_idx, bw_mode, uv);
 1715|  2.54M|  }
 1716|       |
 1717|  5.31M|  if (apply_weights)
 1718|      0|  {
 1719|      0|    if (p_dir==2)
 1720|      0|    {
 1721|      0|      for (j=block_y; j<block_y4; j++)
 1722|      0|        for (i=block_x; i<block_x4; i++)  
 1723|      0|            img->mpr[i][j] =  clip1a_chr(((wbp_weight[0][fw_ref_idx][bw_ref_idx][uv+1] * *fpred++ + wbp_weight[1][fw_ref_idx][bw_ref_idx][uv+1] * *bpred++ 
 1724|      0|                  + 2*wp_chroma_round) >> (chroma_log_weight_denom + 1)) + ((wp_offset[0][fw_ref_idx][uv+1] + wp_offset[1][bw_ref_idx][uv+1] + 1)>>1) );
 1725|      0|    }
 1726|      0|    else if (p_dir==0)
 1727|      0|    {
 1728|      0|      for (j=block_y; j<block_y4; j++)
 1729|      0|        for (i=block_x; i<block_x4; i++)  
 1730|      0|           img->mpr[i][j] = clip1a_chr(((wp_weight[0][fw_ref_idx][uv+1] * *fpred++ + wp_chroma_round) >> chroma_log_weight_denom) +  wp_offset[0][fw_ref_idx][uv+1]);
 1731|      0|    }
 1732|      0|    else // (p_dir==1)
 1733|      0|    {
 1734|      0|      for (j=block_y; j<block_y4; j++)
 1735|      0|        for (i=block_x; i<block_x4; i++)  
 1736|      0|          img->mpr[i][j] = clip1a_chr(((wp_weight[1][bw_ref_idx][uv+1] * *bpred++ + wp_chroma_round) >> chroma_log_weight_denom) + wp_offset[1][bw_ref_idx][uv+1]);
 1737|      0|    }
 1738|      0|  }
 1739|  5.31M|  else
 1740|  5.31M|  {
 1741|  5.31M|    if (p_dir==2)
 1742|  1.30M|    {
 1743|  6.50M|      for (j=block_y; j<block_y4; j++)
 1744|  26.0M|        for (i=block_x; i<block_x4; i++)  
 1745|  20.8M|          img->mpr[i][j] = (*fpred++ + *bpred++ + 1) / 2; 
 1746|  1.30M|    }
 1747|  4.01M|    else if (p_dir==0)
 1748|  2.77M|    {
 1749|  13.8M|      for (j=block_y; j<block_y4; j++)
 1750|  55.4M|        for (i=block_x; i<block_x4; i++)  img->mpr[i][j] = *fpred++;
 1751|  2.77M|    }
 1752|  1.24M|    else // (p_dir==1)
 1753|  1.24M|    {
 1754|  6.22M|      for (j=block_y; j<block_y4; j++)
 1755|  24.9M|        for (i=block_x; i<block_x4; i++)  img->mpr[i][j] = *bpred++;
 1756|  1.24M|    }
 1757|  5.31M|  }
 1758|  5.31M|}
 1759|       |
 1760|       |
 1761|       |
 1762|       |
 1763|       |/*!
 1764|       | ************************************************************************
 1765|       | * \brief
 1766|       | *    Chroma residual coding for an macroblock
 1767|       | ************************************************************************
 1768|       | */
 1769|       |void ChromaResidualCoding (int* cr_cbp)
 1770|  1.50M|{
 1771|  1.50M|  int   uv, block8, block_y, block_x, j, i;
 1772|  1.50M|  int   fw_mode, bw_mode;
 1773|  1.50M|  short p_dir, refframe, bw_ref;
 1774|  1.50M|  int   skipped = (img->mb_data[img->current_mb_nr].mb_type == 0 && (img->type == P_SLICE || img->type == SP_SLICE));
 1775|  1.50M|  int   yuv = img->yuv_format - 1; //ADD-VG-15052004
 1776|       |
 1777|  1.50M|  int   block8x8_idx[3][4][4] =     //ADD-VG-15052004
 1778|  1.50M|  { { {0, 1, 0, 0}, 
 1779|  1.50M|      {2, 3, 0, 0},
 1780|  1.50M|      {0, 0, 0, 0},
 1781|  1.50M|      {0, 0, 0, 0}, },
 1782|       |
 1783|  1.50M|    { {0, 1, 0, 0}, 
 1784|  1.50M|      {0, 1, 0, 0}, 
 1785|  1.50M|      {2, 3, 0, 0},
 1786|  1.50M|      {2, 3, 0, 0}  },
 1787|       |
 1788|  1.50M|    { {0, 0, 1, 1},
 1789|  1.50M|      {0, 0, 1, 1},
 1790|  1.50M|      {2, 2, 3, 3},
 1791|  1.50M|      {2, 2, 3, 3}  }
 1792|  1.50M|  };
 1793|  1.50M|  int residue_R, residue_G, residue_B, temp;
 1794|       |
 1795|  4.51M|  for (*cr_cbp=0, uv=0; uv<2; uv++)
 1796|  3.01M|  {
 1797|       |    //===== prediction of chrominance blocks ===d==
 1798|  3.01M|    block8 = 0;
 1799|  9.03M|    for (block_y=0; block_y < img->mb_cr_size_y; block_y+=4)
 1800|  18.0M|    for (block_x=0; block_x < img->mb_cr_size_x; block_x+=4)
 1801|  12.0M|    {
 1802|  12.0M|      block8 = block8x8_idx[yuv][block_y>>2][block_x>>2];
 1803|  12.0M|      SetModesAndRefframe (block8, &p_dir, &fw_mode, &bw_mode, &refframe, &bw_ref);
 1804|       |
 1805|  12.0M|      ChromaPrediction4x4 (uv, block_x, block_y, p_dir, fw_mode, bw_mode, refframe, bw_ref);
 1806|  12.0M|    }
 1807|       |
 1808|       |    // ==== set chroma residue to zero for skip Mode in SP frames 
 1809|  3.01M|    if (img->NoResidueDirect)
 1810|   203k|    {
 1811|  1.82M|      for (j=0; j<img->mb_cr_size_y; j++)
 1812|  14.6M|        for (i=0; i<img->mb_cr_size_x; i++)
 1813|  13.0M|        {
 1814|       |          // Residue Color Transform
 1815|  13.0M|          if(!img->residue_transform_flag)
 1816|  13.0M|          {
 1817|  13.0M|            enc_picture->imgUV[uv][img->pix_c_y+j][img->pix_c_x+i] = img->mpr[i][j];
 1818|  13.0M|          } 
 1819|      0|          else 
 1820|      0|          {
 1821|      0|            if(uv==0) rec_resR[i][j] = 0;
 1822|      0|            else      rec_resB[i][j] = 0;
 1823|      0|          }
 1824|  13.0M|        }
 1825|   203k|    }
 1826|  2.80M|    else
 1827|  2.80M|    if (skipped && img->type==SP_SLICE)
 1828|      0|    {
 1829|      0|      for (j=0; j<8; j++)
 1830|      0|        for (i=0; i<8; i++)
 1831|      0|        {
 1832|      0|          img->m7[i][j] = 0;
 1833|      0|        }
 1834|      0|    }
 1835|  2.80M|    else
 1836|  2.80M|    if (skipped)
 1837|  72.9k|    {
 1838|   656k|      for (j=0; j<img->mb_cr_size_y; j++)
 1839|  5.25M|        for (i=0; i<img->mb_cr_size_x; i++)
 1840|  4.66M|        {
 1841|       |          // Residue Color Transform
 1842|  4.66M|          if(!img->residue_transform_flag)
 1843|  4.66M|          {
 1844|  4.66M|            enc_picture->imgUV[uv][img->pix_c_y+j][img->pix_c_x+i] = img->mpr[i][j];
 1845|  4.66M|          } 
 1846|      0|          else 
 1847|      0|          {
 1848|      0|            if(uv==0) rec_resR[i][j] = 0;
 1849|      0|            else      rec_resB[i][j] = 0;
 1850|      0|          }
 1851|  4.66M|        }
 1852|  72.9k|    }
 1853|  2.73M|    else
 1854|  2.73M|    {
 1855|  24.6M|      for (j=0; j<img->mb_cr_size_y; j++)
 1856|   196M|        for (i=0; i<img->mb_cr_size_x; i++)
 1857|   174M|        {
 1858|       |          // Residue Color Transform
 1859|   174M|          if(!img->residue_transform_flag)
 1860|   174M|          {
 1861|   174M|            img->m7[i][j] = imgUV_org[uv][img->opix_c_y+j][img->opix_c_x+i] - img->mpr[i][j];
 1862|   174M|          } else 
 1863|      0|          {
 1864|      0|            if(uv==0) img->m7[i][j] = resTrans_R[i][j];
 1865|      0|            else      img->m7[i][j] = resTrans_B[i][j];
 1866|      0|          }
 1867|   174M|        }
 1868|  2.73M|    }
 1869|       |
 1870|       |    //===== DCT, Quantization, inverse Quantization, IDCT, and Reconstruction =====
 1871|       |    //===== Call function for skip mode in SP frames to properly process frame ====
 1872|       |    
 1873|  3.01M|    if (skipped && img->type==SP_SLICE)
 1874|      0|    {
 1875|      0|        *cr_cbp=dct_chroma_sp(uv,*cr_cbp);
 1876|      0|    }
 1877|  3.01M|    else
 1878|  3.01M|    {
 1879|  3.01M|      if (!img->NoResidueDirect && !skipped)
 1880|  2.73M|      {
 1881|  2.73M|        if (img->type!=SP_SLICE || IS_INTRA (&img->mb_data[img->current_mb_nr]))
 1882|  2.73M|          *cr_cbp=dct_chroma   (uv,*cr_cbp);
 1883|      0|        else
 1884|      0|          *cr_cbp=dct_chroma_sp(uv,*cr_cbp);
 1885|       |
 1886|  2.73M|        if(img->residue_transform_flag){
 1887|      0|        for (j=0; j < img->mb_cr_size_y; j++)
 1888|      0|        for (i=0; i < img->mb_cr_size_x; i++)
 1889|      0|          if(uv==0)
 1890|      0|            rec_resR[i][j] = img->m7[i][j];
 1891|      0|          else
 1892|      0|            rec_resB[i][j] = img->m7[i][j];
 1893|      0|        }
 1894|  2.73M|      }
 1895|  3.01M|    }
 1896|  3.01M|  }
 1897|       |
 1898|       |  //===== update currMB->cbp =====
 1899|  1.50M|  img->mb_data[img->current_mb_nr].cbp += ((*cr_cbp)<<4);  
 1900|       |
 1901|       |  // Residue Color Transform
 1902|       |  /* Inverse Residue Transform */
 1903|  1.50M|  if(img->residue_transform_flag)
 1904|      0|  {
 1905|      0|    for (j=0; j<16; j++)
 1906|      0|      for (i=0; i<16; i++)
 1907|      0|      {
 1908|       |        /* YCoCg-R */
 1909|      0|        temp      = rec_resG[i][j]-(rec_resB[i][j]>>1);
 1910|      0|        residue_G = rec_resB[i][j]+temp;
 1911|      0|        residue_B = temp - (rec_resR[i][j]>>1);
 1912|      0|        residue_R = residue_B+rec_resR[i][j];
 1913|      0|        enc_picture->imgUV[0][img->pix_y+j][img->pix_x+i] = min(img->max_imgpel_value_uv,max(0,residue_B+mprRGB[1][i][j]));
 1914|      0|        enc_picture->imgY[img->pix_y+j][img->pix_x+i]     = min(img->max_imgpel_value, max(0,residue_G+mprRGB[0][i][j]));
 1915|      0|        enc_picture->imgUV[1][img->pix_y+j][img->pix_x+i] = min(img->max_imgpel_value_uv,max(0,residue_R+mprRGB[2][i][j]));
 1916|      0|      }
 1917|      0|  }
 1918|  1.50M|}
 1919|       |
 1920|       |
 1921|       |/*!
 1922|       | ************************************************************************
 1923|       | * \brief
 1924|       | *    Intra prediction of the chrminance layers of one macroblock
 1925|       | ************************************************************************
 1926|       | */
 1927|       |void IntraChromaPrediction (int *mb_up, int *mb_left, int*mb_up_left)
 1928|   109k|{
 1929|       |
 1930|   109k|  Macroblock *currMB = &img->mb_data[img->current_mb_nr];
 1931|   109k|  int      s, s0, s1, s2, s3, i, j, k;
 1932|   109k|  pel_t**  image;
 1933|   109k|  int      block_x, block_y;
 1934|   109k|  int      mb_nr = img->current_mb_nr;
 1935|   109k|  int      mb_available_up;
 1936|   109k|  int      mb_available_left[2];
 1937|   109k|  int      mb_available_up_left;
 1938|   109k|  int      ih,iv;
 1939|   109k|  int      ib,ic,iaa;
 1940|   109k|  int      uv;
 1941|   109k|  int      hline[16], vline[16];
 1942|   109k|  int      mode;
 1943|   109k|  int      best_mode = DC_PRED_8;  //just an initilaization here, should always be overwritten
 1944|   109k|  int      cost;
 1945|   109k|  int      min_cost;
 1946|   109k|  int      diff[16];
 1947|   109k|  PixelPos up;        //!< pixel position  p(0,-1)
 1948|   109k|  PixelPos left[17];  //!< pixel positions p(-1, -1..15)
 1949|   109k|  int      cr_MB_x = img->mb_cr_size_x;
 1950|   109k|  int      cr_MB_y = img->mb_cr_size_y;
 1951|       |
 1952|       |  //ADD-VG-07062004 
 1953|   109k|  int      blk_x;
 1954|   109k|  int      blk_y;
 1955|   109k|  int      b8,b4;
 1956|   109k|  int      yuv = img->yuv_format - 1;
 1957|       |  
 1958|   109k|  int      block_pos[3][4][4]= //[yuv][b8][b4]
 1959|   109k|  {
 1960|   109k|    { {0, 1, 2, 3},{0, 0, 0, 0},{0, 0, 0, 0},{0, 0, 0, 0}},
 1961|   109k|    { {0, 1, 2, 3},{2, 3, 2, 3},{0, 0, 0, 0},{0, 0, 0, 0}},
 1962|   109k|    { {0, 1, 2, 3},{1, 1, 3, 3},{2, 3, 2, 3},{3, 3, 3, 3}}
 1963|   109k|  };
 1964|       |  
 1965|       |  //ADD-VG-07062004-END 
 1966|       |  
 1967|       |
 1968|  1.09M|  for (i=0;i<cr_MB_y+1;i++)
 1969|   984k|  {
 1970|   984k|    getNeighbour(mb_nr, -1 , i-1 , 0, &left[i]);
 1971|   984k|  }
 1972|       |  
 1973|   109k|  getNeighbour(mb_nr, 0 , -1 , 0, &up);
 1974|       |
 1975|       |
 1976|   109k|  mb_available_up                             = up.available;
 1977|   109k|  mb_available_up_left                        = left[0].available;
 1978|   109k|  mb_available_left[0] = mb_available_left[1] = left[1].available;
 1979|       |
 1980|   109k|  if(input->UseConstrainedIntraPred)
 1981|      0|  {
 1982|      0|    mb_available_up = up.available ? img->intra_block[up.mb_addr] : 0;
 1983|      0|    for (i=0, mb_available_left[0]=1; i<cr_MB_y/2;i++)
 1984|      0|      mb_available_left[0]  &= left[i+1].available ? img->intra_block[left[i+1].mb_addr]: 0;
 1985|      0|    for (i=cr_MB_y/2, mb_available_left[1]=1; i<cr_MB_y;i++)
 1986|      0|      mb_available_left[1] &= left[i+1].available ? img->intra_block[left[i+1].mb_addr]: 0;
 1987|      0|    mb_available_up_left = left[0].available ? img->intra_block[left[0].mb_addr]: 0;
 1988|      0|  }
 1989|       |
 1990|   109k|  if (mb_up)
 1991|   109k|    *mb_up = mb_available_up;
 1992|   109k|  if (mb_left)
 1993|   109k|    *mb_left = mb_available_left[0] && mb_available_left[1];
 1994|   109k|  if (mb_up_left)
 1995|   109k|    *mb_up_left = mb_available_up_left;
 1996|       |
 1997|       |
 1998|       |  // compute all chroma intra prediction modes for both U and V
 1999|   328k|  for (uv=0; uv<2; uv++)
 2000|   218k|  {
 2001|   218k|    image = enc_picture->imgUV[uv];
 2002|       |
 2003|       |    // DC prediction
 2004|   437k|    for(b8=0; b8<img->num_blk8x8_uv/2;b8++)
 2005|   218k|    {
 2006|  1.09M|      for (b4=0; b4<4; b4++)
 2007|   875k|      {
 2008|   875k|        block_y = subblk_offset_y[yuv][b8][b4];
 2009|   875k|        block_x = subblk_offset_x[yuv][b8][b4];
 2010|   875k|        blk_x = block_x;
 2011|   875k|        blk_y = block_y + 1;
 2012|       |
 2013|   875k|        s=img->dc_pred_value;
 2014|   875k|        s0=s1=s2=s3=0;
 2015|       |
 2016|       |        //===== get prediction value =====
 2017|   875k|        switch (block_pos[yuv][b8][b4])
 2018|   875k|        {
 2019|   218k|        case 0:  //===== TOP LEFT =====
 2020|  1.03M|          if      (mb_available_up)       for (i=blk_x;i<(blk_x+4);i++)  s0 += image[up.pos_y][up.pos_x + i];
 2021|  1.06M|          if      (mb_available_left[0])  for (i=blk_y;i<(blk_y+4);i++)  s2 += image[left[i].pos_y][left[i].pos_x];
 2022|   218k|          if      (mb_available_up && mb_available_left[0])  s  = (s0+s2+4) >> 3;
 2023|  17.4k|          else if (mb_available_up)                          s  = (s0   +2) >> 2;
 2024|  10.9k|          else if (mb_available_left[0])                     s  = (s2   +2) >> 2;
 2025|   218k|          break;
 2026|   218k|        case 1: //===== TOP RIGHT =====
 2027|  1.03M|          if      (mb_available_up)       for (i=blk_x;i<(blk_x+4);i++)  s1 += image[up.pos_y][up.pos_x + i];
 2028|  53.0k|          else if (mb_available_left[0])  for (i=blk_y;i<(blk_y+4);i++)  s2 += image[left[i].pos_y][left[i].pos_x];
 2029|   218k|          if      (mb_available_up)                          s  = (s1   +2) >> 2;
 2030|  10.9k|          else if (mb_available_left[0])                     s  = (s2   +2) >> 2;
 2031|   218k|          break;
 2032|   218k|        case 2: //===== BOTTOM LEFT =====
 2033|  1.06M|          if      (mb_available_left[1])  for (i=blk_y;i<(blk_y+4);i++)  s3 += image[left[i].pos_y][left[i].pos_x];
 2034|  32.4k|          else if (mb_available_up)       for (i=blk_x;i<(blk_x+4);i++)  s0 += image[up.pos_y][up.pos_x + i];
 2035|   218k|          if      (mb_available_left[1])                     s  = (s3   +2) >> 2;
 2036|  6.84k|          else if (mb_available_up)                          s  = (s0   +2) >> 2;
 2037|   218k|          break;
 2038|   218k|        case 3: //===== BOTTOM RIGHT =====
 2039|  1.03M|          if      (mb_available_up)       for (i=blk_x;i<(blk_x+4);i++)  s1 += image[up.pos_y][up.pos_x + i];
 2040|  1.06M|          if      (mb_available_left[1])  for (i=blk_y;i<(blk_y+4);i++)  s3 += image[left[i].pos_y][left[i].pos_x];
 2041|   218k|          if      (mb_available_up && mb_available_left[1])  s  = (s1+s3+4) >> 3;
 2042|  17.4k|          else if (mb_available_up)                          s  = (s1   +2) >> 2;
 2043|  10.9k|          else if (mb_available_left[1])                     s  = (s3   +2) >> 2;
 2044|   218k|          break;
 2045|   875k|        }
 2046|       |        
 2047|       |        //===== prediction =====
 2048|  4.37M|        for (j=block_y; j<block_y+4; j++)
 2049|  17.5M|          for (i=block_x; i<block_x+4; i++)
 2050|  14.0M|          {
 2051|  14.0M|            img->mprr_c[uv][DC_PRED_8][i][j] = s;
 2052|  14.0M|          }
 2053|   875k|      }
 2054|   218k|    }
 2055|       |
 2056|       |    // vertical prediction
 2057|   218k|    if (mb_available_up)
 2058|   207k|    {
 2059|  1.87M|      for (i=0; i<cr_MB_x; i++)
 2060|  1.66M|        hline[i] = image[up.pos_y][up.pos_x + i];
 2061|  1.87M|      for (i=0; i<cr_MB_x; i++)
 2062|  14.9M|        for (j=0; j<cr_MB_y; j++)
 2063|  13.3M|          img->mprr_c[uv][VERT_PRED_8][i][j] = hline[i];
 2064|   207k|    }
 2065|       |
 2066|       |    // horizontal prediction 
 2067|   218k|    if (mb_available_left[0] && mb_available_left[1])
 2068|   212k|    {
 2069|  1.90M|      for (i=0; i<cr_MB_y; i++)
 2070|  1.69M|        vline[i] = image[left[i+1].pos_y][left[i+1].pos_x];
 2071|  1.90M|      for (i=0; i<cr_MB_x; i++)
 2072|  15.2M|        for (j=0; j<cr_MB_y; j++)
 2073|  13.5M|          img->mprr_c[uv][HOR_PRED_8][i][j] = vline[j];
 2074|   212k|    }
 2075|       |
 2076|       |    // plane prediction
 2077|   218k|    if (mb_available_left[0] && mb_available_left[1] && mb_available_up && mb_available_up_left)
 2078|   201k|    {
 2079|   201k|      ih = cr_MB_x/2*(hline[cr_MB_x-1] - image[left[0].pos_y][left[0].pos_x]);
 2080|   805k|      for (i=0;i<cr_MB_x/2-1;i++)
 2081|   604k|        ih += (i+1)*(hline[cr_MB_x/2+i] - hline[cr_MB_x/2-2-i]);
 2082|       |
 2083|   201k|      iv = cr_MB_y/2*(vline[cr_MB_y-1] - image[left[0].pos_y][left[0].pos_x]);
 2084|   805k|      for (i=0;i<cr_MB_y/2-1;i++)
 2085|   604k|        iv += (i+1)*(vline[cr_MB_y/2+i] - vline[cr_MB_y/2-2-i]);
 2086|       |
 2087|   201k|      ib= ((cr_MB_x == 8?17:5)*ih+2*cr_MB_x)>>(cr_MB_x == 8?5:6);
 2088|   201k|      ic= ((cr_MB_y == 8?17:5)*iv+2*cr_MB_y)>>(cr_MB_y == 8?5:6);
 2089|       |
 2090|   201k|      iaa=16*(hline[cr_MB_x-1]+vline[cr_MB_y-1]);
 2091|  1.81M|      for (j=0; j<cr_MB_y; j++)
 2092|  14.5M|        for (i=0; i<cr_MB_x; i++)
 2093|  12.8M|          img->mprr_c[uv][PLANE_8][i][j]=max(0,min(img->max_imgpel_value_uv,
 2094|   201k|                                                   (iaa+(i-cr_MB_x/2+1)*ib+(j-cr_MB_y/2+1)*ic+16)>>5));
 2095|   201k|    }
 2096|   218k|  }
 2097|       |
 2098|   109k|  if (!input->rdopt)      // the rd-opt part does not work correctly (see encode_one_macroblock)
 2099|      0|  {                       // since ipredmodes could be overwritten => encoder-decoder-mismatches
 2100|       |    // pick lowest cost prediction mode
 2101|      0|    min_cost = INT_MAX;
 2102|      0|    for (i=0;i<cr_MB_y;i++)
 2103|      0|    {
 2104|      0|      getNeighbour(mb_nr, 0 , i, 0, &left[i]);
 2105|      0|    }
 2106|      0|    for (mode=DC_PRED_8; mode<=PLANE_8; mode++)
 2107|      0|    {
 2108|      0|        if (input->ChromaIntraDisable == 1 && mode!=DC_PRED_8)
 2109|      0|          continue;
 2110|       |
 2111|      0|      if ((mode==VERT_PRED_8 && !mb_available_up) ||
 2112|      0|          (mode==HOR_PRED_8 && (!mb_available_left[0] || !mb_available_left[1])) ||
 2113|      0|          (mode==PLANE_8 && (!mb_available_left[0] || !mb_available_left[1] || !mb_available_up || !mb_available_up_left)))
 2114|      0|        continue;
 2115|       |
 2116|      0|      cost = 0;
 2117|      0|      for (uv=0; uv<2; uv++)
 2118|      0|      {
 2119|      0|        image = imgUV_org[uv];
 2120|      0|        for (block_y=0; block_y<cr_MB_y; block_y+=4)
 2121|      0|          for (block_x=0; block_x<cr_MB_x; block_x+=4)
 2122|      0|          {
 2123|      0|            for (k=0,j=block_y; j<block_y+4; j++)
 2124|      0|              for (i=block_x; i<block_x+4; i++,k++)
 2125|      0|              {
 2126|      0|                diff[k] = image[left[j].pos_y][left[j].pos_x+i] - img->mprr_c[uv][mode][i][j];
 2127|      0|              }
 2128|      0|            cost += SATD(diff, input->hadamard);
 2129|      0|          }
 2130|      0|      }
 2131|      0|      if (cost < min_cost)
 2132|      0|      {
 2133|      0|        best_mode = mode;
 2134|      0|        min_cost = cost;
 2135|      0|      }
 2136|      0|    }
 2137|       |
 2138|      0|    currMB->c_ipred_mode = best_mode;
 2139|      0|  }
 2140|       | 
 2141|   109k|}
 2142|       |
 2143|       |
 2144|       |/*!
 2145|       | ************************************************************************
 2146|       | * \brief
 2147|       | *    Check if all reference frames for a macroblock are zero
 2148|       | ************************************************************************
 2149|       | */
 2150|       |int
 2151|       |ZeroRef (Macroblock* currMB)
 2152|  92.7k|{
 2153|  92.7k|  int i,j;
 2154|       |
 2155|   359k|  for (j=0; j<4; j++)
 2156|  1.37M|  for (i=0; i<4; i++)
 2157|  1.10M|  {
 2158|  1.10M|    if (enc_picture->ref_idx[LIST_0][img->block_x+i][img->block_y+j]!=0)
 2159|  29.0k|    {
 2160|  29.0k|        return 0;
 2161|  29.0k|    }
 2162|  1.10M|  }
 2163|  63.6k|  return 1;
 2164|  92.7k|}
 2165|       |
 2166|       |
 2167|       |/*!
 2168|       | ************************************************************************
 2169|       | * \brief
 2170|       | *    Converts macroblock type to coding value
 2171|       | ************************************************************************
 2172|       | */
 2173|       |int
 2174|       |MBType2Value (Macroblock* currMB)
 2175|  1.61M|{
 2176|  1.61M|  static const int dir1offset[3]    =  { 1,  2, 3};
 2177|  1.61M|  static const int dir2offset[3][3] = {{ 0,  4,  8},   // 1. block forward
 2178|  1.61M|                                       { 6,  2, 10},   // 1. block backward
 2179|  1.61M|                                       {12, 14, 16}};  // 1. block bi-directional
 2180|       |
 2181|  1.61M|  int mbtype, pdir0, pdir1;
 2182|       |
 2183|  1.61M|  if (img->type!=B_SLICE)
 2184|   660k|  {
 2185|   660k|    if      (currMB->mb_type==I8MB ||currMB->mb_type==I4MB)
 2186|   216k|      return (img->type==I_SLICE ? 0 : 6);
 2187|   443k|    else if (currMB->mb_type==I16MB)    return (img->type==I_SLICE ? 0 : 6) + img->i16offset;
 2188|   210k|    else if (currMB->mb_type==P8x8)
 2189|  37.9k|    {
 2190|  37.9k|      if (input->symbol_mode==UVLC && ZeroRef (currMB))  return 5;
 2191|  37.9k|      else                                               return 4;
 2192|  37.9k|    }
 2193|   173k|    else                                return currMB->mb_type;
 2194|   660k|  }
 2195|   954k|  else
 2196|   954k|  {
 2197|   954k|    mbtype = currMB->mb_type;
 2198|   954k|    pdir0  = currMB->b8pdir[0];
 2199|   954k|    pdir1  = currMB->b8pdir[3];
 2200|       |
 2201|   954k|    if      (mbtype==0)       return 0;
 2202|   753k|    else if (mbtype==I4MB || mbtype==I8MB)
 2203|   208k|      return 23;
 2204|   544k|    else if (mbtype==I16MB)   return 23 + img->i16offset;
 2205|   335k|    else if (mbtype==P8x8)    return 22;
 2206|   280k|    else if (mbtype==1)       return dir1offset[pdir0];
 2207|   109k|    else if (mbtype==2)       return 4 + dir2offset[pdir0][pdir1];
 2208|  54.7k|    else                      return 5 + dir2offset[pdir0][pdir1];
 2209|   954k|  }
 2210|  1.61M|}
 2211|       |
 2212|       |
 2213|       |
 2214|       |/*!
 2215|       | ************************************************************************
 2216|       | * \brief
 2217|       | *    Writes intra prediction modes for an 8x8 block
 2218|       | ************************************************************************
 2219|       | */
 2220|       |int writeIntra4x4Modes(int only_this_block)
 2221|  1.61M|{
 2222|  1.61M|  int i,j,bs_x,bs_y,ii,jj;
 2223|  1.61M|  int block8x8;
 2224|  1.61M|  int rate;
 2225|  1.61M|  int ipred_array[16],cont_array[16],ipred_number;
 2226|  1.61M|  Macroblock    *currMB     = &img->mb_data[img->current_mb_nr];
 2227|  1.61M|  SyntaxElement *currSE     = &img->MB_SyntaxElements[currMB->currSEnr];
 2228|  1.61M|  int           *bitCount   = currMB->bitcounter;
 2229|  1.61M|  Slice         *currSlice  = img->currentSlice;
 2230|  1.61M|  DataPartition *dataPart;
 2231|  1.61M|  const int     *partMap    = assignSE2partition[input->partition_mode];
 2232|       |
 2233|  1.61M|  ipred_number=0;
 2234|  8.07M|  for(block8x8=0;block8x8<4;block8x8++)
 2235|  6.45M|  {
 2236|  6.45M|    if((( currMB->b8mode[block8x8]==IBLOCK && (only_this_block<0||only_this_block==block8x8)) ||
 2237|  6.45M|      ((currMB->b8mode[block8x8]==I8MB) && (only_this_block<0||only_this_block==block8x8))))
 2238|  1.70M|    {
 2239|  1.70M|      bs_x = bs_y = (currMB->b8mode[block8x8] == I8MB)?8:4; 
 2240|  1.70M|      ii=(bs_x>>2); // bug fix for solaris. mwi 
 2241|  1.70M|      jj=(bs_y>>2); // bug fix for solaris. mwi
 2242|       |      
 2243|  5.10M|      for(j=0;j<2;j+=jj)
 2244|  3.40M|      {
 2245|  10.2M|        for(i=0;i<2;i+=ii)
 2246|  6.80M|        {
 2247|  6.80M|          ipred_array[ipred_number]=currMB->intra_pred_modes[(block8x8<<2)|(j<<1)|i];
 2248|  6.80M|          cont_array[ipred_number]=(block8x8<<2)+(j<<1)+i;
 2249|  6.80M|          ipred_number++;
 2250|  6.80M|        }
 2251|  3.40M|      }
 2252|  1.70M|    }
 2253|  6.45M|  }
 2254|  1.61M|  rate=0;
 2255|       |
 2256|  8.41M|  for(i=0;i<ipred_number;i++)
 2257|  6.80M|  {
 2258|  6.80M|    currMB->IntraChromaPredModeFlag = 1;
 2259|  6.80M|    currSE->context = cont_array[i];
 2260|  6.80M|    currSE->value1  = ipred_array[i];
 2261|  6.80M|    currSE->value2  = 0;
 2262|       |
 2263|       |#if TRACE
 2264|       |    snprintf(currSE->tracestring, TRACESTRING_SIZE, "Intra mode     = %3d %d",currSE->value1,currSE->context);
 2265|       |#endif
 2266|       |
 2267|       |    /*--- set symbol type and function pointers ---*/
 2268|  6.80M|    if (input->symbol_mode != UVLC)    currSE->writing = writeIntraPredMode_CABAC;
 2269|  6.80M|    currSE->type = SE_INTRAPREDMODE;
 2270|       |
 2271|       |    /*--- choose data partition ---*/
 2272|  6.80M|    dataPart = &(currSlice->partArr[partMap[SE_INTRAPREDMODE]]);   
 2273|       |    /*--- encode and update rate ---*/
 2274|  6.80M|    if (input->symbol_mode == UVLC)    writeSyntaxElement_Intra4x4PredictionMode(currSE, dataPart);
 2275|  6.80M|    else                               dataPart->writeSyntaxElement (currSE, dataPart);
 2276|  6.80M|    bitCount[BITS_COEFF_Y_MB]+=currSE->len;
 2277|  6.80M|    rate += currSE->len;
 2278|  6.80M|    currSE++;
 2279|  6.80M|    currMB->currSEnr++;
 2280|  6.80M|  }
 2281|       |
 2282|  1.61M|  return rate;
 2283|  1.61M|}
 2284|       |
 2285|       |
 2286|       |
 2287|       |/*!
 2288|       | ************************************************************************
 2289|       | * \brief
 2290|       | *    Converts 8x8 block tyoe to coding value
 2291|       | ************************************************************************
 2292|       | */
 2293|       |int
 2294|       |B8Mode2Value (int b8mode, int b8pdir)
 2295|  2.04M|{
 2296|  2.04M|  static const int b8start[8] = {0,0,0,0, 1, 4, 5, 10};
 2297|  2.04M|  static const int b8inc  [8] = {0,0,0,0, 1, 2, 2, 1};
 2298|       |  
 2299|  2.04M|  if (img->type!=B_SLICE)
 2300|   735k|  {
 2301|   735k|    return (b8mode-4);
 2302|   735k|  }
 2303|  1.30M|  else
 2304|  1.30M|  {
 2305|  1.30M|    return b8start[b8mode] + b8inc[b8mode] * b8pdir;
 2306|  1.30M|  }
 2307|  2.04M|}
 2308|       |
 2309|       |/*!
 2310|       |************************************************************************
 2311|       |* \brief
 2312|       |*    Codes macroblock header
 2313|       |************************************************************************
 2314|       |*/
 2315|       |int writeMBLayer (int rdopt)  // GB CHROMA !!!!!!!!
 2316|  1.61M|{
 2317|  1.61M|  int             i,j;
 2318|  1.61M|  int             mb_nr     = img->current_mb_nr;
 2319|  1.61M|  Macroblock*     currMB    = &img->mb_data[mb_nr];
 2320|  1.61M|  Macroblock*     prevMB    = mb_nr ? (&img->mb_data[mb_nr-1]) : NULL;
 2321|  1.61M|  SyntaxElement  *currSE    = &img->MB_SyntaxElements[currMB->currSEnr];
 2322|  1.61M|  int*            bitCount  = currMB->bitcounter;
 2323|  1.61M|  Slice*          currSlice = img->currentSlice;
 2324|  1.61M|  DataPartition*  dataPart;
 2325|  1.61M|  const int*      partMap   = assignSE2partition[input->partition_mode];
 2326|  1.61M|  int             no_bits   = 0;
 2327|  1.61M|  int             skip      = currMB->mb_type ? 0:((img->type == B_SLICE) ? !currMB->cbp:1);
 2328|  1.61M|  int             mb_type;
 2329|  1.61M|  int             prevMbSkipped = 0;
 2330|  1.61M|  int             mb_field_tmp;
 2331|  1.61M|  Macroblock      *topMB = NULL;
 2332|       |  
 2333|  1.61M|  int             WriteFrameFieldMBInHeader = 0;
 2334|       |
 2335|  1.61M|  if (img->MbaffFrameFlag)
 2336|      0|  {
 2337|      0|    if (0==(mb_nr%2))
 2338|      0|    {
 2339|      0|      WriteFrameFieldMBInHeader = 1; // top field
 2340|       |
 2341|      0|      prevMbSkipped = 0;
 2342|      0|    }
 2343|      0|    else
 2344|      0|    {
 2345|      0|      if (prevMB->mb_type ? 0:((img->type == B_SLICE) ? !prevMB->cbp:1))
 2346|      0|      {
 2347|      0|        WriteFrameFieldMBInHeader = 1; // bottom, if top was skipped
 2348|      0|      }
 2349|       |
 2350|      0|      topMB= &img->mb_data[img->current_mb_nr-1];
 2351|      0|      if(!(img->type == B_SLICE))
 2352|      0|        prevMbSkipped = (topMB->mb_type == 0);
 2353|      0|      else 
 2354|      0|        prevMbSkipped = (topMB->mb_type == 0 && topMB->cbp == 0);
 2355|      0|    }
 2356|      0|  }
 2357|  1.61M|  currMB->IntraChromaPredModeFlag = IS_INTRA(currMB);
 2358|       |
 2359|       |  // choose the appropriate data partition
 2360|  1.61M|  dataPart = &(currSlice->partArr[partMap[SE_MBTYPE]]);
 2361|       |  
 2362|  1.61M|  if(img->type == I_SLICE)//GB
 2363|   161k|  {
 2364|       |    //========= write mb_aff (I_SLICE) =========
 2365|   161k|    if(img->MbaffFrameFlag && !skip) // check for copy mode, Krit
 2366|      0|    {
 2367|      0|      if(WriteFrameFieldMBInHeader)
 2368|      0|      {
 2369|      0|        currSE->value1 =  currMB->mb_field;
 2370|      0|        currSE->value2 = 0;
 2371|      0|        currSE->type   =  SE_MBTYPE;
 2372|       |        
 2373|      0|        if (input->symbol_mode==UVLC)   currSE->mapping = ue_linfo;
 2374|      0|        else                            currSE->writing = writeFieldModeInfo_CABAC;
 2375|       |        
 2376|       |#if TRACE
 2377|       |        snprintf(currSE->tracestring, TRACESTRING_SIZE, "Field mode = %3d",currMB->mb_field);
 2378|       |#endif
 2379|      0|        if( input->symbol_mode==UVLC)
 2380|      0|        {
 2381|      0|          currSE->bitpattern = (currMB->mb_field ? 1 : 0);
 2382|      0|          currSE->len = 1;
 2383|      0|          writeSyntaxElement2Buf_Fixed(currSE, dataPart->bitstream);
 2384|      0|        }
 2385|      0|        else
 2386|      0|        {
 2387|      0|          dataPart->writeSyntaxElement(currSE, dataPart);
 2388|      0|        }
 2389|       |
 2390|      0|        bitCount[BITS_MB_MODE] += currSE->len;
 2391|      0|        no_bits                += currSE->len;
 2392|      0|        currSE++;
 2393|      0|        currMB->currSEnr++;
 2394|      0|      }
 2395|      0|    }
 2396|       |    
 2397|       |    //========= write mb_type (I_SLICE) =========
 2398|   161k|    currSE->value1  = MBType2Value (currMB);
 2399|   161k|    currSE->value2  = 0;
 2400|   161k|    currSE->type    = SE_MBTYPE;
 2401|       |
 2402|   161k|    if (input->symbol_mode == UVLC)  currSE->mapping = ue_linfo;
 2403|   161k|    else                             currSE->writing = writeMB_typeInfo_CABAC;
 2404|       |
 2405|   161k|    dataPart->writeSyntaxElement( currSE, dataPart);
 2406|       |#if TRACE
 2407|       |    snprintf(currSE->tracestring, TRACESTRING_SIZE,   "MB mode(%2d,%2d) = %3d",img->mb_x, img->mb_y, currMB->mb_type);
 2408|       |#endif
 2409|   161k|    bitCount[BITS_MB_MODE] += currSE->len;
 2410|   161k|    no_bits                += currSE->len;
 2411|   161k|    currSE++;
 2412|   161k|    currMB->currSEnr++;
 2413|   161k|  }
 2414|  1.45M|  else if (input->symbol_mode == CABAC)//GB
 2415|  1.45M|  {
 2416|  1.45M|    if (img->MbaffFrameFlag && (img->current_mb_nr%2 == 0||prevMbSkipped))
 2417|      0|    {
 2418|      0|      mb_field_tmp = currMB->mb_field;
 2419|      0|      currMB->mb_field = field_flag_inference();
 2420|      0|      CheckAvailabilityOfNeighborsCABAC();
 2421|      0|      currMB->mb_field = mb_field_tmp;
 2422|      0|    }
 2423|       |    
 2424|       |    //========= write mb_skip_flag (CABAC) =========
 2425|  1.45M|    mb_type         = MBType2Value (currMB);
 2426|  1.45M|    currSE->value1  = mb_type;
 2427|  1.45M|    currSE->value2  = currMB->cbp;
 2428|  1.45M|    currSE->type    = SE_MBTYPE;
 2429|  1.45M|    currSE->writing = writeMB_skip_flagInfo_CABAC;
 2430|  1.45M|    dataPart->writeSyntaxElement( currSE, dataPart);
 2431|       |#if TRACE
 2432|       |    if (img->type == B_SLICE)  snprintf(currSE->tracestring, TRACESTRING_SIZE, "B_MB skipflag(%2d,%2d) = %3d",img->mb_x, img->mb_y, (mb_type!=0 ||currMB->cbp!=0));
 2433|       |    else                     snprintf(currSE->tracestring, TRACESTRING_SIZE,   "MB skipflag(%2d,%2d,%d) = %3d",img->mb_x, img->mb_y, currSE->context,(mb_type!=0));
 2434|       |#endif
 2435|  1.45M|    bitCount[BITS_MB_MODE] += currSE->len;
 2436|  1.45M|    no_bits                += currSE->len;
 2437|  1.45M|    currSE++;
 2438|  1.45M|    currMB->currSEnr++;
 2439|       |
 2440|  1.45M|    CheckAvailabilityOfNeighborsCABAC();
 2441|       |    
 2442|       |    //========= write mb_aff (CABAC) =========
 2443|  1.45M|    if(img->MbaffFrameFlag && !skip) // check for copy mode, Krit
 2444|      0|    {
 2445|      0|      if(WriteFrameFieldMBInHeader)
 2446|      0|      {
 2447|      0|        currSE->value1 = currMB->mb_field;
 2448|      0|        currSE->value2 = 0;
 2449|      0|        currSE->type   =  SE_MBTYPE;
 2450|       |
 2451|      0|        if (input->symbol_mode==UVLC)   currSE->mapping = ue_linfo;
 2452|      0|        else                            currSE->writing = writeFieldModeInfo_CABAC;
 2453|       |
 2454|      0|        if( input->symbol_mode==UVLC)
 2455|      0|        {
 2456|      0|          currSE->bitpattern = (currMB->mb_field ? 1 : 0);
 2457|      0|          currSE->len = 1;
 2458|      0|          writeSyntaxElement2Buf_Fixed(currSE, dataPart->bitstream);
 2459|      0|        }
 2460|      0|        else
 2461|      0|        {
 2462|      0|          dataPart->writeSyntaxElement(currSE, dataPart);
 2463|      0|        }
 2464|       |#if TRACE
 2465|       |        snprintf(currSE->tracestring, TRACESTRING_SIZE, "Field mode = %3d",currMB->mb_field);
 2466|       |#endif
 2467|      0|        bitCount[BITS_MB_MODE] += currSE->len;
 2468|      0|        no_bits                += currSE->len;
 2469|      0|        currSE++;
 2470|      0|        currMB->currSEnr++;
 2471|      0|      }
 2472|      0|    }
 2473|       |    
 2474|       |    //========= write mb_type (CABAC) =========
 2475|  1.45M|    if (currMB->mb_type != 0 || ((img->type == B_SLICE) && currMB->cbp != 0))
 2476|  1.20M|    {
 2477|  1.20M|      currSE->value1  = mb_type;
 2478|  1.20M|      currSE->value2  = 0;
 2479|  1.20M|      currSE->type    = SE_MBTYPE;
 2480|  1.20M|      currSE->writing = writeMB_typeInfo_CABAC;
 2481|  1.20M|      dataPart->writeSyntaxElement( currSE, dataPart);
 2482|       |#if TRACE
 2483|       |      if (img->type == B_SLICE)  snprintf(currSE->tracestring, TRACESTRING_SIZE, "B_MB mode(%2d,%2d) = %3d",img->mb_x, img->mb_y, currMB->mb_type);
 2484|       |      else                     snprintf(currSE->tracestring, TRACESTRING_SIZE,   "MB mode(%2d,%2d) = %3d",img->mb_x, img->mb_y,currMB->mb_type);
 2485|       |#endif
 2486|  1.20M|      bitCount[BITS_MB_MODE] += currSE->len;
 2487|  1.20M|      no_bits                += currSE->len;
 2488|  1.20M|      currSE++;
 2489|  1.20M|      currMB->currSEnr++;
 2490|  1.20M|    }
 2491|  1.45M|  }
 2492|       |
 2493|      0|  else if (currMB->mb_type != 0 || ((img->type == B_SLICE) && currMB->cbp != 0))
 2494|      0|  {
 2495|       |    //===== Run Length Coding: Non-Skipped macorblock =====
 2496|      0|    currSE->value1  = img->cod_counter;
 2497|      0|    currSE->value2  = 0;
 2498|      0|    currSE->mapping = ue_linfo;
 2499|      0|    currSE->type    = SE_MBTYPE;
 2500|      0|    dataPart->writeSyntaxElement( currSE, dataPart);
 2501|       |#if TRACE
 2502|       |    snprintf(currSE->tracestring, TRACESTRING_SIZE, "MB runlength = %3d",img->cod_counter);
 2503|       |#endif
 2504|      0|    bitCount[BITS_MB_MODE] += currSE->len;
 2505|      0|    no_bits                += currSE->len;
 2506|      0|    currSE++;
 2507|      0|    currMB->currSEnr++;
 2508|       |    
 2509|       |    // Reset cod counter
 2510|      0|    img->cod_counter = 0;
 2511|       |    
 2512|       |    // write mb_aff
 2513|      0|    if(img->MbaffFrameFlag && !skip) // check for copy mode, Krit
 2514|      0|    {
 2515|      0|      if(WriteFrameFieldMBInHeader)
 2516|      0|      {
 2517|      0|        currSE->value1 = currMB->mb_field;
 2518|      0|        currSE->type   =  SE_MBTYPE;
 2519|      0|        currSE->mapping = ue_linfo;
 2520|       |        
 2521|       |        //dataPart->writeSyntaxElement(currSE, dataPart);
 2522|      0|        currSE->bitpattern = (currMB->mb_field ? 1 : 0);
 2523|      0|        currSE->len = 1;
 2524|      0|        writeSyntaxElement2Buf_Fixed(currSE, dataPart->bitstream);
 2525|       |
 2526|       |#if TRACE
 2527|       |        snprintf(currSE->tracestring, TRACESTRING_SIZE, "Field mode = %3d",currMB->mb_field);
 2528|       |#endif
 2529|      0|        bitCount[BITS_MB_MODE] += currSE->len;
 2530|      0|        no_bits                += currSE->len;
 2531|      0|        currSE++;
 2532|      0|        currMB->currSEnr++;
 2533|      0|      }
 2534|      0|    }
 2535|       |    // Put out mb mode
 2536|      0|    currSE->value1  = MBType2Value (currMB);
 2537|       |
 2538|      0|    if (img->type != B_SLICE)
 2539|      0|    {
 2540|      0|      currSE->value1--;
 2541|      0|    }
 2542|      0|    currSE->mapping = ue_linfo;
 2543|      0|    currSE->type    = SE_MBTYPE;
 2544|      0|    currSE->value2  = 0;
 2545|       |
 2546|      0|    dataPart->writeSyntaxElement( currSE, dataPart);
 2547|       |#if TRACE
 2548|       |    if (img->type == B_SLICE)   snprintf(currSE->tracestring, TRACESTRING_SIZE, "B_MB mode(%2d,%2d) = %3d",img->mb_x, img->mb_y, currMB->mb_type);
 2549|       |    else                      snprintf(currSE->tracestring, TRACESTRING_SIZE,   "MB mode(%2d,%2d) = %3d",img->mb_x, img->mb_y,currMB->mb_type);
 2550|       |#endif
 2551|      0|    bitCount[BITS_MB_MODE] += currSE->len;
 2552|      0|    no_bits                += currSE->len;
 2553|      0|    currSE++;
 2554|      0|    currMB->currSEnr++;
 2555|      0|  }
 2556|      0|  else
 2557|      0|  {
 2558|       |    //Run Length Coding: Skipped macroblock
 2559|      0|    img->cod_counter++;
 2560|       |
 2561|       |    // CAVLC
 2562|      0|    for (j=0; j < (4 + img->num_blk8x8_uv); j++)
 2563|      0|      for (i=0; i < 4; i++)
 2564|      0|        img->nz_coeff [img->current_mb_nr][i][j]=0;
 2565|       |
 2566|       |
 2567|      0|    if(img->current_mb_nr == img->total_number_mb)
 2568|      0|    {
 2569|       |      // Put out run
 2570|      0|      currSE->value1  = img->cod_counter;
 2571|      0|      currSE->value2  = 0;
 2572|      0|      currSE->mapping = ue_linfo;
 2573|      0|      currSE->type    = SE_MBTYPE;
 2574|       |
 2575|      0|      dataPart->writeSyntaxElement( currSE, dataPart);
 2576|       |#if TRACE
 2577|       |      snprintf(currSE->tracestring, TRACESTRING_SIZE, "MB runlength = %3d",img->cod_counter);
 2578|       |#endif
 2579|      0|      bitCount[BITS_MB_MODE] += currSE->len;
 2580|      0|      no_bits                += currSE->len;
 2581|      0|      currSE++;
 2582|      0|      currMB->currSEnr++;
 2583|       |
 2584|       |      // Reset cod counter
 2585|      0|      img->cod_counter = 0;
 2586|      0|    }
 2587|      0|  }
 2588|       |
 2589|       |  //init NoMbPartLessThan8x8Flag
 2590|  1.61M|  currMB->NoMbPartLessThan8x8Flag = (IS_DIRECT(currMB) && !(active_sps->direct_8x8_inference_flag))? 0: 1;
 2591|       |  
 2592|       |  //===== BITS FOR 8x8 SUB-PARTITION MODES =====
 2593|  1.61M|  if (IS_P8x8 (currMB))
 2594|  92.7k|  {
 2595|  92.7k|    dataPart = &(currSlice->partArr[partMap[SE_MBTYPE]]);
 2596|       |    
 2597|   463k|    for (i=0; i<4; i++)
 2598|   370k|    {
 2599|   370k|      if (input->symbol_mode==UVLC)   currSE->mapping = ue_linfo;
 2600|   370k|      else                            currSE->writing = writeB8_typeInfo_CABAC;
 2601|       |
 2602|   370k|      currSE->value1  = B8Mode2Value (currMB->b8mode[i], currMB->b8pdir[i]);
 2603|   370k|      currSE->value2  = 0;
 2604|   370k|      currSE->type    = SE_MBTYPE;
 2605|   370k|      dataPart->writeSyntaxElement (currSE, dataPart);
 2606|       |#if TRACE
 2607|       |      snprintf(currSE->tracestring, TRACESTRING_SIZE, "8x8 mode/pdir(%2d) = %3d/%d",
 2608|       |        i,currMB->b8mode[i],currMB->b8pdir[i]);
 2609|       |#endif
 2610|   370k|      bitCount[BITS_MB_MODE]+= currSE->len;
 2611|   370k|      no_bits               += currSE->len;
 2612|   370k|      currSE++;
 2613|   370k|      currMB->currSEnr++;
 2614|       |
 2615|       |      //set NoMbPartLessThan8x8Flag for P8x8 mode
 2616|   370k|      currMB->NoMbPartLessThan8x8Flag &= (currMB->b8mode[i]==0 && active_sps->direct_8x8_inference_flag) || 
 2617|   370k|                                         (currMB->b8mode[i]==4);
 2618|   370k|    }
 2619|  92.7k|    no_bits += writeMotionInfo2NAL  ();
 2620|  92.7k|    currSE   = &img->MB_SyntaxElements[currMB->currSEnr];
 2621|  92.7k|  }
 2622|       |
 2623|       |  //============= Transform size flag for INTRA MBs =============
 2624|       |  //-------------------------------------------------------------
 2625|       |  //transform size flag for INTRA_4x4 and INTRA_8x8 modes
 2626|  1.61M|  if ((currMB->mb_type == I8MB || currMB->mb_type == I4MB) && input->AllowTransform8x8)
 2627|      0|  {
 2628|      0|    currSE->value1 = currMB->luma_transform_size_8x8_flag;
 2629|      0|    currSE->type   = SE_TRANSFORM_SIZE_FLAG;
 2630|       |    
 2631|      0|    if (input->symbol_mode==UVLC)   currSE->mapping = ue_linfo;
 2632|      0|    else                            currSE->writing = writeMB_transform_size_CABAC;
 2633|       |    
 2634|      0|    if( input->symbol_mode==UVLC)
 2635|      0|    {
 2636|      0|      currSE->bitpattern = currMB->luma_transform_size_8x8_flag;
 2637|      0|      currSE->len = 1;
 2638|      0|      writeSyntaxElement2Buf_Fixed(currSE, dataPart->bitstream);
 2639|      0|    }
 2640|      0|    else
 2641|      0|    {
 2642|      0|      dataPart->writeSyntaxElement(currSE, dataPart);
 2643|      0|    }
 2644|       |#if TRACE
 2645|       |    snprintf(currSE->tracestring, TRACESTRING_SIZE, "transform size 8x8 flag = %3d", currMB->luma_transform_size_8x8_flag);
 2646|       |#endif
 2647|       |    
 2648|      0|    bitCount[BITS_MB_MODE] += currSE->len;
 2649|      0|    no_bits                += currSE->len;
 2650|      0|    currSE++;
 2651|      0|    currMB->currSEnr++;
 2652|      0|  }
 2653|       |  
 2654|       |    
 2655|       | //===== BITS FOR INTRA PREDICTION MODES ====
 2656|  1.61M|  no_bits += writeIntra4x4Modes(-1);
 2657|       |  //===== BITS FOR CHROMA INTRA PREDICTION MODE ====
 2658|  1.61M|  if (currMB->IntraChromaPredModeFlag && img->yuv_format != YUV400)
 2659|   867k|    no_bits += writeChromaIntraPredMode();
 2660|   747k|  else if(!rdopt) //GB CHROMA !!!!!
 2661|  82.6k|    currMB->c_ipred_mode = DC_PRED_8; //setting c_ipred_mode to default is not the right place here
 2662|       |                                      //resetting in rdopt.c (but where ??)
 2663|       |                                      //with cabac and bframes maybe it could crash without this default
 2664|       |                                      //since cabac needs the right neighborhood for the later MBs
 2665|       |
 2666|  1.61M|  if (currMB->mb_type !=0 && currMB->mb_type !=P8x8)
 2667|  1.26M|  {
 2668|       |    //----- motion information -----
 2669|  1.26M|    no_bits  += writeMotionInfo2NAL  ();
 2670|  1.26M|  }
 2671|       |  
 2672|  1.61M|  if ((currMB->mb_type!=0) || (img->type==B_SLICE && (currMB->cbp!=0)))
 2673|  1.36M|  {
 2674|  1.36M|    no_bits  += writeCBPandLumaCoeff ();
 2675|  1.36M|    if (img->yuv_format != YUV400)
 2676|  1.36M|      no_bits  += writeChromaCoeff     ();
 2677|  1.36M|  }
 2678|       |  
 2679|  1.61M|  return no_bits;
 2680|  1.61M|}
 2681|       |
 2682|       |void write_terminating_bit (short bit)
 2683|   109k|{
 2684|   109k|  DataPartition*          dataPart;
 2685|   109k|  const int*              partMap   = assignSE2partition[input->partition_mode];
 2686|   109k|  EncodingEnvironmentPtr  eep_dp;
 2687|       |
 2688|       |  //--- write non-slice termination symbol if the macroblock is not the first one in its slice ---
 2689|   109k|  dataPart = &(img->currentSlice->partArr[partMap[SE_MBTYPE]]);
 2690|   109k|  dataPart->bitstream->write_flag = 1;
 2691|   109k|  eep_dp                          = &(dataPart->ee_cabac);
 2692|       |  
 2693|   109k|  biari_encode_symbol_final(eep_dp, bit); 
 2694|       |#if TRACE
 2695|       |  fprintf (p_trace, "      CABAC terminating bit = %d\n",bit);
 2696|       |#endif
 2697|       |
 2698|   109k|}
 2699|       |
 2700|       |
 2701|       |/*!
 2702|       | ************************************************************************
 2703|       | * \brief
 2704|       | *    Write chroma intra prediction mode.
 2705|       | ************************************************************************
 2706|       | */
 2707|       |int writeChromaIntraPredMode()
 2708|   867k|{
 2709|   867k|  Macroblock*     currMB    = &img->mb_data[img->current_mb_nr];
 2710|   867k|  SyntaxElement*  currSE    = &img->MB_SyntaxElements[currMB->currSEnr];
 2711|   867k|  Slice*          currSlice = img->currentSlice;
 2712|   867k|  int*            bitCount  = currMB->bitcounter;
 2713|   867k|  const int*      partMap   = assignSE2partition[input->partition_mode];
 2714|   867k|  int             rate      = 0;
 2715|   867k|  DataPartition*  dataPart;
 2716|       |
 2717|       |  //===== BITS FOR CHROMA INTRA PREDICTION MODES
 2718|   867k|  if (input->symbol_mode==UVLC)   currSE->mapping = ue_linfo;
 2719|   867k|  else                            currSE->writing = writeCIPredMode_CABAC;
 2720|       |
 2721|   867k|  currSE->value1 = currMB->c_ipred_mode;
 2722|   867k|  currSE->value2 = 0;
 2723|   867k|  currSE->type = SE_INTRAPREDMODE;
 2724|   867k|  dataPart = &(currSlice->partArr[partMap[SE_INTRAPREDMODE]]);
 2725|       |
 2726|   867k|  dataPart->writeSyntaxElement (currSE, dataPart);
 2727|   867k|  bitCount[BITS_COEFF_UV_MB] += currSE->len;
 2728|   867k|  rate                    += currSE->len;
 2729|       |#if TRACE
 2730|       |  snprintf(currSE->tracestring, TRACESTRING_SIZE, "Chroma intra pred mode");
 2731|       |#endif
 2732|   867k|  currSE++;
 2733|   867k|  currMB->currSEnr++;
 2734|       |
 2735|   867k|  return rate;
 2736|   867k|}
 2737|       |
 2738|       |
 2739|       |/*!
 2740|       | ************************************************************************
 2741|       | * \brief
 2742|       |*    Set global last_dquant according to macroblock delta qp
 2743|       |************************************************************************
 2744|       |*/
 2745|       |
 2746|       |extern int last_dquant;
 2747|       |
 2748|       |void set_last_dquant()
 2749|   109k|{
 2750|   109k|  Macroblock *currMB = &img->mb_data[img->current_mb_nr];
 2751|       |
 2752|   109k|  if ((IS_INTERMV (currMB)  || IS_INTRA (currMB)  ) ||
 2753|   109k|    ((img->type==B_SLICE)     && currMB->cbp != 0)  )
 2754|  47.0k|  {
 2755|       |    // non-skip
 2756|  47.0k|    last_dquant = currMB->delta_qp;
 2757|  47.0k|  }
 2758|  62.3k|  else
 2759|  62.3k|  {
 2760|       |    // skip
 2761|  62.3k|    last_dquant = 0;
 2762|  62.3k|  }
 2763|   109k|}
 2764|       |
 2765|       |
 2766|       |/*!
 2767|       | ************************************************************************
 2768|       | * \brief
 2769|       | *    Passes the chosen syntax elements to the NAL
 2770|       | ************************************************************************
 2771|       | */
 2772|       |void write_one_macroblock (int eos_bit)
 2773|   109k|{
 2774|   109k|  Macroblock* currMB   = &img->mb_data[img->current_mb_nr];
 2775|   109k|  int*        bitCount = currMB->bitcounter;
 2776|   109k|  int i,j;
 2777|       |
 2778|   109k|  extern int cabac_encoding;
 2779|       |
 2780|       |  //===== init and update number of intra macroblocks =====
 2781|   109k|  if (img->current_mb_nr==0)
 2782|    171|    intras=0;
 2783|   109k|  if (IS_INTRA(currMB))
 2784|  26.7k|    intras++;
 2785|       |
 2786|       |  //--- write non-slice termination symbol if the macroblock is not the first one in its slice ---
 2787|   109k|  if (input->symbol_mode==CABAC && img->current_mb_nr!=img->currentSlice->start_mb_nr && eos_bit)
 2788|   109k|  {
 2789|   109k|    write_terminating_bit (0);
 2790|   109k|  }
 2791|       |
 2792|   109k|  cabac_encoding = 1;
 2793|       |
 2794|       |  //--- write macroblock ---
 2795|   109k|  writeMBLayer (0); 
 2796|       |
 2797|   109k|  if (!((currMB->mb_type !=0 ) || ((img->type==B_SLICE) && currMB->cbp != 0) ))
 2798|  62.3k|  { 
 2799|   436k|    for (j=0; j < (4 + img->num_blk8x8_uv); j++)
 2800|  1.87M|      for (i=0; i < 4; i++)
 2801|  1.49M|        img->nz_coeff [img->current_mb_nr][i][j]=0;  // CAVLC
 2802|  62.3k|  }
 2803|       |
 2804|   109k|  set_last_dquant();
 2805|       |
 2806|       |  //--- constrain intra prediction ---
 2807|   109k|  if(input->UseConstrainedIntraPred && (img->type==P_SLICE || img->type==B_SLICE))
 2808|      0|  {
 2809|      0|    if( !IS_INTRA(currMB) )
 2810|      0|    {
 2811|      0|      img->intra_block[img->current_mb_nr] = 0;
 2812|      0|    }
 2813|      0|  }
 2814|       |
 2815|       |  //--- set total bit-counter ---
 2816|   109k|  bitCount[BITS_TOTAL_MB] = bitCount[BITS_MB_MODE] + bitCount[BITS_COEFF_Y_MB]     + bitCount[BITS_INTER_MB]
 2817|   109k|                          + bitCount[BITS_CBP_MB]  + bitCount[BITS_DELTA_QUANT_MB] + bitCount[BITS_COEFF_UV_MB];
 2818|       |
 2819|       |  //Rate control
 2820|   109k|  img->NumberofMBHeaderBits=bitCount[BITS_MB_MODE]   + bitCount[BITS_INTER_MB]
 2821|   109k|    + bitCount[BITS_CBP_MB]  + bitCount[BITS_DELTA_QUANT_MB];
 2822|   109k|  img->NumberofMBTextureBits= bitCount[BITS_COEFF_Y_MB]+ bitCount[BITS_COEFF_UV_MB];
 2823|   109k|  img->NumberofTextureBits +=img->NumberofMBTextureBits;
 2824|   109k|  img->NumberofHeaderBits +=img->NumberofMBHeaderBits;
 2825|       |  /*basic unit layer rate control*/
 2826|   109k|  if(img->BasicUnit<img->Frame_Total_Number_MB)
 2827|      0|  {
 2828|      0|      img->NumberofBasicUnitHeaderBits +=img->NumberofMBHeaderBits;
 2829|      0|      img->NumberofBasicUnitTextureBits +=img->NumberofMBTextureBits;
 2830|      0|  }
 2831|       |  /*record the total number of MBs*/
 2832|   109k|  img->NumberofCodedMacroBlocks++;
 2833|       |  
 2834|   109k|  stats->bit_slice += bitCount[BITS_TOTAL_MB];
 2835|       |
 2836|   109k|  cabac_encoding = 0;
 2837|   109k|}
 2838|       |
 2839|       |
 2840|       |/*!
 2841|       | ************************************************************************
 2842|       | * \brief
 2843|       | *    Sets context for reference frame parameter
 2844|       | ************************************************************************
 2845|       | */
 2846|       |int BType2CtxRef (int btype)
 2847|  1.51M|{
 2848|  1.51M|  if (btype<4)   return 0;
 2849|  1.10M|  else           return 1;
 2850|  1.51M|}
 2851|       |
 2852|       |
 2853|       |/*!
 2854|       | ************************************************************************
 2855|       | * \brief
 2856|       | *    Codes the reference frame
 2857|       | ************************************************************************
 2858|       | */
 2859|       |int writeReferenceFrame (int mode, int i, int j, int fwd_flag, int  ref)
 2860|  1.76M|{
 2861|  1.76M|  Macroblock*     currMB    = &img->mb_data[img->current_mb_nr];
 2862|  1.76M|  SyntaxElement*  currSE    = &img->MB_SyntaxElements[currMB->currSEnr];
 2863|  1.76M|  Slice*          currSlice = img->currentSlice;
 2864|  1.76M|  int*            bitCount  = currMB->bitcounter;
 2865|  1.76M|  const int*      partMap   = assignSE2partition[input->partition_mode];
 2866|  1.76M|  int             rate      = 0;
 2867|  1.76M|  DataPartition*  dataPart;
 2868|  1.76M|  int             list_offset = ((img->MbaffFrameFlag)&&(currMB->mb_field))? img->current_mb_nr%2 ? 4 : 2 : 0;
 2869|  1.76M|  int             num_ref   = ( fwd_flag ? listXsize[LIST_0+list_offset]: listXsize[LIST_1+list_offset]);
 2870|  1.76M|  int             flag_mode = 0;
 2871|       |
 2872|  1.76M|  if( num_ref == 1 )
 2873|   248k|  {
 2874|   248k|    return 0;
 2875|   248k|  }
 2876|  1.51M|  if ( num_ref == 2 )
 2877|  29.0k|  {
 2878|  29.0k|    flag_mode = 1;
 2879|  29.0k|  }
 2880|       |
 2881|  1.51M|  currSE->value1 = ref;
 2882|  1.51M|  currSE->value2  = 0;
 2883|  1.51M|  currSE->type   = SE_REFFRAME;
 2884|       |
 2885|  1.51M|  dataPart = &(currSlice->partArr[partMap[currSE->type]]);
 2886|  1.51M|  if (input->symbol_mode == UVLC)
 2887|      0|  {
 2888|      0|    if( flag_mode )
 2889|      0|    {
 2890|      0|      currSE->bitpattern = 1 - currSE->value1;
 2891|      0|      currSE->len = 1;
 2892|      0|      writeSyntaxElement2Buf_Fixed(currSE, dataPart->bitstream);
 2893|      0|    }
 2894|      0|    else
 2895|      0|    {
 2896|      0|      currSE->mapping = ue_linfo;
 2897|      0|      dataPart->writeSyntaxElement (currSE, dataPart);
 2898|      0|    }
 2899|      0|  }
 2900|  1.51M|  else
 2901|  1.51M|  {
 2902|  1.51M|    currSE->context = BType2CtxRef (mode);
 2903|  1.51M|    img->subblock_x = i; // position used for context determination
 2904|  1.51M|    img->subblock_y = j; // position used for context determination
 2905|  1.51M|    currSE->writing = writeRefFrame_CABAC;
 2906|  1.51M|    currSE->value2 = (fwd_flag)? LIST_0:LIST_1;
 2907|  1.51M|    dataPart->writeSyntaxElement (currSE, dataPart);
 2908|  1.51M|  }
 2909|       |
 2910|  1.51M|  bitCount[BITS_INTER_MB] += currSE->len;
 2911|  1.51M|  rate                    += currSE->len;
 2912|       |#if TRACE
 2913|       |  if (fwd_flag)
 2914|       |  {
 2915|       |    snprintf(currSE->tracestring, TRACESTRING_SIZE, "ref_idx_l0 = %d", currSE->value1);
 2916|       |  }
 2917|       |  else
 2918|       |  {
 2919|       |    snprintf(currSE->tracestring, TRACESTRING_SIZE, "ref_idx_l1 = %d", currSE->value1);
 2920|       |  }
 2921|       |#endif
 2922|  1.51M|  currSE++;
 2923|  1.51M|  currMB->currSEnr++;
 2924|       |
 2925|  1.51M|  return rate;
 2926|  1.76M|}
 2927|       |
 2928|       |
 2929|       |/*!
 2930|       | ************************************************************************
 2931|       | * \brief
 2932|       | *    Writes motion vectors of an 8x8 block
 2933|       | ************************************************************************
 2934|       | */
 2935|       |int writeMotionVector8x8 (int  i0,
 2936|       |                          int  j0,
 2937|       |                          int  i1,
 2938|       |                          int  j1,
 2939|       |                          int  refframe,
 2940|       |                          int  list_idx,
 2941|       |                          int  mv_mode)
 2942|  2.27M|{
 2943|  2.27M|  int            i, j, k, l, m;
 2944|  2.27M|  int            curr_mvd;
 2945|  2.27M|  DataPartition* dataPart;
 2946|       |
 2947|  2.27M|  int            rate       = 0;
 2948|  2.27M|  int            step_h     = input->part_size[mv_mode][0];
 2949|  2.27M|  int            step_v     = input->part_size[mv_mode][1];
 2950|  2.27M|  Macroblock*    currMB     = &img->mb_data[img->current_mb_nr];
 2951|  2.27M|  SyntaxElement* currSE     = &img->MB_SyntaxElements[currMB->currSEnr];
 2952|  2.27M|  Slice*         currSlice  = img->currentSlice;
 2953|  2.27M|  int*           bitCount   = currMB->bitcounter;
 2954|  2.27M|  const int*     partMap    = assignSE2partition[input->partition_mode];
 2955|  2.27M|  int            refindex   = refframe;
 2956|       |
 2957|  2.27M|  short******    all_mv     = img->all_mv;
 2958|  2.27M|  short******    pred_mv    = img->pred_mv;
 2959|       |
 2960|  2.27M|#if BI_PREDICTION
 2961|  2.27M|  if (currMB->bi_pred_me && currMB->b8pdir[0]==2 && mv_mode == 1 && refindex == 0)
 2962|      0|  {
 2963|      0|      all_mv = currMB->bi_pred_me == 1? img->bipred_mv1 : img->bipred_mv2 ;
 2964|      0|  }
 2965|  2.27M|#endif
 2966|       |
 2967|  5.29M|  for (j=j0; j<j1; j+=step_v)
 2968|  7.13M|  for (i=i0; i<i1; i+=step_h)
 2969|  4.11M|  {
 2970|  12.3M|    for (k=0; k<2; k++) 
 2971|  8.23M|    {
 2972|       |
 2973|  8.23M|      curr_mvd = all_mv[i][j][list_idx][refindex][mv_mode][k] - pred_mv[i][j][list_idx][refindex][mv_mode][k];
 2974|       |
 2975|       |      //--- store (oversampled) mvd ---
 2976|  22.1M|      for (l=0; l < step_v; l++)
 2977|  41.5M|        for (m=0; m < step_h; m++)
 2978|  27.6M|        {
 2979|  27.6M|          currMB->mvd[list_idx][j+l][i+m][k] = curr_mvd;
 2980|  27.6M|        }
 2981|  8.23M|      currSE->value1 = curr_mvd;
 2982|  8.23M|      currSE->value2 = 0;
 2983|  8.23M|      currSE->type   = SE_MVD;
 2984|  8.23M|      if (input->symbol_mode == UVLC)
 2985|      0|      {
 2986|      0|        currSE->mapping = se_linfo;
 2987|      0|      }
 2988|  8.23M|      else
 2989|  8.23M|      {
 2990|  8.23M|        img->subblock_x = i; // position used for context determination
 2991|  8.23M|        img->subblock_y = j; // position used for context determination
 2992|  8.23M|        currSE->value2  = 2*k+list_idx; // identifies the component and the direction; only used for context determination
 2993|  8.23M|        currSE->writing = writeMVD_CABAC;
 2994|  8.23M|      }  
 2995|  8.23M|      dataPart = &(currSlice->partArr[partMap[SE_MVD]]);
 2996|  8.23M|      dataPart->writeSyntaxElement (currSE, dataPart);
 2997|       |#if TRACE
 2998|       |        if (!list_idx)
 2999|       |        {
 3000|       |          snprintf(currSE->tracestring, TRACESTRING_SIZE, "mvd_l0 (%d) = %3d  (org_mv %3d pred_mv %3d)",k, curr_mvd, all_mv[i][j][list_idx][refindex][mv_mode][k], pred_mv[i][j][list_idx][refindex][mv_mode][k]);
 3001|       |        }
 3002|       |        else
 3003|       |        {
 3004|       |          snprintf(currSE->tracestring, TRACESTRING_SIZE, "mvd_l1 (%d) = %3d  (org_mv %3d pred_mv %3d)",k, curr_mvd, all_mv[i][j][list_idx][refindex][mv_mode][k], pred_mv[i][j][list_idx][refindex][mv_mode][k]);
 3005|       |        }
 3006|       |
 3007|       |#endif
 3008|  8.23M|      bitCount[BITS_INTER_MB] += currSE->len;
 3009|  8.23M|      rate                    += currSE->len;
 3010|  8.23M|      currSE++;  
 3011|  8.23M|      currMB->currSEnr++;
 3012|  8.23M|    }
 3013|  4.11M|  }
 3014|       |
 3015|  2.27M|  return rate;
 3016|  2.27M|}
 3017|       |
 3018|       |
 3019|       |/*!
 3020|       | ************************************************************************
 3021|       | * \brief
 3022|       | *    Writes motion info
 3023|       | ************************************************************************
 3024|       | */
 3025|       |int writeMotionInfo2NAL ()
 3026|  1.35M|{
 3027|  1.35M|  int k, j0, i0, refframe;
 3028|       |
 3029|  1.35M|  Macroblock*     currMB    = &img->mb_data[img->current_mb_nr];
 3030|  1.35M|  int             no_bits   = 0;
 3031|  1.35M|  int   bframe          = (img->type==B_SLICE);
 3032|  1.35M|  int   step_h0         = (input->blc_size[IS_P8x8(currMB) ? 4 : currMB->mb_type][0] >> 2);
 3033|  1.35M|  int   step_v0         = (input->blc_size[IS_P8x8(currMB) ? 4 : currMB->mb_type][1] >> 2);
 3034|       |
 3035|       |  //=== If multiple ref. frames, write reference frame for the MB ===
 3036|  1.35M|  if (IS_INTERMV (currMB))
 3037|   492k|  {
 3038|       |    // if UVLC is turned on, a 8x8 macroblock with all ref=0 in a P-frame is signalled in macroblock mode
 3039|   492k|    if (!IS_P8x8 (currMB) || !ZeroRef (currMB) || input->symbol_mode==CABAC || bframe)
 3040|   492k|    {
 3041|  1.17M|      for (j0=0; j0<4; j0+=step_v0)
 3042|  1.63M|      for (i0=0; i0<4; i0+=step_h0)
 3043|   956k|      {
 3044|   956k|        k=j0+(i0/2);
 3045|       |
 3046|   956k|        if ((currMB->b8pdir[k]==0 || currMB->b8pdir[k]==2) && currMB->b8mode[k]!=0)//has forward vector
 3047|   573k|        {
 3048|   573k|          no_bits += writeReferenceFrame (currMB->b8mode[k], i0, j0, 1, enc_picture->ref_idx[LIST_0][img->block_x+i0][img->block_y+j0]);
 3049|   573k|        }
 3050|   956k|      }
 3051|  1.17M|        for (j0=0; j0<4; j0+=step_v0)
 3052|  1.63M|        for (i0=0; i0<4; i0+=step_h0)
 3053|   956k|        {
 3054|   956k|          k=j0+(i0/2);
 3055|   956k|          if ((currMB->b8pdir[k]==1 || currMB->b8pdir[k]==2) && currMB->b8mode[k]!=0)//has backward vector
 3056|   242k|          {
 3057|   242k|            no_bits += writeReferenceFrame (currMB->b8mode[k], i0, j0, 0, enc_picture->ref_idx[LIST_1][img->block_x+i0][img->block_y+j0]);
 3058|   242k|          }
 3059|   956k|        }
 3060|   492k|    }
 3061|   492k|  }
 3062|       |
 3063|       |  //===== write forward motion vectors =====
 3064|  1.35M|  if (IS_INTERMV (currMB))
 3065|   492k|  {
 3066|  1.17M|    for (j0=0; j0<4; j0+=step_v0)
 3067|  1.63M|    for (i0=0; i0<4; i0+=step_h0)
 3068|   956k|    {
 3069|   956k|      k=j0+(i0/2);
 3070|   956k|      if ((currMB->b8pdir[k]==0 || currMB->b8pdir[k]==2) && currMB->b8mode[k]!=0)//has forward vector
 3071|   573k|      {
 3072|   573k|        refframe  = enc_picture->ref_idx[LIST_0][img->block_x+i0][img->block_y+j0];
 3073|   573k|        no_bits  += writeMotionVector8x8 (i0, j0, i0+step_h0, j0+step_v0, refframe, LIST_0, currMB->b8mode[k]);
 3074|   573k|      }
 3075|   956k|    }
 3076|   492k|  }
 3077|       |
 3078|       |
 3079|       |  //===== write backward motion vectors =====
 3080|  1.35M|  if (IS_INTERMV (currMB) && bframe)
 3081|   335k|  {
 3082|   780k|    for (j0=0; j0<4; j0+=step_v0)
 3083|  1.05M|    for (i0=0; i0<4; i0+=step_h0)
 3084|   609k|    {
 3085|   609k|      k=j0+(i0/2);
 3086|   609k|      if ((currMB->b8pdir[k]==1 || currMB->b8pdir[k]==2) && currMB->b8mode[k]!=0)//has backward vector
 3087|   242k|      {
 3088|   242k|        refframe  = enc_picture->ref_idx[LIST_1][img->block_x+i0][img->block_y+j0];
 3089|   242k|        no_bits  += writeMotionVector8x8 (i0, j0, i0+step_h0, j0+step_v0, refframe, LIST_1, currMB->b8mode[k]);
 3090|   242k|      }
 3091|   609k|    }
 3092|   335k|  }
 3093|  1.35M|  return no_bits;
 3094|  1.35M|}
 3095|       |
 3096|       |
 3097|       |
 3098|       |/*!
 3099|       | ************************************************************************
 3100|       | * \brief
 3101|       | *    Writes chrominance coefficients
 3102|       | ************************************************************************
 3103|       | */
 3104|       |int writeChromaCoeff ()
 3105|  1.36M|{
 3106|  1.36M|  int             rate      = 0;
 3107|  1.36M|  Macroblock*     currMB    = &img->mb_data[img->current_mb_nr];
 3108|  1.36M|  SyntaxElement*  currSE    = &img->MB_SyntaxElements[currMB->currSEnr];
 3109|  1.36M|  int*            bitCount  = currMB->bitcounter;
 3110|  1.36M|  Slice*          currSlice = img->currentSlice;
 3111|  1.36M|  const int*      partMap   = assignSE2partition[input->partition_mode];
 3112|  1.36M|  int             cbp       = currMB->cbp;
 3113|  1.36M|  DataPartition*  dataPart;
 3114|       |
 3115|  1.36M|  int   level, run;
 3116|  1.36M|  int   k, uv;
 3117|  1.36M|  int   b8, b4, param;
 3118|  1.36M|  int*  ACLevel;
 3119|  1.36M|  int*  ACRun;
 3120|  1.36M|  int*  DCLevel;
 3121|  1.36M|  int*  DCRun;
 3122|       |  //ADD-VG-14052004
 3123|  1.36M|  int   chroma_dc_context[3]={CHROMA_DC, CHROMA_DC_2x4, CHROMA_DC_4x4};
 3124|  1.36M|  int   yuv = img->yuv_format - 1;
 3125|       |
 3126|  1.36M|  static unsigned char chroma_ac_param[3][8][4] =
 3127|  1.36M|  {
 3128|  1.36M|   {{ 4, 20,  5, 21},
 3129|  1.36M|    {36, 52, 37, 53},
 3130|  1.36M|    { 0,  0,  0,  0},
 3131|  1.36M|    { 0,  0,  0,  0},
 3132|  1.36M|    { 0,  0,  0,  0},
 3133|  1.36M|    { 0,  0,  0,  0},
 3134|  1.36M|    { 0,  0,  0,  0},
 3135|  1.36M|    { 0,  0,  0,  0}},
 3136|       |    
 3137|  1.36M|   {{ 4, 20,  5, 21},
 3138|  1.36M|    { 6, 22,  7, 23},
 3139|  1.36M|    {36, 52, 37, 53},
 3140|  1.36M|    {38, 54, 39, 55},
 3141|  1.36M|    { 0,  0,  0,  0},
 3142|  1.36M|    { 0,  0,  0,  0},
 3143|  1.36M|    { 0,  0,  0,  0},
 3144|  1.36M|    { 0,  0,  0,  0}},
 3145|       |    
 3146|  1.36M|   {{ 4, 20,  5, 21},
 3147|  1.36M|    {36, 52, 37, 53},
 3148|  1.36M|    { 6, 22,  7, 23},
 3149|  1.36M|    {38, 54, 39, 55},
 3150|  1.36M|    { 8, 24,  9, 25},
 3151|  1.36M|    {40, 56, 41, 57},
 3152|  1.36M|    {10, 26, 11, 27},
 3153|  1.36M|    {42, 58, 43, 59}}};
 3154|       |   //ADD-VG-14052004-END
 3155|       |
 3156|       |  //=====
 3157|       |  //=====   D C - C O E F F I C I E N T S
 3158|       |  //=====
 3159|  1.36M|  if (cbp > 15)  // check if any chroma bits in coded block pattern is set
 3160|   438k|  {
 3161|  1.31M|    for (uv=0; uv < 2; uv++)
 3162|   876k|    {
 3163|       |
 3164|   876k|      if (input->symbol_mode == UVLC)
 3165|      0|      {
 3166|      0|        param = uv;
 3167|      0|        rate += writeCoeff4x4_CAVLC (CHROMA_DC, 0, 0, param);
 3168|       |          // CAVLC
 3169|      0|      }
 3170|   876k|      else
 3171|   876k|      {
 3172|       |
 3173|   876k|        DCLevel = img->cofDC[uv+1][0];
 3174|   876k|        DCRun   = img->cofDC[uv+1][1];
 3175|       |
 3176|   876k|        level=1;
 3177|  2.92M|        for (k=0; k <= img->num_cdc_coeff && level != 0; ++k)
 3178|  2.04M|        {
 3179|  2.04M|          level = currSE->value1 = DCLevel[k]; // level
 3180|  2.04M|          run   = currSE->value2 = DCRun  [k]; // run
 3181|       |
 3182|  2.04M|          if (input->symbol_mode == UVLC)   currSE->mapping = levrun_linfo_c2x2;
 3183|  2.04M|          else                              currSE->writing = writeRunLevel_CABAC;
 3184|       |
 3185|  2.04M|          currSE->context     = chroma_dc_context[yuv];
 3186|  2.04M|          currSE->type        = (IS_INTRA(currMB) ? SE_CHR_DC_INTRA : SE_CHR_DC_INTER);
 3187|  2.04M|          img->is_intra_block =  IS_INTRA(currMB);
 3188|  2.04M|          img->is_v_block     = uv;
 3189|       |
 3190|       |          // choose the appropriate data partition
 3191|  2.04M|          dataPart = &(currSlice->partArr[partMap[currSE->type]]);
 3192|  2.04M|          dataPart->writeSyntaxElement (currSE, dataPart);
 3193|  2.04M|          bitCount[BITS_COEFF_UV_MB] += currSE->len;
 3194|  2.04M|          rate                       += currSE->len;
 3195|       |#if TRACE
 3196|       |          snprintf(currSE->tracestring, TRACESTRING_SIZE, "DC Chroma %2d: level =%3d run =%2d",k, level, run);
 3197|       |#endif
 3198|       |          // proceed to next SE 
 3199|  2.04M|          currSE++;  
 3200|  2.04M|          currMB->currSEnr++;
 3201|  2.04M|      }
 3202|   876k|      }
 3203|   876k|    }
 3204|   438k|  }
 3205|       |
 3206|       |
 3207|       |  //=====
 3208|       |  //=====   A C - C O E F F I C I E N T S
 3209|       |  //=====
 3210|  1.36M|  uv=-1;   
 3211|  1.36M|  if (cbp >> 4 == 2) // check if chroma bits in coded block pattern = 10b
 3212|   139k|  {  
 3213|   419k|    for (b8=4; b8 < (4+img->num_blk8x8_uv); b8++)
 3214|  1.39M|    for (b4=0; b4 < 4; b4++)
 3215|  1.11M|    {
 3216|  1.11M|      if (input->symbol_mode == UVLC)
 3217|      0|      {
 3218|      0|        param = chroma_ac_param[yuv][b8-4][b4];
 3219|      0|        rate += writeCoeff4x4_CAVLC (CHROMA_AC, b8, b4, param);
 3220|       |        // CAVLC
 3221|      0|      }
 3222|  1.11M|      else
 3223|  1.11M|      {
 3224|       |
 3225|  1.11M|        ACLevel = img->cofAC[b8][b4][0];
 3226|  1.11M|        ACRun   = img->cofAC[b8][b4][1];
 3227|       |
 3228|  1.11M|        level=1;
 3229|  1.11M|        uv++;
 3230|       |
 3231|  1.11M|        img->subblock_y = subblk_offset_y[yuv][b8-4][b4]>>2;
 3232|  1.11M|        img->subblock_x = subblk_offset_x[yuv][b8-4][b4]>>2;
 3233|       |
 3234|  3.43M|        for (k=0; k < 16 && level != 0; k++)
 3235|  2.31M|        {
 3236|  2.31M|          level = currSE->value1 = ACLevel[k]; // level
 3237|  2.31M|          run   = currSE->value2 = ACRun  [k]; // run
 3238|       |
 3239|  2.31M|          if (input->symbol_mode == UVLC)   currSE->mapping = levrun_linfo_inter;
 3240|  2.31M|          else                              currSE->writing = writeRunLevel_CABAC;
 3241|       |        
 3242|  2.31M|          currSE->context     = CHROMA_AC;
 3243|  2.31M|          currSE->type        = (IS_INTRA(currMB) ? SE_CHR_AC_INTRA : SE_CHR_AC_INTER);
 3244|  2.31M|          img->is_intra_block =  IS_INTRA(currMB);
 3245|  2.31M|          img->is_v_block     = (uv>=(img->num_blk8x8_uv<<1));
 3246|       |
 3247|       |          // choose the appropriate data partition
 3248|  2.31M|          dataPart = &(currSlice->partArr[partMap[currSE->type]]); 
 3249|  2.31M|          dataPart->writeSyntaxElement (currSE, dataPart);
 3250|  2.31M|          bitCount[BITS_COEFF_UV_MB] += currSE->len;
 3251|  2.31M|          rate                       += currSE->len;
 3252|       |#if TRACE
 3253|       |          snprintf(currSE->tracestring, TRACESTRING_SIZE, "AC Chroma %2d: level =%3d run =%2d",k, level, run);
 3254|       |#endif
 3255|       |
 3256|       |          // proceed to next SE 
 3257|  2.31M|          currSE++;  
 3258|  2.31M|          currMB->currSEnr++;
 3259|  2.31M|        }
 3260|  1.11M|      }
 3261|  1.11M|    }
 3262|   139k|  }
 3263|       |
 3264|  1.36M|  return rate;
 3265|  1.36M|}
 3266|       |
 3267|       |
 3268|       |
 3269|       |/*!
 3270|       | ************************************************************************
 3271|       | * \brief
 3272|       | *    Writes Luma coeff of an 4x4 block
 3273|       | ************************************************************************
 3274|       | */
 3275|       |int writeLumaCoeff4x4_CABAC (int b8, int b4, int intra4x4mode)
 3276|  62.6M|{
 3277|  62.6M|  int             rate      = 0;
 3278|  62.6M|  Macroblock*     currMB    = &img->mb_data[img->current_mb_nr];
 3279|  62.6M|  SyntaxElement*  currSE    = &img->MB_SyntaxElements[currMB->currSEnr];
 3280|  62.6M|  Slice*          currSlice = img->currentSlice;
 3281|  62.6M|  const int*      partMap   = assignSE2partition[input->partition_mode];
 3282|  62.6M|  int*            bitCount  = currMB->bitcounter;
 3283|  62.6M|  DataPartition*  dataPart;
 3284|       |
 3285|  62.6M|  int   level, run;
 3286|  62.6M|  int   k;
 3287|  62.6M|  int*  ACLevel = img->cofAC[b8][b4][0];
 3288|  62.6M|  int*  ACRun   = img->cofAC[b8][b4][1];
 3289|       |
 3290|  62.6M|  img->subblock_x = ((b8&0x1)==0)?(((b4&0x1)==0)?0:1):(((b4&0x1)==0)?2:3); // horiz. position for coeff_count context
 3291|  62.6M|  img->subblock_y = (b8<2)?((b4<2)?0:1):((b4<2)?2:3); // vert.  position for coeff_count context
 3292|       |
 3293|  62.6M|  level=1; // get inside loop
 3294|   150M|  for(k=0; k<=16 && level !=0; k++)
 3295|  87.6M|  {
 3296|  87.6M|    level = currSE->value1 = ACLevel[k]; // level
 3297|  87.6M|    run   = currSE->value2 = ACRun  [k]; // run
 3298|       |      
 3299|  87.6M|    currSE->writing = writeRunLevel_CABAC;
 3300|       |
 3301|  87.6M|    currSE->context     = LUMA_4x4;
 3302|  87.6M|    currSE->type        = (k==0 ? (intra4x4mode?SE_LUM_DC_INTRA:SE_LUM_DC_INTER) : (intra4x4mode?SE_LUM_AC_INTRA:SE_LUM_AC_INTER));
 3303|  87.6M|    img->is_intra_block = intra4x4mode;
 3304|       |
 3305|       |    // choose the appropriate data partition
 3306|  87.6M|    dataPart = &(currSlice->partArr[partMap[currSE->type]]);          
 3307|  87.6M|    dataPart->writeSyntaxElement (currSE, dataPart);
 3308|  87.6M|    bitCount[BITS_COEFF_Y_MB] += currSE->len;
 3309|  87.6M|    rate                      += currSE->len;
 3310|       |#if TRACE
 3311|       |    snprintf(currSE->tracestring, TRACESTRING_SIZE, "Luma sng(%2d) level =%3d run =%2d", k, level,run);
 3312|       |#endif
 3313|       |    /* proceed to next SE */
 3314|  87.6M|    currSE++;  
 3315|  87.6M|    currMB->currSEnr++;
 3316|  87.6M|  }
 3317|       |
 3318|  62.6M|  return rate;
 3319|  62.6M|}
 3320|       |
 3321|       |/*!
 3322|       | ************************************************************************
 3323|       | * \brief
 3324|       | *    Writes Luma coeff of an 8x8 block
 3325|       | ************************************************************************
 3326|       | */
 3327|       |int writeLumaCoeff8x8_CABAC (int b8, int intra_mode)
 3328|      0|{
 3329|      0|  int             rate      = 0;
 3330|      0|  Macroblock*     currMB    = &img->mb_data[img->current_mb_nr];
 3331|      0|  SyntaxElement*  currSE    = &img->MB_SyntaxElements[currMB->currSEnr];
 3332|      0|  Slice*          currSlice = img->currentSlice;
 3333|      0|  const int*      partMap   = assignSE2partition[input->partition_mode];
 3334|      0|  int*            bitCount  = currMB->bitcounter;
 3335|      0|  DataPartition*  dataPart;
 3336|       |  
 3337|      0|  int   level, run;
 3338|      0|  int   k;
 3339|      0|  int*  ACLevel = img->cofAC[b8][0][0];
 3340|      0|  int*  ACRun   = img->cofAC[b8][0][1];
 3341|       |
 3342|      0|  img->subblock_x = ((b8&0x1)==0)?0:2;  // horiz. position for coeff_count context
 3343|      0|  img->subblock_y = (b8<2)?0:2;     // vert.  position for coeff_count context
 3344|       |  
 3345|       |  
 3346|      0|  level=1; // get inside loop
 3347|      0|  for(k=0; k<=64 && level !=0; k++)
 3348|      0|  {
 3349|      0|    level = currSE->value1 = ACLevel[k]; // level
 3350|      0|    run   = currSE->value2 = ACRun  [k]; // run
 3351|       |
 3352|      0|    currSE->writing = writeRunLevel_CABAC;
 3353|       |    
 3354|      0|    currSE->context     = LUMA_8x8;
 3355|      0|    currSE->type        = (k==0 ? (intra_mode?SE_LUM_DC_INTRA:SE_LUM_DC_INTER) : (intra_mode?SE_LUM_AC_INTRA:SE_LUM_AC_INTER));
 3356|      0|    img->is_intra_block = intra_mode;
 3357|       |    
 3358|       |    // choose the appropriate data partition
 3359|       |    //if (img->type != B_SLICE && img->type != BS_IMG)    dataPart = &(currSlice->partArr[partMap[currSE->type]]);
 3360|      0|    if (img->type != B_SLICE)    dataPart = &(currSlice->partArr[partMap[currSE->type]]);
 3361|      0|    else                                              dataPart = &(currSlice->partArr[partMap[SE_BFRAME]]);
 3362|       |    
 3363|      0|    dataPart->writeSyntaxElement (currSE, dataPart);
 3364|      0|    bitCount[BITS_COEFF_Y_MB] += currSE->len;
 3365|      0|    rate                      += currSE->len;
 3366|       |#if TRACE
 3367|       |    snprintf(currSE->tracestring, TRACESTRING_SIZE, "Luma8x8 sng(%2d) level =%3d run =%2d", k, level,run);
 3368|       |#endif
 3369|       |    /* proceed to next SE */
 3370|      0|    currSE++;  
 3371|      0|    currMB->currSEnr++;
 3372|       |    
 3373|      0|  }
 3374|       |    
 3375|      0|  return rate;
 3376|      0|}
 3377|       |
 3378|       |/*!
 3379|       |************************************************************************
 3380|       |* \brief
 3381|       |*    Writes Luma Coeff of an 8x8 block
 3382|       |************************************************************************
 3383|       |*/
 3384|       |int writeLumaCoeff8x8 (int block8x8, int block_mode, int transform_size_flag)
 3385|   633k|{
 3386|   633k|  int  block4x4, rate = 0;
 3387|   633k|  int intra4x4mode = (block_mode==IBLOCK);
 3388|       |  
 3389|   633k|  if (block_mode == I8MB)
 3390|      0|    assert(transform_size_flag == 1);
 3391|       |  
 3392|       |  
 3393|       |  //if((!transform_size_flag))
 3394|   633k|  if((!transform_size_flag) || input->symbol_mode == UVLC) // allow here if 4x4 or UVLC
 3395|   633k|  {
 3396|  3.16M|    for (block4x4=0; block4x4<4; block4x4++)
 3397|  2.53M|    {
 3398|  2.53M|      if (input->symbol_mode == UVLC )
 3399|       |    //    rate += writeCoeff4x4_CAVLC (LUMA, block8x8, block4x4, intra4x4mode);// CAVLC
 3400|      0|		  rate += writeCoeff4x4_CAVLC (LUMA, block8x8, block4x4, (transform_size_flag)?(block_mode==I8MB):intra4x4mode);// CAVLC, pass new intra
 3401|  2.53M|      else
 3402|  2.53M|        rate += writeLumaCoeff4x4_CABAC (block8x8, block4x4, intra4x4mode);
 3403|       |      
 3404|  2.53M|    }
 3405|   633k|  }
 3406|      0|  else 
 3407|      0|    if (block_mode == I8MB)
 3408|      0|    {
 3409|      0|      rate += writeLumaCoeff8x8_CABAC (block8x8, 1);
 3410|      0|    }
 3411|      0|    else
 3412|      0|    {
 3413|      0|      rate += writeLumaCoeff8x8_CABAC (block8x8, 0);
 3414|      0|    }
 3415|       |
 3416|   633k|    return rate;
 3417|   633k|}
 3418|       |
 3419|       |/*!
 3420|       | ************************************************************************
 3421|       | * \brief
 3422|       | *    Writes CBP, DQUANT, and Luma Coefficients of an macroblock
 3423|       | ************************************************************************
 3424|       | */
 3425|       |int writeCBPandLumaCoeff ()
 3426|  1.36M|{
 3427|  1.36M|  int             mb_x, mb_y, i, j, k;
 3428|  1.36M|  int             level, run;
 3429|  1.36M|  int             rate      = 0;
 3430|  1.36M|  Macroblock*     currMB    = &img->mb_data[img->current_mb_nr];
 3431|  1.36M|  int*            bitCount  = currMB->bitcounter;
 3432|  1.36M|  SyntaxElement*  currSE    = &img->MB_SyntaxElements[currMB->currSEnr];
 3433|  1.36M|  Slice*          currSlice = img->currentSlice;
 3434|  1.36M|  const int*      partMap   = assignSE2partition[input->partition_mode];
 3435|  1.36M|  int             cbp       = currMB->cbp;
 3436|  1.36M|  DataPartition*  dataPart;
 3437|  1.36M|  int             need_transform_size_flag;   //ADD-VG-24062004
 3438|       | 
 3439|  1.36M|  int   b8, b4;
 3440|  1.36M|  int*  DCLevel = img->cofDC[0][0];
 3441|  1.36M|  int*  DCRun   = img->cofDC[0][1];
 3442|  1.36M|  int*  ACLevel;
 3443|  1.36M|  int*  ACRun;
 3444|       |
 3445|  1.36M|  if (!IS_NEWINTRA (currMB))
 3446|   924k|  {
 3447|       |    //=====   C B P   =====
 3448|       |    //---------------------
 3449|   924k|    currSE->value1 = cbp;
 3450|       |    
 3451|   924k|    if (IS_OLDINTRA (currMB) || currMB->mb_type == SI4MB ||  currMB->mb_type == I8MB)
 3452|   425k|    {
 3453|   425k|      if (input->symbol_mode == UVLC)  currSE->mapping = cbp_linfo_intra;
 3454|   425k|      currSE->type = SE_CBP_INTRA;
 3455|   425k|    }
 3456|   499k|    else
 3457|   499k|    {
 3458|   499k|      if (input->symbol_mode == UVLC)  currSE->mapping = cbp_linfo_inter;
 3459|   499k|      currSE->type = SE_CBP_INTER;
 3460|   499k|    }
 3461|   924k|    if (input->symbol_mode == CABAC)   currSE->writing = writeCBP_CABAC;
 3462|       |                      
 3463|       |    // choose the appropriate data partition
 3464|   924k|    dataPart = &(currSlice->partArr[partMap[currSE->type]]);
 3465|       |    
 3466|   924k|    dataPart->writeSyntaxElement(currSE, dataPart);
 3467|   924k|    bitCount[BITS_CBP_MB] += currSE->len;
 3468|   924k|    rate                  += currSE->len;
 3469|       |#if TRACE
 3470|       |    snprintf(currSE->tracestring, TRACESTRING_SIZE, "CBP (%2d,%2d) = %3d",img->mb_x, img->mb_y, cbp);
 3471|       |#endif
 3472|       |    // proceed to next SE
 3473|   924k|    currSE++;  
 3474|   924k|    currMB->currSEnr++;
 3475|       |
 3476|       |
 3477|       |    //============= Transform Size Flag for INTER MBs =============
 3478|       |    //-------------------------------------------------------------
 3479|   924k|    need_transform_size_flag = (((currMB->mb_type >= 1 && currMB->mb_type <= 3)||
 3480|   924k|                                (IS_DIRECT(currMB) && active_sps->direct_8x8_inference_flag) ||
 3481|   924k|                                (currMB->NoMbPartLessThan8x8Flag))
 3482|   924k|                                && currMB->mb_type != I8MB && currMB->mb_type != I4MB
 3483|   924k|                                && (currMB->cbp&15)
 3484|   924k|                                && input->AllowTransform8x8);
 3485|       |
 3486|   924k|    if (need_transform_size_flag)
 3487|      0|    {
 3488|      0|      currSE->value1 = currMB->luma_transform_size_8x8_flag;
 3489|      0|      currSE->type   = SE_TRANSFORM_SIZE_FLAG;
 3490|       |    
 3491|      0|      if (input->symbol_mode==UVLC)   currSE->mapping = ue_linfo;
 3492|      0|      else                            currSE->writing = writeMB_transform_size_CABAC;
 3493|       |    
 3494|      0|      if( input->symbol_mode==UVLC)
 3495|      0|      {
 3496|      0|        currSE->bitpattern = currMB->luma_transform_size_8x8_flag;
 3497|      0|        currSE->len = 1;
 3498|      0|        writeSyntaxElement2Buf_Fixed(currSE, dataPart->bitstream);
 3499|      0|      }
 3500|      0|      else
 3501|      0|      {
 3502|      0|        dataPart->writeSyntaxElement(currSE, dataPart);
 3503|      0|      }
 3504|       |  #if TRACE
 3505|       |      snprintf(currSE->tracestring, TRACESTRING_SIZE, "transform size 8x8 flag = %3d", currMB->luma_transform_size_8x8_flag);
 3506|       |  #endif
 3507|       |    
 3508|      0|      bitCount[BITS_MB_MODE] += currSE->len;
 3509|      0|      rate                   += currSE->len;
 3510|      0|      currSE++;
 3511|      0|      currMB->currSEnr++;
 3512|      0|    }
 3513|   924k|  }
 3514|       |  
 3515|       |  //=====   DQUANT   =====
 3516|       |  //----------------------
 3517|  1.36M|  if (cbp!=0 || IS_NEWINTRA (currMB))
 3518|   795k|  {
 3519|   795k|    currSE->value1 = currMB->delta_qp;
 3520|       |
 3521|   795k|    if (input->symbol_mode==UVLC)   currSE->mapping = se_linfo;
 3522|   795k|    else                            currSE->writing = writeDquant_CABAC;
 3523|       |
 3524|   795k|    if (IS_INTER (currMB))  currSE->type = SE_DELTA_QUANT_INTER;
 3525|   742k|    else                    currSE->type = SE_DELTA_QUANT_INTRA;
 3526|       |
 3527|       |
 3528|       |    // choose the appropriate data partition
 3529|   795k|    dataPart = &(img->currentSlice->partArr[partMap[currSE->type]]);
 3530|   795k|    dataPart->writeSyntaxElement(  currSE, dataPart);
 3531|   795k|    bitCount[BITS_DELTA_QUANT_MB] += currSE->len;
 3532|   795k|    rate                          += currSE->len;
 3533|       |#if TRACE
 3534|       |    snprintf(currSE->tracestring, TRACESTRING_SIZE, "Delta QP (%2d,%2d) = %3d",img->mb_x, img->mb_y, currMB->delta_qp);
 3535|       |#endif
 3536|       |    // proceed to next SE
 3537|   795k|    currSE++;
 3538|   795k|    currMB->currSEnr++;
 3539|   795k|  }
 3540|       |
 3541|  9.56M|    for (j=0; j < (4 + img->num_blk8x8_uv); j++)
 3542|  41.0M|      for (i=0; i < 4; i++)
 3543|  32.8M|        img->nz_coeff [img->current_mb_nr][i][j]=0;  // CAVLC
 3544|       |
 3545|  1.36M|  if (!IS_NEWINTRA (currMB))
 3546|   924k|  {
 3547|       |    //=====  L U M I N A N C E   =====
 3548|       |    //--------------------------------
 3549|  4.62M|    for (i=0; i<4; i++)  if (cbp & (1<<i))
 3550|   589k|    {
 3551|   589k|      rate += writeLumaCoeff8x8 (i, currMB->b8mode[i], currMB->luma_transform_size_8x8_flag);
 3552|   589k|    }
 3553|   924k|  }
 3554|   441k|  else
 3555|   441k|  {
 3556|       |    //=====  L U M I N A N C E   f o r   1 6 x 1 6   =====
 3557|       |    //----------------------------------------------------
 3558|       |    // DC coeffs
 3559|   441k|    if (input->symbol_mode == UVLC)
 3560|      0|    {
 3561|      0|      rate += writeCoeff4x4_CAVLC (LUMA_INTRA16x16DC, 0, 0, 0);  // CAVLC
 3562|      0|    }
 3563|   441k|    else
 3564|   441k|    {
 3565|   441k|      level=1; // get inside loop
 3566|  1.77M|      for (k=0; k<=16 && level!=0; k++)
 3567|  1.33M|      {
 3568|  1.33M|        level = currSE->value1 = DCLevel[k]; // level
 3569|  1.33M|        run   = currSE->value2 = DCRun  [k]; // run
 3570|       |
 3571|  1.33M|        if (input->symbol_mode == UVLC)
 3572|      0|        {
 3573|      0|          currSE->mapping = levrun_linfo_inter;
 3574|      0|        }
 3575|  1.33M|        else
 3576|  1.33M|        {
 3577|  1.33M|          currSE->writing = writeRunLevel_CABAC;
 3578|  1.33M|        }
 3579|       |
 3580|  1.33M|        currSE->context     = LUMA_16DC;
 3581|  1.33M|        currSE->type        = SE_LUM_DC_INTRA;   // element is of type DC
 3582|  1.33M|        img->is_intra_block = 1;
 3583|       |
 3584|       |        // choose the appropriate data partition
 3585|  1.33M|        dataPart = &(currSlice->partArr[partMap[currSE->type]]);
 3586|       |    
 3587|  1.33M|        dataPart->writeSyntaxElement (currSE, dataPart);
 3588|  1.33M|        bitCount[BITS_COEFF_Y_MB] += currSE->len;
 3589|  1.33M|        rate                      += currSE->len;
 3590|       |#if TRACE
 3591|       |        snprintf(currSE->tracestring, TRACESTRING_SIZE, "DC luma 16x16 sng(%2d) level =%3d run =%2d", k, level, run);
 3592|       |#endif
 3593|       |        // proceed to next SE
 3594|  1.33M|        currSE++;
 3595|  1.33M|        currMB->currSEnr++;
 3596|  1.33M|      }
 3597|   441k|    }
 3598|       |
 3599|       |    // AC coeffs
 3600|   441k|    if (cbp & 15)
 3601|  84.4k|    {
 3602|   253k|      for (mb_y=0; mb_y < 4; mb_y += 2)
 3603|   506k|      for (mb_x=0; mb_x < 4; mb_x += 2)
 3604|  1.01M|      for (j=mb_y; j < mb_y+2; j++)
 3605|  2.02M|      for (i=mb_x; i < mb_x+2; i++)
 3606|  1.35M|      {
 3607|  1.35M|        b8      = 2*(j/2) + (i/2);
 3608|  1.35M|        b4      = 2*(j%2) + (i%2);
 3609|  1.35M|        if (input->symbol_mode == UVLC)
 3610|      0|        {
 3611|      0|          rate += writeCoeff4x4_CAVLC (LUMA_INTRA16x16AC, b8, b4, 0);  // CAVLC
 3612|      0|        }
 3613|  1.35M|        else
 3614|  1.35M|        {
 3615|  1.35M|          ACLevel = img->cofAC[b8][b4][0];
 3616|  1.35M|          ACRun   = img->cofAC[b8][b4][1];
 3617|       |
 3618|  1.35M|          img->subblock_y = j;
 3619|  1.35M|          img->subblock_x = i;
 3620|       |
 3621|  1.35M|          level=1; // get inside loop
 3622|  3.49M|          for (k=0;k<16 && level !=0;k++)
 3623|  2.13M|          {
 3624|  2.13M|            level = currSE->value1 = ACLevel[k]; // level
 3625|  2.13M|            run   = currSE->value2 = ACRun  [k]; // run
 3626|       |
 3627|  2.13M|            if (input->symbol_mode == UVLC)
 3628|      0|            {
 3629|      0|              currSE->mapping = levrun_linfo_inter;
 3630|      0|            }
 3631|  2.13M|            else
 3632|  2.13M|            {
 3633|  2.13M|              currSE->writing = writeRunLevel_CABAC;
 3634|  2.13M|            }
 3635|  2.13M|            currSE->context     = LUMA_16AC;
 3636|  2.13M|            currSE->type        = SE_LUM_AC_INTRA;   // element is of type AC
 3637|  2.13M|            img->is_intra_block = 1;
 3638|       |
 3639|       |            // choose the appropriate data partition
 3640|  2.13M|           dataPart = &(currSlice->partArr[partMap[currSE->type]]);
 3641|       |
 3642|  2.13M|            dataPart->writeSyntaxElement (currSE, dataPart);
 3643|  2.13M|            bitCount[BITS_COEFF_Y_MB] += currSE->len;
 3644|  2.13M|            rate                      += currSE->len;
 3645|       |#if TRACE
 3646|       |            snprintf(currSE->tracestring, TRACESTRING_SIZE, "AC luma 16x16 sng(%2d) level =%3d run =%2d", k, level, run);
 3647|       |#endif
 3648|       |            // proceed to next SE
 3649|  2.13M|            currSE++;
 3650|  2.13M|            currMB->currSEnr++;
 3651|  2.13M|          }
 3652|  1.35M|        }
 3653|  1.35M|      }
 3654|  84.4k|    }
 3655|   441k|  }
 3656|       |
 3657|  1.36M|  return rate;
 3658|  1.36M|}
 3659|       |
 3660|       |
 3661|       |/*!
 3662|       | ************************************************************************
 3663|       | * \brief
 3664|       | *    Get the Prediction from the Neighboring Blocks for Number of Nonzero Coefficients 
 3665|       | *    
 3666|       | *    Luma Blocks
 3667|       | ************************************************************************
 3668|       | */
 3669|       |int predict_nnz(int i,int j)
 3670|      0|{
 3671|      0|  PixelPos pix;
 3672|       |
 3673|      0|  int pred_nnz = 0;
 3674|      0|  int cnt      = 0;
 3675|      0|  int mb_nr    = img->current_mb_nr;
 3676|       |
 3677|       |  // left block
 3678|      0|  getLuma4x4Neighbour(mb_nr, i, j, -1, 0, &pix);
 3679|       |
 3680|      0|  if (pix.available && active_pps->constrained_intra_pred_flag && (input->partition_mode != 0))
 3681|      0|  {
 3682|      0|    pix.available &= img->intra_block[pix.mb_addr];
 3683|      0|  }
 3684|       |
 3685|      0|  if (pix.available)
 3686|      0|  {
 3687|      0|    pred_nnz = img->nz_coeff [pix.mb_addr ][pix.x][pix.y];
 3688|      0|    cnt++;
 3689|      0|  }
 3690|       |
 3691|       |  // top block
 3692|      0|  getLuma4x4Neighbour(mb_nr, i, j, 0, -1, &pix);
 3693|       |
 3694|      0|  if (pix.available && active_pps->constrained_intra_pred_flag && (input->partition_mode != 0))
 3695|      0|  {
 3696|      0|    pix.available &= img->intra_block[pix.mb_addr];
 3697|      0|  }
 3698|       |
 3699|      0|  if (pix.available)
 3700|      0|  {
 3701|      0|    pred_nnz += img->nz_coeff [pix.mb_addr ][pix.x][pix.y];
 3702|      0|    cnt++;
 3703|      0|  }
 3704|       |
 3705|      0|  if (cnt==2)
 3706|      0|  {
 3707|      0|    pred_nnz++;
 3708|      0|    pred_nnz/=cnt; 
 3709|      0|  }
 3710|       |
 3711|      0|  return pred_nnz;
 3712|      0|}
 3713|       |
 3714|       |
 3715|       |/*!
 3716|       | ************************************************************************
 3717|       | * \brief
 3718|       | *    Get the Prediction from the Neighboring Blocks for Number of Nonzero Coefficients 
 3719|       | *    
 3720|       | *    Chroma Blocks   
 3721|       | ************************************************************************
 3722|       | */
 3723|       |int predict_nnz_chroma(int i,int j)
 3724|      0|{
 3725|      0|  PixelPos pix;
 3726|       |  
 3727|      0|  int pred_nnz = 0;
 3728|      0|  int cnt      = 0;
 3729|      0|  int mb_nr    = img->current_mb_nr;
 3730|      0|  int j_off_tab [12] = {0,0,0,0,4,4,4,4,8,8,8,8};
 3731|      0|  int j_off = j_off_tab[j];
 3732|       |  
 3733|       |
 3734|      0|  if (img->yuv_format != YUV444)
 3735|      0|  {
 3736|       |    //YUV420 and YUV422
 3737|       |    // left block
 3738|      0|    getChroma4x4Neighbour(mb_nr, i%2, j-4, -1, 0, &pix);
 3739|       |
 3740|      0|    if (pix.available && active_pps->constrained_intra_pred_flag && (input->partition_mode != 0))
 3741|      0|    {
 3742|      0|      pix.available &= img->intra_block[pix.mb_addr];
 3743|      0|    }
 3744|       |
 3745|      0|    if (pix.available)
 3746|      0|    {
 3747|      0|      pred_nnz = img->nz_coeff [pix.mb_addr ][2 * (i/2) + pix.x][4 + pix.y];
 3748|      0|      cnt++;
 3749|      0|    }
 3750|       |    
 3751|       |    // top block
 3752|      0|    getChroma4x4Neighbour(mb_nr, i%2, j-4, 0, -1, &pix);
 3753|       |
 3754|      0|    if (pix.available && active_pps->constrained_intra_pred_flag && (input->partition_mode != 0))
 3755|      0|    {
 3756|      0|      pix.available &= img->intra_block[pix.mb_addr];
 3757|      0|    }
 3758|       |
 3759|      0|    if (pix.available)
 3760|      0|    {
 3761|      0|      pred_nnz += img->nz_coeff [pix.mb_addr ][2 * (i/2) + pix.x][4 + pix.y];
 3762|      0|      cnt++;
 3763|      0|    }
 3764|      0|  }
 3765|      0|  else
 3766|      0|  {
 3767|       |    //YUV444
 3768|       |    // left block
 3769|      0|    getChroma4x4Neighbour(mb_nr, i, j-j_off, -1, 0, &pix);
 3770|       |
 3771|      0|    if (pix.available && active_pps->constrained_intra_pred_flag && (input->partition_mode != 0))
 3772|      0|    {
 3773|      0|      pix.available &= img->intra_block[pix.mb_addr];
 3774|      0|    }
 3775|       |
 3776|      0|    if (pix.available)
 3777|      0|    {
 3778|      0|      pred_nnz = img->nz_coeff [pix.mb_addr ][pix.x][j_off + pix.y];
 3779|      0|      cnt++;
 3780|      0|    }
 3781|       |    
 3782|       |    // top block
 3783|      0|    getChroma4x4Neighbour(mb_nr, i, j-j_off, 0, -1, &pix);
 3784|       |
 3785|      0|    if (pix.available && active_pps->constrained_intra_pred_flag && (input->partition_mode != 0))
 3786|      0|    {
 3787|      0|      pix.available &= img->intra_block[pix.mb_addr];
 3788|      0|    }
 3789|       |
 3790|      0|    if (pix.available)
 3791|      0|    {
 3792|      0|      pred_nnz += img->nz_coeff [pix.mb_addr ][pix.x][j_off + pix.y];
 3793|      0|      cnt++;
 3794|      0|    }
 3795|       |    
 3796|      0|  }
 3797|       |  
 3798|      0|  if (cnt==2)
 3799|      0|  {
 3800|      0|    pred_nnz++;
 3801|      0|    pred_nnz/=cnt; 
 3802|      0|  }
 3803|       |
 3804|      0|  return pred_nnz;
 3805|      0|}
 3806|       |
 3807|       |
 3808|       |
 3809|       |/*!
 3810|       | ************************************************************************
 3811|       | * \brief
 3812|       | *    Writes coeff of an 4x4 block (CAVLC)
 3813|       | *
 3814|       | * \author
 3815|       | *    Karl Lillevold <karll@real.com>
 3816|       | *    contributions by James Au <james@ubvideo.com>
 3817|       | ************************************************************************
 3818|       | */
 3819|       |
 3820|       |int writeCoeff4x4_CAVLC (int block_type, int b8, int b4, int param)
 3821|      0|{
 3822|      0|  int           no_bits    = 0;
 3823|      0|  Macroblock    *currMB    = &img->mb_data[img->current_mb_nr];
 3824|      0|  SyntaxElement *currSE    = &img->MB_SyntaxElements[currMB->currSEnr];
 3825|      0|  int           *bitCount  = currMB->bitcounter;
 3826|      0|  Slice         *currSlice = img->currentSlice;
 3827|      0|  DataPartition *dataPart;
 3828|      0|  int           *partMap   = assignSE2partition[input->partition_mode];
 3829|       |
 3830|      0|  int k,level,run,vlcnum;
 3831|      0|  int numcoeff, lastcoeff, numtrailingones; 
 3832|      0|  int numones, totzeros, zerosleft, numcoef;
 3833|      0|  int numcoeff_vlc;
 3834|      0|  int code, level_two_or_higher;
 3835|      0|  int dptype = 0, bitcounttype = 0;
 3836|      0|  int nnz, max_coeff_num = 0, cdc=0, cac=0;
 3837|      0|  int subblock_x, subblock_y;
 3838|      0|  char type[15];
 3839|       |
 3840|      0|  int incVlc[] = {0,3,6,12,24,48,32768};  // maximum vlc = 6
 3841|       |
 3842|       |
 3843|      0|  int*  pLevel = NULL;
 3844|      0|  int*  pRun = NULL;
 3845|       |
 3846|      0|  switch (block_type)
 3847|      0|  {
 3848|      0|  case LUMA:
 3849|      0|    max_coeff_num = 16;
 3850|      0|    bitcounttype = BITS_COEFF_Y_MB;
 3851|       |
 3852|      0|    pLevel = img->cofAC[b8][b4][0];
 3853|      0|    pRun   = img->cofAC[b8][b4][1];
 3854|       |
 3855|      0|    sprintf(type, "%s", "Luma");
 3856|      0|    if (IS_INTRA (currMB))
 3857|      0|    {
 3858|      0|      dptype = SE_LUM_AC_INTRA;
 3859|      0|    }
 3860|      0|    else
 3861|      0|    {
 3862|      0|      dptype = SE_LUM_AC_INTER;
 3863|      0|    }
 3864|      0|    break;
 3865|      0|  case LUMA_INTRA16x16DC:
 3866|      0|    max_coeff_num = 16;
 3867|      0|    bitcounttype = BITS_COEFF_Y_MB;
 3868|       |
 3869|      0|    pLevel = img->cofDC[0][0];
 3870|      0|    pRun   = img->cofDC[0][1];
 3871|       |
 3872|      0|    sprintf(type, "%s", "Lum16DC");
 3873|      0|    dptype = SE_LUM_DC_INTRA;
 3874|      0|    break;
 3875|      0|  case LUMA_INTRA16x16AC:
 3876|      0|    max_coeff_num = 15;
 3877|      0|    bitcounttype = BITS_COEFF_Y_MB;
 3878|       |
 3879|      0|    pLevel = img->cofAC[b8][b4][0];
 3880|      0|    pRun   = img->cofAC[b8][b4][1];
 3881|       |
 3882|      0|    sprintf(type, "%s", "Lum16AC");
 3883|      0|    dptype = SE_LUM_AC_INTRA;
 3884|      0|    break;
 3885|       |
 3886|      0|  case CHROMA_DC:
 3887|      0|    max_coeff_num = img->num_cdc_coeff;
 3888|      0|    bitcounttype = BITS_COEFF_UV_MB;
 3889|      0|    cdc = 1;
 3890|       |
 3891|      0|    pLevel = img->cofDC[param+1][0];
 3892|      0|    pRun   = img->cofDC[param+1][1];
 3893|       |
 3894|      0|    sprintf(type, "%s", "ChrDC");
 3895|      0|    if (IS_INTRA (currMB))
 3896|      0|    {
 3897|      0|      dptype = SE_CHR_DC_INTRA;
 3898|      0|    }
 3899|      0|    else
 3900|      0|    {
 3901|      0|      dptype = SE_CHR_DC_INTER;
 3902|      0|    }
 3903|      0|    break;
 3904|      0|  case CHROMA_AC:
 3905|      0|    max_coeff_num = 15;
 3906|      0|    bitcounttype = BITS_COEFF_UV_MB;
 3907|      0|    cac = 1;
 3908|       |
 3909|      0|    pLevel = img->cofAC[b8][b4][0];
 3910|      0|    pRun   = img->cofAC[b8][b4][1];
 3911|       |
 3912|      0|    sprintf(type, "%s", "ChrAC");
 3913|      0|    if (IS_INTRA (currMB))
 3914|      0|    {
 3915|      0|      dptype = SE_CHR_AC_INTRA;
 3916|      0|    }
 3917|      0|    else
 3918|      0|    {
 3919|      0|      dptype = SE_CHR_AC_INTER;
 3920|      0|    }
 3921|      0|    break;
 3922|      0|  default:
 3923|      0|    error("writeCoeff4x4_CAVLC: Invalid block type", 600);
 3924|      0|    break;
 3925|      0|  }
 3926|       |
 3927|      0|  dataPart = &(currSlice->partArr[partMap[dptype]]);
 3928|       |
 3929|      0|  numcoeff = 0;
 3930|      0|  numtrailingones = 0;
 3931|      0|  numones = 0;
 3932|      0|  lastcoeff = 0;
 3933|      0|  totzeros = 0;
 3934|      0|  level = 1;
 3935|       |
 3936|      0|  for(k = 0; (k <= ((cdc)?img->num_cdc_coeff:16))&& level !=0; k++)
 3937|      0|  {
 3938|      0|    level = pLevel[k]; // level
 3939|      0|    run   = pRun[k];   // run
 3940|       |
 3941|      0|    if (level)
 3942|      0|    {
 3943|      0|      if (run)
 3944|      0|        totzeros += run;
 3945|      0|      if (abs(level) == 1)
 3946|      0|      {
 3947|      0|        numtrailingones ++;
 3948|      0|        numones ++;
 3949|      0|        if (numtrailingones > 3)
 3950|      0|        {
 3951|      0|          numtrailingones = 3; /* clip to 3 */
 3952|      0|        }
 3953|      0|      }
 3954|      0|      else
 3955|      0|      {
 3956|      0|        numtrailingones = 0;
 3957|      0|      }
 3958|      0|      numcoeff ++;
 3959|      0|      lastcoeff = k;
 3960|      0|    }
 3961|      0|  }
 3962|       |
 3963|      0|  if (!cdc)
 3964|      0|  {
 3965|      0|    if (!cac)
 3966|      0|    {
 3967|       |      // luma
 3968|      0|      subblock_x = ((b8&0x1)==0)?(((b4&0x1)==0)?0:1):(((b4&0x1)==0)?2:3); 
 3969|       |        // horiz. position for coeff_count context
 3970|      0|      subblock_y = (b8<2)?((b4<2)?0:1):((b4<2)?2:3); 
 3971|       |        // vert.  position for coeff_count context
 3972|      0|      nnz = predict_nnz(subblock_x,subblock_y);
 3973|      0|    }
 3974|      0|    else
 3975|      0|    {
 3976|       |      // chroma AC
 3977|      0|      subblock_x = param >> 4;
 3978|      0|      subblock_y = param & 15;
 3979|      0|      nnz = predict_nnz_chroma(subblock_x,subblock_y);
 3980|      0|    }
 3981|       |
 3982|      0|    img->nz_coeff [img->current_mb_nr ][subblock_x][subblock_y] = numcoeff;
 3983|       |
 3984|       |
 3985|      0|    if (nnz < 2)
 3986|      0|    {
 3987|      0|      numcoeff_vlc = 0;
 3988|      0|    }
 3989|      0|    else if (nnz < 4)
 3990|      0|    {
 3991|      0|      numcoeff_vlc = 1;
 3992|      0|    }
 3993|      0|    else if (nnz < 8)
 3994|      0|    {
 3995|      0|      numcoeff_vlc = 2;
 3996|      0|    }
 3997|      0|    else 
 3998|      0|    {
 3999|      0|      numcoeff_vlc = 3;
 4000|      0|    }
 4001|       |
 4002|       |
 4003|      0|  }
 4004|      0|  else
 4005|      0|  {
 4006|       |    // chroma DC (has its own VLC)
 4007|       |    // numcoeff_vlc not relevant
 4008|      0|    numcoeff_vlc = 0;
 4009|       |
 4010|      0|    subblock_x = param;
 4011|      0|    subblock_y = param;
 4012|      0|  }
 4013|       |
 4014|      0|  currSE->type  = dptype;   
 4015|       |
 4016|      0|  currSE->value1 = numcoeff;
 4017|      0|  currSE->value2 = numtrailingones;
 4018|      0|  currSE->len = numcoeff_vlc; /* use len to pass vlcnum */
 4019|       |
 4020|       |#if TRACE
 4021|       |  snprintf(currSE->tracestring, 
 4022|       |    TRACESTRING_SIZE, "%s # c & tr.1s(%d,%d) vlc=%d #c=%d #t1=%d",
 4023|       |    type, subblock_x, subblock_y, numcoeff_vlc, numcoeff, numtrailingones);
 4024|       |#endif
 4025|       |
 4026|      0|  if (!cdc)
 4027|      0|    writeSyntaxElement_NumCoeffTrailingOnes(currSE, dataPart);
 4028|      0|  else
 4029|      0|    writeSyntaxElement_NumCoeffTrailingOnesChromaDC(currSE, dataPart);
 4030|       |
 4031|      0|  bitCount[bitcounttype]+=currSE->len;
 4032|      0|  no_bits               +=currSE->len;
 4033|       |
 4034|       |  // proceed to next SE
 4035|      0|  currSE++;
 4036|      0|  currMB->currSEnr++;
 4037|       |
 4038|       |
 4039|      0|  if (!numcoeff)
 4040|      0|    return no_bits;
 4041|       |
 4042|      0|  if (numcoeff)
 4043|      0|  {
 4044|      0|    code = 0;
 4045|      0|    for (k = lastcoeff; k > lastcoeff-numtrailingones; k--)
 4046|      0|    {
 4047|      0|      level = pLevel[k]; // level
 4048|      0|      if (abs(level) > 1)
 4049|      0|      {
 4050|      0|        printf("ERROR: level > 1\n");
 4051|      0|        exit(-1);
 4052|      0|      }
 4053|      0|      code <<= 1;
 4054|      0|      if (level < 0)
 4055|      0|      {
 4056|      0|        code |= 0x1;
 4057|      0|      }
 4058|      0|    }
 4059|       |
 4060|      0|    if (numtrailingones)
 4061|      0|    {
 4062|      0|      currSE->type  = dptype;   
 4063|       |
 4064|      0|      currSE->value2 = numtrailingones;
 4065|      0|      currSE->value1 = code;
 4066|       |
 4067|       |#if TRACE
 4068|       |      snprintf(currSE->tracestring, 
 4069|       |        TRACESTRING_SIZE, "%s trailing ones sign (%d,%d)", 
 4070|       |        type, subblock_x, subblock_y);
 4071|       |#endif
 4072|       |
 4073|      0|      writeSyntaxElement_VLC (currSE, dataPart);
 4074|      0|      bitCount[bitcounttype]+=currSE->len;
 4075|      0|      no_bits               +=currSE->len;
 4076|       |
 4077|       |      // proceed to next SE
 4078|      0|      currSE++;
 4079|      0|      currMB->currSEnr++;
 4080|      0|    }
 4081|       |
 4082|       |    // encode levels
 4083|      0|    level_two_or_higher = 1;
 4084|      0|    if (numcoeff > 3 && numtrailingones == 3)
 4085|      0|      level_two_or_higher = 0;
 4086|       |
 4087|      0|    if (numcoeff > 10 && numtrailingones < 3)
 4088|      0|      vlcnum = 1;
 4089|      0|    else
 4090|      0|      vlcnum = 0;
 4091|       |
 4092|      0|    for (k = lastcoeff - numtrailingones; k >= 0; k--)
 4093|      0|    {
 4094|      0|      level = pLevel[k]; // level
 4095|       |
 4096|      0|      currSE->value1 = level;
 4097|      0|      currSE->type  = dptype;   
 4098|       |
 4099|       |  #if TRACE
 4100|       |        snprintf(currSE->tracestring, 
 4101|       |          TRACESTRING_SIZE, "%s lev (%d,%d) k=%d vlc=%d lev=%3d",
 4102|       |            type, subblock_x, subblock_y, k, vlcnum, level);
 4103|       |  #endif
 4104|       |
 4105|      0|          if (level_two_or_higher)
 4106|      0|          {
 4107|      0|            if (currSE->value1 > 0)
 4108|      0|              currSE->value1 --;
 4109|      0|            else
 4110|      0|              currSE->value1 ++;
 4111|      0|            level_two_or_higher = 0;
 4112|      0|          }
 4113|       |
 4114|       |      //    encode level
 4115|      0|      if (vlcnum == 0)
 4116|      0|        writeSyntaxElement_Level_VLC1(currSE, dataPart);
 4117|      0|      else
 4118|      0|        writeSyntaxElement_Level_VLCN(currSE, vlcnum, dataPart);
 4119|       |
 4120|       |      // update VLC table
 4121|      0|      if (abs(level)>incVlc[vlcnum])
 4122|      0|        vlcnum++;
 4123|       |
 4124|      0|      if (k == lastcoeff - numtrailingones && abs(level)>3)
 4125|      0|        vlcnum = 2;
 4126|       |
 4127|      0|      bitCount[bitcounttype]+=currSE->len;
 4128|      0|      no_bits               +=currSE->len;
 4129|       |
 4130|       |      // proceed to next SE
 4131|      0|      currSE++;
 4132|      0|      currMB->currSEnr++;
 4133|      0|    }
 4134|       |
 4135|       |    // encode total zeroes
 4136|      0|    if (numcoeff < max_coeff_num)
 4137|      0|    {
 4138|       |
 4139|      0|      currSE->type  = dptype;   
 4140|      0|      currSE->value1 = totzeros;
 4141|       |
 4142|      0|      vlcnum = numcoeff-1;
 4143|       |
 4144|      0|      currSE->len = vlcnum;
 4145|       |
 4146|       |#if TRACE
 4147|       |      snprintf(currSE->tracestring, 
 4148|       |        TRACESTRING_SIZE, "%s totalrun (%d,%d) vlc=%d totzeros=%3d",
 4149|       |          type, subblock_x, subblock_y, vlcnum, totzeros);
 4150|       |#endif
 4151|      0|      if (!cdc)
 4152|      0|        writeSyntaxElement_TotalZeros(currSE, dataPart);
 4153|      0|      else
 4154|      0|        writeSyntaxElement_TotalZerosChromaDC(currSE, dataPart);
 4155|       |
 4156|      0|      bitCount[bitcounttype]+=currSE->len;
 4157|      0|      no_bits               +=currSE->len;
 4158|       |
 4159|       |      // proceed to next SE
 4160|      0|      currSE++;
 4161|      0|      currMB->currSEnr++;
 4162|      0|    }
 4163|       |
 4164|       |    // encode run before each coefficient
 4165|      0|    zerosleft = totzeros;
 4166|      0|    numcoef = numcoeff;
 4167|      0|    for (k = lastcoeff; k >= 0; k--)
 4168|      0|    {
 4169|      0|      run = pRun[k]; // run
 4170|       |
 4171|      0|      currSE->value1 = run;
 4172|      0|      currSE->type  = dptype;   
 4173|       |
 4174|       |      // for last coeff, run is remaining totzeros
 4175|       |      // when zerosleft is zero, remaining coeffs have 0 run
 4176|      0|      if (numcoeff <= 1 || !zerosleft)
 4177|      0|        break;
 4178|       |
 4179|      0|      if (numcoef > 1 && zerosleft) 
 4180|      0|      {
 4181|       |
 4182|      0|        vlcnum = zerosleft - 1;
 4183|      0|        if (vlcnum > RUNBEFORE_NUM-1)
 4184|      0|          vlcnum = RUNBEFORE_NUM-1;
 4185|       |
 4186|      0|        currSE->len = vlcnum;
 4187|       |
 4188|       |#if TRACE
 4189|       |        snprintf(currSE->tracestring, 
 4190|       |          TRACESTRING_SIZE, "%s run (%d,%d) k=%d vlc=%d run=%2d",
 4191|       |            type, subblock_x, subblock_y, k, vlcnum, run);
 4192|       |#endif
 4193|       |
 4194|      0|        writeSyntaxElement_Run(currSE, dataPart);
 4195|       |
 4196|      0|        bitCount[bitcounttype]+=currSE->len;
 4197|      0|        no_bits               +=currSE->len;
 4198|       |
 4199|      0|        zerosleft -= run;
 4200|      0|        numcoef --;
 4201|       |
 4202|       |        // proceed to next SE
 4203|      0|        currSE++;
 4204|      0|        currMB->currSEnr++;
 4205|      0|      }
 4206|      0|    }
 4207|      0|  }
 4208|       |
 4209|      0|  return no_bits;
 4210|      0|}
 4211|       |
 4212|       |
 4213|       |
 4214|       |
 4215|       |/*!
 4216|       | ************************************************************************
 4217|       | * \brief
 4218|       | *    Find best 16x16 based intra mode
 4219|       | *
 4220|       | * \par Input:
 4221|       | *    Image parameters, pointer to best 16x16 intra mode
 4222|       | *
 4223|       | * \par Output:
 4224|       | *    best 16x16 based SAD
 4225|       | ************************************************************************/
 4226|       |int find_sad_16x16(int *intra_mode)
 4227|   420k|{
 4228|   420k|  int current_intra_sad_2,best_intra_sad2;
 4229|   420k|  int M1[16][16],M0[4][4][4][4],M3[4],M4[4][4];
 4230|       |
 4231|   420k|  int i,j,k;
 4232|   420k|  int ii,jj;
 4233|   420k|  int mb_nr = img->current_mb_nr;
 4234|       |  
 4235|   420k|  PixelPos up;          //!< pixel position p(0,-1)
 4236|   420k|  PixelPos left[17];    //!< pixel positions p(-1, -1..15)
 4237|       |
 4238|   420k|  int up_avail, left_avail, left_up_avail;
 4239|       |
 4240|  7.56M|  for (i=0;i<17;i++)
 4241|  7.14M|  {
 4242|  7.14M|    getNeighbour(mb_nr, -1 ,  i-1 , 1, &left[i]);
 4243|  7.14M|  }
 4244|       |  
 4245|   420k|  getNeighbour(mb_nr, 0     ,  -1 , 1, &up);
 4246|       |
 4247|   420k|  if (!(input->UseConstrainedIntraPred))
 4248|   420k|  {
 4249|   420k|    up_avail   = up.available;
 4250|   420k|    left_avail = left[1].available;
 4251|   420k|    left_up_avail = left[0].available;
 4252|   420k|  }
 4253|      0|  else
 4254|      0|  {
 4255|      0|    up_avail      = up.available ? img->intra_block[up.mb_addr] : 0;
 4256|      0|    for (i=1, left_avail=1; i<17;i++)
 4257|      0|      left_avail  &= left[i].available ? img->intra_block[left[i].mb_addr]: 0;
 4258|      0|    left_up_avail = left[0].available ? img->intra_block[left[0].mb_addr]: 0;
 4259|      0|  }
 4260|       |
 4261|   420k|  best_intra_sad2=MAX_VALUE;
 4262|   420k|  *intra_mode = DC_PRED_16;
 4263|       |
 4264|  2.10M|  for (k=0;k<4;k++)
 4265|  1.68M|  {
 4266|  1.68M|    if (input->IntraDisableInterOnly == 0 || img->type != I_SLICE)
 4267|  1.68M|    {
 4268|  1.68M|      if (input->Intra16x16ParDisable && (k==VERT_PRED_16||k==HOR_PRED_16))
 4269|      0|        continue;
 4270|       |      
 4271|  1.68M|      if (input->Intra16x16PlaneDisable && k==PLANE_16)
 4272|      0|        continue;
 4273|  1.68M|    }
 4274|       |    //check if there are neighbours to predict from
 4275|  1.68M|    if ((k==0 && !up_avail) || (k==1 && !left_avail) || (k==3 && (!left_avail || !up_avail || !left_up_avail)))
 4276|  34.7k|    {
 4277|  34.7k|      ; // edge, do nothing
 4278|  34.7k|    }
 4279|  1.64M|    else
 4280|  1.64M|    {
 4281|  27.9M|      for (j=0;j<16;j++)
 4282|  26.3M|      {
 4283|   447M|        for (i=0;i<16;i++)
 4284|   421M|        {
 4285|   421M|          M1[i][j]=imgY_org[img->opix_y+j][img->opix_x+i]-img->mprr_2[k][j][i];
 4286|   421M|          M0[i%4][i/4][j%4][j/4]=M1[i][j];
 4287|   421M|        }
 4288|  26.3M|      }
 4289|  1.64M|      current_intra_sad_2=0;              // no SAD start handicap here
 4290|  8.22M|      for (jj=0;jj<4;jj++)
 4291|  6.58M|      {
 4292|  32.9M|        for (ii=0;ii<4;ii++)
 4293|  26.3M|        {
 4294|   131M|          for (j=0;j<4;j++)
 4295|   105M|          {
 4296|   105M|            M3[0]=M0[0][ii][j][jj]+M0[3][ii][j][jj];
 4297|   105M|            M3[1]=M0[1][ii][j][jj]+M0[2][ii][j][jj];
 4298|   105M|            M3[2]=M0[1][ii][j][jj]-M0[2][ii][j][jj];
 4299|   105M|            M3[3]=M0[0][ii][j][jj]-M0[3][ii][j][jj];
 4300|       |
 4301|   105M|            M0[0][ii][j][jj]=M3[0]+M3[1];
 4302|   105M|            M0[2][ii][j][jj]=M3[0]-M3[1];
 4303|   105M|            M0[1][ii][j][jj]=M3[2]+M3[3];
 4304|   105M|            M0[3][ii][j][jj]=M3[3]-M3[2];
 4305|   105M|          }
 4306|       |
 4307|   131M|          for (i=0;i<4;i++)
 4308|   105M|          {
 4309|   105M|            M3[0]=M0[i][ii][0][jj]+M0[i][ii][3][jj];
 4310|   105M|            M3[1]=M0[i][ii][1][jj]+M0[i][ii][2][jj];
 4311|   105M|            M3[2]=M0[i][ii][1][jj]-M0[i][ii][2][jj];
 4312|   105M|            M3[3]=M0[i][ii][0][jj]-M0[i][ii][3][jj];
 4313|       |
 4314|   105M|            M0[i][ii][0][jj]=M3[0]+M3[1];
 4315|   105M|            M0[i][ii][2][jj]=M3[0]-M3[1];
 4316|   105M|            M0[i][ii][1][jj]=M3[2]+M3[3];
 4317|   105M|            M0[i][ii][3][jj]=M3[3]-M3[2];
 4318|   526M|            for (j=0;j<4;j++)
 4319|   421M|              if ((i+j)!=0)
 4320|   395M|                current_intra_sad_2 += abs(M0[i][ii][j][jj]);
 4321|   105M|          }
 4322|  26.3M|        }
 4323|  6.58M|      }
 4324|       |
 4325|  8.22M|      for (j=0;j<4;j++)
 4326|  32.9M|        for (i=0;i<4;i++)
 4327|  26.3M|          M4[i][j]=M0[0][i][0][j]/4;
 4328|       |
 4329|       |        // Hadamard of DC koeff
 4330|  8.22M|        for (j=0;j<4;j++)
 4331|  6.58M|        {
 4332|  6.58M|          M3[0]=M4[0][j]+M4[3][j];
 4333|  6.58M|          M3[1]=M4[1][j]+M4[2][j];
 4334|  6.58M|          M3[2]=M4[1][j]-M4[2][j];
 4335|  6.58M|          M3[3]=M4[0][j]-M4[3][j];
 4336|       |
 4337|  6.58M|          M4[0][j]=M3[0]+M3[1];
 4338|  6.58M|          M4[2][j]=M3[0]-M3[1];
 4339|  6.58M|          M4[1][j]=M3[2]+M3[3];
 4340|  6.58M|          M4[3][j]=M3[3]-M3[2];
 4341|  6.58M|        }
 4342|       |
 4343|  8.22M|        for (i=0;i<4;i++)
 4344|  6.58M|        {
 4345|  6.58M|          M3[0]=M4[i][0]+M4[i][3];
 4346|  6.58M|          M3[1]=M4[i][1]+M4[i][2];
 4347|  6.58M|          M3[2]=M4[i][1]-M4[i][2];
 4348|  6.58M|          M3[3]=M4[i][0]-M4[i][3];
 4349|       |
 4350|  6.58M|          M4[i][0]=M3[0]+M3[1];
 4351|  6.58M|          M4[i][2]=M3[0]-M3[1];
 4352|  6.58M|          M4[i][1]=M3[2]+M3[3];
 4353|  6.58M|          M4[i][3]=M3[3]-M3[2];
 4354|       |
 4355|  32.9M|          for (j=0;j<4;j++)
 4356|  26.3M|            current_intra_sad_2 += abs(M4[i][j]);
 4357|  6.58M|        }
 4358|  1.64M|        if(current_intra_sad_2 < best_intra_sad2)
 4359|   910k|        {
 4360|   910k|          best_intra_sad2=current_intra_sad_2;
 4361|   910k|          *intra_mode = k; // update best intra mode
 4362|       |
 4363|   910k|        }
 4364|  1.64M|    }
 4365|  1.68M|  }
 4366|   420k|  best_intra_sad2 = best_intra_sad2/2;
 4367|       |
 4368|   420k|  return best_intra_sad2;
 4369|       |
 4370|   420k|}

/home/xzp/speccpu2006-v1.0.1/benchspec/CPU2006/464.h264ref/run/build_base_ql_riscv_llvm17.0000/mb_access.c:
    1|       |
    2|       |/*!
    3|       | *************************************************************************************
    4|       | * \file mb_access.c
    5|       | *
    6|       | * \brief
    7|       | *    Functions for macroblock neighborhoods
    8|       | *
    9|       | *  \author
   10|       | *      Main contributors (see contributors.h for copyright, address and affiliation details)
   11|       | *      - Karsten S�hring          <suehring@hhi.de>
   12|       | *************************************************************************************
   13|       | */
   14|       |#include <assert.h>
   15|       |
   16|       |#include "global.h"
   17|       |
   18|       |/*!
   19|       | ************************************************************************
   20|       | * \brief
   21|       | *    returns 1 if the macroblock at the given address is available
   22|       | ************************************************************************
   23|       | */
   24|       |int mb_is_available(int mbAddr, int currMbAddr)
   25|   875k|{
   26|   875k|  if ((mbAddr < 0) || (mbAddr > ((int)img->PicSizeInMbs - 1)))
   27|  33.1k|    return 0;
   28|       |
   29|       |  // the following line checks both: slice number and if the mb has been decoded
   30|   842k|  if (!img->DeblockCall)
   31|   421k|  {
   32|   421k|    if (img->mb_data[mbAddr].slice_nr != img->mb_data[currMbAddr].slice_nr)
   33|      0|      return 0;
   34|   421k|  }
   35|       |  
   36|   842k|  return 1;
   37|   842k|}
   38|       |
   39|       |
   40|       |/*!
   41|       | ************************************************************************
   42|       | * \brief
   43|       | *    Checks the availability of neighboring macroblocks of
   44|       | *    the current macroblock for prediction and context determination;
   45|       | ************************************************************************
   46|       | */
   47|       |void CheckAvailabilityOfNeighbors()
   48|   218k|{
   49|   218k|  const int mb_nr = img->current_mb_nr;
   50|   218k|  Macroblock *currMB = &img->mb_data[mb_nr];
   51|       |
   52|       |  // mark all neighbors as unavailable
   53|   218k|  currMB->mb_available_up   = NULL;
   54|   218k|  currMB->mb_available_left = NULL;
   55|       |
   56|   218k|  if (img->MbaffFrameFlag)
   57|      0|  {
   58|      0|    currMB->mbAddrA = 2 * (mb_nr/2 - 1);
   59|      0|    currMB->mbAddrB = 2 * (mb_nr/2 - img->PicWidthInMbs);
   60|      0|    currMB->mbAddrC = 2 * (mb_nr/2 - img->PicWidthInMbs + 1);
   61|      0|    currMB->mbAddrD = 2 * (mb_nr/2 - img->PicWidthInMbs - 1);
   62|       |    
   63|      0|    currMB->mbAvailA = mb_is_available(currMB->mbAddrA, mb_nr) && (((mb_nr/2) % img->PicWidthInMbs)!=0);
   64|      0|    currMB->mbAvailB = mb_is_available(currMB->mbAddrB, mb_nr);
   65|      0|    currMB->mbAvailC = mb_is_available(currMB->mbAddrC, mb_nr) && (((mb_nr/2 +1) % img->PicWidthInMbs)!=0);
   66|      0|    currMB->mbAvailD = mb_is_available(currMB->mbAddrD, mb_nr) && (((mb_nr/2) % img->PicWidthInMbs)!=0);
   67|      0|  }
   68|   218k|  else
   69|   218k|  {
   70|   218k|    currMB->mbAddrA = mb_nr - 1;
   71|   218k|    currMB->mbAddrB = mb_nr - img->PicWidthInMbs;
   72|   218k|    currMB->mbAddrC = mb_nr - img->PicWidthInMbs + 1;
   73|   218k|    currMB->mbAddrD = mb_nr - img->PicWidthInMbs - 1;
   74|       |
   75|   218k|    currMB->mbAvailA = mb_is_available(currMB->mbAddrA, mb_nr) && ((mb_nr % img->PicWidthInMbs)!=0);
   76|   218k|    currMB->mbAvailB = mb_is_available(currMB->mbAddrB, mb_nr);
   77|   218k|    currMB->mbAvailC = mb_is_available(currMB->mbAddrC, mb_nr) && (((mb_nr+1) % img->PicWidthInMbs)!=0);
   78|   218k|    currMB->mbAvailD = mb_is_available(currMB->mbAddrD, mb_nr) && ((mb_nr % img->PicWidthInMbs)!=0);
   79|   218k|  }
   80|       |
   81|   218k|  if (currMB->mbAvailA) currMB->mb_available_left = &(img->mb_data[currMB->mbAddrA]);
   82|   218k|  if (currMB->mbAvailB) currMB->mb_available_up   = &(img->mb_data[currMB->mbAddrB]);
   83|   218k|}
   84|       |
   85|       |
   86|       |/*!
   87|       | ************************************************************************
   88|       | * \brief
   89|       | *    returns the x and y macroblock coordinates for a given MbAddress
   90|       | ************************************************************************
   91|       | */
   92|       |void get_mb_block_pos (int mb_addr, int *x, int*y)
   93|   348M|{
   94|       |
   95|   348M|  if (img->MbaffFrameFlag)
   96|      0|  {
   97|      0|    *x = ( (mb_addr/2) % img->PicWidthInMbs);
   98|      0|    *y = (((mb_addr/2) / img->PicWidthInMbs) * 2 + (mb_addr%2));
   99|      0|  }
  100|   348M|  else
  101|   348M|  {
  102|   348M|    *x = (mb_addr % img->PicWidthInMbs);
  103|   348M|    *y = (mb_addr / img->PicWidthInMbs);
  104|   348M|  }
  105|   348M|}
  106|       |
  107|       |
  108|       |/*!
  109|       | ************************************************************************
  110|       | * \brief
  111|       | *    returns the x and y sample coordinates for a given MbAddress
  112|       | ************************************************************************
  113|       | */
  114|       |void get_mb_pos (int mb_addr, int *x, int*y)
  115|   338M|{
  116|   338M|  get_mb_block_pos(mb_addr, x, y);
  117|       |  
  118|   338M|  (*x) *= MB_BLOCK_SIZE;
  119|   338M|  (*y) *= MB_BLOCK_SIZE;
  120|   338M|}
  121|       |
  122|       |
  123|       |/*!
  124|       | ************************************************************************
  125|       | * \brief
  126|       | *    get neighbouring positions for non-aff coding
  127|       | * \param curr_mb_nr
  128|       | *   current macroblock number (decoding order)
  129|       | * \param xN
  130|       | *    input x position
  131|       | * \param yN
  132|       | *    input y position
  133|       | * \param luma
  134|       | *    1 if luma coding, 0 for chroma
  135|       | * \param pix
  136|       | *    returns position informations
  137|       | ************************************************************************
  138|       | */
  139|       |void getNonAffNeighbour(unsigned int curr_mb_nr, int xN, int yN, int luma, PixelPos *pix)
  140|   347M|{
  141|   347M|  Macroblock *currMb = &img->mb_data[curr_mb_nr];
  142|   347M|  int maxW, maxH;
  143|       |
  144|   347M|  if (luma)
  145|   337M|  {
  146|   337M|    maxW = 16;
  147|   337M|    maxH = 16;
  148|   337M|  }
  149|  10.2M|  else
  150|  10.2M|  {
  151|  10.2M|    assert(img->yuv_format != 0);
  152|  10.2M|    maxW = img->mb_cr_size_x;
  153|  10.2M|    maxH = img->mb_cr_size_y;
  154|  10.2M|  }
  155|       |
  156|   347M|  if ((xN<0)&&(yN<0))
  157|  5.53M|  {
  158|  5.53M|    pix->mb_addr   = currMb->mbAddrD;
  159|  5.53M|    pix->available = currMb->mbAvailD;
  160|  5.53M|  }
  161|   341M|  else if ((xN<0)&&((yN>=0)&&(yN<maxH)))
  162|  66.8M|  {
  163|  66.8M|    pix->mb_addr  = currMb->mbAddrA;
  164|  66.8M|    pix->available = currMb->mbAvailA;
  165|  66.8M|  }
  166|   274M|  else if (((xN>=0)&&(xN<maxW))&&(yN<0))
  167|  51.3M|  {
  168|  51.3M|    pix->mb_addr  = currMb->mbAddrB;
  169|  51.3M|    pix->available = currMb->mbAvailB;
  170|  51.3M|  }
  171|   223M|  else if (((xN>=0)&&(xN<maxW))&&((yN>=0)&&(yN<maxH)))
  172|   213M|  {
  173|   213M|    pix->mb_addr  = curr_mb_nr;
  174|   213M|    pix->available = 1;
  175|   213M|  }
  176|  10.3M|  else if ((xN>=maxW)&&(yN<0))
  177|  4.58M|  {
  178|  4.58M|    pix->mb_addr  = currMb->mbAddrC;
  179|  4.58M|    pix->available = currMb->mbAvailC;
  180|  4.58M|  }
  181|  5.75M|  else 
  182|  5.75M|  {
  183|  5.75M|    pix->available = 0;
  184|  5.75M|  }
  185|       |
  186|   347M|  if (pix->available || img->DeblockCall)
  187|   338M|  {
  188|   338M|    pix->x = (xN + maxW) % maxW;
  189|   338M|    pix->y = (yN + maxH) % maxH;
  190|   338M|    get_mb_pos(pix->mb_addr, &(pix->pos_x), &(pix->pos_y));
  191|   338M|    if (luma)
  192|   327M|    {
  193|   327M|      pix->pos_x += pix->x;
  194|   327M|      pix->pos_y += pix->y;
  195|   327M|    }
  196|  10.1M|    else
  197|  10.1M|    {
  198|  10.1M|      pix->pos_x = pix->pos_x/(16/img->mb_cr_size_x) + pix->x;
  199|  10.1M|      pix->pos_y = pix->pos_y/(16/img->mb_cr_size_y) + pix->y;
  200|  10.1M|    }
  201|   338M|  }
  202|   347M|}
  203|       |
  204|       |/*!
  205|       | ************************************************************************
  206|       | * \brief
  207|       | *    get neighbouring positions for aff coding
  208|       | * \param curr_mb_nr
  209|       | *   current macroblock number (decoding order)
  210|       | * \param xN
  211|       | *    input x position
  212|       | * \param yN
  213|       | *    input y position
  214|       | * \param luma
  215|       | *    1 if luma coding, 0 for chroma
  216|       | * \param pix
  217|       | *    returns position informations
  218|       | ************************************************************************
  219|       | */
  220|       |void getAffNeighbour(unsigned int curr_mb_nr, int xN, int yN, int luma, PixelPos *pix)
  221|      0|{
  222|      0|  Macroblock *currMb = &img->mb_data[curr_mb_nr];
  223|      0|  int maxW, maxH;
  224|      0|  int yM = -1;
  225|       |
  226|      0|  if (luma)
  227|      0|  {
  228|      0|    maxW = 16;
  229|      0|    maxH = 16;
  230|      0|  }
  231|      0|  else
  232|      0|  {
  233|      0|    assert(img->yuv_format != 0);
  234|      0|    maxW = img->mb_cr_size_x;
  235|      0|    maxH = img->mb_cr_size_y;
  236|      0|  }
  237|       |
  238|       |  // initialize to "not available"
  239|      0|  pix->available = 0;
  240|       |
  241|      0|  if(yN > (maxH - 1))
  242|      0|  {
  243|      0|    return;
  244|      0|  }
  245|      0|  if(xN > (maxW - 1) && yN >= 0 && yN < maxH)
  246|      0|  {
  247|      0|    return;
  248|      0|  }
  249|       |
  250|      0|  if (xN < 0)
  251|      0|  {
  252|      0|    if (yN < 0)
  253|      0|    {
  254|      0|      if(!currMb->mb_field)
  255|      0|      {
  256|       |        // frame
  257|      0|        if (curr_mb_nr%2 == 0)
  258|      0|        {
  259|       |          // top
  260|      0|          pix->mb_addr   = currMb->mbAddrD  + 1;
  261|      0|          pix->available = currMb->mbAvailD;
  262|      0|          yM = yN;
  263|      0|        }
  264|      0|        else
  265|      0|        {
  266|       |          // bottom
  267|      0|          pix->mb_addr   = currMb->mbAddrA;
  268|      0|          pix->available = currMb->mbAvailA;
  269|      0|          if (currMb->mbAvailA)
  270|      0|          {
  271|      0|            if(!img->mb_data[currMb->mbAddrA].mb_field)
  272|      0|            {
  273|      0|               yM = yN;
  274|      0|            }
  275|      0|            else
  276|      0|            {
  277|      0|              (pix->mb_addr)++;
  278|      0|               yM = (yN + maxH) >> 1;
  279|      0|            }
  280|      0|          }
  281|      0|        }
  282|      0|      }
  283|      0|      else
  284|      0|      {
  285|       |        // field
  286|      0|        if(curr_mb_nr % 2 == 0)
  287|      0|        {
  288|       |          // top
  289|      0|          pix->mb_addr   = currMb->mbAddrD;
  290|      0|          pix->available = currMb->mbAvailD;
  291|      0|          if (currMb->mbAvailD)
  292|      0|          {
  293|      0|            if(!img->mb_data[currMb->mbAddrD].mb_field)
  294|      0|            {
  295|      0|              (pix->mb_addr)++;
  296|      0|               yM = 2 * yN;
  297|      0|            }
  298|      0|            else
  299|      0|            {
  300|      0|               yM = yN;
  301|      0|            }
  302|      0|          }
  303|      0|        }
  304|      0|        else
  305|      0|        {
  306|       |          // bottom
  307|      0|          pix->mb_addr   = currMb->mbAddrD+1;
  308|      0|          pix->available = currMb->mbAvailD;
  309|      0|          yM = yN;
  310|      0|        }
  311|      0|      }
  312|      0|    }
  313|      0|    else
  314|      0|    { // xN < 0 && yN >= 0
  315|      0|      if (yN >= 0 && yN <maxH)
  316|      0|      {
  317|      0|        if (!currMb->mb_field)
  318|      0|        {
  319|       |          // frame
  320|      0|          if(curr_mb_nr % 2 == 0)
  321|      0|          {
  322|       |            // top
  323|      0|            pix->mb_addr   = currMb->mbAddrA;
  324|      0|            pix->available = currMb->mbAvailA;
  325|      0|            if (currMb->mbAvailA)
  326|      0|            {
  327|      0|              if(!img->mb_data[currMb->mbAddrA].mb_field)
  328|      0|              {
  329|      0|                 yM = yN;
  330|      0|              }
  331|      0|              else
  332|      0|              {
  333|      0|                if (yN %2 == 0)
  334|      0|                {
  335|      0|                   yM = yN>> 1;
  336|      0|                }
  337|      0|                else
  338|      0|                {
  339|      0|                  (pix->mb_addr)++;
  340|      0|                   yM = yN>> 1;
  341|      0|                }
  342|      0|              }
  343|      0|            }
  344|      0|          }
  345|      0|          else
  346|      0|          {
  347|       |            // bottom
  348|      0|            pix->mb_addr   = currMb->mbAddrA;
  349|      0|            pix->available = currMb->mbAvailA;
  350|      0|            if (currMb->mbAvailA)
  351|      0|            {
  352|      0|              if(!img->mb_data[currMb->mbAddrA].mb_field)
  353|      0|              {
  354|      0|                (pix->mb_addr)++;
  355|      0|                 yM = yN;
  356|      0|              }
  357|      0|              else
  358|      0|              {
  359|      0|                if (yN %2 == 0)
  360|      0|                {
  361|      0|                   yM = (yN + maxH) >> 1;
  362|      0|                }
  363|      0|                else
  364|      0|                {
  365|      0|                  (pix->mb_addr)++;
  366|      0|                   yM = (yN + maxH) >> 1;
  367|      0|                }
  368|      0|              }
  369|      0|            }
  370|      0|          }
  371|      0|        }
  372|      0|        else
  373|      0|        {
  374|       |          // field
  375|      0|          if (curr_mb_nr % 2 == 0)
  376|      0|          {
  377|       |            // top
  378|      0|            pix->mb_addr  = currMb->mbAddrA;
  379|      0|            pix->available = currMb->mbAvailA;
  380|      0|            if (currMb->mbAvailA)
  381|      0|            {
  382|      0|              if(!img->mb_data[currMb->mbAddrA].mb_field)
  383|      0|              {
  384|      0|                if (yN < (maxH / 2))
  385|      0|                {
  386|      0|                   yM = yN << 1;
  387|      0|                }
  388|      0|                else
  389|      0|                {
  390|      0|                  (pix->mb_addr)++;
  391|      0|                   yM = (yN << 1 ) - maxH;
  392|      0|                }
  393|      0|              }
  394|      0|              else
  395|      0|              {
  396|      0|                 yM = yN;
  397|      0|              }
  398|      0|            }
  399|      0|          }
  400|      0|          else
  401|      0|          {
  402|       |            // bottom
  403|      0|            pix->mb_addr  = currMb->mbAddrA;
  404|      0|            pix->available = currMb->mbAvailA;
  405|      0|            if (currMb->mbAvailA)
  406|      0|            {
  407|      0|              if(!img->mb_data[currMb->mbAddrA].mb_field)
  408|      0|              {
  409|      0|                if (yN < (maxH / 2))
  410|      0|                {
  411|      0|                  yM = (yN << 1) + 1;
  412|      0|                }
  413|      0|                else
  414|      0|                {
  415|      0|                  (pix->mb_addr)++;
  416|      0|                   yM = (yN << 1 ) + 1 - maxH;
  417|      0|                }
  418|      0|              }
  419|      0|              else
  420|      0|              {
  421|      0|                (pix->mb_addr)++;
  422|      0|                 yM = yN;
  423|      0|              }
  424|      0|            }
  425|      0|          }
  426|      0|        }
  427|      0|      }
  428|      0|    }
  429|      0|  }
  430|      0|  else
  431|      0|  { // xN >= 0
  432|      0|    if (xN >= 0 && xN < maxW)
  433|      0|    {
  434|      0|      if (yN<0)
  435|      0|      {
  436|      0|        if (!currMb->mb_field)
  437|      0|        {
  438|       |          //frame
  439|      0|          if (curr_mb_nr % 2 == 0)
  440|      0|          {
  441|       |            //top
  442|      0|            pix->mb_addr  = currMb->mbAddrB;
  443|       |            // for the deblocker if the current MB is a frame and the one above is a field
  444|       |            // then the neighbor is the top MB of the pair
  445|      0|            if (currMb->mbAvailB)
  446|      0|            {
  447|      0|              if (!(img->DeblockCall == 1 && (img->mb_data[currMb->mbAddrB]).mb_field))
  448|      0|                pix->mb_addr  += 1;
  449|      0|            }
  450|       |            
  451|      0|            pix->available = currMb->mbAvailB;
  452|      0|            yM = yN;
  453|      0|          }
  454|      0|          else
  455|      0|          {
  456|       |            // bottom
  457|      0|            pix->mb_addr   = curr_mb_nr - 1;
  458|      0|            pix->available = 1;
  459|      0|            yM = yN;
  460|      0|          }
  461|      0|        }
  462|      0|        else
  463|      0|        {
  464|       |          // field
  465|      0|          if (curr_mb_nr % 2 == 0)
  466|      0|          {
  467|       |            // top
  468|      0|            pix->mb_addr   = currMb->mbAddrB;
  469|      0|            pix->available = currMb->mbAvailB;
  470|      0|            if (currMb->mbAvailB)
  471|      0|            {
  472|      0|              if(!img->mb_data[currMb->mbAddrB].mb_field)
  473|      0|              {
  474|      0|                (pix->mb_addr)++;
  475|      0|                 yM = 2* yN;
  476|      0|              }
  477|      0|              else
  478|      0|              {
  479|      0|                 yM = yN;
  480|      0|              }
  481|      0|            }
  482|      0|          }
  483|      0|          else
  484|      0|          {
  485|       |            // bottom
  486|      0|            pix->mb_addr   = currMb->mbAddrB + 1;
  487|      0|            pix->available = currMb->mbAvailB;
  488|      0|            yM = yN;
  489|      0|          }
  490|      0|        }
  491|      0|      }
  492|      0|      else
  493|      0|      {
  494|       |        // yN >=0
  495|       |        // for the deblocker if this is the extra edge then do this special stuff
  496|      0|        if (yN == 0 && img->DeblockCall == 2)
  497|      0|        {
  498|      0|          pix->mb_addr  = currMb->mbAddrB + 1;
  499|      0|          pix->available = 1;
  500|      0|          yM = yN - 1;
  501|      0|        }
  502|       |
  503|      0|        else if ((yN >= 0) && (yN <maxH))
  504|      0|        {
  505|      0|          pix->mb_addr   = curr_mb_nr;
  506|      0|          pix->available = 1;
  507|      0|          yM = yN;
  508|      0|        }
  509|      0|      }
  510|      0|    }
  511|      0|    else
  512|      0|    { // xN >= maxW
  513|      0|      if(yN < 0)
  514|      0|      {
  515|      0|        if (!currMb->mb_field)
  516|      0|        {
  517|       |          // frame
  518|      0|          if (curr_mb_nr % 2 == 0)
  519|      0|          {
  520|       |            // top
  521|      0|            pix->mb_addr  = currMb->mbAddrC + 1;
  522|      0|            pix->available = currMb->mbAvailC;
  523|      0|            yM = yN;
  524|      0|          }
  525|      0|          else
  526|      0|          {
  527|       |            // bottom
  528|      0|            pix->available = 0;
  529|      0|          }
  530|      0|        }
  531|      0|        else
  532|      0|        {
  533|       |          // field
  534|      0|          if (curr_mb_nr % 2 == 0)
  535|      0|          {
  536|       |            // top
  537|      0|            pix->mb_addr   = currMb->mbAddrC;
  538|      0|            pix->available = currMb->mbAvailC;
  539|      0|            if (currMb->mbAvailC)
  540|      0|            {
  541|      0|              if(!img->mb_data[currMb->mbAddrC].mb_field)
  542|      0|              {
  543|      0|                (pix->mb_addr)++;
  544|      0|                 yM = 2* yN;
  545|      0|              }
  546|      0|              else
  547|      0|              {
  548|      0|                yM = yN;
  549|      0|              }
  550|      0|            }
  551|      0|          }
  552|      0|          else
  553|      0|          {
  554|       |            // bottom
  555|      0|            pix->mb_addr   = currMb->mbAddrC + 1;
  556|      0|            pix->available = currMb->mbAvailC;
  557|      0|            yM = yN;
  558|      0|          }
  559|      0|        }
  560|      0|      }
  561|      0|    }
  562|      0|  }
  563|      0|  if (pix->available || img->DeblockCall)
  564|      0|  {
  565|      0|    pix->x = (xN + maxW) % maxW;
  566|      0|    pix->y = (yM + maxH) % maxH;
  567|      0|    get_mb_pos(pix->mb_addr, &(pix->pos_x), &(pix->pos_y));
  568|      0|    if (luma)
  569|      0|    {
  570|      0|      pix->pos_x += pix->x;
  571|      0|      pix->pos_y += pix->y;
  572|      0|    }
  573|      0|    else
  574|      0|    {
  575|      0|      pix->pos_x = pix->pos_x/(16/img->mb_cr_size_x) + pix->x;
  576|      0|      pix->pos_y = pix->pos_y/(16/img->mb_cr_size_y) + pix->y;
  577|      0|    }
  578|      0|  }
  579|      0|}
  580|       |
  581|       |
  582|       |/*!
  583|       | ************************************************************************
  584|       | * \brief
  585|       | *    get neighbouring positions. MB AFF is automatically used from img structure
  586|       | * \param curr_mb_nr
  587|       | *   current macroblock number (decoding order)
  588|       | * \param xN
  589|       | *    input x position
  590|       | * \param yN
  591|       | *    input y position
  592|       | * \param luma
  593|       | *    1 if luma coding, 0 for chroma
  594|       | * \param pix
  595|       | *    returns position informations
  596|       | ************************************************************************
  597|       | */
  598|       |void getNeighbour(int curr_mb_nr, int xN, int yN, int luma, PixelPos *pix)
  599|   347M|{
  600|   347M|  if (curr_mb_nr<0)
  601|      0|    error ("getNeighbour: invalid macroblock number", 100);
  602|       |
  603|   347M|  if (img->MbaffFrameFlag)
  604|      0|    getAffNeighbour(curr_mb_nr, xN, yN, luma, pix);
  605|   347M|  else
  606|   347M|    getNonAffNeighbour(curr_mb_nr, xN, yN, luma, pix);
  607|   347M|}
  608|       |
  609|       |
  610|       |/*!
  611|       | ************************************************************************
  612|       | * \brief
  613|       | *    get neighbouring  get neighbouring 4x4 luma block
  614|       | * \param curr_mb_nr
  615|       | *   current macroblock number (decoding order)
  616|       | * \param block_x
  617|       | *    input x block position
  618|       | * \param block_y
  619|       | *    input y block position
  620|       | * \param rel_x
  621|       | *    relative x position of neighbor
  622|       | * \param rel_y
  623|       | *    relative y position of neighbor
  624|       | * \param pix
  625|       | *    returns position informations
  626|       | ************************************************************************
  627|       | */
  628|       |void getLuma4x4Neighbour (int curr_mb_nr, int block_x, int block_y, int rel_x, int rel_y, PixelPos *pix)
  629|   249M|{
  630|   249M|  int x = 4* block_x + rel_x;
  631|   249M|  int y = 4* block_y + rel_y;
  632|       |
  633|   249M|  getNeighbour(curr_mb_nr, x, y, 1, pix);
  634|       |
  635|   249M|  if (pix->available)
  636|   241M|  {
  637|   241M|    pix->x /= 4;
  638|   241M|    pix->y /= 4;
  639|   241M|    pix->pos_x /= 4;
  640|   241M|    pix->pos_y /= 4;
  641|   241M|  }
  642|   249M|}
  643|       |
  644|       |
  645|       |/*!
  646|       | ************************************************************************
  647|       | * \brief
  648|       | *    get neighbouring 4x4 chroma block
  649|       | * \param curr_mb_nr
  650|       | *   current macroblock number (decoding order)
  651|       | * \param block_x
  652|       | *    input x block position
  653|       | * \param block_y
  654|       | *    input y block position
  655|       | * \param rel_x
  656|       | *    relative x position of neighbor
  657|       | * \param rel_y
  658|       | *    relative y position of neighbor
  659|       | * \param pix
  660|       | *    returns position informations
  661|       | ************************************************************************
  662|       | */
  663|       |void getChroma4x4Neighbour (int curr_mb_nr, int block_x, int block_y, int rel_x, int rel_y, PixelPos *pix)
  664|  3.99M|{
  665|  3.99M|  int x = 4* block_x + rel_x;
  666|  3.99M|  int y = 4* block_y + rel_y;
  667|       |
  668|  3.99M|  getNeighbour(curr_mb_nr, x, y, 0, pix);
  669|       |
  670|  3.99M|  if (pix->available)
  671|  3.93M|  {
  672|  3.93M|    pix->x /= 4;
  673|  3.93M|    pix->y /= 4;
  674|  3.93M|    pix->pos_x /= 4;
  675|  3.93M|    pix->pos_y /= 4;
  676|  3.93M|  }
  677|  3.99M|}

/home/xzp/speccpu2006-v1.0.1/benchspec/CPU2006/464.h264ref/run/build_base_ql_riscv_llvm17.0000/mbuffer.c:
    1|       |
    2|       |/*!
    3|       | ***********************************************************************
    4|       | *  \file
    5|       | *      mbuffer.c
    6|       | *
    7|       | *  \brief
    8|       | *      Frame buffer functions
    9|       | *
   10|       | *  \author
   11|       | *      Main contributors (see contributors.h for copyright, address and affiliation details)
   12|       | *      - Karsten S�hring                 <suehring@hhi.de>
   13|       | *      - Alexis Tourapis                 <alexismt@ieee.org>
   14|       | ***********************************************************************
   15|       | */
   16|       |
   17|       |#include <stdlib.h>
   18|       |#include <assert.h>
   19|       |#include <limits.h>
   20|       |#include <string.h>
   21|       |
   22|       |#include "global.h"
   23|       |
   24|       |#include "mbuffer.h"
   25|       |#include "memalloc.h"
   26|       |#include "output.h"
   27|       |#include "image.h"
   28|       |
   29|       |static void insert_picture_in_dpb(FrameStore* fs, StorablePicture* p);
   30|       |static void output_one_frame_from_dpb();
   31|       |static int  is_used_for_reference(FrameStore* fs);
   32|       |static void get_smallest_poc(int *poc,int * pos);
   33|       |static int  remove_unused_frame_from_dpb();
   34|       |static int  is_short_term_reference(FrameStore* fs);
   35|       |static int  is_long_term_reference(FrameStore* fs);
   36|       |void gen_field_ref_ids(StorablePicture *p);
   37|       |
   38|       |DecodedPictureBuffer dpb;
   39|       |
   40|       |StorablePicture **listX[6];
   41|       |
   42|       |ColocatedParams *Co_located = NULL;
   43|       |
   44|       |
   45|       |int listXsize[6];
   46|       |
   47|  32.0k|#define MAX_LIST_SIZE 33
   48|       |
   49|       |/*!
   50|       | ************************************************************************
   51|       | * \brief
   52|       | *    Print out list of pictures in DPB. Used for debug purposes.
   53|       | ************************************************************************
   54|       | */
   55|       |void dump_dpb()
   56|    171|{
   57|    171|  unsigned i;
   58|       |
   59|    171|  return;
   60|       |  
   61|      0|  for (i=0; i<dpb.used_size;i++)
   62|      0|  {
   63|      0|    printf("(");
   64|      0|    printf("fn=%d  ", dpb.fs[i]->frame_num);
   65|      0|    if (dpb.fs[i]->is_used & 1)
   66|      0|    {
   67|      0|      if (dpb.fs[i]->top_field)
   68|      0|        printf("T: poc=%d  ", dpb.fs[i]->top_field->poc);
   69|      0|      else
   70|      0|        printf("T: poc=%d  ", dpb.fs[i]->frame->top_poc);
   71|      0|    }
   72|      0|    if (dpb.fs[i]->is_used & 2)
   73|      0|    {
   74|      0|      if (dpb.fs[i]->bottom_field)
   75|      0|        printf("B: poc=%d  ", dpb.fs[i]->bottom_field->poc);
   76|      0|      else
   77|      0|        printf("B: poc=%d  ", dpb.fs[i]->frame->bottom_poc);
   78|      0|    }
   79|      0|    if (dpb.fs[i]->is_used == 3)
   80|      0|      printf("F: poc=%d  ", dpb.fs[i]->frame->poc);
   81|      0|    printf("G: poc=%d)  ", dpb.fs[i]->poc);
   82|      0|    if (dpb.fs[i]->is_reference) printf ("ref (%d) ", dpb.fs[i]->is_reference);
   83|      0|    if (dpb.fs[i]->is_long_term) printf ("lt_ref (%d) ", dpb.fs[i]->is_reference);
   84|      0|    if (dpb.fs[i]->is_output) printf ("out  ");
   85|      0|    if (dpb.fs[i]->is_used == 3)
   86|      0|    {
   87|      0|      if (dpb.fs[i]->frame->non_existing) printf ("ne  ");
   88|      0|    }
   89|      0|    printf ("\n");
   90|      0|  }
   91|      0|}
   92|       |
   93|       |/*!
   94|       | ************************************************************************
   95|       | * \brief
   96|       | *    Returns the size of the dpb depending on level and picture size
   97|       | *
   98|       | *
   99|       | ************************************************************************
  100|       | */
  101|       |int getDpbSize()
  102|      1|{
  103|      1|  int pic_size = (active_sps->pic_width_in_mbs_minus1 + 1) * (active_sps->pic_height_in_map_units_minus1 + 1) * (active_sps->frame_mbs_only_flag?1:2) * 384;
  104|       |
  105|      1|  int size = 0;
  106|       |
  107|      1|  switch (active_sps->level_idc)
  108|      1|  {
  109|      0|  case 10:
  110|      0|    size = 152064;
  111|      0|    break;
  112|      0|  case 11:
  113|      0|    size = 345600;
  114|      0|    break;
  115|      0|  case 12:
  116|      0|    size = 912384;
  117|      0|    break;
  118|      0|  case 13:
  119|      0|    size = 912384;
  120|      0|    break;
  121|      0|  case 20:
  122|      0|    size = 912384;
  123|      0|    break;
  124|      0|  case 21:
  125|      0|    size = 1824768;
  126|      0|    break;
  127|      0|  case 22:
  128|      0|    size = 3110400;
  129|      0|    break;
  130|      1|  case 30:
  131|      1|    size = 3110400;
  132|      1|    break;
  133|      0|  case 31:
  134|      0|    size = 6912000;
  135|      0|    break;
  136|      0|  case 32:
  137|      0|    size = 7864320;
  138|      0|    break;
  139|      0|  case 40:
  140|      0|    size = 12582912;
  141|      0|    break;
  142|      0|  case 41:
  143|      0|    size = 12582912;
  144|      0|    break;
  145|      0|  case 42:
  146|      0|    size = 12582912;
  147|      0|    break;
  148|      0|  case 50:
  149|      0|    size = 42393600;
  150|      0|    break;
  151|      0|  case 51:
  152|      0|    size = 70778880;
  153|      0|    break;
  154|      0|  default:
  155|      0|    error ("undefined level", 500);
  156|      0|    break;
  157|      1|  }
  158|       |
  159|      1|  size /= pic_size;
  160|      1|  return min( size, 16);
  161|      1|}
  162|       |
  163|       |/*!
  164|       | ************************************************************************
  165|       | * \brief
  166|       | *    Allocate memory for decoded picture buffer and initialize with sane values.
  167|       | *
  168|       | ************************************************************************
  169|       | */
  170|       |void init_dpb()
  171|      1|{
  172|      1|  unsigned i,j;
  173|       |
  174|      1|  if (dpb.init_done)
  175|      0|  {
  176|      0|    free_dpb();
  177|      0|  }
  178|       |
  179|      1|  dpb.size      = getDpbSize();
  180|       |  
  181|      1|  if (dpb.size < (unsigned int)input->num_ref_frames)
  182|      0|  {
  183|      0|    error ("DPB size at specified level is smaller than the specified number of reference frames. This is not allowed.\n", 1000);
  184|      0|  }
  185|       |
  186|      1|  dpb.used_size = 0;
  187|      1|  dpb.last_picture = NULL;
  188|       |
  189|      1|  dpb.ref_frames_in_buffer = 0;
  190|      1|  dpb.ltref_frames_in_buffer = 0;
  191|       |  
  192|      1|  dpb.fs = calloc(dpb.size, sizeof (FrameStore*));
  193|      1|  if (NULL==dpb.fs) 
  194|      0|    no_mem_exit("init_dpb: dpb->fs");
  195|       |
  196|      1|  dpb.fs_ref = calloc(dpb.size, sizeof (FrameStore*));
  197|      1|  if (NULL==dpb.fs_ref) 
  198|      0|    no_mem_exit("init_dpb: dpb->fs_ref");
  199|       |
  200|      1|  dpb.fs_ltref = calloc(dpb.size, sizeof (FrameStore*));
  201|      1|  if (NULL==dpb.fs_ltref) 
  202|      0|    no_mem_exit("init_dpb: dpb->fs_ltref");
  203|       |
  204|     13|  for (i=0; i<dpb.size; i++)
  205|     12|  {
  206|     12|    dpb.fs[i]       = alloc_frame_store();
  207|     12|    dpb.fs_ref[i]   = NULL;
  208|     12|    dpb.fs_ltref[i] = NULL;
  209|     12|  }
  210|       |  
  211|      7|  for (i=0; i<6; i++)
  212|      6|  {
  213|      6|    listX[i] = calloc(MAX_LIST_SIZE, sizeof (StorablePicture*)); // +1 for reordering
  214|      6|    if (NULL==listX[i]) 
  215|      0|      no_mem_exit("init_dpb: listX[i]");
  216|      6|  }
  217|       |
  218|      7|  for (j=0;j<6;j++)
  219|      6|  {
  220|    204|    for (i=0; i<MAX_LIST_SIZE; i++)
  221|    198|    {
  222|    198|      listX[j][i] = NULL;
  223|    198|    }
  224|      6|    listXsize[j]=0;
  225|      6|  }
  226|       |
  227|      1|  dpb.last_output_poc = INT_MIN;
  228|       |
  229|      1|  img->last_has_mmco_5 = 0;
  230|       |
  231|      1|  dpb.init_done = 1;
  232|      1|}
  233|       |
  234|       |
  235|       |/*!
  236|       | ************************************************************************
  237|       | * \brief
  238|       | *    Free memory for decoded picture buffer.
  239|       | ************************************************************************
  240|       | */
  241|       |void free_dpb()
  242|      1|{
  243|      1|  unsigned i;
  244|      1|  if (dpb.fs)
  245|      1|  {
  246|     13|    for (i=0; i<dpb.size; i++)
  247|     12|    {
  248|     12|      free_frame_store(dpb.fs[i]);
  249|     12|    }
  250|      1|    free (dpb.fs);
  251|      1|    dpb.fs=NULL;
  252|      1|  }
  253|      1|  if (dpb.fs_ref)
  254|      1|  {
  255|      1|    free (dpb.fs_ref);
  256|      1|  }
  257|      1|  if (dpb.fs_ltref)
  258|      1|  {
  259|      1|    free (dpb.fs_ltref);
  260|      1|  }
  261|      1|  dpb.last_output_poc = INT_MIN;
  262|       |
  263|      7|  for (i=0; i<6; i++)
  264|      6|    if (listX[i])
  265|      6|    {
  266|      6|      free (listX[i]);
  267|      6|      listX[i] = NULL;
  268|      6|    }
  269|       |
  270|      1|  dpb.init_done = 0;
  271|      1|}
  272|       |
  273|       |
  274|       |/*!
  275|       | ************************************************************************
  276|       | * \brief
  277|       | *    Allocate memory for decoded picture buffer frame stores an initialize with sane values.
  278|       | *
  279|       | * \return
  280|       | *    the allocated FrameStore structure
  281|       | ************************************************************************
  282|       | */
  283|       |FrameStore* alloc_frame_store()
  284|     13|{
  285|     13|  FrameStore *f;
  286|       |
  287|     13|  f = calloc (1, sizeof(FrameStore));
  288|     13|  if (NULL==f) 
  289|      0|    no_mem_exit("alloc_frame_store: f");
  290|       |
  291|     13|  f->is_used      = 0;
  292|     13|  f->is_reference = 0;
  293|     13|  f->is_long_term = 0;
  294|     13|  f->is_orig_reference = 0;
  295|       |
  296|     13|  f->is_output = 0;
  297|       |
  298|     13|  f->frame        = NULL;;
  299|     13|  f->top_field    = NULL;
  300|     13|  f->bottom_field = NULL;
  301|       |
  302|     13|  return f;
  303|     13|}
  304|       |
  305|       |/*!
  306|       | ************************************************************************
  307|       | * \brief
  308|       | *    Allocate memory for a stored picture. 
  309|       | *
  310|       | * \param structure
  311|       | *    picture structure
  312|       | * \param size_x
  313|       | *    horizontal luma size
  314|       | * \param size_y
  315|       | *    vertical luma size
  316|       | * \param size_x_cr
  317|       | *    horizontal chroma size
  318|       | * \param size_y_cr
  319|       | *    vertical chroma size
  320|       | *
  321|       | * \return
  322|       | *    the allocated StorablePicture structure
  323|       | ************************************************************************
  324|       | */
  325|       |StorablePicture* alloc_storable_picture(PictureStructure structure, int size_x, int size_y, int size_x_cr, int size_y_cr)
  326|    171|{
  327|    171|  StorablePicture *s;
  328|       |
  329|       |  //printf ("Allocating (%s) picture (x=%d, y=%d, x_cr=%d, y_cr=%d)\n", (type == FRAME)?"FRAME":(type == TOP_FIELD)?"TOP_FIELD":"BOTTOM_FIELD", size_x, size_y, size_x_cr, size_y_cr);
  330|       |
  331|    171|  s = calloc (1, sizeof(StorablePicture));
  332|    171|  if (NULL==s) 
  333|      0|    no_mem_exit("alloc_storable_picture: s");
  334|       |
  335|    171|  get_mem2Dpel (&(s->imgY), size_y, size_x);
  336|       |  
  337|    171|  s->imgY_11  = NULL;
  338|    171|  s->imgY_ups = NULL;
  339|    171|  s->imgUV    = NULL;
  340|       |
  341|    171|  if (input->WeightedPrediction || input->WeightedBiprediction || input->GenerateMultiplePPS)
  342|      0|  {
  343|      0|      s->imgY_11_w = NULL;
  344|      0|      s->imgY_ups_w = NULL;
  345|      0|  }
  346|       |
  347|    171|  if (img->yuv_format != YUV400)
  348|    171|    get_mem3Dpel (&(s->imgUV), 2, size_y_cr, size_x_cr);
  349|       |
  350|    171|  s->mb_field = calloc (img->PicSizeInMbs, sizeof(int));
  351|    171|  if (NULL==s->mb_field) 
  352|      0|    no_mem_exit("alloc_storable_picture: s->mb_field");
  353|       |
  354|    171|  get_mem3Dshort (&(s->ref_idx), 2, size_x / BLOCK_SIZE, size_y / BLOCK_SIZE);
  355|    171|  get_mem3Dint64 (&(s->ref_pic_id), 6, size_x / BLOCK_SIZE, size_y / BLOCK_SIZE);
  356|    171|  get_mem3Dint64 (&(s->ref_id), 6, size_x / BLOCK_SIZE, size_y / BLOCK_SIZE);
  357|    171|  get_mem4Dshort (&(s->mv), 2, size_x / BLOCK_SIZE, size_y / BLOCK_SIZE,2 );
  358|       |
  359|    171|  get_mem2D (&(s->moving_block), size_x / BLOCK_SIZE, size_y / BLOCK_SIZE);
  360|    171|  get_mem2D (&(s->field_frame), size_x / BLOCK_SIZE, size_y / BLOCK_SIZE);
  361|       |
  362|    171|  s->pic_num=0;
  363|    171|  s->frame_num=0;
  364|    171|  s->long_term_frame_idx=0;
  365|    171|  s->long_term_pic_num=0;
  366|    171|  s->used_for_reference=0;
  367|    171|  s->is_long_term=0;
  368|    171|  s->non_existing=0;
  369|    171|  s->is_output = 0;
  370|       |
  371|    171|  s->structure=structure;
  372|       |
  373|    171|  s->size_x = size_x;
  374|    171|  s->size_y = size_y;
  375|    171|  s->size_x_cr = size_x_cr;
  376|    171|  s->size_y_cr = size_y_cr;
  377|       |  
  378|    171|  s->top_field    = NULL;
  379|    171|  s->bottom_field = NULL;
  380|    171|  s->frame        = NULL;
  381|       |
  382|    171|  s->coded_frame                   = 0;
  383|    171|  s->MbaffFrameFlag    = 0;
  384|       |
  385|    171|  return s;
  386|    171|}
  387|       |
  388|       |/*!
  389|       | ************************************************************************
  390|       | * \brief
  391|       | *    Free frame store memory.
  392|       | *
  393|       | * \param f
  394|       | *    FrameStore to be freed
  395|       | *
  396|       | ************************************************************************
  397|       | */
  398|       |void free_frame_store(FrameStore* f)
  399|     13|{
  400|     13|  if (f)
  401|     13|  {
  402|     13|    if (f->frame)
  403|      0|    {
  404|      0|      free_storable_picture(f->frame);
  405|      0|      f->frame=NULL;
  406|      0|    }
  407|     13|    if (f->top_field)
  408|      0|    {
  409|      0|      free_storable_picture(f->top_field);
  410|      0|      f->top_field=NULL;
  411|      0|    }
  412|     13|    if (f->bottom_field)
  413|      0|    {
  414|      0|      free_storable_picture(f->bottom_field);
  415|      0|      f->bottom_field=NULL;
  416|      0|    }
  417|     13|    free(f);
  418|     13|  }
  419|     13|}
  420|       |
  421|       |/*!
  422|       | ************************************************************************
  423|       | * \brief
  424|       | *    Free picture memory.
  425|       | *
  426|       | * \param p
  427|       | *    Picture to be freed
  428|       | *
  429|       | ************************************************************************
  430|       | */
  431|       |void free_storable_picture(StorablePicture* p)
  432|    855|{
  433|    855|  if (p)
  434|    171|  {
  435|    171|    if (p->ref_idx)
  436|    171|    {
  437|    171|      free_mem3Dshort (p->ref_idx, 2);
  438|    171|      p->ref_idx = NULL;
  439|    171|    }
  440|       |    
  441|    171|    if (p->ref_pic_id)
  442|    171|    {
  443|    171|      free_mem3Dint64 (p->ref_pic_id, 6);
  444|    171|      p->ref_pic_id = NULL;
  445|    171|    }
  446|    171|    if (p->ref_id)
  447|    171|    {
  448|    171|      free_mem3Dint64 (p->ref_id, 6);
  449|    171|      p->ref_id = NULL;
  450|    171|    }
  451|    171|    if (p->mv)
  452|    171|    {
  453|    171|      free_mem4Dshort (p->mv, 2, p->size_x / BLOCK_SIZE);
  454|    171|      p->mv = NULL;
  455|    171|    }
  456|       |
  457|    171|    if (p->moving_block)
  458|    171|    {
  459|    171|      free_mem2D (p->moving_block);
  460|    171|      p->moving_block=NULL;
  461|    171|    }
  462|       |
  463|    171|    if (p->field_frame)
  464|    171|    {
  465|    171|      free_mem2D (p->field_frame);
  466|    171|      p->field_frame=NULL;
  467|    171|    }
  468|       |
  469|       |    
  470|    171|    if (p->imgY)
  471|    171|    {
  472|    171|      free_mem2Dpel (p->imgY);
  473|    171|      p->imgY=NULL;
  474|    171|    }
  475|    171|    if (p->imgY_11)
  476|     86|    {
  477|     86|      free (p->imgY_11);
  478|     86|      p->imgY_11=NULL;
  479|     86|    }
  480|    171|    if (p->imgY_ups)
  481|      0|    {
  482|      0|      free_mem2Dpel (p->imgY_ups);
  483|      0|      p->imgY_ups=NULL;
  484|      0|    }
  485|    171|    if (p->imgUV)
  486|    171|    {
  487|    171|      free_mem3Dpel (p->imgUV, 2);
  488|    171|      p->imgUV=NULL;
  489|    171|    }
  490|       |
  491|    171|    if (input->WeightedPrediction || input->WeightedBiprediction || input->GenerateMultiplePPS)
  492|      0|    {
  493|      0|      if (p->imgY_11_w)
  494|      0|      {
  495|      0|        free (p->imgY_11_w);
  496|      0|        p->imgY_11_w=NULL;
  497|      0|      }
  498|      0|      if (p->imgY_ups_w)
  499|      0|      {
  500|      0|        free_mem2Dpel (p->imgY_ups_w);
  501|      0|        p->imgY_ups_w=NULL;
  502|      0|      }
  503|      0|    }
  504|       |    
  505|    171|    if (p->mb_field)
  506|    171|    {
  507|    171|      free(p->mb_field);
  508|    171|      p->mb_field=NULL;
  509|    171|    }
  510|       |
  511|    171|    free(p);
  512|    171|    p = NULL;
  513|    171|  }
  514|    855|}
  515|       |
  516|       |/*!
  517|       | ************************************************************************
  518|       | * \brief
  519|       | *    mark FrameStore unused for reference
  520|       | *
  521|       | ************************************************************************
  522|       | */
  523|       |static void unmark_for_reference(FrameStore* fs)
  524|     93|{
  525|       |
  526|     93|  if (!active_sps->frame_mbs_only_flag)
  527|      0|  {
  528|      0|    if (fs->is_used & 1)
  529|      0|    {
  530|      0|      fs->top_field->used_for_reference = 0;
  531|      0|    }
  532|      0|    if (fs->is_used & 2)
  533|      0|    {
  534|      0|      fs->bottom_field->used_for_reference = 0;
  535|      0|    }
  536|      0|  }
  537|       |
  538|     93|  if (fs->is_used == 3)
  539|     93|  {
  540|     93|    if (!active_sps->frame_mbs_only_flag)
  541|      0|    {
  542|      0|      fs->top_field->used_for_reference = 0;
  543|      0|      fs->bottom_field->used_for_reference = 0;
  544|      0|    }
  545|     93|    fs->frame->used_for_reference = 0;
  546|     93|  }
  547|       |
  548|     93|  fs->is_reference = 0;
  549|       |
  550|     93|  if (fs->frame->imgY_ups_w)
  551|      0|  {
  552|      0|    free_mem2Dpel (fs->frame->imgY_ups_w);
  553|      0|    fs->frame->imgY_ups_w=NULL;
  554|      0|  }
  555|     93|  if (fs->frame->imgY_ups)
  556|     86|  {
  557|     86|    free_mem2Dpel (fs->frame->imgY_ups);
  558|     86|    fs->frame->imgY_ups=NULL;
  559|     86|  }
  560|     93|  if (fs->frame->imgY_11_w)
  561|      0|  {
  562|      0|    free (fs->frame->imgY_11_w);
  563|      0|    fs->frame->imgY_11_w=NULL;
  564|      0|  }
  565|     93|}
  566|       |
  567|       |
  568|       |/*!
  569|       | ************************************************************************
  570|       | * \brief
  571|       | *    mark FrameStore unused for reference and reset long term flags
  572|       | *
  573|       | ************************************************************************
  574|       | */
  575|       |static void unmark_for_long_term_reference(FrameStore* fs)
  576|      0|{
  577|       |
  578|      0|  if (!active_sps->frame_mbs_only_flag)
  579|      0|  {
  580|      0|    if (fs->is_used & 1)
  581|      0|    {
  582|      0|      fs->top_field->used_for_reference = 0;
  583|      0|      fs->top_field->is_long_term = 0;
  584|      0|    }
  585|      0|    if (fs->is_used & 2)
  586|      0|    {
  587|      0|      fs->bottom_field->used_for_reference = 0;
  588|      0|      fs->bottom_field->is_long_term = 0;
  589|      0|    }
  590|      0|  }
  591|      0|  if (fs->is_used == 3)
  592|      0|  {
  593|      0|    if (!active_sps->frame_mbs_only_flag)
  594|      0|    {
  595|      0|      fs->top_field->used_for_reference = 0;
  596|      0|      fs->top_field->is_long_term = 0;
  597|      0|      fs->bottom_field->used_for_reference = 0;
  598|      0|      fs->bottom_field->is_long_term = 0;
  599|      0|    }
  600|      0|    fs->frame->used_for_reference = 0;
  601|      0|    fs->frame->is_long_term = 0;
  602|      0|  }
  603|       |
  604|      0|  fs->is_reference = 0;
  605|      0|  fs->is_long_term = 0;
  606|      0|}
  607|       |
  608|       |
  609|       |/*!
  610|       | ************************************************************************
  611|       | * \brief
  612|       | *    compares two stored pictures by picture number for qsort in descending order
  613|       | *
  614|       | ************************************************************************
  615|       | */
  616|       |static int compare_pic_by_pic_num_desc( const void *arg1, const void *arg2 )
  617|    383|{
  618|    383|  if ( (*(StorablePicture**)arg1)->pic_num < (*(StorablePicture**)arg2)->pic_num)
  619|    383|    return 1;
  620|      0|  if ( (*(StorablePicture**)arg1)->pic_num > (*(StorablePicture**)arg2)->pic_num)
  621|      0|    return -1;
  622|      0|  else
  623|      0|    return 0;
  624|      0|}
  625|       |
  626|       |/*!
  627|       | ************************************************************************
  628|       | * \brief
  629|       | *    compares two stored pictures by picture number for qsort in descending order
  630|       | *
  631|       | ************************************************************************
  632|       | */
  633|       |static int compare_pic_by_lt_pic_num_asc( const void *arg1, const void *arg2 )
  634|      0|{
  635|      0|  if ( (*(StorablePicture**)arg1)->long_term_pic_num < (*(StorablePicture**)arg2)->long_term_pic_num)
  636|      0|    return -1;
  637|      0|  if ( (*(StorablePicture**)arg1)->long_term_pic_num > (*(StorablePicture**)arg2)->long_term_pic_num)
  638|      0|    return 1;
  639|      0|  else
  640|      0|    return 0;
  641|      0|}
  642|       |
  643|       |/*!
  644|       | ************************************************************************
  645|       | * \brief
  646|       | *    compares two frame stores by pic_num for qsort in descending order
  647|       | *
  648|       | ************************************************************************
  649|       | */
  650|       |static int compare_fs_by_frame_num_desc( const void *arg1, const void *arg2 )
  651|      0|{
  652|      0|  if ( (*(FrameStore**)arg1)->frame_num_wrap < (*(FrameStore**)arg2)->frame_num_wrap)
  653|      0|    return 1;
  654|      0|  if ( (*(FrameStore**)arg1)->frame_num_wrap > (*(FrameStore**)arg2)->frame_num_wrap)
  655|      0|    return -1;
  656|      0|  else
  657|      0|    return 0;
  658|      0|}
  659|       |
  660|       |
  661|       |/*!
  662|       | ************************************************************************
  663|       | * \brief
  664|       | *    compares two frame stores by lt_pic_num for qsort in descending order
  665|       | *
  666|       | ************************************************************************
  667|       | */
  668|       |static int compare_fs_by_lt_pic_idx_asc( const void *arg1, const void *arg2 )
  669|      0|{
  670|      0|  if ( (*(FrameStore**)arg1)->long_term_frame_idx < (*(FrameStore**)arg2)->long_term_frame_idx)
  671|      0|    return -1;
  672|      0|  if ( (*(FrameStore**)arg1)->long_term_frame_idx > (*(FrameStore**)arg2)->long_term_frame_idx)
  673|      0|    return 1;
  674|      0|  else
  675|      0|    return 0;
  676|      0|}
  677|       |
  678|       |
  679|       |/*!
  680|       | ************************************************************************
  681|       | * \brief
  682|       | *    compares two stored pictures by poc for qsort in ascending order
  683|       | *
  684|       | ************************************************************************
  685|       | */
  686|       |static int compare_pic_by_poc_asc( const void *arg1, const void *arg2 )
  687|      0|{
  688|      0|  if ( (*(StorablePicture**)arg1)->poc < (*(StorablePicture**)arg2)->poc)
  689|      0|    return -1;
  690|      0|  if ( (*(StorablePicture**)arg1)->poc > (*(StorablePicture**)arg2)->poc)
  691|      0|    return 1;
  692|      0|  else
  693|      0|    return 0;
  694|      0|}
  695|       |
  696|       |
  697|       |/*!
  698|       | ************************************************************************
  699|       | * \brief
  700|       | *    compares two stored pictures by poc for qsort in descending order
  701|       | *
  702|       | ************************************************************************
  703|       | */
  704|       |static int compare_pic_by_poc_desc( const void *arg1, const void *arg2 )
  705|    332|{
  706|    332|  if ( (*(StorablePicture**)arg1)->poc < (*(StorablePicture**)arg2)->poc)
  707|    332|    return 1;
  708|      0|  if ( (*(StorablePicture**)arg1)->poc > (*(StorablePicture**)arg2)->poc)
  709|      0|    return -1;
  710|      0|  else
  711|      0|    return 0;
  712|      0|}
  713|       |
  714|       |
  715|       |/*!
  716|       | ************************************************************************
  717|       | * \brief
  718|       | *    compares two frame stores by poc for qsort in ascending order
  719|       | *
  720|       | ************************************************************************
  721|       | */
  722|       |static int compare_fs_by_poc_asc( const void *arg1, const void *arg2 )
  723|      0|{
  724|      0|  if ( (*(FrameStore**)arg1)->poc < (*(FrameStore**)arg2)->poc)
  725|      0|    return -1;
  726|      0|  if ( (*(FrameStore**)arg1)->poc > (*(FrameStore**)arg2)->poc)
  727|      0|    return 1;
  728|      0|  else
  729|      0|    return 0;
  730|      0|}
  731|       |
  732|       |
  733|       |/*!
  734|       | ************************************************************************
  735|       | * \brief
  736|       | *    compares two frame stores by poc for qsort in descending order
  737|       | *
  738|       | ************************************************************************
  739|       | */
  740|       |static int compare_fs_by_poc_desc( const void *arg1, const void *arg2 )
  741|      0|{
  742|      0|  if ( (*(FrameStore**)arg1)->poc < (*(FrameStore**)arg2)->poc)
  743|      0|    return 1;
  744|      0|  if ( (*(FrameStore**)arg1)->poc > (*(FrameStore**)arg2)->poc)
  745|      0|    return -1;
  746|      0|  else
  747|      0|    return 0;
  748|      0|}
  749|       |
  750|       |
  751|       |/*!
  752|       | ************************************************************************
  753|       | * \brief
  754|       | *    returns true, if picture is short term reference picture
  755|       | *
  756|       | ************************************************************************
  757|       | */
  758|       |int is_short_ref(StorablePicture *s)
  759|      0|{
  760|      0|  return ((s->used_for_reference) && (!(s->is_long_term)));
  761|      0|}
  762|       |
  763|       |
  764|       |/*!
  765|       | ************************************************************************
  766|       | * \brief
  767|       | *    returns true, if picture is long term reference picture
  768|       | *
  769|       | ************************************************************************
  770|       | */
  771|       |int is_long_ref(StorablePicture *s)
  772|      0|{
  773|      0|  return ((s->used_for_reference) && (s->is_long_term));
  774|      0|}
  775|       |
  776|       |
  777|       |/*!
  778|       | ************************************************************************
  779|       | * \brief
  780|       | *    Generates a alternating field list from a given FrameStore list
  781|       | *
  782|       | ************************************************************************
  783|       | */
  784|       |static void gen_pic_list_from_frame_list(PictureStructure currStrcture, FrameStore **fs_list, int list_idx, StorablePicture **list, int *list_size, int long_term)
  785|      0|{
  786|      0|  int top_idx = 0;
  787|      0|  int bot_idx = 0;
  788|       |
  789|      0|  int (*is_ref)(StorablePicture *s);
  790|       |
  791|      0|  if (long_term)
  792|      0|    is_ref=is_long_ref;
  793|      0|  else
  794|      0|    is_ref=is_short_ref;
  795|       |
  796|      0|  if (currStrcture == TOP_FIELD)
  797|      0|  {
  798|      0|    while ((top_idx<list_idx)||(bot_idx<list_idx))
  799|      0|    {
  800|      0|      for ( ; top_idx<list_idx; top_idx++)
  801|      0|      {
  802|      0|        if(fs_list[top_idx]->is_used & 1)
  803|      0|        {
  804|      0|          if(is_ref(fs_list[top_idx]->top_field))
  805|      0|          {
  806|       |            // short term ref pic
  807|      0|            list[*list_size] = fs_list[top_idx]->top_field;
  808|      0|            (*list_size)++;
  809|      0|            top_idx++;
  810|      0|            break;
  811|      0|          }
  812|      0|        }
  813|      0|      }
  814|      0|      for ( ; bot_idx<list_idx; bot_idx++)
  815|      0|      {
  816|      0|        if(fs_list[bot_idx]->is_used & 2)
  817|      0|        {
  818|      0|          if(is_ref(fs_list[bot_idx]->bottom_field))
  819|      0|          {
  820|       |            // short term ref pic
  821|      0|            list[*list_size] = fs_list[bot_idx]->bottom_field;
  822|      0|            (*list_size)++;
  823|      0|            bot_idx++;
  824|      0|            break;
  825|      0|          }
  826|      0|        }
  827|      0|      }
  828|      0|    }
  829|      0|  }
  830|      0|  if (currStrcture == BOTTOM_FIELD)
  831|      0|  {
  832|      0|    while ((top_idx<list_idx)||(bot_idx<list_idx))
  833|      0|    {
  834|      0|      for ( ; bot_idx<list_idx; bot_idx++)
  835|      0|      {
  836|      0|        if(fs_list[bot_idx]->is_used & 2)
  837|      0|        {
  838|      0|          if(is_ref(fs_list[bot_idx]->bottom_field))
  839|      0|          {
  840|       |            // short term ref pic
  841|      0|            list[*list_size] = fs_list[bot_idx]->bottom_field;
  842|      0|            (*list_size)++;
  843|      0|            bot_idx++;
  844|      0|            break;
  845|      0|          }
  846|      0|        }
  847|      0|      }
  848|      0|      for ( ; top_idx<list_idx; top_idx++)
  849|      0|      {
  850|      0|        if(fs_list[top_idx]->is_used & 1)
  851|      0|        {
  852|      0|          if(is_ref(fs_list[top_idx]->top_field))
  853|      0|          {
  854|       |            // short term ref pic
  855|      0|            list[*list_size] = fs_list[top_idx]->top_field;
  856|      0|            (*list_size)++;
  857|      0|            top_idx++;
  858|      0|            break;
  859|      0|          }
  860|      0|        }
  861|      0|      }
  862|      0|    }
  863|      0|  }
  864|      0|}
  865|       |
  866|       |
  867|       |/*!
  868|       | ************************************************************************
  869|       | * \brief
  870|       | *    Initialize listX[0] and list 1 depending on current picture type
  871|       | *
  872|       | ************************************************************************
  873|       | */
  874|       |void init_lists(int currSliceType, PictureStructure currPicStructure)
  875|    171|{
  876|    171|  int add_top = 0, add_bottom = 0;
  877|    171|  unsigned i;
  878|    171|  int j;
  879|    171|  int MaxFrameNum = 1 << (log2_max_frame_num_minus4 + 4);
  880|    171|  int diff;
  881|       |
  882|    171|  int list0idx = 0;
  883|    171|  int list0idx_1 = 0;
  884|    171|  int listltidx = 0;
  885|       |
  886|    171|  FrameStore **fs_list0;
  887|    171|  FrameStore **fs_list1;
  888|    171|  FrameStore **fs_listlt;
  889|       |
  890|    171|  StorablePicture *tmp_s;
  891|       |
  892|    171|  if (currPicStructure == FRAME)  
  893|    171|  {
  894|  1.00k|    for (i=0; i<dpb.ref_frames_in_buffer; i++)
  895|    834|    {
  896|    834|      if (dpb.fs_ref[i]->is_used==3)
  897|    834|      {
  898|    834|        if ((dpb.fs_ref[i]->frame->used_for_reference)&&(!dpb.fs_ref[i]->frame->is_long_term))
  899|    834|        {
  900|    834|          if( dpb.fs_ref[i]->frame_num > img->frame_num )
  901|    150|          {
  902|    150|            dpb.fs_ref[i]->frame_num_wrap = dpb.fs_ref[i]->frame_num - MaxFrameNum;
  903|    150|          }
  904|    684|          else
  905|    684|          {
  906|    684|            dpb.fs_ref[i]->frame_num_wrap = dpb.fs_ref[i]->frame_num;
  907|    684|          }
  908|    834|          dpb.fs_ref[i]->frame->pic_num = dpb.fs_ref[i]->frame_num_wrap;
  909|    834|          dpb.fs_ref[i]->frame->order_num=list0idx;
  910|    834|        }
  911|    834|      }
  912|    834|    }
  913|    171|  }
  914|      0|  else
  915|      0|  {
  916|      0|    if (currPicStructure == TOP_FIELD)
  917|      0|    {
  918|      0|      add_top    = 1;
  919|      0|      add_bottom = 0;
  920|      0|    }
  921|      0|    else
  922|      0|    {
  923|      0|      add_top    = 0;
  924|      0|      add_bottom = 1;
  925|      0|    }
  926|       |    
  927|      0|    for (i=0; i<dpb.ref_frames_in_buffer; i++)
  928|      0|    {
  929|      0|      if (dpb.fs_ref[i]->is_reference)
  930|      0|      {
  931|      0|        if( dpb.fs_ref[i]->frame_num > img->frame_num )
  932|      0|        {
  933|      0|          dpb.fs_ref[i]->frame_num_wrap = dpb.fs_ref[i]->frame_num - MaxFrameNum;
  934|      0|        }
  935|      0|        else
  936|      0|        {
  937|      0|          dpb.fs_ref[i]->frame_num_wrap = dpb.fs_ref[i]->frame_num;
  938|      0|        }
  939|      0|        if (dpb.fs_ref[i]->is_reference & 1)
  940|      0|        {
  941|      0|          dpb.fs_ref[i]->top_field->pic_num = (2 * dpb.fs_ref[i]->frame_num_wrap) + add_top;
  942|      0|        }
  943|      0|        if (dpb.fs_ref[i]->is_reference & 2)
  944|      0|        {
  945|      0|          dpb.fs_ref[i]->bottom_field->pic_num = (2 * dpb.fs_ref[i]->frame_num_wrap) + add_bottom;
  946|      0|        }
  947|      0|      }
  948|      0|    }
  949|      0|  }
  950|       |
  951|    171|  if ((currSliceType == I_SLICE)||(currSliceType == SI_SLICE))
  952|     29|  {
  953|     29|    listXsize[0] = 0;
  954|     29|    listXsize[1] = 0;
  955|     29|    return;
  956|     29|  }
  957|       |
  958|    142|  if ((currSliceType == P_SLICE)||(currSliceType == SP_SLICE))
  959|     57|  {
  960|       |    // Calculate FrameNumWrap and PicNum
  961|     57|    if (currPicStructure == FRAME)  
  962|     57|    {
  963|    334|      for (i=0; i<dpb.ref_frames_in_buffer; i++)
  964|    277|      {
  965|    277|        if (dpb.fs_ref[i]->is_used==3)
  966|    277|        {
  967|    277|          if ((dpb.fs_ref[i]->frame->used_for_reference)&&(!dpb.fs_ref[i]->frame->is_long_term))
  968|    277|          {
  969|    277|            listX[0][list0idx++] = dpb.fs_ref[i]->frame;
  970|    277|          }
  971|    277|        }
  972|    277|      }
  973|       |      // order list 0 by PicNum
  974|     57|      qsort((void *)listX[0], list0idx, sizeof(StorablePicture*), compare_pic_by_pic_num_desc);
  975|     57|      listXsize[0] = list0idx;
  976|       |//      printf("listX[0] (PicNum): "); for (i=0; i<list0idx; i++){printf ("%d  ", listX[0][i]->pic_num);} printf("\n");
  977|       |
  978|       |      // long term handling
  979|     57|      for (i=0; i<dpb.ltref_frames_in_buffer; i++)
  980|      0|      {
  981|      0|        if (dpb.fs_ltref[i]->is_used==3)
  982|      0|        {
  983|      0|          if (dpb.fs_ltref[i]->frame->is_long_term)
  984|      0|          {
  985|      0|            dpb.fs_ltref[i]->frame->long_term_pic_num = dpb.fs_ltref[i]->frame->long_term_frame_idx;
  986|      0|            dpb.fs_ltref[i]->frame->order_num=list0idx;
  987|      0|            listX[0][list0idx++]=dpb.fs_ltref[i]->frame;
  988|      0|          }
  989|      0|        }
  990|      0|      }
  991|     57|      qsort((void *)&listX[0][listXsize[0]], list0idx-listXsize[0], sizeof(StorablePicture*), compare_pic_by_lt_pic_num_asc);
  992|     57|      listXsize[0] = list0idx;
  993|     57|    }
  994|      0|    else
  995|      0|    {
  996|      0|      fs_list0 = calloc(dpb.size, sizeof (FrameStore*));
  997|      0|      if (NULL==fs_list0) 
  998|      0|         no_mem_exit("init_lists: fs_list0");
  999|      0|      fs_listlt = calloc(dpb.size, sizeof (FrameStore*));
 1000|      0|      if (NULL==fs_listlt) 
 1001|      0|         no_mem_exit("init_lists: fs_listlt");
 1002|       |
 1003|      0|      for (i=0; i<dpb.ref_frames_in_buffer; i++)
 1004|      0|      {
 1005|      0|        if (dpb.fs_ref[i]->is_reference)
 1006|      0|        {
 1007|      0|          fs_list0[list0idx++] = dpb.fs_ref[i];
 1008|      0|        }
 1009|      0|      }
 1010|       |
 1011|      0|      qsort((void *)fs_list0, list0idx, sizeof(FrameStore*), compare_fs_by_frame_num_desc);
 1012|       |
 1013|       |//      printf("fs_list0 (FrameNum): "); for (i=0; i<list0idx; i++){printf ("%d  ", fs_list0[i]->frame_num_wrap);} printf("\n");
 1014|       |
 1015|      0|      listXsize[0] = 0;
 1016|      0|      gen_pic_list_from_frame_list(currPicStructure, fs_list0, list0idx, listX[0], &listXsize[0], 0);
 1017|       |
 1018|       |//      printf("listX[0] (PicNum): "); for (i=0; i<listXsize[0]; i++){printf ("%d  ", listX[0][i]->pic_num);} printf("\n");
 1019|       |
 1020|       |      // long term handling
 1021|      0|      for (i=0; i<dpb.ltref_frames_in_buffer; i++)
 1022|      0|      {
 1023|      0|        fs_listlt[listltidx++]=dpb.fs_ltref[i];
 1024|      0|        if (dpb.fs_ltref[i]->is_long_term & 1)
 1025|      0|        {
 1026|      0|          dpb.fs_ltref[i]->top_field->long_term_pic_num = 2 * dpb.fs_ltref[i]->top_field->long_term_frame_idx + add_top;
 1027|      0|        }
 1028|      0|        if (dpb.fs_ltref[i]->is_long_term & 2)
 1029|      0|        {
 1030|      0|          dpb.fs_ltref[i]->bottom_field->long_term_pic_num = 2 * dpb.fs_ltref[i]->bottom_field->long_term_frame_idx + add_bottom;
 1031|      0|        }
 1032|      0|      }
 1033|       |
 1034|      0|      qsort((void *)fs_listlt, listltidx, sizeof(FrameStore*), compare_fs_by_lt_pic_idx_asc);
 1035|       |
 1036|      0|      gen_pic_list_from_frame_list(currPicStructure, fs_listlt, listltidx, listX[0], &listXsize[0], 1);
 1037|       |
 1038|      0|      free(fs_list0);
 1039|      0|      free(fs_listlt);
 1040|      0|    }
 1041|     57|    listXsize[1] = 0;
 1042|     57|  }
 1043|     85|  else
 1044|     85|  {
 1045|       |    // B-Slice
 1046|     85|    if (currPicStructure == FRAME)  
 1047|     85|    {
 1048|    504|      for (i=0; i<dpb.ref_frames_in_buffer; i++)
 1049|    419|      {
 1050|    419|        if (dpb.fs_ref[i]->is_used==3)
 1051|    419|        {
 1052|    419|          if ((dpb.fs_ref[i]->frame->used_for_reference)&&(!dpb.fs_ref[i]->frame->is_long_term))
 1053|    419|          {
 1054|    419|            if (img->framepoc > dpb.fs_ref[i]->frame->poc)
 1055|    334|            {
 1056|    334|              dpb.fs_ref[i]->frame->order_num=list0idx;
 1057|    334|              listX[0][list0idx++] = dpb.fs_ref[i]->frame;
 1058|    334|            }
 1059|    419|          }
 1060|    419|        }
 1061|    419|      }
 1062|     85|      qsort((void *)listX[0], list0idx, sizeof(StorablePicture*), compare_pic_by_poc_desc);
 1063|     85|      list0idx_1 = list0idx;
 1064|    504|      for (i=0; i<dpb.ref_frames_in_buffer; i++)
 1065|    419|      {
 1066|    419|        if (dpb.fs_ref[i]->is_used==3)
 1067|    419|        {
 1068|    419|          if ((dpb.fs_ref[i]->frame->used_for_reference)&&(!dpb.fs_ref[i]->frame->is_long_term))
 1069|    419|          {
 1070|    419|            if (img->framepoc < dpb.fs_ref[i]->frame->poc)
 1071|     85|            {
 1072|     85|              dpb.fs_ref[i]->frame->order_num=list0idx;
 1073|     85|              listX[0][list0idx++] = dpb.fs_ref[i]->frame;
 1074|     85|            }
 1075|    419|          }
 1076|    419|        }
 1077|    419|      }
 1078|     85|      qsort((void *)&listX[0][list0idx_1], list0idx-list0idx_1, sizeof(StorablePicture*), compare_pic_by_poc_asc);
 1079|       |
 1080|    419|      for (j=0; j<list0idx_1; j++)
 1081|    334|      {
 1082|    334|        listX[1][list0idx-list0idx_1+j]=listX[0][j];
 1083|    334|      }
 1084|    170|      for (j=list0idx_1; j<list0idx; j++)
 1085|     85|      {
 1086|     85|        listX[1][j-list0idx_1]=listX[0][j];
 1087|     85|      }
 1088|       |
 1089|     85|      listXsize[0] = listXsize[1] = list0idx;
 1090|       |
 1091|       |//      printf("listX[0] currPoc=%d (Poc): ", img->framepoc); for (i=0; i<listXsize[0]; i++){printf ("%d  ", listX[0][i]->poc);} printf("\n");
 1092|       |//      printf("listX[1] currPoc=%d (Poc): ", img->framepoc); for (i=0; i<listXsize[1]; i++){printf ("%d  ", listX[1][i]->poc);} printf("\n");
 1093|       |
 1094|       |      // long term handling
 1095|     85|      for (i=0; i<dpb.ltref_frames_in_buffer; i++)
 1096|      0|      {
 1097|      0|        if (dpb.fs_ltref[i]->is_used==3)
 1098|      0|        {
 1099|      0|          if (dpb.fs_ltref[i]->frame->is_long_term)
 1100|      0|          {
 1101|      0|            dpb.fs_ltref[i]->frame->long_term_pic_num = dpb.fs_ltref[i]->frame->long_term_frame_idx;
 1102|      0|            dpb.fs_ltref[i]->frame->order_num=list0idx;
 1103|       |
 1104|      0|            listX[0][list0idx]  =dpb.fs_ltref[i]->frame;
 1105|      0|            listX[1][list0idx++]=dpb.fs_ltref[i]->frame;
 1106|      0|          }
 1107|      0|        }
 1108|      0|      }
 1109|     85|      qsort((void *)&listX[0][listXsize[0]], list0idx-listXsize[0], sizeof(StorablePicture*), compare_pic_by_lt_pic_num_asc);
 1110|     85|      qsort((void *)&listX[1][listXsize[0]], list0idx-listXsize[0], sizeof(StorablePicture*), compare_pic_by_lt_pic_num_asc);
 1111|     85|      listXsize[0] = listXsize[1] = list0idx;
 1112|     85|    }
 1113|      0|    else
 1114|      0|    {
 1115|      0|      fs_list0 = calloc(dpb.size, sizeof (FrameStore*));
 1116|      0|      if (NULL==fs_list0) 
 1117|      0|         no_mem_exit("init_lists: fs_list0");
 1118|      0|      fs_list1 = calloc(dpb.size, sizeof (FrameStore*));
 1119|      0|      if (NULL==fs_list1) 
 1120|      0|         no_mem_exit("init_lists: fs_list1");
 1121|      0|      fs_listlt = calloc(dpb.size, sizeof (FrameStore*));
 1122|      0|      if (NULL==fs_listlt) 
 1123|      0|         no_mem_exit("init_lists: fs_listlt");
 1124|       |
 1125|      0|      listXsize[0] = 0;
 1126|      0|      listXsize[1] = 1;
 1127|       |
 1128|      0|      for (i=0; i<dpb.ref_frames_in_buffer; i++)
 1129|      0|      {
 1130|      0|        if (dpb.fs_ref[i]->is_used)
 1131|      0|        {
 1132|      0|          if (img->ThisPOC >= dpb.fs_ref[i]->poc)
 1133|      0|          {
 1134|      0|            fs_list0[list0idx++] = dpb.fs_ref[i];
 1135|      0|          }
 1136|      0|        }
 1137|      0|      }
 1138|      0|      qsort((void *)fs_list0, list0idx, sizeof(FrameStore*), compare_fs_by_poc_desc);
 1139|      0|      list0idx_1 = list0idx;
 1140|      0|      for (i=0; i<dpb.ref_frames_in_buffer; i++)
 1141|      0|      {
 1142|      0|        if (dpb.fs_ref[i]->is_used)
 1143|      0|        {
 1144|      0|          if (img->ThisPOC < dpb.fs_ref[i]->poc)
 1145|      0|          {
 1146|      0|            fs_list0[list0idx++] = dpb.fs_ref[i];
 1147|      0|          }
 1148|      0|        }
 1149|      0|      }
 1150|      0|      qsort((void *)&fs_list0[list0idx_1], list0idx-list0idx_1, sizeof(FrameStore*), compare_fs_by_poc_asc);
 1151|       |
 1152|      0|      for (j=0; j<list0idx_1; j++)
 1153|      0|      {
 1154|      0|        fs_list1[list0idx-list0idx_1+j]=fs_list0[j];
 1155|      0|      }
 1156|      0|      for (j=list0idx_1; j<list0idx; j++)
 1157|      0|      {
 1158|      0|        fs_list1[j-list0idx_1]=fs_list0[j];
 1159|      0|      }
 1160|       |      
 1161|       |//      printf("fs_list0 currPoc=%d (Poc): ", img->ThisPOC); for (i=0; i<list0idx; i++){printf ("%d  ", fs_list0[i]->poc);} printf("\n");
 1162|       |//      printf("fs_list1 currPoc=%d (Poc): ", img->ThisPOC); for (i=0; i<list0idx; i++){printf ("%d  ", fs_list1[i]->poc);} printf("\n");
 1163|       |
 1164|      0|      listXsize[0] = 0;
 1165|      0|      listXsize[1] = 0;
 1166|      0|      gen_pic_list_from_frame_list(currPicStructure, fs_list0, list0idx, listX[0], &listXsize[0], 0);
 1167|      0|      gen_pic_list_from_frame_list(currPicStructure, fs_list1, list0idx, listX[1], &listXsize[1], 0);
 1168|       |
 1169|       |//      printf("listX[0] currPoc=%d (Poc): ", img->framepoc); for (i=0; i<listXsize[0]; i++){printf ("%d  ", listX[0][i]->poc);} printf("\n");
 1170|       |//      printf("listX[1] currPoc=%d (Poc): ", img->framepoc); for (i=0; i<listXsize[1]; i++){printf ("%d  ", listX[1][i]->poc);} printf("\n");
 1171|       |
 1172|       |      // long term handling
 1173|      0|      for (i=0; i<dpb.ltref_frames_in_buffer; i++)
 1174|      0|      {
 1175|      0|        fs_listlt[listltidx++]=dpb.fs_ltref[i];
 1176|      0|        if (dpb.fs_ltref[i]->is_long_term & 1)
 1177|      0|        {
 1178|      0|          dpb.fs_ltref[i]->top_field->long_term_pic_num = 2 * dpb.fs_ltref[i]->top_field->long_term_frame_idx + add_top;
 1179|      0|        }
 1180|      0|        if (dpb.fs_ltref[i]->is_long_term & 2)
 1181|      0|        {
 1182|      0|          dpb.fs_ltref[i]->bottom_field->long_term_pic_num = 2 * dpb.fs_ltref[i]->bottom_field->long_term_frame_idx + add_bottom;
 1183|      0|        }
 1184|      0|      }
 1185|       |
 1186|      0|      qsort((void *)fs_listlt, listltidx, sizeof(FrameStore*), compare_fs_by_lt_pic_idx_asc);
 1187|       |
 1188|      0|      gen_pic_list_from_frame_list(currPicStructure, fs_listlt, listltidx, listX[0], &listXsize[0], 1);
 1189|      0|      gen_pic_list_from_frame_list(currPicStructure, fs_listlt, listltidx, listX[1], &listXsize[1], 1);
 1190|       |
 1191|      0|      free(fs_list0);
 1192|      0|      free(fs_list1);
 1193|      0|      free(fs_listlt);
 1194|      0|    }
 1195|     85|  } 
 1196|       |
 1197|    142|  if ((listXsize[0] == listXsize[1]) && (listXsize[0] > 1))
 1198|     85|  {
 1199|       |    // check if lists are identical, if yes swap first two elements of listX[1]
 1200|     85|    diff=0;
 1201|    504|    for (j = 0; j< listXsize[0]; j++)
 1202|    419|    {
 1203|    419|      if (listX[0][j]!=listX[1][j])
 1204|    419|        diff=1;
 1205|    419|    }
 1206|     85|    if (!diff)
 1207|      0|    {
 1208|      0|      tmp_s = listX[1][0];
 1209|      0|      listX[1][0]=listX[1][1];
 1210|      0|      listX[1][1]=tmp_s;
 1211|      0|    }
 1212|     85|  }
 1213|       |  // set max size
 1214|    142|  listXsize[0] = min (listXsize[0], img->num_ref_idx_l0_active);
 1215|    142|  listXsize[1] = min (listXsize[1], img->num_ref_idx_l1_active);
 1216|       |
 1217|       |  // set the unused list entries to NULL
 1218|  4.13k|  for (i=listXsize[0]; i< (MAX_LIST_SIZE) ; i++)
 1219|  3.99k|  {
 1220|  3.99k|    listX[0][i] = NULL;
 1221|  3.99k|  }
 1222|  4.40k|  for (i=listXsize[1]; i< (MAX_LIST_SIZE) ; i++)
 1223|  4.26k|  {
 1224|  4.26k|    listX[1][i] = NULL;
 1225|  4.26k|  }
 1226|    142|}
 1227|       |
 1228|       |/*!
 1229|       | ************************************************************************
 1230|       | * \brief
 1231|       | *    Initilaize listX[2..5] from lists 0 and 1
 1232|       | *    listX[2]: list0 for current_field==top
 1233|       | *    listX[3]: list1 for current_field==top
 1234|       | *    listX[4]: list0 for current_field==bottom
 1235|       | *    listX[5]: list1 for current_field==bottom
 1236|       | *
 1237|       | ************************************************************************
 1238|       | */
 1239|       |void init_mbaff_lists()
 1240|    171|{
 1241|    171|  unsigned j;
 1242|    171|  int i;
 1243|       |
 1244|    855|  for (i=2;i<6;i++)
 1245|    684|  {
 1246|  23.2k|    for (j=0; j<MAX_LIST_SIZE; j++)
 1247|  22.5k|    {
 1248|  22.5k|      listX[i][j] = NULL;
 1249|  22.5k|    }
 1250|    684|    listXsize[i]=0;
 1251|    684|  }
 1252|       |
 1253|    867|  for (i=0; i<listXsize[0]; i++)
 1254|    696|  {
 1255|    696|    listX[2][2*i]  =listX[0][i]->top_field;
 1256|    696|    listX[2][2*i+1]=listX[0][i]->bottom_field;
 1257|    696|    listX[4][2*i]  =listX[0][i]->bottom_field;
 1258|    696|    listX[4][2*i+1]=listX[0][i]->top_field;
 1259|    696|  }
 1260|    171|  listXsize[2]=listXsize[4]=listXsize[0] * 2;
 1261|       |
 1262|    256|  for (i=0; i<listXsize[1]; i++)
 1263|     85|  {
 1264|     85|    listX[3][2*i]  =listX[1][i]->top_field;
 1265|     85|    listX[3][2*i+1]=listX[1][i]->bottom_field;
 1266|     85|    listX[5][2*i]  =listX[1][i]->bottom_field;
 1267|     85|    listX[5][2*i+1]=listX[1][i]->top_field;
 1268|     85|  }
 1269|    171|  listXsize[3]=listXsize[5]=listXsize[1] * 2;
 1270|    171|}
 1271|       | 
 1272|       | /*!
 1273|       | ************************************************************************
 1274|       | * \brief
 1275|       | *    Returns short term pic with given picNum
 1276|       | *
 1277|       | ************************************************************************
 1278|       | */
 1279|       |static StorablePicture*  get_short_term_pic(int picNum)
 1280|      0|{
 1281|      0|  unsigned i;
 1282|       |
 1283|      0|  for (i=0; i<dpb.ref_frames_in_buffer; i++)
 1284|      0|  {
 1285|      0|    if (img->structure==FRAME)
 1286|      0|    {
 1287|      0|      if (dpb.fs_ref[i]->is_reference == 3)
 1288|      0|        if ((!dpb.fs_ref[i]->frame->is_long_term)&&(dpb.fs_ref[i]->frame->pic_num == picNum))
 1289|      0|          return dpb.fs_ref[i]->frame;
 1290|      0|    }
 1291|      0|    else
 1292|      0|    {
 1293|      0|      if (dpb.fs_ref[i]->is_reference & 1)
 1294|      0|        if ((!dpb.fs_ref[i]->top_field->is_long_term)&&(dpb.fs_ref[i]->top_field->pic_num == picNum))
 1295|      0|          return dpb.fs_ref[i]->top_field;
 1296|      0|      if (dpb.fs_ref[i]->is_reference & 2)
 1297|      0|        if ((!dpb.fs_ref[i]->bottom_field->is_long_term)&&(dpb.fs_ref[i]->bottom_field->pic_num == picNum))
 1298|      0|          return dpb.fs_ref[i]->bottom_field;
 1299|      0|    }
 1300|      0|  }
 1301|      0|  return NULL;
 1302|      0|}
 1303|       |
 1304|       |/*!
 1305|       | ************************************************************************
 1306|       | * \brief
 1307|       | *    Returns short term pic with given LongtermPicNum
 1308|       | *
 1309|       | ************************************************************************
 1310|       | */
 1311|       |static StorablePicture*  get_long_term_pic(int LongtermPicNum)
 1312|      0|{
 1313|      0|  unsigned i;
 1314|       |
 1315|      0|  for (i=0; i<dpb.ltref_frames_in_buffer; i++)
 1316|      0|  {
 1317|      0|    if (img->structure==FRAME)
 1318|      0|    {
 1319|      0|      if (dpb.fs_ltref[i]->is_reference == 3)
 1320|      0|        if ((dpb.fs_ltref[i]->frame->is_long_term)&&(dpb.fs_ltref[i]->frame->long_term_pic_num == LongtermPicNum))
 1321|      0|          return dpb.fs_ltref[i]->frame;
 1322|      0|    }
 1323|      0|    else
 1324|      0|    {
 1325|      0|      if (dpb.fs_ltref[i]->is_reference & 1)
 1326|      0|        if ((dpb.fs_ltref[i]->top_field->is_long_term)&&(dpb.fs_ltref[i]->top_field->long_term_pic_num == LongtermPicNum))
 1327|      0|          return dpb.fs_ltref[i]->top_field;
 1328|      0|      if (dpb.fs_ltref[i]->is_reference & 2)
 1329|      0|        if ((dpb.fs_ltref[i]->bottom_field->is_long_term)&&(dpb.fs_ltref[i]->bottom_field->long_term_pic_num == LongtermPicNum))
 1330|      0|          return dpb.fs_ltref[i]->bottom_field;
 1331|      0|    }
 1332|      0|  }
 1333|      0|  return NULL;
 1334|      0|}
 1335|       |
 1336|       |/*!
 1337|       | ************************************************************************
 1338|       | * \brief
 1339|       | *    Reordering process for short-term reference pictures
 1340|       | *
 1341|       | ************************************************************************
 1342|       | */
 1343|       |static void reorder_short_term(StorablePicture **RefPicListX, int num_ref_idx_lX_active_minus1, int picNumLX, int *refIdxLX)
 1344|      0|{
 1345|      0|  int cIdx, nIdx;
 1346|       |
 1347|      0|  StorablePicture *picLX;
 1348|       |
 1349|      0|  picLX = get_short_term_pic(picNumLX);
 1350|       |
 1351|      0|  for( cIdx = num_ref_idx_lX_active_minus1+1; cIdx > *refIdxLX; cIdx-- )
 1352|      0|    RefPicListX[ cIdx ] = RefPicListX[ cIdx - 1];
 1353|       |  
 1354|      0|  RefPicListX[ (*refIdxLX)++ ] = picLX;
 1355|       |
 1356|      0|  nIdx = *refIdxLX;
 1357|       |
 1358|      0|  for( cIdx = *refIdxLX; cIdx <= num_ref_idx_lX_active_minus1+1; cIdx++ )
 1359|      0|    if (RefPicListX[ cIdx ])
 1360|      0|      if( (RefPicListX[ cIdx ]->is_long_term ) ||  (RefPicListX[ cIdx ]->pic_num != picNumLX ))
 1361|      0|        RefPicListX[ nIdx++ ] = RefPicListX[ cIdx ];
 1362|       |
 1363|      0|}
 1364|       |
 1365|       |
 1366|       |/*!
 1367|       | ************************************************************************
 1368|       | * \brief
 1369|       | *    Reordering process for short-term reference pictures
 1370|       | *
 1371|       | ************************************************************************
 1372|       | */
 1373|       |static void reorder_long_term(StorablePicture **RefPicListX, int num_ref_idx_lX_active_minus1, int LongTermPicNum, int *refIdxLX)
 1374|      0|{
 1375|      0|  int cIdx, nIdx;
 1376|       |
 1377|      0|  StorablePicture *picLX;
 1378|       |
 1379|      0|  picLX = get_long_term_pic(LongTermPicNum);
 1380|       |
 1381|      0|  for( cIdx = num_ref_idx_lX_active_minus1+1; cIdx > *refIdxLX; cIdx-- )
 1382|      0|    RefPicListX[ cIdx ] = RefPicListX[ cIdx - 1];
 1383|       |  
 1384|      0|  RefPicListX[ (*refIdxLX)++ ] = picLX;
 1385|       |
 1386|      0|  nIdx = *refIdxLX;
 1387|       |
 1388|      0|  for( cIdx = *refIdxLX; cIdx <= num_ref_idx_lX_active_minus1+1; cIdx++ )
 1389|      0|    if( (!RefPicListX[ cIdx ]->is_long_term ) ||  (RefPicListX[ cIdx ]->long_term_pic_num != LongTermPicNum ))
 1390|      0|      RefPicListX[ nIdx++ ] = RefPicListX[ cIdx ];
 1391|      0|}
 1392|       |
 1393|       |
 1394|       |/*!
 1395|       | ************************************************************************
 1396|       | * \brief
 1397|       | *    Reordering process for reference picture lists
 1398|       | *
 1399|       | ************************************************************************
 1400|       | */
 1401|       |void reorder_ref_pic_list(StorablePicture **list, int *list_size, int num_ref_idx_lX_active_minus1, int *remapping_of_pic_nums_idc, int *abs_diff_pic_num_minus1, int *long_term_pic_idx)
 1402|      0|{
 1403|      0|  int i;
 1404|       |
 1405|      0|  int maxPicNum, currPicNum, picNumLXNoWrap, picNumLXPred, picNumLX;
 1406|      0|  int refIdxLX = 0;
 1407|      0|  int MaxFrameNum = 1 << (log2_max_frame_num_minus4 + 4);
 1408|       |
 1409|      0|  if (img->structure==FRAME)
 1410|      0|  {
 1411|      0|    maxPicNum  = MaxFrameNum;
 1412|      0|    currPicNum = img->frame_num;
 1413|      0|  }
 1414|      0|  else
 1415|      0|  {
 1416|      0|    maxPicNum  = 2 * MaxFrameNum;
 1417|      0|    currPicNum = 2 * img->frame_num + 1;
 1418|      0|  }
 1419|       |
 1420|      0|  picNumLXPred = currPicNum;
 1421|       |
 1422|      0|  for (i=0; remapping_of_pic_nums_idc[i]!=3; i++)
 1423|      0|  {
 1424|      0|    if (remapping_of_pic_nums_idc[i]>3)
 1425|      0|      error ("Invalid remapping_of_pic_nums_idc command", 500);
 1426|       |
 1427|      0|    if (remapping_of_pic_nums_idc[i] < 2)
 1428|      0|    {
 1429|      0|      if (remapping_of_pic_nums_idc[i] == 0)
 1430|      0|      {
 1431|      0|        if( picNumLXPred - ( abs_diff_pic_num_minus1[i] + 1 ) < 0 )
 1432|      0|          picNumLXNoWrap = picNumLXPred - ( abs_diff_pic_num_minus1[i] + 1 ) + maxPicNum;
 1433|      0|        else
 1434|      0|          picNumLXNoWrap = picNumLXPred - ( abs_diff_pic_num_minus1[i] + 1 );
 1435|      0|      }
 1436|      0|      else // (remapping_of_pic_nums_idc[i] == 1)
 1437|      0|      {
 1438|      0|        if( picNumLXPred + ( abs_diff_pic_num_minus1[i] + 1 )  >=  maxPicNum )
 1439|      0|          picNumLXNoWrap = picNumLXPred + ( abs_diff_pic_num_minus1[i] + 1 ) - maxPicNum;
 1440|      0|        else
 1441|      0|          picNumLXNoWrap = picNumLXPred + ( abs_diff_pic_num_minus1[i] + 1 );
 1442|      0|      }
 1443|      0|      picNumLXPred = picNumLXNoWrap;
 1444|       |
 1445|      0|      if( picNumLXNoWrap > currPicNum )
 1446|      0|        picNumLX = picNumLXNoWrap - maxPicNum;
 1447|      0|      else
 1448|      0|        picNumLX = picNumLXNoWrap;
 1449|       |
 1450|      0|      reorder_short_term(list, num_ref_idx_lX_active_minus1, picNumLX, &refIdxLX);
 1451|      0|    }
 1452|      0|    else //(remapping_of_pic_nums_idc[i] == 2)
 1453|      0|    {
 1454|      0|      reorder_long_term(list, num_ref_idx_lX_active_minus1, long_term_pic_idx[i], &refIdxLX);
 1455|      0|    }
 1456|       |    
 1457|      0|  }
 1458|       |  // that's a definition
 1459|      0|  *list_size = num_ref_idx_lX_active_minus1 + 1;
 1460|      0|}
 1461|       |
 1462|       |
 1463|       |
 1464|       |/*!
 1465|       | ************************************************************************
 1466|       | * \brief
 1467|       | *    Update the list of frame stores that contain reference frames/fields
 1468|       | *
 1469|       | ************************************************************************
 1470|       | */
 1471|       |void update_ref_list()
 1472|    253|{
 1473|    253|  unsigned i, j;
 1474|  3.20k|  for (i=0, j=0; i<dpb.used_size; i++)
 1475|  2.95k|  {
 1476|  2.95k|    if (is_short_term_reference(dpb.fs[i]))
 1477|  1.16k|    {
 1478|  1.16k|      dpb.fs_ref[j++]=dpb.fs[i];
 1479|  1.16k|    }
 1480|  2.95k|  }
 1481|       |
 1482|    253|  dpb.ref_frames_in_buffer = j;
 1483|       |
 1484|  2.12k|  while (j<dpb.size)
 1485|  1.87k|  {
 1486|  1.87k|    dpb.fs_ref[j++]=NULL;
 1487|  1.87k|  }
 1488|    253|}
 1489|       |
 1490|       |
 1491|       |/*!
 1492|       | ************************************************************************
 1493|       | * \brief
 1494|       | *    Update the list of frame stores that contain long-term reference 
 1495|       | *    frames/fields
 1496|       | *
 1497|       | ************************************************************************
 1498|       | */
 1499|       |void update_ltref_list()
 1500|    172|{
 1501|    172|  unsigned i, j;
 1502|  2.15k|  for (i=0, j=0; i<dpb.used_size; i++)
 1503|  1.98k|  {
 1504|  1.98k|    if (is_long_term_reference(dpb.fs[i]))
 1505|      0|    {
 1506|      0|      dpb.fs_ltref[j++]=dpb.fs[i];
 1507|      0|    }
 1508|  1.98k|  }
 1509|       |
 1510|    172|  dpb.ltref_frames_in_buffer=j;
 1511|       |
 1512|  2.23k|  while (j<dpb.size)
 1513|  2.06k|  {
 1514|  2.06k|    dpb.fs_ltref[j++]=NULL;
 1515|  2.06k|  }
 1516|    172|}
 1517|       |
 1518|       |/*!
 1519|       | ************************************************************************
 1520|       | * \brief
 1521|       | *    Perform Memory management for idr pictures
 1522|       | *
 1523|       | ************************************************************************
 1524|       | */
 1525|       |static void idr_memory_management(StorablePicture* p)
 1526|      1|{
 1527|      1|  unsigned i;
 1528|       |
 1529|      1|  assert (img->currentPicture->idr_flag);
 1530|       |
 1531|      1|  if (img->no_output_of_prior_pics_flag)
 1532|      0|  {
 1533|       |    // free all stored pictures
 1534|      0|    for (i=0; i<dpb.used_size; i++)
 1535|      0|    {
 1536|       |      // reset all reference settings
 1537|      0|      free_frame_store(dpb.fs[i]);
 1538|      0|      dpb.fs[i]=alloc_frame_store();
 1539|      0|    }
 1540|      0|    for (i=0; i<dpb.ref_frames_in_buffer; i++)
 1541|      0|    {
 1542|      0|      dpb.fs_ref[i]=NULL;
 1543|      0|    }
 1544|      0|    for (i=0; i<dpb.ltref_frames_in_buffer; i++)
 1545|      0|    {
 1546|      0|      dpb.fs_ltref[i]=NULL;
 1547|      0|    }
 1548|      0|    dpb.used_size=0;
 1549|      0|  }
 1550|      1|  else
 1551|      1|  {
 1552|      1|    flush_dpb();
 1553|      1|  }
 1554|      1|  dpb.last_picture = NULL;
 1555|       |
 1556|      1|  update_ref_list();
 1557|      1|  update_ltref_list();
 1558|      1|  dpb.last_output_poc = INT_MIN;
 1559|       |  
 1560|      1|  if (img->long_term_reference_flag)
 1561|      0|  {
 1562|      0|    dpb.max_long_term_pic_idx = 0;
 1563|      0|    p->is_long_term           = 1;
 1564|      0|    p->long_term_frame_idx    = 0;
 1565|      0|  }
 1566|      1|  else
 1567|      1|  {
 1568|      1|    dpb.max_long_term_pic_idx = -1;
 1569|      1|    p->is_long_term           = 0;
 1570|      1|  }
 1571|      1|}
 1572|       |
 1573|       |/*!
 1574|       | ************************************************************************
 1575|       | * \brief
 1576|       | *    Perform Sliding window decoded reference picture marking process
 1577|       | *
 1578|       | ************************************************************************
 1579|       | */
 1580|       |static void sliding_window_memory_management(StorablePicture* p)
 1581|     85|{
 1582|     85|  unsigned i;
 1583|       |
 1584|     85|  assert (!img->currentPicture->idr_flag);
 1585|       |  // if this is a reference pic with sliding sliding window, unmark first ref frame
 1586|     85|  if (dpb.ref_frames_in_buffer==active_sps->num_ref_frames - dpb.ltref_frames_in_buffer)
 1587|     81|  {
 1588|    240|    for (i=0; i<dpb.used_size;i++)
 1589|    240|    {
 1590|    240|      if (dpb.fs[i]->is_reference  && (!(dpb.fs[i]->is_long_term)))
 1591|     81|      {
 1592|     81|        unmark_for_reference(dpb.fs[i]);
 1593|     81|        update_ref_list();
 1594|     81|        break;
 1595|     81|      }
 1596|    240|    }
 1597|     81|  }
 1598|       |
 1599|     85|  p->is_long_term = 0;
 1600|     85|}
 1601|       |
 1602|       |/*!
 1603|       | ************************************************************************
 1604|       | * \brief
 1605|       | *    Calculate picNumX
 1606|       | ************************************************************************
 1607|       | */
 1608|       |static int get_pic_num_x (StorablePicture *p, int difference_of_pic_nums_minus1)
 1609|      0|{
 1610|      0|  int currPicNum;
 1611|       |
 1612|      0|  if (p->structure == FRAME)
 1613|      0|    currPicNum = p->frame_num;
 1614|      0|  else 
 1615|      0|    currPicNum = 2 * p->frame_num + 1;
 1616|       |  
 1617|      0|  return currPicNum - (difference_of_pic_nums_minus1 + 1);
 1618|      0|}
 1619|       |
 1620|       |
 1621|       |/*!
 1622|       | ************************************************************************
 1623|       | * \brief
 1624|       | *    Adaptive Memory Management: Mark short term picture unused
 1625|       | ************************************************************************
 1626|       | */
 1627|       |static void mm_unmark_short_term_for_reference(StorablePicture *p, int difference_of_pic_nums_minus1)
 1628|      0|{
 1629|      0|  int picNumX;
 1630|       |
 1631|      0|  unsigned i;
 1632|       |
 1633|      0|  picNumX = get_pic_num_x(p, difference_of_pic_nums_minus1);
 1634|       |
 1635|      0|  for (i=0; i<dpb.ref_frames_in_buffer; i++)
 1636|      0|  {
 1637|      0|    if (p->structure == FRAME)
 1638|      0|    {
 1639|      0|      if ((dpb.fs_ref[i]->is_reference==3) && (dpb.fs_ref[i]->is_long_term==0))
 1640|      0|      {
 1641|      0|        if (dpb.fs_ref[i]->frame->pic_num == picNumX)
 1642|      0|        {
 1643|      0|          unmark_for_reference(dpb.fs_ref[i]);
 1644|      0|          return;
 1645|      0|        }
 1646|      0|      }
 1647|      0|    }
 1648|      0|    else
 1649|      0|    {
 1650|      0|      if ((dpb.fs_ref[i]->is_reference & 1) && (!(dpb.fs_ref[i]->is_long_term & 1)))
 1651|      0|      {
 1652|      0|        if (dpb.fs_ref[i]->top_field->pic_num == picNumX)
 1653|      0|        {
 1654|      0|          dpb.fs_ref[i]->top_field->used_for_reference = 0;
 1655|      0|          dpb.fs_ref[i]->is_reference &= 2;
 1656|      0|          if (dpb.fs_ref[i]->is_used == 3)
 1657|      0|          {
 1658|      0|            dpb.fs_ref[i]->frame->used_for_reference = 0;
 1659|      0|          }
 1660|      0|          return;
 1661|      0|        }
 1662|      0|      }
 1663|      0|      if ((dpb.fs_ref[i]->is_reference & 2) && (!(dpb.fs_ref[i]->is_long_term & 2)))
 1664|      0|      {
 1665|      0|        if (dpb.fs_ref[i]->bottom_field->pic_num == picNumX)
 1666|      0|        {
 1667|      0|          dpb.fs_ref[i]->bottom_field->used_for_reference = 0;
 1668|      0|          dpb.fs_ref[i]->is_reference &= 1;
 1669|      0|          if (dpb.fs_ref[i]->is_used == 3)
 1670|      0|          {
 1671|      0|            dpb.fs_ref[i]->frame->used_for_reference = 0;
 1672|      0|          }
 1673|      0|          return;
 1674|      0|        }
 1675|      0|      }
 1676|      0|    }
 1677|      0|  }
 1678|      0|}
 1679|       |
 1680|       |
 1681|       |/*!
 1682|       | ************************************************************************
 1683|       | * \brief
 1684|       | *    Adaptive Memory Management: Mark long term picture unused
 1685|       | ************************************************************************
 1686|       | */
 1687|       |static void mm_unmark_long_term_for_reference(StorablePicture *p, int long_term_pic_num)
 1688|      0|{
 1689|      0|  unsigned i;
 1690|      0|  for (i=0; i<dpb.ltref_frames_in_buffer; i++)
 1691|      0|  {
 1692|      0|    if (p->structure == FRAME)
 1693|      0|    {
 1694|      0|      if ((dpb.fs_ltref[i]->is_reference==3) && (dpb.fs_ltref[i]->is_long_term==3))
 1695|      0|      {
 1696|      0|        if (dpb.fs_ltref[i]->frame->long_term_pic_num == long_term_pic_num)
 1697|      0|        {
 1698|      0|          unmark_for_long_term_reference(dpb.fs_ltref[i]);
 1699|      0|        }
 1700|      0|      }
 1701|      0|    }
 1702|      0|    else
 1703|      0|    {
 1704|      0|      if ((dpb.fs_ltref[i]->is_reference & 1) && ((dpb.fs_ltref[i]->is_long_term & 1)))
 1705|      0|      {
 1706|      0|        if (dpb.fs_ltref[i]->top_field->long_term_pic_num == long_term_pic_num)
 1707|      0|        {
 1708|      0|          dpb.fs_ltref[i]->top_field->used_for_reference = 0;
 1709|      0|          dpb.fs_ltref[i]->top_field->is_long_term = 0;
 1710|      0|          dpb.fs_ltref[i]->is_reference &= 2;
 1711|      0|          dpb.fs_ltref[i]->is_long_term &= 2;
 1712|      0|          if (dpb.fs_ltref[i]->is_used == 3)
 1713|      0|          {
 1714|      0|            dpb.fs_ltref[i]->frame->used_for_reference = 0;
 1715|      0|            dpb.fs_ltref[i]->frame->is_long_term = 0;
 1716|      0|          }
 1717|      0|          return;
 1718|      0|        }
 1719|      0|      }
 1720|      0|      if ((dpb.fs_ltref[i]->is_reference & 2) && ((dpb.fs_ltref[i]->is_long_term & 2)))
 1721|      0|      {
 1722|      0|        if (dpb.fs_ltref[i]->bottom_field->long_term_pic_num == long_term_pic_num)
 1723|      0|        {
 1724|      0|          dpb.fs_ltref[i]->bottom_field->used_for_reference = 0;
 1725|      0|          dpb.fs_ltref[i]->bottom_field->is_long_term = 0;
 1726|      0|          dpb.fs_ltref[i]->is_reference &= 1;
 1727|      0|          dpb.fs_ltref[i]->is_long_term &= 1;
 1728|      0|          if (dpb.fs_ltref[i]->is_used == 3)
 1729|      0|          {
 1730|      0|            dpb.fs_ltref[i]->frame->used_for_reference = 0;
 1731|      0|            dpb.fs_ltref[i]->frame->is_long_term = 0;
 1732|      0|          }
 1733|      0|          return;
 1734|      0|        }
 1735|      0|      }
 1736|      0|    }
 1737|      0|  }
 1738|      0|}
 1739|       |
 1740|       |
 1741|       |/*!
 1742|       | ************************************************************************
 1743|       | * \brief
 1744|       | *    Mark a long-term reference frame or complementary field pair unused for referemce
 1745|       | ************************************************************************
 1746|       | */
 1747|       |static void unmark_long_term_frame_for_reference_by_frame_idx(int long_term_frame_idx)
 1748|      0|{
 1749|      0|  unsigned i;
 1750|      0|  for(i=0; i<dpb.ltref_frames_in_buffer; i++)
 1751|      0|  {
 1752|      0|    if (dpb.fs_ltref[i]->long_term_frame_idx == long_term_frame_idx)
 1753|      0|      unmark_for_long_term_reference(dpb.fs_ltref[i]);
 1754|      0|  }
 1755|      0|}
 1756|       |
 1757|       |/*!
 1758|       | ************************************************************************
 1759|       | * \brief
 1760|       | *    Mark a long-term reference field unused for reference only if it's not
 1761|       | *    the complementary field of the picture indicated by picNumX
 1762|       | ************************************************************************
 1763|       | */
 1764|       |static void unmark_long_term_field_for_reference_by_frame_idx(PictureStructure structure, int long_term_frame_idx, int mark_current, unsigned curr_frame_num, int curr_pic_num)
 1765|      0|{
 1766|      0|  unsigned i;
 1767|      0|  int MaxFrameNum = 1 << (log2_max_frame_num_minus4 + 4);
 1768|       |
 1769|      0|  assert(structure!=FRAME);
 1770|      0|  if (curr_pic_num<0)
 1771|      0|    curr_pic_num+=(2*MaxFrameNum);
 1772|       |
 1773|      0|  for(i=0; i<dpb.ltref_frames_in_buffer; i++)
 1774|      0|  {
 1775|      0|    if (dpb.fs_ltref[i]->long_term_frame_idx == long_term_frame_idx)
 1776|      0|    {
 1777|      0|      if (structure == TOP_FIELD)
 1778|      0|      {
 1779|      0|        if ((dpb.fs_ltref[i]->is_long_term == 3))
 1780|      0|        {
 1781|      0|          unmark_for_long_term_reference(dpb.fs_ltref[i]);
 1782|      0|        }
 1783|      0|        else
 1784|      0|        {
 1785|      0|          if ((dpb.fs_ltref[i]->is_long_term == 1))
 1786|      0|          {
 1787|      0|            unmark_for_long_term_reference(dpb.fs_ltref[i]);
 1788|      0|          }
 1789|      0|          else
 1790|      0|          {
 1791|      0|            if (mark_current)
 1792|      0|            {
 1793|      0|              if (dpb.last_picture)
 1794|      0|              {
 1795|      0|                if ( ( dpb.last_picture != dpb.fs_ltref[i] )|| dpb.last_picture->frame_num != curr_frame_num)
 1796|      0|                  unmark_for_long_term_reference(dpb.fs_ltref[i]);
 1797|      0|              }
 1798|      0|              else
 1799|      0|              {
 1800|      0|              unmark_for_long_term_reference(dpb.fs_ltref[i]);
 1801|      0|          }
 1802|      0|        }
 1803|      0|            else
 1804|      0|            {
 1805|      0|              if ((dpb.fs_ltref[i]->frame_num) != (unsigned)(curr_pic_num/2))
 1806|      0|              {
 1807|      0|                unmark_for_long_term_reference(dpb.fs_ltref[i]);
 1808|      0|              }
 1809|      0|            }
 1810|      0|      }
 1811|      0|        }
 1812|      0|      }
 1813|      0|      if (structure == BOTTOM_FIELD)
 1814|      0|      {
 1815|      0|        if ((dpb.fs_ltref[i]->is_long_term == 3))
 1816|      0|        {
 1817|      0|          unmark_for_long_term_reference(dpb.fs_ltref[i]);
 1818|      0|        }
 1819|      0|        else
 1820|      0|        {
 1821|      0|          if ((dpb.fs_ltref[i]->is_long_term == 2))
 1822|      0|          {
 1823|      0|            unmark_for_long_term_reference(dpb.fs_ltref[i]);
 1824|      0|          }
 1825|      0|          else
 1826|      0|          {
 1827|      0|            if (mark_current)
 1828|      0|            {
 1829|      0|              if (dpb.last_picture)
 1830|      0|            {
 1831|      0|                if ( ( dpb.last_picture != dpb.fs_ltref[i] )|| dpb.last_picture->frame_num != curr_frame_num)
 1832|      0|              unmark_for_long_term_reference(dpb.fs_ltref[i]);
 1833|      0|            }
 1834|      0|              else
 1835|      0|              {
 1836|      0|                unmark_for_long_term_reference(dpb.fs_ltref[i]);
 1837|      0|              }
 1838|      0|            }
 1839|      0|            else
 1840|      0|            {
 1841|      0|              if ((dpb.fs_ltref[i]->frame_num) != (unsigned)(curr_pic_num/2))
 1842|      0|              {
 1843|      0|                unmark_for_long_term_reference(dpb.fs_ltref[i]);
 1844|      0|              }
 1845|      0|            }
 1846|      0|          }
 1847|      0|        }
 1848|      0|      }
 1849|      0|    }
 1850|      0|  }
 1851|      0|}
 1852|       |
 1853|       |
 1854|       |/*!
 1855|       | ************************************************************************
 1856|       | * \brief
 1857|       | *    mark a picture as long-term reference
 1858|       | ************************************************************************
 1859|       | */
 1860|       |static void mark_pic_long_term(StorablePicture* p, int long_term_frame_idx, int picNumX)
 1861|      0|{
 1862|      0|  unsigned i;
 1863|      0|  int add_top, add_bottom;
 1864|       |
 1865|      0|  if (p->structure == FRAME)
 1866|      0|  {
 1867|      0|    for (i=0; i<dpb.ref_frames_in_buffer; i++)
 1868|      0|    {
 1869|      0|      if (dpb.fs_ref[i]->is_reference == 3)
 1870|      0|      {
 1871|      0|        if ((!dpb.fs_ref[i]->frame->is_long_term)&&(dpb.fs_ref[i]->frame->pic_num == picNumX))
 1872|      0|        {
 1873|      0|          dpb.fs_ref[i]->long_term_frame_idx = dpb.fs_ref[i]->frame->long_term_frame_idx
 1874|      0|                                             = dpb.fs_ref[i]->top_field->long_term_frame_idx
 1875|      0|                                             = dpb.fs_ref[i]->bottom_field->long_term_frame_idx
 1876|      0|                                             = long_term_frame_idx;
 1877|      0|          dpb.fs_ref[i]->frame->long_term_pic_num = dpb.fs_ref[i]->top_field->long_term_pic_num
 1878|      0|                                                  = dpb.fs_ref[i]->bottom_field->long_term_pic_num
 1879|      0|                                                  = long_term_frame_idx;
 1880|      0|          dpb.fs_ref[i]->frame->is_long_term = dpb.fs_ref[i]->top_field->is_long_term
 1881|      0|                                             = dpb.fs_ref[i]->bottom_field->is_long_term
 1882|      0|                                             = 1;
 1883|      0|          dpb.fs_ref[i]->is_long_term = 3;
 1884|      0|          return;
 1885|      0|        }
 1886|      0|      }
 1887|      0|    }
 1888|      0|    printf ("Warning: reference frame for long term marking not found\n");
 1889|      0|  }
 1890|      0|  else
 1891|      0|  {
 1892|      0|    if (p->structure == TOP_FIELD)
 1893|      0|    {
 1894|      0|      add_top    = 1;
 1895|      0|      add_bottom = 0;
 1896|      0|    }
 1897|      0|    else
 1898|      0|    {
 1899|      0|      add_top    = 0;
 1900|      0|      add_bottom = 1;
 1901|      0|    }
 1902|      0|    for (i=0; i<dpb.ref_frames_in_buffer; i++)
 1903|      0|    {
 1904|      0|      if (dpb.fs_ref[i]->is_reference & 1)
 1905|      0|      {
 1906|      0|        if ((!dpb.fs_ref[i]->top_field->is_long_term)&&(dpb.fs_ref[i]->top_field->pic_num == picNumX))
 1907|      0|        {
 1908|      0|          if ((dpb.fs_ref[i]->is_long_term) && (dpb.fs_ref[i]->long_term_frame_idx != long_term_frame_idx))
 1909|      0|          {
 1910|      0|              printf ("Warning: assigning long_term_frame_idx different from other field\n");
 1911|      0|          }
 1912|       |
 1913|      0|          dpb.fs_ref[i]->long_term_frame_idx = dpb.fs_ref[i]->top_field->long_term_frame_idx 
 1914|      0|                                             = long_term_frame_idx;
 1915|      0|          dpb.fs_ref[i]->top_field->long_term_pic_num = 2 * long_term_frame_idx + add_top;
 1916|      0|          dpb.fs_ref[i]->top_field->is_long_term = 1;
 1917|      0|          dpb.fs_ref[i]->is_long_term |= 1;
 1918|      0|          if (dpb.fs_ref[i]->is_long_term == 3)
 1919|      0|          {
 1920|      0|            dpb.fs_ref[i]->frame->is_long_term = 1;
 1921|      0|            dpb.fs_ref[i]->frame->long_term_frame_idx = dpb.fs_ref[i]->frame->long_term_pic_num = long_term_frame_idx;
 1922|      0|          }
 1923|      0|          return;
 1924|      0|        }
 1925|      0|      }
 1926|      0|      if (dpb.fs_ref[i]->is_reference & 2)
 1927|      0|      {
 1928|      0|        if ((!dpb.fs_ref[i]->bottom_field->is_long_term)&&(dpb.fs_ref[i]->bottom_field->pic_num == picNumX))
 1929|      0|        {
 1930|      0|          if ((dpb.fs_ref[i]->is_long_term) && (dpb.fs_ref[i]->long_term_frame_idx != long_term_frame_idx))
 1931|      0|          {
 1932|      0|              printf ("Warning: assigning long_term_frame_idx different from other field\n");
 1933|      0|          }
 1934|       |
 1935|      0|          dpb.fs_ref[i]->long_term_frame_idx = dpb.fs_ref[i]->bottom_field->long_term_frame_idx 
 1936|      0|                                             = long_term_frame_idx;
 1937|      0|          dpb.fs_ref[i]->bottom_field->long_term_pic_num = 2 * long_term_frame_idx + add_top;
 1938|      0|          dpb.fs_ref[i]->bottom_field->is_long_term = 1;
 1939|      0|          dpb.fs_ref[i]->is_long_term |= 2;
 1940|      0|          if (dpb.fs_ref[i]->is_long_term == 3)
 1941|      0|          {
 1942|      0|            dpb.fs_ref[i]->frame->is_long_term = 1;
 1943|      0|            dpb.fs_ref[i]->frame->long_term_frame_idx = dpb.fs_ref[i]->frame->long_term_pic_num = long_term_frame_idx;
 1944|      0|          }
 1945|      0|          return;
 1946|      0|        }
 1947|      0|      }
 1948|      0|    }
 1949|      0|    printf ("Warning: reference field for long term marking not found\n");
 1950|      0|  }
 1951|      0|}
 1952|       |
 1953|       |
 1954|       |/*!
 1955|       | ************************************************************************
 1956|       | * \brief
 1957|       | *    Assign a long term frame index to a short term picture
 1958|       | ************************************************************************
 1959|       | */
 1960|       |static void mm_assign_long_term_frame_idx(StorablePicture* p, int difference_of_pic_nums_minus1, int long_term_frame_idx)
 1961|      0|{
 1962|      0|  int picNumX;
 1963|       |
 1964|      0|  picNumX = get_pic_num_x(p, difference_of_pic_nums_minus1);
 1965|       |
 1966|       |  // remove frames/fields with same long_term_frame_idx
 1967|      0|  if (p->structure == FRAME)
 1968|      0|  {
 1969|      0|    unmark_long_term_frame_for_reference_by_frame_idx(long_term_frame_idx);
 1970|      0|  }
 1971|      0|  else
 1972|      0|  {
 1973|      0|    unsigned i;
 1974|      0|    PictureStructure structure = FRAME;
 1975|       |
 1976|      0|    for (i=0; i<dpb.ref_frames_in_buffer; i++)
 1977|      0|    {
 1978|      0|      if (dpb.fs_ref[i]->is_reference & 1)
 1979|      0|      {
 1980|      0|        if (dpb.fs_ref[i]->top_field->pic_num == picNumX)
 1981|      0|        {
 1982|      0|          structure = TOP_FIELD;
 1983|      0|          break;
 1984|      0|        }
 1985|      0|      }
 1986|      0|      if (dpb.fs_ref[i]->is_reference & 2)
 1987|      0|      {
 1988|      0|        if (dpb.fs_ref[i]->bottom_field->pic_num == picNumX)
 1989|      0|        {
 1990|      0|          structure = BOTTOM_FIELD;
 1991|      0|          break;
 1992|      0|        }
 1993|      0|      }
 1994|      0|    }
 1995|      0|    if (structure==FRAME)
 1996|      0|    {
 1997|      0|      error ("field for long term marking not found",200);
 1998|      0|    }
 1999|       |    
 2000|      0|    unmark_long_term_field_for_reference_by_frame_idx(structure, long_term_frame_idx, 0, 0, picNumX);
 2001|      0|  }
 2002|       |
 2003|      0|  mark_pic_long_term(p, long_term_frame_idx, picNumX);
 2004|      0|}
 2005|       |
 2006|       |/*!
 2007|       | ************************************************************************
 2008|       | * \brief
 2009|       | *    Set new max long_term_frame_idx
 2010|       | ************************************************************************
 2011|       | */
 2012|       |void mm_update_max_long_term_frame_idx(int max_long_term_frame_idx_plus1)
 2013|      0|{
 2014|      0|  unsigned i;
 2015|       |
 2016|      0|  dpb.max_long_term_pic_idx = max_long_term_frame_idx_plus1 - 1;
 2017|       |
 2018|       |  // check for invalid frames
 2019|      0|  for (i=0; i<dpb.ltref_frames_in_buffer; i++)
 2020|      0|  {
 2021|      0|    if (dpb.fs_ltref[i]->long_term_frame_idx > dpb.max_long_term_pic_idx)
 2022|      0|    {
 2023|      0|      unmark_for_long_term_reference(dpb.fs_ltref[i]);
 2024|      0|    }
 2025|      0|  }
 2026|      0|}
 2027|       |
 2028|       |
 2029|       |/*!
 2030|       | ************************************************************************
 2031|       | * \brief
 2032|       | *    Mark all long term reference pictures unused for reference
 2033|       | ************************************************************************
 2034|       | */
 2035|       |static void mm_unmark_all_long_term_for_reference ()
 2036|      0|{
 2037|      0|  mm_update_max_long_term_frame_idx(0);
 2038|      0|}
 2039|       |
 2040|       |/*!
 2041|       | ************************************************************************
 2042|       | * \brief
 2043|       | *    Mark all short term reference pictures unused for reference
 2044|       | ************************************************************************
 2045|       | */
 2046|       |static void mm_unmark_all_short_term_for_reference ()
 2047|      0|{
 2048|      0|  unsigned int i;
 2049|      0|  for (i=0; i<dpb.ref_frames_in_buffer; i++)
 2050|      0|  {
 2051|      0|    unmark_for_reference(dpb.fs_ref[i]);
 2052|      0|  }
 2053|      0|  update_ref_list();
 2054|      0|}
 2055|       |
 2056|       |
 2057|       |/*!
 2058|       | ************************************************************************
 2059|       | * \brief
 2060|       | *    Mark the current picture used for long term reference
 2061|       | ************************************************************************
 2062|       | */
 2063|       |static void mm_mark_current_picture_long_term(StorablePicture *p, int long_term_frame_idx)
 2064|      0|{
 2065|       |  // remove long term pictures with same long_term_frame_idx
 2066|      0|  if (p->structure == FRAME)
 2067|      0|  {
 2068|      0|    unmark_long_term_frame_for_reference_by_frame_idx(long_term_frame_idx);
 2069|      0|  }
 2070|      0|  else
 2071|      0|  {
 2072|      0|    unmark_long_term_field_for_reference_by_frame_idx(p->structure, long_term_frame_idx, 1, p->pic_num, 0);
 2073|      0|  }
 2074|       |
 2075|      0|  p->is_long_term = 1;
 2076|      0|  p->long_term_frame_idx = long_term_frame_idx;
 2077|      0|}
 2078|       |
 2079|       |
 2080|       |/*!
 2081|       | ************************************************************************
 2082|       | * \brief
 2083|       | *    Perform Adaptive memory control decoded reference picture marking process
 2084|       | ************************************************************************
 2085|       | */
 2086|       |static void adaptive_memory_management(StorablePicture* p)
 2087|      0|{
 2088|      0|  DecRefPicMarking_t *tmp_drpm;
 2089|       |
 2090|      0|  img->last_has_mmco_5 = 0;
 2091|       |
 2092|      0|  assert (!img->currentPicture->idr_flag);
 2093|      0|  assert (img->adaptive_ref_pic_buffering_flag);
 2094|       |
 2095|      0|  while (img->dec_ref_pic_marking_buffer)
 2096|      0|  {
 2097|      0|    tmp_drpm = img->dec_ref_pic_marking_buffer;
 2098|      0|    switch (tmp_drpm->memory_management_control_operation)
 2099|      0|    {
 2100|      0|      case 0:
 2101|      0|        if (tmp_drpm->Next != NULL)
 2102|      0|        {
 2103|      0|          error ("memory_management_control_operation = 0 not last operation in buffer", 500);
 2104|      0|        }
 2105|      0|        break;
 2106|      0|      case 1:
 2107|      0|        mm_unmark_short_term_for_reference(p, tmp_drpm->difference_of_pic_nums_minus1);
 2108|      0|        update_ref_list();
 2109|      0|        break;
 2110|      0|      case 2:
 2111|      0|        mm_unmark_long_term_for_reference(p, tmp_drpm->long_term_pic_num);
 2112|      0|        update_ltref_list();
 2113|      0|        break;
 2114|      0|      case 3:
 2115|      0|        mm_assign_long_term_frame_idx(p, tmp_drpm->difference_of_pic_nums_minus1, tmp_drpm->long_term_frame_idx);
 2116|      0|        update_ref_list();
 2117|      0|        update_ltref_list();
 2118|      0|        break;
 2119|      0|      case 4:
 2120|      0|        mm_update_max_long_term_frame_idx (tmp_drpm->max_long_term_frame_idx_plus1);
 2121|      0|        update_ltref_list();
 2122|      0|        break;
 2123|      0|      case 5:
 2124|      0|        mm_unmark_all_short_term_for_reference();
 2125|      0|        mm_unmark_all_long_term_for_reference();
 2126|      0|       img->last_has_mmco_5 = 1;
 2127|      0|        break;
 2128|      0|      case 6:
 2129|      0|        mm_mark_current_picture_long_term(p, tmp_drpm->long_term_frame_idx);
 2130|      0|        break;
 2131|      0|      default:
 2132|      0|        error ("invalid memory_management_control_operation in buffer", 500);
 2133|      0|    }
 2134|      0|    img->dec_ref_pic_marking_buffer = tmp_drpm->Next;
 2135|      0|    free (tmp_drpm);
 2136|      0|  }
 2137|      0|  if ( img->last_has_mmco_5 )
 2138|      0|  {
 2139|      0|    p->pic_num = p->frame_num = 0;
 2140|      0|    p->poc = 0;
 2141|      0|    img->ThisPOC=0;
 2142|       |    
 2143|      0|    switch (p->structure)
 2144|      0|    {
 2145|      0|    case TOP_FIELD:
 2146|      0|      {
 2147|      0|        img->toppoc=0;
 2148|      0|        break;
 2149|      0|      }
 2150|      0|    case BOTTOM_FIELD:
 2151|      0|      {
 2152|      0|        img->bottompoc=0;
 2153|      0|        break;
 2154|      0|      }
 2155|      0|    case FRAME:
 2156|      0|      {
 2157|      0|        img->framepoc=0;
 2158|      0|        break;
 2159|      0|      }
 2160|      0|    }
 2161|      0|    flush_dpb();
 2162|      0|  }
 2163|      0|}
 2164|       |
 2165|       |
 2166|       |/*!
 2167|       | ************************************************************************
 2168|       | * \brief
 2169|       | *    Store a picture in DPB. This includes cheking for space in DPB and 
 2170|       | *    flushing frames.
 2171|       | *    If we received a frame, we need to check for a new store, if we
 2172|       | *    got a field, check if it's the second field of an already allocated
 2173|       | *    store.
 2174|       | *
 2175|       | * \param p
 2176|       | *    Picture to be stored
 2177|       | *
 2178|       | ************************************************************************
 2179|       | */
 2180|       |void store_picture_in_dpb(StorablePicture* p)
 2181|    171|{
 2182|    171|  unsigned i;
 2183|    171|  int poc, pos;
 2184|       |  // diagnostics
 2185|       |  //printf ("Storing (%s) non-ref pic with frame_num #%d\n", (p->type == FRAME)?"FRAME":(p->type == TOP_FIELD)?"TOP_FIELD":"BOTTOM_FIELD", p->pic_num);
 2186|       |  // if frame, check for new store, 
 2187|    171|  assert (p!=NULL);
 2188|       |
 2189|    171|  p->used_for_reference = (img->nal_reference_idc != 0);
 2190|       |  
 2191|    171|  img->last_has_mmco_5=0;
 2192|    171|  img->last_pic_bottom_field = (img->structure == BOTTOM_FIELD);
 2193|       |
 2194|    171|  if (img->currentPicture->idr_flag)
 2195|      1|    idr_memory_management(p);
 2196|    170|  else
 2197|    170|  {
 2198|       |    // adaptive memory management
 2199|    170|    if (p->used_for_reference && (img->adaptive_ref_pic_buffering_flag))
 2200|      0|      adaptive_memory_management(p);
 2201|    170|  }
 2202|       |
 2203|    171|  if ((p->structure==TOP_FIELD)||(p->structure==BOTTOM_FIELD))
 2204|      0|  {
 2205|       |    // check for frame store with same pic_number
 2206|      0|    if (dpb.last_picture)
 2207|      0|    {
 2208|      0|      if ((int)dpb.last_picture->frame_num == p->pic_num)
 2209|      0|      {
 2210|      0|        if (((p->structure==TOP_FIELD)&&(dpb.last_picture->is_used==2))||((p->structure==BOTTOM_FIELD)&&(dpb.last_picture->is_used==1)))
 2211|      0|        {
 2212|      0|          if ((p->used_for_reference && (dpb.last_picture->is_orig_reference!=0))||
 2213|      0|              (!p->used_for_reference && (dpb.last_picture->is_orig_reference==0)))
 2214|      0|          {
 2215|      0|            insert_picture_in_dpb(dpb.last_picture, p);
 2216|      0|            update_ref_list();
 2217|      0|            update_ltref_list();
 2218|      0|            dump_dpb();
 2219|      0|            dpb.last_picture = NULL;
 2220|      0|            return;
 2221|      0|          }
 2222|      0|        }
 2223|      0|      }
 2224|      0|    }
 2225|      0|  }
 2226|       |  
 2227|       |  // this is a frame or a field which has no stored complementatry field
 2228|       |
 2229|       |  // sliding window, if necessary
 2230|    171|  if ((!img->currentPicture->idr_flag)&&(p->used_for_reference && (!img->adaptive_ref_pic_buffering_flag)))
 2231|     85|  {
 2232|     85|    sliding_window_memory_management(p);
 2233|     85|  } 
 2234|       |
 2235|       |  // first try to remove unused frames
 2236|    171|  if (dpb.used_size==dpb.size)
 2237|    159|  {
 2238|    159|    remove_unused_frame_from_dpb();
 2239|    159|  }
 2240|       |  
 2241|       |  // then output frames until one can be removed
 2242|    330|  while (dpb.used_size==dpb.size)
 2243|    159|  {
 2244|       |    // non-reference frames may be output directly
 2245|    159|    if (!p->used_for_reference)
 2246|     80|    {
 2247|     80|      get_smallest_poc(&poc, &pos);
 2248|     80|      if ((-1==pos) || (p->poc < poc))
 2249|      0|      {
 2250|      0|        direct_output(p, p_dec);
 2251|      0|        return;
 2252|      0|      }
 2253|     80|    }
 2254|       |    // flush a frame
 2255|    159|    output_one_frame_from_dpb();
 2256|    159|  }
 2257|       |  
 2258|       |  // check for duplicate frame number in short term reference buffer
 2259|    171|  if ((p->used_for_reference)&&(!p->is_long_term))
 2260|     86|  {
 2261|    420|    for (i=0; i<dpb.ref_frames_in_buffer; i++)
 2262|    334|    {
 2263|    334|      if (dpb.fs_ref[i]->frame_num == p->frame_num)
 2264|      0|      {
 2265|      0|        error("duplicate frame_num im short-term reference picture buffer", 500);
 2266|      0|      }
 2267|    334|    }
 2268|       |
 2269|     86|  }
 2270|       |  // store at end of buffer
 2271|       |//  printf ("store frame/field at pos %d\n",dpb.used_size);
 2272|    171|  insert_picture_in_dpb(dpb.fs[dpb.used_size],p);
 2273|       |  
 2274|    171|  if (p->structure != FRAME)
 2275|      0|  {
 2276|      0|    dpb.last_picture = dpb.fs[dpb.used_size];
 2277|      0|  }
 2278|    171|  else
 2279|    171|  {
 2280|    171|    dpb.last_picture = NULL;
 2281|    171|  }
 2282|       |
 2283|    171|  dpb.used_size++;
 2284|       |
 2285|    171|  update_ref_list();
 2286|    171|  update_ltref_list();
 2287|    171|  dump_dpb();
 2288|    171|}
 2289|       |
 2290|       |
 2291|       |/*!
 2292|       | ************************************************************************
 2293|       | * \brief
 2294|       | *    Insert the frame picture into the if the top field has already
 2295|       | *    been stored for the coding decision
 2296|       | *
 2297|       | * \param p
 2298|       | *    StorablePicture to be inserted
 2299|       | *
 2300|       | ************************************************************************
 2301|       | */
 2302|       |void replace_top_pic_with_frame(StorablePicture* p)
 2303|      0|{
 2304|      0|  FrameStore* fs = NULL;
 2305|      0|  unsigned i, found;
 2306|       |
 2307|      0|  assert (p!=NULL);
 2308|      0|  assert (p->structure==FRAME);
 2309|       |
 2310|      0|  p->used_for_reference = (img->nal_reference_idc != 0);
 2311|       |  // upsample a reference picture
 2312|      0|  if (p->used_for_reference)
 2313|      0|  {
 2314|      0|    UnifiedOneForthPix(p);
 2315|      0|  }
 2316|       |
 2317|      0|  found=0;
 2318|       |
 2319|      0|  for (i=0;i<dpb.used_size;i++)
 2320|      0|  {
 2321|      0|    if((dpb.fs[i]->frame_num == img->frame_num)&&(dpb.fs[i]->is_used==1))
 2322|      0|    {
 2323|      0|      found=1;
 2324|      0|      fs = dpb.fs[i];
 2325|      0|      break;
 2326|      0|    }
 2327|      0|  }
 2328|       |
 2329|      0|  if (!found)
 2330|      0|  {
 2331|      0|    error("replace_top_pic_with_frame: error storing reference frame (top field not found)",500);
 2332|      0|  }
 2333|       |
 2334|      0|  free_storable_picture(fs->top_field);
 2335|      0|  fs->top_field=NULL;
 2336|      0|  fs->frame=p;
 2337|      0|  fs->is_used = 3;
 2338|      0|  if (p->used_for_reference)
 2339|      0|  {
 2340|      0|    fs->is_reference = 3;
 2341|      0|    if (p->is_long_term)
 2342|      0|    {
 2343|      0|      fs->is_long_term = 3;
 2344|      0|    }
 2345|      0|  }
 2346|       |  // generate field views
 2347|      0|  dpb_split_field(fs);
 2348|      0|  update_ref_list();
 2349|      0|  update_ltref_list();
 2350|      0|}
 2351|       |
 2352|       |
 2353|       |/*!
 2354|       | ************************************************************************
 2355|       | * \brief
 2356|       | *    Insert the picture into the DPB. A free DPB position is necessary
 2357|       | *    for frames, .
 2358|       | *
 2359|       | * \param fs
 2360|       | *    FrameStore into which the picture will be inserted
 2361|       | * \param p
 2362|       | *    StorablePicture to be inserted
 2363|       | *
 2364|       | ************************************************************************
 2365|       | */
 2366|       |static void insert_picture_in_dpb(FrameStore* fs, StorablePicture* p)
 2367|    171|{
 2368|       |//  printf ("insert (%s) pic with frame_num #%d, poc %d\n", (p->structure == FRAME)?"FRAME":(p->structure == TOP_FIELD)?"TOP_FIELD":"BOTTOM_FIELD", p->pic_num, p->poc);
 2369|    171|  assert (p!=NULL);
 2370|    171|  assert (fs!=NULL);
 2371|       |
 2372|       |  // upsample a reference picture
 2373|    171|  if (p->used_for_reference)
 2374|     86|  {
 2375|     86|    UnifiedOneForthPix(p);
 2376|     86|  }
 2377|       |
 2378|    171|  switch (p->structure)
 2379|    171|  {
 2380|    171|  case FRAME: 
 2381|    171|    fs->frame = p;
 2382|    171|    fs->is_used = 3;
 2383|    171|    if (p->used_for_reference)
 2384|     86|    {
 2385|     86|      fs->is_reference = 3;
 2386|     86|      fs->is_orig_reference = 3;
 2387|     86|      if (p->is_long_term)
 2388|      0|      {
 2389|      0|        fs->is_long_term = 3;
 2390|      0|      }
 2391|     86|    }
 2392|       |   // generate field views
 2393|    171|      dpb_split_field(fs); 
 2394|    171|    break;
 2395|      0|  case TOP_FIELD:
 2396|      0|    fs->top_field = p;
 2397|      0|    fs->is_used |= 1;
 2398|      0|    if (p->used_for_reference)
 2399|      0|    {
 2400|      0|      fs->is_reference |= 1;
 2401|      0|      fs->is_orig_reference |= 1;
 2402|      0|      if (p->is_long_term)
 2403|      0|      {
 2404|      0|        fs->is_long_term |= 1;
 2405|      0|        fs->long_term_frame_idx = p->long_term_frame_idx;
 2406|      0|      }
 2407|      0|    }
 2408|      0|    if (fs->is_used == 3)
 2409|      0|    {
 2410|       |      // generate frame view
 2411|      0|      dpb_combine_field(fs);
 2412|      0|    } else
 2413|      0|    {
 2414|      0|      fs->poc = p->poc;
 2415|      0|      gen_field_ref_ids(p);
 2416|      0|    }
 2417|      0|    break;
 2418|      0|  case BOTTOM_FIELD:
 2419|      0|    fs->bottom_field = p;
 2420|      0|    fs->is_used |= 2;
 2421|      0|    if (p->used_for_reference)
 2422|      0|    {
 2423|      0|      fs->is_reference |= 2;
 2424|      0|      fs->is_orig_reference |= 2;
 2425|      0|      if (p->is_long_term)
 2426|      0|      {
 2427|      0|        fs->is_long_term |= 2;
 2428|      0|        fs->long_term_frame_idx = p->long_term_frame_idx;
 2429|      0|      }
 2430|      0|    }
 2431|      0|    if (fs->is_used == 3)
 2432|      0|    {
 2433|       |      // generate frame view
 2434|      0|      dpb_combine_field(fs);
 2435|      0|    } else
 2436|      0|    {
 2437|      0|      fs->poc = p->poc;
 2438|      0|      gen_field_ref_ids(p);
 2439|      0|    }
 2440|      0|    break;
 2441|    171|  }
 2442|    171|  fs->frame_num = p->pic_num;
 2443|    171|  fs->is_output = p->is_output;
 2444|       |
 2445|    171|}
 2446|       |
 2447|       |/*!
 2448|       | ************************************************************************
 2449|       | * \brief
 2450|       | *    Check if one of the frames/fields in frame store is used for reference
 2451|       | ************************************************************************
 2452|       | */
 2453|       |static int is_used_for_reference(FrameStore* fs)
 2454|    171|{
 2455|    171|  if (fs->is_reference)
 2456|      0|  {
 2457|      0|    return 1;
 2458|      0|  }
 2459|       |  
 2460|    171|  if (fs->is_used==3) // frame
 2461|    171|  {
 2462|    171|    if (fs->frame->used_for_reference)
 2463|      0|    {
 2464|      0|      return 1;
 2465|      0|    }
 2466|    171|  }
 2467|    171|  if (!active_sps->frame_mbs_only_flag)
 2468|      0|  {
 2469|      0|    if (fs->is_used&1) // top field
 2470|      0|    {
 2471|      0|      if (fs->top_field->used_for_reference)
 2472|      0|      {
 2473|      0|        return 1;
 2474|      0|      }
 2475|      0|    }
 2476|       |
 2477|      0|    if (fs->is_used&2) // bottom field
 2478|      0|    {
 2479|      0|      if (fs->bottom_field->used_for_reference)
 2480|      0|      {
 2481|      0|        return 1;
 2482|      0|      }
 2483|      0|    }
 2484|      0|  }
 2485|    171|  return 0;
 2486|    171|}
 2487|       |
 2488|       |
 2489|       |/*!
 2490|       | ************************************************************************
 2491|       | * \brief
 2492|       | *    Check if one of the frames/fields in frame store is used for short-term reference
 2493|       | ************************************************************************
 2494|       | */
 2495|       |static int is_short_term_reference(FrameStore* fs)
 2496|  2.95k|{
 2497|       |
 2498|  2.95k|  if (fs->is_used==3) // frame
 2499|  2.95k|  {
 2500|  2.95k|    if ((fs->frame->used_for_reference)&&(!fs->frame->is_long_term))
 2501|  1.16k|    {
 2502|  1.16k|      return 1;
 2503|  1.16k|    }
 2504|  2.95k|  }
 2505|  1.79k|  if (!active_sps->frame_mbs_only_flag)
 2506|      0|  {
 2507|      0|    if (fs->is_used&1) // top field
 2508|      0|    {
 2509|      0|      if ((fs->top_field->used_for_reference)&&(!fs->top_field->is_long_term))
 2510|      0|      {
 2511|      0|        return 1;
 2512|      0|      }
 2513|      0|    }
 2514|       |
 2515|      0|    if (fs->is_used&2) // bottom field
 2516|      0|    {
 2517|      0|        if ((fs->bottom_field->used_for_reference)&&(!fs->bottom_field->is_long_term))
 2518|      0|      {
 2519|      0|        return 1;
 2520|      0|      }
 2521|      0|    }
 2522|      0|  }
 2523|  1.79k|  return 0;
 2524|  1.79k|}
 2525|       |
 2526|       |
 2527|       |/*!
 2528|       | ************************************************************************
 2529|       | * \brief
 2530|       | *    Check if one of the frames/fields in frame store is used for short-term reference
 2531|       | ************************************************************************
 2532|       | */
 2533|       |static int is_long_term_reference(FrameStore* fs)
 2534|  1.98k|{
 2535|       |
 2536|  1.98k|  if (fs->is_used==3) // frame
 2537|  1.98k|  {
 2538|  1.98k|    if ((fs->frame->used_for_reference)&&(fs->frame->is_long_term))
 2539|      0|    {
 2540|      0|      return 1;
 2541|      0|    }
 2542|  1.98k|  }
 2543|  1.98k|  if (!active_sps->frame_mbs_only_flag)
 2544|      0|  {
 2545|      0|    if (fs->is_used&1) // top field
 2546|      0|    {
 2547|      0|      if ((fs->top_field->used_for_reference)&&(fs->top_field->is_long_term))
 2548|      0|      {
 2549|      0|        return 1;
 2550|      0|      }
 2551|      0|    }
 2552|       |
 2553|      0|    if (fs->is_used&2) // bottom field
 2554|      0|    {
 2555|      0|        if ((fs->bottom_field->used_for_reference)&&(fs->bottom_field->is_long_term))
 2556|      0|      {
 2557|      0|        return 1;
 2558|      0|      }
 2559|      0|    }
 2560|      0|  }
 2561|  1.98k|  return 0;
 2562|  1.98k|}
 2563|       |
 2564|       |
 2565|       |/*!
 2566|       | ************************************************************************
 2567|       | * \brief
 2568|       | *    remove one frame from DPB
 2569|       | ************************************************************************
 2570|       | */
 2571|       |static void remove_frame_from_dpb(int pos)
 2572|    171|{
 2573|    171|  FrameStore* fs = dpb.fs[pos];
 2574|    171|  FrameStore* tmp;
 2575|    171|  unsigned i;
 2576|       |  
 2577|       |//  printf ("remove frame with frame_num #%d\n", fs->frame_num);
 2578|    171|  switch (fs->is_used)
 2579|    171|  {
 2580|    171|  case 3:
 2581|    171|    free_storable_picture(fs->frame);
 2582|    171|    free_storable_picture(fs->top_field);
 2583|    171|    free_storable_picture(fs->bottom_field);
 2584|    171|    fs->frame=NULL;
 2585|    171|    fs->top_field=NULL;
 2586|    171|    fs->bottom_field=NULL;
 2587|    171|    break;
 2588|      0|  case 2:
 2589|      0|    free_storable_picture(fs->bottom_field);
 2590|      0|    fs->bottom_field=NULL;
 2591|      0|    break;
 2592|      0|  case 1:
 2593|      0|    free_storable_picture(fs->top_field);
 2594|      0|    fs->top_field=NULL;
 2595|      0|    break;
 2596|      0|  case 0:
 2597|      0|    break;
 2598|      0|  default:
 2599|      0|    error("invalid frame store type",500);
 2600|    171|  }
 2601|    171|  fs->is_used = 0;
 2602|    171|  fs->is_long_term = 0;
 2603|    171|  fs->is_reference = 0;
 2604|    171|  fs->is_orig_reference = 0;
 2605|       |
 2606|       |  // move empty framestore to end of buffer
 2607|    171|  tmp = dpb.fs[pos];
 2608|       |
 2609|  1.90k|  for (i=pos; i<dpb.used_size-1;i++)
 2610|  1.73k|  {
 2611|  1.73k|    dpb.fs[i] = dpb.fs[i+1];
 2612|  1.73k|  }
 2613|    171|  dpb.fs[dpb.used_size-1] = tmp;
 2614|    171|  dpb.used_size--;
 2615|    171|}
 2616|       |
 2617|       |/*!
 2618|       | ************************************************************************
 2619|       | * \brief
 2620|       | *    find smallest POC in the DPB.
 2621|       | ************************************************************************
 2622|       | */
 2623|       |static void get_smallest_poc(int *poc,int * pos)
 2624|    251|{
 2625|    251|  unsigned i;
 2626|       |
 2627|    251|  if (dpb.used_size<1)
 2628|      0|  {
 2629|      0|    error("Cannot determine smallest POC, DPB empty.",150);
 2630|      0|  }
 2631|       |
 2632|    251|  *pos=-1;
 2633|    251|  *poc = INT_MAX;
 2634|  3.19k|  for (i=0; i<dpb.used_size; i++)
 2635|  2.94k|  {
 2636|  2.94k|    if ((*poc>dpb.fs[i]->poc)&&(!dpb.fs[i]->is_output))
 2637|    336|    {
 2638|    336|      *poc = dpb.fs[i]->poc;
 2639|    336|      *pos=i;
 2640|    336|    }
 2641|  2.94k|  }
 2642|    251|}
 2643|       |
 2644|       |/*!
 2645|       | ************************************************************************
 2646|       | * \brief
 2647|       | *    Remove a picture from DPB which is no longer needed.
 2648|       | ************************************************************************
 2649|       | */
 2650|       |static int remove_unused_frame_from_dpb()
 2651|    161|{
 2652|    161|  unsigned i;
 2653|       |
 2654|       |  // check for frames that were already output and no longer used for reference
 2655|  2.08k|  for (i=0; i<dpb.used_size; i++)
 2656|  1.92k|  {
 2657|  1.92k|    if (dpb.fs[i]->is_output && (!is_used_for_reference(dpb.fs[i])))
 2658|      0|    {
 2659|      0|      remove_frame_from_dpb(i);
 2660|      0|      return 1;
 2661|      0|    }
 2662|  1.92k|  }
 2663|    161|  return 0;
 2664|    161|}
 2665|       |
 2666|       |/*!
 2667|       | ************************************************************************
 2668|       | * \brief
 2669|       | *    Output one picture stored in the DPB.
 2670|       | ************************************************************************
 2671|       | */
 2672|       |static void output_one_frame_from_dpb()
 2673|    171|{
 2674|    171|  int poc, pos;
 2675|       |  //diagnostics
 2676|    171|  if (dpb.used_size<1)
 2677|      0|  {
 2678|      0|    error("Cannot output frame, DPB empty.",150);
 2679|      0|  }
 2680|       |
 2681|       |  // find smallest POC
 2682|    171|  get_smallest_poc(&poc, &pos);
 2683|       |
 2684|    171|  if(pos==-1)
 2685|      0|  {
 2686|      0|    error("no frames for output available", 150);
 2687|      0|  }
 2688|       |
 2689|       |  // call the output function
 2690|       |//  printf ("output frame with frame_num #%d, poc %d (dpb. dpb.size=%d, dpb.used_size=%d)\n", dpb.fs[pos]->frame_num, dpb.fs[pos]->frame->poc, dpb.size, dpb.used_size);
 2691|       |
 2692|    171|#if defined(SPEC_CPU)
 2693|    171|  if (p_dec != -1) write_stored_frame(dpb.fs[pos], p_dec);
 2694|       |#else
 2695|       |  write_stored_frame(dpb.fs[pos], p_dec);
 2696|       |#endif
 2697|       |
 2698|    171|  if (dpb.last_output_poc >= poc)
 2699|      0|  {
 2700|      0|    error ("output POC must be in ascending order", 150);
 2701|      0|  } 
 2702|    171|  dpb.last_output_poc = poc;
 2703|       |  // free frame store and move empty store to end of buffer
 2704|    171|  if (!is_used_for_reference(dpb.fs[pos]))
 2705|    171|  {
 2706|    171|    remove_frame_from_dpb(pos);
 2707|    171|  }
 2708|    171|}
 2709|       |
 2710|       |
 2711|       |
 2712|       |/*!
 2713|       | ************************************************************************
 2714|       | * \brief
 2715|       | *    All stored picture are output. Should be called to empty the buffer
 2716|       | ************************************************************************
 2717|       | */
 2718|       |void flush_dpb()
 2719|      2|{
 2720|      2|  unsigned i;
 2721|       |
 2722|       |  //diagnostics
 2723|       |//  printf("Flush remaining frames from dpb. dpb.size=%d, dpb.used_size=%d\n",dpb.size,dpb.used_size);
 2724|       |
 2725|       |  // mark all frames unused
 2726|     14|  for (i=0; i<dpb.used_size; i++)
 2727|     12|  {
 2728|     12|    unmark_for_reference (dpb.fs[i]);
 2729|     12|  }
 2730|       |
 2731|      2|  while (remove_unused_frame_from_dpb()) ;
 2732|       |  
 2733|       |  // output frames in POC order
 2734|     14|  while (dpb.used_size)
 2735|     12|  {
 2736|     12|    output_one_frame_from_dpb();
 2737|     12|  }
 2738|       |
 2739|      2|  dpb.last_output_poc = INT_MIN;
 2740|      2|}
 2741|       |
 2742|  13.9M|#define RSD(x) ((x&2)?(x|1):(x&(~1)))
 2743|       |
 2744|       |
 2745|       |void gen_field_ref_ids(StorablePicture *p)
 2746|      0|{
 2747|      0|  int i,j, dummylist0, dummylist1;
 2748|       |   //! Generate Frame parameters from field information.
 2749|      0|  for (i=0 ; i<p->size_x/4 ; i++)
 2750|      0|  {
 2751|      0|    for (j=0 ; j<p->size_y/4 ; j++)
 2752|      0|    {              
 2753|      0|        dummylist0= p->ref_idx[LIST_0][i][j];
 2754|      0|        dummylist1= p->ref_idx[LIST_1][i][j];
 2755|       |        //! association with id already known for fields.
 2756|      0|        p->ref_id[LIST_0][i][j] = (dummylist0>=0)? p->ref_pic_num[LIST_0][dummylist0] : 0;
 2757|      0|        p->ref_id[LIST_1][i][j] = (dummylist1>=0)? p->ref_pic_num[LIST_1][dummylist1] : 0;          
 2758|      0|        p->field_frame[i][j]=1;
 2759|      0|    }     
 2760|      0|  }
 2761|      0|}
 2762|       |
 2763|       |/*!
 2764|       | ************************************************************************
 2765|       | * \brief
 2766|       | *    Extract top field from a frame
 2767|       | ************************************************************************
 2768|       | */
 2769|       |void dpb_split_field(FrameStore *fs)
 2770|    171|{
 2771|    171|  int i, j;
 2772|    171|  int dummylist0,dummylist1;
 2773|       |
 2774|    171|  fs->poc = fs->frame->poc;
 2775|       |
 2776|    171|  if (!fs->frame->frame_mbs_only_flag)
 2777|      0|  {
 2778|      0|    fs->top_field    = alloc_storable_picture(TOP_FIELD,    fs->frame->size_x, fs->frame->size_y/2, fs->frame->size_x_cr, fs->frame->size_y_cr/2);
 2779|      0|    fs->bottom_field = alloc_storable_picture(BOTTOM_FIELD, fs->frame->size_x, fs->frame->size_y/2, fs->frame->size_x_cr, fs->frame->size_y_cr/2);
 2780|       |    
 2781|      0|    for (i=0; i<fs->frame->size_y/2; i++)
 2782|      0|    {
 2783|      0|      memcpy(fs->top_field->imgY[i], fs->frame->imgY[i*2], fs->frame->size_x*sizeof(imgpel));
 2784|      0|    }
 2785|       |    
 2786|      0|    for (i=0; i<fs->frame->size_y_cr/2; i++)
 2787|      0|    {
 2788|      0|      memcpy(fs->top_field->imgUV[0][i], fs->frame->imgUV[0][i*2], fs->frame->size_x_cr*sizeof(imgpel));
 2789|      0|      memcpy(fs->top_field->imgUV[1][i], fs->frame->imgUV[1][i*2], fs->frame->size_x_cr*sizeof(imgpel));
 2790|      0|    }
 2791|       |    
 2792|      0|    for (i=0; i<fs->frame->size_y/2; i++)
 2793|      0|    {
 2794|      0|      memcpy(fs->bottom_field->imgY[i], fs->frame->imgY[i*2 + 1], fs->frame->size_x*sizeof(imgpel));
 2795|      0|    }
 2796|       |    
 2797|      0|    for (i=0; i<fs->frame->size_y_cr/2; i++)
 2798|      0|    {
 2799|      0|      memcpy(fs->bottom_field->imgUV[0][i], fs->frame->imgUV[0][i*2 + 1], fs->frame->size_x_cr*sizeof(imgpel));
 2800|      0|      memcpy(fs->bottom_field->imgUV[1][i], fs->frame->imgUV[1][i*2 + 1], fs->frame->size_x_cr*sizeof(imgpel));
 2801|      0|    }
 2802|       |    
 2803|      0|    UnifiedOneForthPix(fs->top_field);
 2804|      0|    UnifiedOneForthPix(fs->bottom_field);
 2805|       |
 2806|      0|    fs->top_field->poc = fs->frame->top_poc;
 2807|      0|    fs->bottom_field->poc =  fs->frame->bottom_poc;
 2808|       |  
 2809|      0|    fs->top_field->frame_poc =  fs->frame->frame_poc;
 2810|       |  
 2811|      0|    fs->top_field->bottom_poc =fs->bottom_field->bottom_poc =  fs->frame->bottom_poc;
 2812|      0|    fs->top_field->top_poc =fs->bottom_field->top_poc =  fs->frame->top_poc;
 2813|      0|    fs->bottom_field->frame_poc =  fs->frame->frame_poc;
 2814|       |  
 2815|      0|    fs->top_field->used_for_reference = fs->bottom_field->used_for_reference 
 2816|      0|                                      = fs->frame->used_for_reference;
 2817|      0|    fs->top_field->is_long_term = fs->bottom_field->is_long_term 
 2818|      0|                                = fs->frame->is_long_term;
 2819|      0|    fs->long_term_frame_idx = fs->top_field->long_term_frame_idx 
 2820|      0|                            = fs->bottom_field->long_term_frame_idx 
 2821|      0|                            = fs->frame->long_term_frame_idx;
 2822|       |
 2823|      0|    fs->top_field->coded_frame = fs->bottom_field->coded_frame = 1;
 2824|      0|    fs->top_field->MbaffFrameFlag = fs->bottom_field->MbaffFrameFlag
 2825|      0|                                  = fs->frame->MbaffFrameFlag;
 2826|       |
 2827|      0|    fs->frame->top_field    = fs->top_field;
 2828|      0|    fs->frame->bottom_field = fs->bottom_field;
 2829|       |
 2830|      0|    fs->top_field->bottom_field = fs->bottom_field;
 2831|      0|    fs->top_field->frame        = fs->frame;
 2832|      0|    fs->bottom_field->top_field = fs->top_field;
 2833|      0|    fs->bottom_field->frame     = fs->frame;
 2834|       |  
 2835|      0|    fs->top_field->chroma_format_idc = fs->bottom_field->chroma_format_idc = fs->frame->chroma_format_idc;
 2836|       |
 2837|       |    //store reference picture index
 2838|      0|    if (!fs->frame->frame_mbs_only_flag)
 2839|      0|    {
 2840|      0|      for (i=0;i<listXsize[LIST_1];i++)
 2841|      0|      {
 2842|      0|        fs->top_field->ref_pic_num[LIST_1][2*i]     =fs->frame->ref_pic_num[2 + LIST_1][2*i];
 2843|      0|        fs->top_field->ref_pic_num[LIST_1][2*i + 1] =fs->frame->ref_pic_num[2 + LIST_1][2*i+1];
 2844|      0|        fs->bottom_field->ref_pic_num[LIST_1][2*i]  =fs->frame->ref_pic_num[4 + LIST_1][2*i];
 2845|      0|        fs->bottom_field->ref_pic_num[LIST_1][2*i+1]=fs->frame->ref_pic_num[4 + LIST_1][2*i+1] ;
 2846|      0|      }
 2847|       |    
 2848|      0|      for (i=0;i<listXsize[LIST_0];i++)
 2849|      0|      {
 2850|      0|        fs->top_field->ref_pic_num[LIST_0][2*i]     =fs->frame->ref_pic_num[2 + LIST_0][2*i];
 2851|      0|        fs->top_field->ref_pic_num[LIST_0][2*i + 1] =fs->frame->ref_pic_num[2 + LIST_0][2*i+1];
 2852|      0|        fs->bottom_field->ref_pic_num[LIST_0][2*i]  =fs->frame->ref_pic_num[4 + LIST_0][2*i];
 2853|      0|        fs->bottom_field->ref_pic_num[LIST_0][2*i+1]=fs->frame->ref_pic_num[4 + LIST_0][2*i+1] ;
 2854|      0|      }
 2855|       |    
 2856|      0|    }
 2857|      0|  }
 2858|    171|  else
 2859|    171|  {
 2860|    171|    fs->top_field=NULL;
 2861|    171|    fs->bottom_field=NULL;
 2862|    171|    fs->frame->top_field=NULL;
 2863|    171|    fs->frame->bottom_field=NULL;
 2864|    171|  }
 2865|       |  
 2866|  13.8k|  for (j=0 ; j<fs->frame->size_y/4 ; j++)      
 2867|  13.6k|  {                
 2868|  1.76M|    for (i=0 ; i<fs->frame->size_x/4 ; i++)          
 2869|  1.75M|    {   
 2870|  1.75M|      int idiv4=i/4,jdiv4=j/4;
 2871|  1.75M|      int currentmb=2*(fs->frame->size_x/16)*(jdiv4/2)+ (idiv4)*2 + (jdiv4%2);
 2872|  1.75M|      if (fs->frame->MbaffFrameFlag  && fs->frame->mb_field[currentmb])
 2873|      0|      {    
 2874|      0|        int list_offset = currentmb%2? 4: 2;
 2875|      0|        dummylist0 = fs->frame->ref_idx[LIST_0][i][j];
 2876|      0|        dummylist1 = fs->frame->ref_idx[LIST_1][i][j];        
 2877|       |        //! association with id already known for fields.
 2878|      0|        fs->frame->ref_id[LIST_0 + list_offset][i][j] = (dummylist0>=0)? fs->frame->ref_pic_num[LIST_0 + list_offset][dummylist0] : 0;
 2879|      0|        fs->frame->ref_id[LIST_1 + list_offset][i][j] = (dummylist1>=0)? fs->frame->ref_pic_num[LIST_1 + list_offset][dummylist1] : 0;          
 2880|       |        //! need to make association with frames
 2881|      0|        fs->frame->ref_id[LIST_0][i][j] = (dummylist0>=0)? fs->frame->frm_ref_pic_num[LIST_0 + list_offset][dummylist0] : 0;
 2882|      0|        fs->frame->ref_id[LIST_1][i][j] = (dummylist1>=0)? fs->frame->frm_ref_pic_num[LIST_1 + list_offset][dummylist1] : 0;                   
 2883|       |        
 2884|      0|      }
 2885|  1.75M|      else
 2886|  1.75M|      {
 2887|  1.75M|        dummylist0 = fs->frame->ref_idx[LIST_0][i][j];
 2888|  1.75M|        dummylist1 = fs->frame->ref_idx[LIST_1][i][j];        
 2889|  1.75M|        fs->frame->ref_id[LIST_0][i][j] = (dummylist0>=0)? fs->frame->ref_pic_num[LIST_0][dummylist0] : -1;
 2890|  1.75M|        fs->frame->ref_id[LIST_1][i][j] = (dummylist1>=0)? fs->frame->ref_pic_num[LIST_1][dummylist1] : -1;    
 2891|  1.75M|      }
 2892|  1.75M|    }      
 2893|  13.6k|  }
 2894|       |  
 2895|    171|  if (!fs->frame->frame_mbs_only_flag || active_sps->direct_8x8_inference_flag)      
 2896|    171|  {    
 2897|  22.0k|    for (i=0 ; i<fs->frame->size_x/4 ; i++)
 2898|  21.8k|    {                
 2899|   897k|      for (j=0 ; j<fs->frame->size_y/8; j++)      
 2900|   875k|      { 
 2901|   875k|        int idiv4=i/4,jdiv4=j/2;
 2902|       |        
 2903|   875k|        int currentmb=2*(fs->frame->size_x/16)*(jdiv4/2)+ (idiv4)*2 + (jdiv4%2);
 2904|       |        // Assign field mvs attached to MB-Frame buffer to the proper buffer
 2905|   875k|        if (fs->frame->MbaffFrameFlag  && fs->frame->mb_field[currentmb])
 2906|      0|        {
 2907|      0|          fs->bottom_field->field_frame[i][j] = fs->top_field->field_frame[i][j]=1;
 2908|      0|          fs->frame->field_frame[i][2*j] = fs->frame->field_frame[i][2*j+1]=1;
 2909|       |          
 2910|      0|          fs->bottom_field->mv[LIST_0][i][j][0] = fs->frame->mv[LIST_0][i][(j/4)*8 + j%4 + 4][0];
 2911|      0|          fs->bottom_field->mv[LIST_0][i][j][1] = fs->frame->mv[LIST_0][i][(j/4)*8 + j%4 + 4][1];
 2912|      0|          fs->bottom_field->mv[LIST_1][i][j][0] = fs->frame->mv[LIST_1][i][(j/4)*8 + j%4 + 4][0];
 2913|      0|          fs->bottom_field->mv[LIST_1][i][j][1] = fs->frame->mv[LIST_1][i][(j/4)*8 + j%4 + 4][1];
 2914|      0|          fs->bottom_field->ref_idx[LIST_0][i][j] = fs->frame->ref_idx[LIST_0][i][(j/4)*8 + j%4 + 4];
 2915|      0|          fs->bottom_field->ref_idx[LIST_1][i][j] = fs->frame->ref_idx[LIST_1][i][(j/4)*8 + j%4 + 4];
 2916|      0|          fs->bottom_field->ref_id[LIST_0][i][j] = fs->frame->ref_id[LIST_0+4][i][(j/4)*8 + j%4 + 4];
 2917|      0|          fs->bottom_field->ref_id[LIST_1][i][j] = fs->frame->ref_id[LIST_1+4][i][(j/4)*8 + j%4 + 4];
 2918|       |          
 2919|       |          
 2920|      0|          fs->top_field->mv[LIST_0][i][j][0] = fs->frame->mv[LIST_0][i][(j/4)*8 + j%4][0];
 2921|      0|          fs->top_field->mv[LIST_0][i][j][1] = fs->frame->mv[LIST_0][i][(j/4)*8 + j%4][1];
 2922|      0|          fs->top_field->mv[LIST_1][i][j][0] = fs->frame->mv[LIST_1][i][(j/4)*8 + j%4][0];
 2923|      0|          fs->top_field->mv[LIST_1][i][j][1] = fs->frame->mv[LIST_1][i][(j/4)*8 + j%4][1];
 2924|      0|          fs->top_field->ref_idx[LIST_0][i][j] = fs->frame->ref_idx[LIST_0][i][(j/4)*8 + j%4];
 2925|      0|          fs->top_field->ref_idx[LIST_1][i][j] = fs->frame->ref_idx[LIST_1][i][(j/4)*8 + j%4];
 2926|      0|          fs->top_field->ref_id[LIST_0][i][j] = fs->frame->ref_id[LIST_0+2][i][(j/4)*8 + j%4];
 2927|      0|          fs->top_field->ref_id[LIST_1][i][j] = fs->frame->ref_id[LIST_1+2][i][(j/4)*8 + j%4];
 2928|       |          
 2929|      0|        }
 2930|   875k|      }
 2931|  21.8k|    }             
 2932|    171|  }
 2933|       |    
 2934|       |  //! Generate field MVs from Frame MVs
 2935|  22.0k|  for (i=0 ; i<fs->frame->size_x/4 ; i++)
 2936|  21.8k|  {
 2937|   897k|    for (j=0 ; j<fs->frame->size_y/8 ; j++)
 2938|   875k|    {
 2939|   875k|      int idiv4=i/4,jdiv4=j/2;
 2940|       |      
 2941|   875k|      int currentmb=2*(fs->frame->size_x/16)*(jdiv4/2)+ (idiv4)*2 + (jdiv4%2);
 2942|       |      
 2943|       |      
 2944|   875k|      if (!fs->frame->MbaffFrameFlag  || !fs->frame->mb_field[currentmb])    
 2945|   875k|      {
 2946|       |        
 2947|   875k|        fs->frame->field_frame[i][2*j+1] = fs->frame->field_frame[i][2*j]=0;
 2948|       |        
 2949|   875k|        if (!fs->frame->frame_mbs_only_flag)
 2950|      0|        {
 2951|      0|          fs->top_field->field_frame[i][j] = fs->bottom_field->field_frame[i][j] = 0;
 2952|       |          
 2953|      0|          fs->top_field->mv[LIST_0][i][j][0] = fs->bottom_field->mv[LIST_0][i][j][0] = fs->frame->mv[LIST_0][RSD(i)][2*RSD(j)][0];
 2954|      0|          fs->top_field->mv[LIST_0][i][j][1] = fs->bottom_field->mv[LIST_0][i][j][1] = fs->frame->mv[LIST_0][RSD(i)][2*RSD(j)][1];
 2955|      0|          fs->top_field->mv[LIST_1][i][j][0] = fs->bottom_field->mv[LIST_1][i][j][0] = fs->frame->mv[LIST_1][RSD(i)][2*RSD(j)][0];
 2956|      0|          fs->top_field->mv[LIST_1][i][j][1] = fs->bottom_field->mv[LIST_1][i][j][1] = fs->frame->mv[LIST_1][RSD(i)][2*RSD(j)][1];
 2957|       |          
 2958|       |          // Scaling of references is done here since it will not affect spatial direct (2*0 =0)
 2959|      0|          if (fs->frame->ref_idx[LIST_0][RSD(i)][2*RSD(j)] == -1)      
 2960|      0|            fs->top_field->ref_idx[LIST_0][i][j] = fs->bottom_field->ref_idx[LIST_0][i][j] = - 1;
 2961|      0|          else
 2962|      0|          {
 2963|      0|            dummylist0=fs->top_field->ref_idx[LIST_0][i][j] = fs->bottom_field->ref_idx[LIST_0][i][j] = fs->frame->ref_idx[LIST_0][RSD(i)][2*RSD(j)] ;
 2964|      0|            fs->top_field   ->ref_id[LIST_0][i][j] = (dummylist0>=0)? fs->frame->top_ref_pic_num[LIST_0][dummylist0] : 0;
 2965|      0|            fs->bottom_field->ref_id[LIST_0][i][j] = (dummylist0>=0)? fs->frame->bottom_ref_pic_num[LIST_0][dummylist0] : 0;
 2966|       |            
 2967|      0|          }
 2968|       |          
 2969|      0|          if (fs->frame->ref_idx[LIST_1][RSD(i)][2*RSD(j)] == -1)      
 2970|      0|            fs->top_field->ref_idx[LIST_1][i][j] = fs->bottom_field->ref_idx[LIST_1][i][j] = - 1;
 2971|      0|          else
 2972|      0|          {  
 2973|      0|            dummylist1=fs->top_field->ref_idx[LIST_1][i][j] = fs->bottom_field->ref_idx[LIST_1][i][j] = fs->frame->ref_idx[LIST_1][RSD(i)][2*RSD(j)];           
 2974|       |            
 2975|      0|            fs->top_field   ->ref_id[LIST_1][i][j] = (dummylist1>=0)? fs->frame->top_ref_pic_num[LIST_1][dummylist1] : 0;
 2976|      0|            fs->bottom_field->ref_id[LIST_1][i][j] = (dummylist1>=0)? fs->frame->bottom_ref_pic_num[LIST_1][dummylist1] : 0;
 2977|       |            
 2978|      0|          }
 2979|      0|        }
 2980|   875k|      }
 2981|   875k|    }
 2982|  21.8k|  }
 2983|       |  
 2984|  13.8k|  for (j=0 ; j<fs->frame->size_y/4 ; j++)      
 2985|  13.6k|  {                
 2986|  1.76M|    for (i=0 ; i<fs->frame->size_x/4 ; i++)          
 2987|  1.75M|    {                
 2988|  1.75M|      fs->frame->field_frame[i][j]=0;
 2989|  1.75M|    }      
 2990|  13.6k|  }
 2991|       |  
 2992|    171|  if (!active_sps->frame_mbs_only_flag || active_sps->direct_8x8_inference_flag)      
 2993|    171|  {
 2994|  13.8k|    for (j=0 ; j<fs->frame->size_y/4 ; j++)      
 2995|  13.6k|    {                
 2996|  1.76M|      for (i=0 ; i<fs->frame->size_x/4 ; i++)          
 2997|  1.75M|      {                
 2998|  1.75M|        int idiv4=i/4,jdiv4=j/4;
 2999|  1.75M|        int currentmb=2*(fs->frame->size_x/16)*(jdiv4/2)+ (idiv4)*2 + (jdiv4%2);
 3000|       |        
 3001|  1.75M|        fs->frame->field_frame[i][j]=fs->frame->MbaffFrameFlag ? fs->frame->mb_field[currentmb] : 0;        
 3002|  1.75M|      }
 3003|  13.6k|    }
 3004|    171|  }
 3005|    171|}
 3006|       |
 3007|       |
 3008|       |/*!
 3009|       | ************************************************************************
 3010|       | * \brief
 3011|       | *    Generate a frame from top and bottom fields
 3012|       | ************************************************************************
 3013|       | */
 3014|       |void dpb_combine_field(FrameStore *fs)
 3015|      0|{
 3016|      0|  int i,j;
 3017|      0|  int dummylist0, dummylist1;
 3018|       |
 3019|      0|  fs->frame = alloc_storable_picture(FRAME, fs->top_field->size_x, fs->top_field->size_y*2, fs->top_field->size_x_cr, fs->top_field->size_y_cr*2);
 3020|       |
 3021|      0|  for (i=0; i<fs->top_field->size_y; i++)
 3022|      0|  {
 3023|      0|    memcpy(fs->frame->imgY[i*2],     fs->top_field->imgY[i]   , fs->top_field->size_x*sizeof(imgpel));     // top field
 3024|      0|    memcpy(fs->frame->imgY[i*2 + 1], fs->bottom_field->imgY[i], fs->bottom_field->size_x*sizeof(imgpel)); // bottom field
 3025|      0|  }
 3026|       |
 3027|      0|  for (i=0; i<fs->top_field->size_y_cr; i++)
 3028|      0|  {
 3029|      0|    memcpy(fs->frame->imgUV[0][i*2],     fs->top_field->imgUV[0][i],    fs->top_field->size_x_cr*sizeof(imgpel));
 3030|      0|    memcpy(fs->frame->imgUV[0][i*2 + 1], fs->bottom_field->imgUV[0][i], fs->bottom_field->size_x_cr*sizeof(imgpel));
 3031|      0|    memcpy(fs->frame->imgUV[1][i*2],     fs->top_field->imgUV[1][i],    fs->top_field->size_x_cr*sizeof(imgpel));
 3032|      0|    memcpy(fs->frame->imgUV[1][i*2 + 1], fs->bottom_field->imgUV[1][i], fs->bottom_field->size_x_cr*sizeof(imgpel));
 3033|      0|  }
 3034|       |  
 3035|      0|  UnifiedOneForthPix(fs->frame);
 3036|       |  
 3037|      0|  fs->poc=fs->frame->poc =fs->frame->frame_poc = min (fs->top_field->poc, fs->bottom_field->poc);
 3038|       |
 3039|      0|  fs->bottom_field->frame_poc=fs->top_field->frame_poc=
 3040|      0|  fs->bottom_field->top_poc=fs->frame->frame_poc=fs->frame->top_poc=fs->top_field->poc;
 3041|      0|  fs->top_field->bottom_poc=fs->bottom_field->poc;
 3042|       |
 3043|      0|  fs->frame->bottom_poc=fs->bottom_field->poc;
 3044|       |
 3045|      0|  fs->frame->used_for_reference = (fs->top_field->used_for_reference && fs->bottom_field->used_for_reference );
 3046|      0|  fs->frame->is_long_term = (fs->top_field->is_long_term && fs->bottom_field->is_long_term );
 3047|       |
 3048|      0|  if (fs->frame->is_long_term) 
 3049|      0|    fs->frame->long_term_frame_idx = fs->long_term_frame_idx;
 3050|       |
 3051|      0|  fs->frame->top_field    = fs->top_field;
 3052|      0|  fs->frame->bottom_field = fs->bottom_field;
 3053|       |  
 3054|      0|  fs->frame->coded_frame = 0;
 3055|       |
 3056|      0|  fs->frame->chroma_format_idc = fs->top_field->chroma_format_idc;
 3057|      0|  fs->frame->frame_cropping_flag = fs->top_field->frame_cropping_flag;
 3058|      0|  if (fs->frame->frame_cropping_flag)
 3059|      0|  {
 3060|      0|    fs->frame->frame_cropping_rect_top_offset = fs->top_field->frame_cropping_rect_top_offset;
 3061|      0|    fs->frame->frame_cropping_rect_bottom_offset = fs->top_field->frame_cropping_rect_bottom_offset;
 3062|      0|    fs->frame->frame_cropping_rect_left_offset = fs->top_field->frame_cropping_rect_left_offset;
 3063|      0|    fs->frame->frame_cropping_rect_right_offset = fs->top_field->frame_cropping_rect_right_offset;
 3064|      0|  }
 3065|       |  
 3066|      0|  fs->top_field->frame = fs->bottom_field->frame = fs->frame;
 3067|       |
 3068|       |  //combine field for frame
 3069|      0|  for (i=0;i<(listXsize[LIST_1]+1)/2;i++)
 3070|      0|  {
 3071|      0|    fs->frame->ref_pic_num[LIST_1][i]=   min ((fs->top_field->ref_pic_num[LIST_1][2*i]/2)*2, (fs->bottom_field->ref_pic_num[LIST_1][2*i]/2)*2);
 3072|      0|  }
 3073|       |
 3074|      0|  for (i=0;i<(listXsize[LIST_0]+1)/2;i++)
 3075|      0|  {
 3076|      0|    fs->frame->ref_pic_num[LIST_0][i]=   min ((fs->top_field->ref_pic_num[LIST_0][2*i]/2)*2, (fs->bottom_field->ref_pic_num[LIST_0][2*i]/2)*2);
 3077|      0|  }
 3078|       |
 3079|       |   //! Use inference flag to remap mvs/references 
 3080|       |  
 3081|       |    //! Generate Frame parameters from field information.
 3082|      0|  for (i=0 ; i<fs->top_field->size_x/4 ; i++)
 3083|      0|  {
 3084|      0|  	for (j=0 ; j<fs->top_field->size_y/4 ; j++)
 3085|      0|    {
 3086|      0|      fs->frame->field_frame[i][8*(j/4) + (j%4)]= fs->frame->field_frame[i][8*(j/4) + (j%4) + 4]=1;
 3087|       |      
 3088|      0|        fs->frame->mv[LIST_0][i][8*(j/4) + (j%4)][0] = fs->top_field->mv[LIST_0][i][j][0];
 3089|      0|        fs->frame->mv[LIST_0][i][8*(j/4) + (j%4)][1] = fs->top_field->mv[LIST_0][i][j][1] ;
 3090|      0|        fs->frame->mv[LIST_1][i][8*(j/4) + (j%4)][0] = fs->top_field->mv[LIST_1][i][j][0];
 3091|      0|        fs->frame->mv[LIST_1][i][8*(j/4) + (j%4)][1] = fs->top_field->mv[LIST_1][i][j][1] ; 
 3092|       |        
 3093|      0|        dummylist0=fs->frame->ref_idx[LIST_0][i][8*(j/4) + (j%4)]  = fs->top_field->ref_idx[LIST_0][i][j];
 3094|      0|        dummylist1=fs->frame->ref_idx[LIST_1][i][8*(j/4) + (j%4)]  = fs->top_field->ref_idx[LIST_1][i][j];
 3095|       |         
 3096|       |        //! association with id already known for fields.
 3097|      0|        fs->top_field->ref_id[LIST_0][i][j] = (dummylist0>=0)? fs->top_field->ref_pic_num[LIST_0][dummylist0] : 0;
 3098|      0|        fs->top_field->ref_id[LIST_1][i][j] = (dummylist1>=0)? fs->top_field->ref_pic_num[LIST_1][dummylist1] : 0;          
 3099|       |        
 3100|       |        //! need to make association with frames
 3101|      0|        fs->frame->ref_id[LIST_0][i][8*(j/4) + (j%4)] = (dummylist0>=0)? fs->top_field->frm_ref_pic_num[LIST_0][dummylist0] : 0;
 3102|      0|        fs->frame->ref_id[LIST_1][i][8*(j/4) + (j%4)] = (dummylist1>=0)? fs->top_field->frm_ref_pic_num[LIST_1][dummylist1] : 0;          
 3103|       |        
 3104|      0|        fs->frame->mv[LIST_0][i][8*(j/4) + (j%4) + 4][0] = fs->bottom_field->mv[LIST_0][i][j][0];
 3105|      0|        fs->frame->mv[LIST_0][i][8*(j/4) + (j%4) + 4][1] = fs->bottom_field->mv[LIST_0][i][j][1] ;
 3106|      0|        fs->frame->mv[LIST_1][i][8*(j/4) + (j%4) + 4][0] = fs->bottom_field->mv[LIST_1][i][j][0];
 3107|      0|        fs->frame->mv[LIST_1][i][8*(j/4) + (j%4) + 4][1] = fs->bottom_field->mv[LIST_1][i][j][1] ; 
 3108|       |
 3109|      0|        dummylist0=fs->frame->ref_idx[LIST_0][i][8*(j/4) + (j%4) + 4]  = fs->bottom_field->ref_idx[LIST_0][i][j];
 3110|      0|        dummylist1=fs->frame->ref_idx[LIST_1][i][8*(j/4) + (j%4) + 4]  = fs->bottom_field->ref_idx[LIST_1][i][j];
 3111|       |
 3112|      0|        fs->bottom_field->ref_id[LIST_0][i][j] = (dummylist0>=0)? fs->bottom_field->ref_pic_num[LIST_0][dummylist0] : 0;
 3113|      0|        fs->bottom_field->ref_id[LIST_1][i][j] = (dummylist1>=0)? fs->bottom_field->ref_pic_num[LIST_1][dummylist1] : 0;          
 3114|       |        
 3115|       |        //! need to make association with frames
 3116|      0|      fs->frame->ref_id[LIST_0][i][8*(j/4) + (j%4) + 4] = (dummylist0>=0)? fs->bottom_field->frm_ref_pic_num[LIST_0][dummylist0] : -1;
 3117|      0|      fs->frame->ref_id[LIST_1][i][8*(j/4) + (j%4) + 4] = (dummylist1>=0)? fs->bottom_field->frm_ref_pic_num[LIST_1][dummylist1] : -1;          
 3118|       |
 3119|       |
 3120|      0|    }     
 3121|      0|  }  			
 3122|       |
 3123|      0|  if (!active_sps->frame_mbs_only_flag || active_sps->direct_8x8_inference_flag)      
 3124|      0|  {        
 3125|      0|    for (i=0 ; i<fs->top_field->size_x/4 ; i++)
 3126|      0|    {
 3127|      0|      for (j=0 ; j<fs->top_field->size_y/4 ; j++)
 3128|      0|      {        
 3129|      0|        fs->top_field->field_frame[i][j]=1;
 3130|      0|        fs->bottom_field->field_frame[i][j]=1;
 3131|      0|      }
 3132|      0|    }    
 3133|       |    
 3134|      0|  }
 3135|      0|}
 3136|       |
 3137|       |
 3138|       |/*!
 3139|       | ************************************************************************
 3140|       | * \brief
 3141|       | *    Allocate memory for buffering of reference picture reordering commands
 3142|       | ************************************************************************
 3143|       | */
 3144|       |void alloc_ref_pic_list_reordering_buffer(Slice *currSlice)
 3145|      0|{
 3146|      0|  int size = img->num_ref_idx_l0_active+1;
 3147|       |
 3148|      0|  if (img->type!=I_SLICE && img->type!=SI_SLICE)
 3149|      0|  {
 3150|      0|    if ((currSlice->remapping_of_pic_nums_idc_l0 = calloc(size,sizeof(int)))==NULL) no_mem_exit("alloc_ref_pic_list_reordering_buffer: remapping_of_pic_nums_idc_l0");
 3151|      0|    if ((currSlice->abs_diff_pic_num_minus1_l0 = calloc(size,sizeof(int)))==NULL) no_mem_exit("alloc_ref_pic_list_reordering_buffer: abs_diff_pic_num_minus1_l0");
 3152|      0|    if ((currSlice->long_term_pic_idx_l0 = calloc(size,sizeof(int)))==NULL) no_mem_exit("alloc_ref_pic_list_reordering_buffer: long_term_pic_idx_l0");
 3153|      0|  }
 3154|      0|  else
 3155|      0|  {
 3156|      0|    currSlice->remapping_of_pic_nums_idc_l0 = NULL;
 3157|      0|    currSlice->abs_diff_pic_num_minus1_l0 = NULL;
 3158|      0|    currSlice->long_term_pic_idx_l0 = NULL;
 3159|      0|  }
 3160|       |  
 3161|      0|  size = img->num_ref_idx_l1_active+1;
 3162|       |
 3163|      0|  if (img->type==B_SLICE)
 3164|      0|  {
 3165|      0|    if ((currSlice->remapping_of_pic_nums_idc_l1 = calloc(size,sizeof(int)))==NULL) no_mem_exit("alloc_ref_pic_list_reordering_buffer: remapping_of_pic_nums_idc_l1");
 3166|      0|    if ((currSlice->abs_diff_pic_num_minus1_l1 = calloc(size,sizeof(int)))==NULL) no_mem_exit("alloc_ref_pic_list_reordering_buffer: abs_diff_pic_num_minus1_l1");
 3167|      0|    if ((currSlice->long_term_pic_idx_l1 = calloc(size,sizeof(int)))==NULL) no_mem_exit("alloc_ref_pic_list_reordering_buffer: long_term_pic_idx_l1");
 3168|      0|  }
 3169|      0|  else
 3170|      0|  {
 3171|      0|    currSlice->remapping_of_pic_nums_idc_l1 = NULL;
 3172|      0|    currSlice->abs_diff_pic_num_minus1_l1 = NULL;
 3173|      0|    currSlice->long_term_pic_idx_l1 = NULL;
 3174|      0|  }
 3175|      0|}
 3176|       |
 3177|       |
 3178|       |/*!
 3179|       | ************************************************************************
 3180|       | * \brief
 3181|       | *    Free memory for buffering of reference picture reordering commands
 3182|       | ************************************************************************
 3183|       | */
 3184|       |void free_ref_pic_list_reordering_buffer(Slice *currSlice)
 3185|      0|{
 3186|       |
 3187|      0|  if (currSlice->remapping_of_pic_nums_idc_l0) 
 3188|      0|    free(currSlice->remapping_of_pic_nums_idc_l0);
 3189|      0|  if (currSlice->abs_diff_pic_num_minus1_l0)
 3190|      0|    free(currSlice->abs_diff_pic_num_minus1_l0);
 3191|      0|  if (currSlice->long_term_pic_idx_l0)
 3192|      0|    free(currSlice->long_term_pic_idx_l0);
 3193|       |
 3194|      0|  currSlice->remapping_of_pic_nums_idc_l0 = NULL;
 3195|      0|  currSlice->abs_diff_pic_num_minus1_l0 = NULL;
 3196|      0|  currSlice->long_term_pic_idx_l0 = NULL;
 3197|       |  
 3198|      0|  if (currSlice->remapping_of_pic_nums_idc_l1)
 3199|      0|    free(currSlice->remapping_of_pic_nums_idc_l1);
 3200|      0|  if (currSlice->abs_diff_pic_num_minus1_l1)
 3201|      0|    free(currSlice->abs_diff_pic_num_minus1_l1);
 3202|      0|  if (currSlice->long_term_pic_idx_l1)
 3203|      0|    free(currSlice->long_term_pic_idx_l1);
 3204|       |  
 3205|      0|  currSlice->remapping_of_pic_nums_idc_l1 = NULL;
 3206|      0|  currSlice->abs_diff_pic_num_minus1_l1 = NULL;
 3207|      0|  currSlice->long_term_pic_idx_l1 = NULL;
 3208|      0|}
 3209|       |
 3210|       |/*!
 3211|       | ************************************************************************
 3212|       | * \brief
 3213|       | *      Tian Dong
 3214|       | *          June 13, 2002, Modifed on July 30, 2003
 3215|       | *
 3216|       | *      If a gap in frame_num is found, try to fill the gap
 3217|       | * \param img
 3218|       | *      
 3219|       | ************************************************************************
 3220|       | */
 3221|       |void fill_frame_num_gap(ImageParameters *img)
 3222|      0|{
 3223|      0|  int CurrFrameNum;
 3224|      0|  int UnusedShortTermFrameNum;
 3225|      0|  StorablePicture *picture = NULL;
 3226|      0|  int nal_ref_idc_bak;
 3227|      0|  int MaxFrameNum = 1 << (log2_max_frame_num_minus4 + 4);
 3228|       |
 3229|       |//  printf("A gap in frame number is found, try to fill it.\n");
 3230|       |
 3231|      0|  nal_ref_idc_bak = img->nal_reference_idc;
 3232|      0|  img->nal_reference_idc = 1;
 3233|       |
 3234|      0|  UnusedShortTermFrameNum = (img->pre_frame_num + 1) % MaxFrameNum;
 3235|      0|  CurrFrameNum = img->frame_num;
 3236|       |
 3237|      0|  while (CurrFrameNum != UnusedShortTermFrameNum)
 3238|      0|  {
 3239|      0|    picture = alloc_storable_picture (FRAME, img->width, img->height, img->width_cr, img->height_cr);
 3240|      0|    picture->coded_frame = 1;
 3241|      0|    picture->pic_num = UnusedShortTermFrameNum;
 3242|      0|    picture->non_existing = 1;
 3243|      0|    picture->is_output = 1;
 3244|       |    
 3245|      0|    img->adaptive_ref_pic_buffering_flag = 0;
 3246|       |
 3247|      0|    store_picture_in_dpb(picture);
 3248|       |
 3249|      0|    picture=NULL;
 3250|      0|    UnusedShortTermFrameNum = (UnusedShortTermFrameNum + 1) % MaxFrameNum;
 3251|      0|  }
 3252|       |
 3253|      0|  img->nal_reference_idc = nal_ref_idc_bak;
 3254|      0|}
 3255|       |
 3256|       |/*!
 3257|       | ************************************************************************
 3258|       | * \brief
 3259|       | *    Allocate co-located memory 
 3260|       | *
 3261|       | * \param size_x
 3262|       | *    horizontal luma size
 3263|       | * \param size_y
 3264|       | *    vertical luma size
 3265|       | * \param mb_adaptive_frame_field_flag
 3266|       | *    flag that indicates macroblock adaptive frame/field coding
 3267|       | *
 3268|       | * \return
 3269|       | *    the allocated StorablePicture structure
 3270|       | ************************************************************************
 3271|       | */
 3272|       |ColocatedParams* alloc_colocated(int size_x, int size_y, int mb_adaptive_frame_field_flag)
 3273|      1|{
 3274|      1|  ColocatedParams *s;
 3275|       |
 3276|      1|  s = calloc(1, sizeof(ColocatedParams)); 
 3277|      1|  if (NULL == s)
 3278|      0|    no_mem_exit("alloc_colocated: s");
 3279|       |
 3280|      1|  s->size_x = size_x;
 3281|      1|  s->size_y = size_y;
 3282|       |
 3283|       |
 3284|      1|  get_mem3Dshort (&(s->ref_idx), 2, size_x / BLOCK_SIZE, size_y / BLOCK_SIZE);
 3285|      1|  get_mem3Dint64 (&(s->ref_pic_id), 2, size_x / BLOCK_SIZE, size_y / BLOCK_SIZE);
 3286|      1|  get_mem4Dshort (&(s->mv), 2, size_x / BLOCK_SIZE, size_y / BLOCK_SIZE,2 );
 3287|       |
 3288|      1|  get_mem2D (&(s->moving_block), size_x / BLOCK_SIZE, size_y / BLOCK_SIZE);
 3289|      1|  get_mem2D (&(s->field_frame), size_x / BLOCK_SIZE, size_y / BLOCK_SIZE);
 3290|       |
 3291|      1|  if (mb_adaptive_frame_field_flag)
 3292|      0|  {
 3293|      0|    get_mem3Dshort (&(s->top_ref_idx), 2, size_x / BLOCK_SIZE, size_y / BLOCK_SIZE/2);
 3294|      0|    get_mem3Dint64 (&(s->top_ref_pic_id), 2, size_x / BLOCK_SIZE, size_y / BLOCK_SIZE/2);
 3295|      0|    get_mem4Dshort (&(s->top_mv), 2, size_x / BLOCK_SIZE, size_y / BLOCK_SIZE/2,2 );
 3296|      0|    get_mem2D (&(s->top_moving_block), size_x / BLOCK_SIZE, size_y / BLOCK_SIZE/2);
 3297|       |    
 3298|      0|    get_mem3Dshort (&(s->bottom_ref_idx), 2, size_x / BLOCK_SIZE, size_y / BLOCK_SIZE/2);
 3299|      0|    get_mem3Dint64 (&(s->bottom_ref_pic_id), 2, size_x / BLOCK_SIZE, size_y / BLOCK_SIZE/2);
 3300|      0|    get_mem4Dshort (&(s->bottom_mv), 2, size_x / BLOCK_SIZE, size_y / BLOCK_SIZE/2,2 );
 3301|      0|    get_mem2D (&(s->bottom_moving_block), size_x / BLOCK_SIZE, size_y / BLOCK_SIZE/2);
 3302|      0|  }
 3303|       |
 3304|       |  //s->mb_field = calloc (img->PicSizeInMbs, sizeof(int));
 3305|       |
 3306|      1|  s->mb_adaptive_frame_field_flag  = mb_adaptive_frame_field_flag;
 3307|       |
 3308|      1|  return s;
 3309|      1|}
 3310|       |
 3311|       |/*!
 3312|       | ************************************************************************
 3313|       | * \brief
 3314|       | *    Free co-located memory.
 3315|       | *
 3316|       | * \param p
 3317|       | *    Picture to be freed
 3318|       | *
 3319|       | ************************************************************************
 3320|       | */
 3321|       |void free_colocated(ColocatedParams* p)
 3322|      1|{
 3323|      1|  if (p)
 3324|      1|  {
 3325|      1|    free_mem3Dshort (p->ref_idx, 2);
 3326|      1|    free_mem3Dint64 (p->ref_pic_id, 2);
 3327|      1|    free_mem4Dshort (p->mv, 2, p->size_x / BLOCK_SIZE);
 3328|       |
 3329|      1|    if (p->moving_block)
 3330|      1|    {
 3331|      1|      free_mem2D (p->moving_block);
 3332|      1|      p->moving_block=NULL;
 3333|      1|    }
 3334|      1|    if (p->field_frame)
 3335|      1|    {
 3336|      1|      free_mem2D (p->field_frame);
 3337|      1|      p->field_frame=NULL;
 3338|      1|    }
 3339|       |
 3340|       |    
 3341|      1|    if (p->mb_adaptive_frame_field_flag)
 3342|      0|    {
 3343|      0|      free_mem3Dshort (p->top_ref_idx, 2);
 3344|      0|      free_mem3Dint64 (p->top_ref_pic_id, 2);
 3345|      0|      free_mem4Dshort (p->top_mv, 2, p->size_x / BLOCK_SIZE);
 3346|       |      
 3347|       |      
 3348|      0|      if (p->top_moving_block)
 3349|      0|      {
 3350|      0|        free_mem2D (p->top_moving_block);
 3351|      0|        p->top_moving_block=NULL;
 3352|      0|      }
 3353|       |      
 3354|      0|      free_mem3Dshort (p->bottom_ref_idx, 2);
 3355|      0|      free_mem3Dint64 (p->bottom_ref_pic_id, 2);
 3356|      0|      free_mem4Dshort (p->bottom_mv, 2, p->size_x / BLOCK_SIZE);
 3357|       |      
 3358|       |      
 3359|      0|      if (p->bottom_moving_block)
 3360|      0|      {
 3361|      0|        free_mem2D (p->bottom_moving_block);
 3362|      0|        p->bottom_moving_block=NULL;
 3363|      0|      }    
 3364|       |      
 3365|      0|    }
 3366|       |
 3367|      1|    free(p);
 3368|       |
 3369|      1|    p=NULL;
 3370|      1|  }
 3371|      1|}
 3372|       |
 3373|       |/*!
 3374|       | ************************************************************************
 3375|       | * \brief
 3376|       | *    Compute co-located motion info
 3377|       | *
 3378|       | ************************************************************************
 3379|       | */
 3380|       |
 3381|       |void compute_colocated(ColocatedParams* p, StorablePicture **listX[6])
 3382|     85|{
 3383|     85|  StorablePicture *fs, *fs_top, *fs_bottom;
 3384|     85|  int i,j;
 3385|       |
 3386|     85|  fs_top=fs_bottom=fs = listX[LIST_1 ][0];
 3387|       |
 3388|     85|  if (img->MbaffFrameFlag)
 3389|      0|  {
 3390|      0|    fs_top= listX[LIST_1 + 2][0];
 3391|      0|    fs_bottom= listX[LIST_1 + 4][0];
 3392|      0|  }
 3393|     85|  else
 3394|     85|  {
 3395|     85|    if (img->structure!=FRAME)
 3396|      0|    {
 3397|      0|      if ((img->structure != fs->structure) && (fs->coded_frame))
 3398|      0|      {
 3399|      0|        if (img->structure==TOP_FIELD)
 3400|      0|        {
 3401|      0|          fs_top=fs_bottom=fs = listX[LIST_1 ][0]->top_field;
 3402|      0|        }
 3403|      0|        else
 3404|      0|        {
 3405|      0|          fs_top=fs_bottom=fs = listX[LIST_1 ][0]->bottom_field;
 3406|      0|        }
 3407|      0|      }
 3408|      0|    }
 3409|     85|  }
 3410|       |  
 3411|     85|  if (!active_sps->frame_mbs_only_flag || active_sps->direct_8x8_inference_flag)      
 3412|     85|  { 
 3413|  6.88k|    for (j=0 ; j<fs->size_y/4 ; j++)      
 3414|  6.80k|    {                
 3415|   877k|      for (i=0 ; i<fs->size_x/4 ; i++)          
 3416|   870k|      {                
 3417|       |
 3418|   870k|        if (img->MbaffFrameFlag && fs->field_frame[i][j])
 3419|      0|        { 
 3420|       |          //! Assign frame buffers for field MBs   
 3421|       |          //! Check whether we should use top or bottom field mvs.
 3422|       |          //! Depending on the assigned poc values.
 3423|       |          
 3424|      0|          if (abs(enc_picture->poc - fs_bottom->poc) > abs(enc_picture->poc - fs_top->poc) )
 3425|      0|          {
 3426|      0|            p->mv[LIST_0][i][j][0]    = fs_top->mv[LIST_0][i][j/2][0];
 3427|      0|            p->mv[LIST_0][i][j][1]    = fs_top->mv[LIST_0][i][j/2][1] ;          
 3428|      0|            p->mv[LIST_1][i][j][0]    = fs_top->mv[LIST_1][i][j/2][0];
 3429|      0|            p->mv[LIST_1][i][j][1]    = fs_top->mv[LIST_1][i][j/2][1] ;           
 3430|      0|            p->ref_idx[LIST_0][i][j]  = fs_top->ref_idx[LIST_0][i][j/2];         
 3431|      0|            p->ref_idx[LIST_1][i][j]  = fs_top->ref_idx[LIST_1][i][j/2];  
 3432|      0|            p->ref_pic_id[LIST_0][i][j]   = fs->ref_id[LIST_0][i][j/2 + 4*(j/8)];                     
 3433|      0|            p->ref_pic_id[LIST_1][i][j]   = fs->ref_id[LIST_1][i][j/2 + 4*(j/8)];                     
 3434|       |            
 3435|      0|            p->is_long_term             = fs_top->is_long_term;
 3436|      0|          }
 3437|      0|          else
 3438|      0|          {
 3439|      0|            p->mv[LIST_0][i][j][0]      = fs_bottom->mv[LIST_0][i][j/2][0];
 3440|      0|            p->mv[LIST_0][i][j][1]      = fs_bottom->mv[LIST_0][i][j/2][1] ;          
 3441|      0|            p->mv[LIST_1][i][j][0]      = fs_bottom->mv[LIST_1][i][j/2][0];
 3442|      0|            p->mv[LIST_1][i][j][1]      = fs_bottom->mv[LIST_1][i][j/2][1] ;           
 3443|      0|            p->ref_idx[LIST_0][i][j]    = fs_bottom->ref_idx[LIST_0][i][j/2];         
 3444|      0|            p->ref_idx[LIST_1][i][j]    = fs_bottom->ref_idx[LIST_1][i][j/2];         
 3445|      0|            p->ref_pic_id[LIST_0][i][j] = fs->ref_id[LIST_0][i][j/2 + 4*(j/8)+4];                     
 3446|      0|            p->ref_pic_id[LIST_1][i][j] = fs->ref_id[LIST_1][i][j/2 + 4*(j/8)+4];                     
 3447|       |            
 3448|      0|            p->is_long_term             = fs_bottom->is_long_term;
 3449|      0|          }          
 3450|      0|        }
 3451|   870k|        else
 3452|   870k|        {
 3453|   870k|            p->mv[LIST_0][i][j][0]      = fs->mv[LIST_0][i][j][0];
 3454|   870k|            p->mv[LIST_0][i][j][1]      = fs->mv[LIST_0][i][j][1] ;          
 3455|   870k|            p->mv[LIST_1][i][j][0]      = fs->mv[LIST_1][i][j][0];
 3456|   870k|            p->mv[LIST_1][i][j][1]      = fs->mv[LIST_1][i][j][1] ;           
 3457|   870k|            p->ref_idx[LIST_0][i][j]    = fs->ref_idx[LIST_0][i][j];         
 3458|   870k|            p->ref_idx[LIST_1][i][j]    = fs->ref_idx[LIST_1][i][j];                   
 3459|   870k|            p->ref_pic_id[LIST_0][i][j] = fs->ref_id[LIST_0][i][j];                     
 3460|   870k|            p->ref_pic_id[LIST_1][i][j] = fs->ref_id[LIST_1][i][j];     
 3461|       |
 3462|   870k|            p->is_long_term             = fs->is_long_term;
 3463|   870k|        }
 3464|   870k|      }      
 3465|  6.80k|    }
 3466|     85|  }    
 3467|       |        
 3468|       |
 3469|       |  //! Generate field MVs from Frame MVs
 3470|       |
 3471|     85|  if (img->structure || img->MbaffFrameFlag)
 3472|      0|  {    
 3473|      0|    for (i=0 ; i<fs->size_x/4 ; i++)
 3474|      0|    {
 3475|      0|      for (j=0 ; j<fs->size_y/8 ; j++)
 3476|      0|      {       
 3477|       |        
 3478|       |        //! Do nothing if macroblock as field coded in MB-AFF        
 3479|      0|        if (!img->MbaffFrameFlag )
 3480|      0|        {
 3481|      0|          p->mv[LIST_0][i][j][0] = fs->mv[LIST_0][RSD(i)][RSD(j)][0];
 3482|      0|          p->mv[LIST_0][i][j][1] = fs->mv[LIST_0][RSD(i)][RSD(j)][1];
 3483|      0|          p->mv[LIST_1][i][j][0] = fs->mv[LIST_1][RSD(i)][RSD(j)][0];
 3484|      0|          p->mv[LIST_1][i][j][1] = fs->mv[LIST_1][RSD(i)][RSD(j)][1];
 3485|       |          
 3486|       |          // Scaling of references is done here since it will not affect spatial direct (2*0 =0)
 3487|       |
 3488|      0|          if (fs->ref_idx[LIST_0][RSD(i)][RSD(j)] == -1)      
 3489|      0|          {
 3490|      0|            p->ref_idx[LIST_0][i][j] = - 1;
 3491|      0|            p->ref_pic_id[LIST_0][i][j] = -1;
 3492|      0|          }
 3493|      0|          else
 3494|      0|          {
 3495|      0|            p->ref_idx[LIST_0][i][j] =  fs->ref_idx[LIST_0][RSD(i)][RSD(j)] ;
 3496|       |            //! Need to consider interlace structure here
 3497|      0|            p->ref_pic_id[LIST_0][i][j] = fs->ref_id[LIST_0][RSD(i)][RSD(j)] ;
 3498|      0|          }
 3499|       |          
 3500|      0|          if (fs->ref_idx[LIST_1][RSD(i)][RSD(j)] == -1)      
 3501|      0|          {
 3502|      0|            p->ref_idx[LIST_1][i][j] = - 1;
 3503|      0|            p->ref_pic_id[LIST_1][i][j] = -1;
 3504|      0|          }
 3505|      0|          else
 3506|      0|          {
 3507|      0|            p->ref_idx[LIST_1][i][j] =  fs->ref_idx[LIST_1][RSD(i)][RSD(j)];
 3508|      0|            p->ref_pic_id[LIST_1][i][j] = fs->ref_id[LIST_1][RSD(i)][RSD(j)] ;
 3509|      0|          }
 3510|       |          
 3511|      0|          p->is_long_term             = fs->is_long_term;
 3512|       |
 3513|      0|          if (img->direct_spatial_mv_pred_flag == 1)
 3514|      0|          {
 3515|      0|            p->moving_block[i][j] = 
 3516|      0|              !((!p->is_long_term &&((p->ref_idx[LIST_0][i][j] == 0) && 
 3517|      0|              (abs(p->mv[LIST_0][i][j][0])>>1 == 0) && 
 3518|      0|              (abs(p->mv[LIST_0][i][j][1])>>1 == 0))) || 
 3519|      0|              ((p->ref_idx[LIST_0][i][j] == -1) && 
 3520|      0|              (p->ref_idx[LIST_1][i][j] == 0) && 
 3521|      0|              (abs(p->mv[LIST_1][i][j][0])>>1 == 0) && 
 3522|      0|              (abs(p->mv[LIST_1][i][j][1])>>1 == 0)));
 3523|      0|          }
 3524|      0|        }
 3525|      0|        else
 3526|      0|        {
 3527|      0|          p->bottom_mv[LIST_0][i][j][0] = fs_bottom->mv[LIST_0][RSD(i)][RSD(j)][0];
 3528|      0|          p->bottom_mv[LIST_0][i][j][1] = fs_bottom->mv[LIST_0][RSD(i)][RSD(j)][1];
 3529|      0|          p->bottom_mv[LIST_1][i][j][0] = fs_bottom->mv[LIST_1][RSD(i)][RSD(j)][0];
 3530|      0|          p->bottom_mv[LIST_1][i][j][1] = fs_bottom->mv[LIST_1][RSD(i)][RSD(j)][1];
 3531|      0|          p->bottom_ref_idx[LIST_0][i][j] = fs_bottom->ref_idx[LIST_0][RSD(i)][RSD(j)]; 
 3532|      0|          p->bottom_ref_idx[LIST_1][i][j] = fs_bottom->ref_idx[LIST_1][RSD(i)][RSD(j)]; 
 3533|      0|          p->bottom_ref_pic_id[LIST_0][i][j] = fs_bottom->ref_id[LIST_0][RSD(i)][RSD(j)]; 
 3534|      0|          p->bottom_ref_pic_id[LIST_1][i][j] = fs_bottom->ref_id[LIST_1][RSD(i)][RSD(j)]; 
 3535|       |
 3536|      0|          if (img->direct_spatial_mv_pred_flag == 1)
 3537|      0|          {
 3538|      0|            p->bottom_moving_block[i][j] = 
 3539|      0|              !((!fs_bottom->is_long_term && ((p->bottom_ref_idx[LIST_0][i][j] == 0) && 
 3540|      0|              (abs(p->bottom_mv[LIST_0][i][j][0])>>1 == 0) && 
 3541|      0|              (abs(p->bottom_mv[LIST_0][i][j][1])>>1 == 0))) || 
 3542|      0|              ((p->bottom_ref_idx[LIST_0][i][j] == -1) && 
 3543|      0|              (p->bottom_ref_idx[LIST_1][i][j] == 0) && 
 3544|      0|              (abs(p->bottom_mv[LIST_1][i][j][0])>>1 == 0) && 
 3545|      0|              (abs(p->bottom_mv[LIST_1][i][j][1])>>1 == 0)));
 3546|      0|          }
 3547|       |
 3548|      0|          p->top_mv[LIST_0][i][j][0] = fs_top->mv[LIST_0][RSD(i)][RSD(j)][0];
 3549|      0|          p->top_mv[LIST_0][i][j][1] = fs_top->mv[LIST_0][RSD(i)][RSD(j)][1];
 3550|      0|          p->top_mv[LIST_1][i][j][0] = fs_top->mv[LIST_1][RSD(i)][RSD(j)][0];
 3551|      0|          p->top_mv[LIST_1][i][j][1] = fs_top->mv[LIST_1][RSD(i)][RSD(j)][1];
 3552|      0|          p->top_ref_idx[LIST_0][i][j] = fs_top->ref_idx[LIST_0][RSD(i)][RSD(j)]; 
 3553|      0|          p->top_ref_idx[LIST_1][i][j] = fs_top->ref_idx[LIST_1][RSD(i)][RSD(j)]; 
 3554|      0|          p->top_ref_pic_id[LIST_0][i][j] = fs_top->ref_id[LIST_0][RSD(i)][RSD(j)]; 
 3555|      0|          p->top_ref_pic_id[LIST_1][i][j] = fs_top->ref_id[LIST_1][RSD(i)][RSD(j)]; 
 3556|       |
 3557|      0|          if (img->direct_spatial_mv_pred_flag == 1)
 3558|      0|          {
 3559|      0|            p->top_moving_block[i][j] = 
 3560|      0|              !((!fs_top->is_long_term && ((p->top_ref_idx[LIST_0][i][j] == 0) && 
 3561|      0|              (abs(p->top_mv[LIST_0][i][j][0])>>1 == 0) && 
 3562|      0|              (abs(p->top_mv[LIST_0][i][j][1])>>1 == 0))) || 
 3563|      0|              ((p->top_ref_idx[LIST_0][i][j] == -1) && 
 3564|      0|              (p->top_ref_idx[LIST_1][i][j] == 0) && 
 3565|      0|              (abs(p->top_mv[LIST_1][i][j][0])>>1 == 0) && 
 3566|      0|              (abs(p->top_mv[LIST_1][i][j][1])>>1 == 0)));
 3567|      0|          }
 3568|       |
 3569|      0|          if ((img->direct_spatial_mv_pred_flag == 0 ) && !fs->field_frame[i][2*j])
 3570|      0|          {
 3571|      0|            p->top_mv[LIST_0][i][j][1] /= 2;        
 3572|      0|            p->top_mv[LIST_1][i][j][1] /= 2;
 3573|      0|            p->bottom_mv[LIST_0][i][j][1] /= 2;        
 3574|      0|            p->bottom_mv[LIST_1][i][j][1] /= 2;
 3575|      0|          }
 3576|       |
 3577|      0|        }
 3578|      0|      }
 3579|      0|    }
 3580|      0|  }
 3581|       |
 3582|       |  
 3583|     85|  if (!active_sps->frame_mbs_only_flag || active_sps->direct_8x8_inference_flag)      
 3584|     85|  {       
 3585|       |    //! Use inference flag to remap mvs/references
 3586|       |    //! Frame with field co-located
 3587|       |    
 3588|     85|    if (!img->structure)
 3589|     85|    {
 3590|  6.88k|      for (j=0 ; j<fs->size_y/4 ; j++)      
 3591|  6.80k|      {                
 3592|   877k|        for (i=0 ; i<fs->size_x/4 ; i++)          
 3593|   870k|        {                
 3594|       |          
 3595|   870k|          if (fs->field_frame[i][j])
 3596|      0|          {
 3597|      0|            if (abs(enc_picture->poc - fs->bottom_field->poc) > abs(enc_picture->poc - fs->top_field->poc))
 3598|      0|            {
 3599|      0|              p->mv[LIST_0][i][j][0] = fs->top_field->mv[LIST_0][i][j/2][0];
 3600|      0|              p->mv[LIST_0][i][j][1] = fs->top_field->mv[LIST_0][i][j/2][1] ;
 3601|      0|              p->mv[LIST_1][i][j][0] = fs->top_field->mv[LIST_1][i][j/2][0];
 3602|      0|              p->mv[LIST_1][i][j][1] = fs->top_field->mv[LIST_1][i][j/2][1] ; 
 3603|       |              
 3604|      0|              p->ref_idx[LIST_0][i][j]  = fs->top_field->ref_idx[LIST_0][i][j/2];
 3605|      0|              p->ref_idx[LIST_1][i][j]  = fs->top_field->ref_idx[LIST_1][i][j/2];
 3606|      0|              p->ref_pic_id[LIST_0][i][j]   = fs->ref_id[LIST_0][i][j/2 + 4*(j/8)];                     
 3607|      0|              p->ref_pic_id[LIST_1][i][j]   = fs->ref_id[LIST_1][i][j/2 + 4*(j/8)];                     
 3608|      0|              p->is_long_term               = fs->top_field->is_long_term;
 3609|      0|            }
 3610|      0|            else
 3611|      0|            {
 3612|      0|              p->mv[LIST_0][i][j][0] = fs->bottom_field->mv[LIST_0][i][j/2][0];
 3613|      0|              p->mv[LIST_0][i][j][1] = fs->bottom_field->mv[LIST_0][i][j/2][1] ;
 3614|      0|              p->mv[LIST_1][i][j][0] = fs->bottom_field->mv[LIST_1][i][j/2][0];
 3615|      0|              p->mv[LIST_1][i][j][1] = fs->bottom_field->mv[LIST_1][i][j/2][1] ; 
 3616|       |              
 3617|      0|              p->ref_idx[LIST_0][i][j]  = fs->bottom_field->ref_idx[LIST_0][i][j/2];
 3618|      0|              p->ref_idx[LIST_1][i][j]  = fs->bottom_field->ref_idx[LIST_1][i][j/2];
 3619|      0|              p->ref_pic_id[LIST_0][i][j] = fs->ref_id[LIST_0][i][j/2 + 4*(j/8)+4];                     
 3620|      0|              p->ref_pic_id[LIST_1][i][j] = fs->ref_id[LIST_1][i][j/2 + 4*(j/8)+4];                     
 3621|      0|              p->is_long_term             = fs->bottom_field->is_long_term;
 3622|      0|            }
 3623|      0|          }
 3624|   870k|        }
 3625|  6.80k|      }      
 3626|     85|    }      
 3627|     85|  }
 3628|       |
 3629|  6.88k|  for (j=0 ; j<fs->size_y/4 ; j++)      
 3630|  6.80k|  {                
 3631|   877k|    for (i=0 ; i<fs->size_x/4 ; i++)          
 3632|   870k|    {                
 3633|   870k|      if (!active_sps->frame_mbs_only_flag || active_sps->direct_8x8_inference_flag)      
 3634|   870k|      {       
 3635|       |
 3636|   870k|        p->mv[LIST_0][i][j][0]=p->mv[LIST_0][RSD(i)][RSD(j)][0];
 3637|   870k|        p->mv[LIST_0][i][j][1]=p->mv[LIST_0][RSD(i)][RSD(j)][1];
 3638|   870k|        p->mv[LIST_1][i][j][0]=p->mv[LIST_1][RSD(i)][RSD(j)][0];
 3639|   870k|        p->mv[LIST_1][i][j][1]=p->mv[LIST_1][RSD(i)][RSD(j)][1];        
 3640|       |        
 3641|   870k|        p->ref_idx[LIST_0][i][j]=p->ref_idx[LIST_0][RSD(i)][RSD(j)] ;     
 3642|   870k|        p->ref_idx[LIST_1][i][j]=p->ref_idx[LIST_1][RSD(i)][RSD(j)] ;     
 3643|   870k|        p->ref_pic_id[LIST_0][i][j] = p->ref_pic_id[LIST_0][RSD(i)][RSD(j)];
 3644|   870k|        p->ref_pic_id[LIST_1][i][j] = p->ref_pic_id[LIST_1][RSD(i)][RSD(j)];
 3645|   870k|      }
 3646|      0|      else
 3647|      0|      {
 3648|       |        //! Use inference flag to remap mvs/references
 3649|      0|        p->mv[LIST_0][i][j][0]=fs->mv[LIST_0][i][j][0];
 3650|      0|        p->mv[LIST_0][i][j][1]=fs->mv[LIST_0][i][j][1];
 3651|      0|        p->mv[LIST_1][i][j][0]=fs->mv[LIST_1][i][j][0];
 3652|      0|        p->mv[LIST_1][i][j][1]=fs->mv[LIST_1][i][j][1];        
 3653|       |        
 3654|      0|        p->ref_idx[LIST_0][i][j]=fs->ref_idx[LIST_0][i][j] ;     
 3655|      0|        p->ref_idx[LIST_1][i][j]=fs->ref_idx[LIST_1][i][j] ;         
 3656|      0|        p->ref_pic_id[LIST_0][i][j] = fs->ref_id[LIST_0][i][j];                     
 3657|      0|        p->ref_pic_id[LIST_1][i][j] = fs->ref_id[LIST_1][i][j];     
 3658|       |
 3659|      0|      }
 3660|   870k|      p->is_long_term             = fs->is_long_term;
 3661|       |
 3662|   870k|      if (img->direct_spatial_mv_pred_flag == 1)
 3663|   870k|      {
 3664|   870k|        p->moving_block[i][j]= 
 3665|   870k|          !((!p->is_long_term && ((p->ref_idx[LIST_0][i][j] == 0) && 
 3666|   870k|          (abs(p->mv[LIST_0][i][j][0])>>1 == 0) && 
 3667|   870k|          (abs(p->mv[LIST_0][i][j][1])>>1 == 0))) || 
 3668|   870k|          ((p->ref_idx[LIST_0][i][j] == -1) && 
 3669|   836k|          (p->ref_idx[LIST_1][i][j] == 0) && 
 3670|   836k|          (abs(p->mv[LIST_1][i][j][0])>>1 == 0) && 
 3671|   836k|          (abs(p->mv[LIST_1][i][j][1])>>1 == 0)));
 3672|   870k|      }
 3673|   870k|    }      
 3674|  6.80k|  }
 3675|       |
 3676|       |
 3677|     85|  if (img->direct_spatial_mv_pred_flag ==0)
 3678|      0|  {
 3679|      0|    for (j=0 ; j<fs->size_y/4 ; j++)      
 3680|      0|    {                
 3681|      0|      for (i=0 ; i<fs->size_x/4 ; i++)          
 3682|      0|      {                
 3683|       |        
 3684|      0|        if ((!img->MbaffFrameFlag &&!img->structure && fs->field_frame[i][j]) || (img->MbaffFrameFlag && fs->field_frame[i][j]))
 3685|      0|        {
 3686|      0|          p->mv[LIST_0][i][j][1] *= 2;        
 3687|      0|          p->mv[LIST_1][i][j][1] *= 2;
 3688|      0|        }
 3689|      0|        else  if (img->structure && !fs->field_frame[i][j])
 3690|      0|        {
 3691|      0|          p->mv[LIST_0][i][j][1] /= 2;
 3692|      0|          p->mv[LIST_1][i][j][1] /= 2;
 3693|      0|        }
 3694|       |        
 3695|      0|      }      
 3696|      0|    }
 3697|       |  
 3698|      0|    for (j=0; j<2 + (img->MbaffFrameFlag * 4);j+=2)
 3699|      0|    {
 3700|      0|      for (i=0; i<listXsize[j];i++)
 3701|      0|      {
 3702|      0|        int prescale, iTRb, iTRp;
 3703|       |        
 3704|      0|        if (j==0)
 3705|      0|        {
 3706|      0|          iTRb = Clip3( -128, 127, enc_picture->poc - listX[LIST_0 + j][i]->poc );
 3707|      0|        }
 3708|      0|        else if (j == 2)
 3709|      0|        {          
 3710|      0|          iTRb = Clip3( -128, 127, enc_picture->top_poc - listX[LIST_0 + j][i]->poc );
 3711|      0|        }
 3712|      0|        else
 3713|      0|        {
 3714|      0|          iTRb = Clip3( -128, 127, enc_picture->bottom_poc - listX[LIST_0 + j][i]->poc );
 3715|      0|        }
 3716|       |        
 3717|      0|        iTRp = Clip3( -128, 127,  listX[LIST_1 + j][0]->poc - listX[LIST_0 + j][i]->poc);
 3718|       |        
 3719|      0|        if (iTRp!=0)
 3720|      0|        {
 3721|      0|          prescale = ( 16384 + abs( iTRp / 2 ) ) / iTRp;
 3722|      0|          img->mvscale[j][i] = Clip3( -1024, 1023, ( iTRb * prescale + 32 ) >> 6 ) ;
 3723|      0|        }
 3724|      0|        else
 3725|      0|        {
 3726|      0|          img->mvscale[j][i] = 9999;
 3727|      0|        }
 3728|      0|      }
 3729|      0|    }
 3730|      0|  }
 3731|     85|}
 3732|       |

/home/xzp/speccpu2006-v1.0.1/benchspec/CPU2006/464.h264ref/run/build_base_ql_riscv_llvm17.0000/memalloc.c:
    1|       |
    2|       |/*!
    3|       | ************************************************************************
    4|       | * \file  memalloc.c
    5|       | *
    6|       | * \brief
    7|       | *    Memory allocation and free helper functions
    8|       | *
    9|       | * \author
   10|       | *    Main contributors (see contributors.h for copyright, address and affiliation details)
   11|       | ************************************************************************
   12|       | */
   13|       |
   14|       |#include <stdlib.h>
   15|       |
   16|       |#include "global.h"
   17|       |
   18|       |
   19|       | /*!
   20|       | ************************************************************************
   21|       | * \brief
   22|       | *    Initialize 2-dimensional top and bottom field to point to the proper
   23|       | *    lines in frame
   24|       | *
   25|       | * \par Output:
   26|       | *    memory size in bytes
   27|       | ************************************************************************/
   28|       |int init_top_bot_planes(imgpel **imgFrame, int rows, int columns, imgpel ***imgTopField, imgpel ***imgBotField)
   29|      0|{
   30|      0|  int i;
   31|       |      
   32|      0|  if((*imgTopField   = (imgpel**)calloc(rows/2,        sizeof(imgpel*))) == NULL)
   33|      0|    no_mem_exit("init_top_bot_planes: imgTopField");
   34|       |
   35|      0|  if((*imgBotField   = (imgpel**)calloc(rows/2,        sizeof(imgpel*))) == NULL)
   36|      0|    no_mem_exit("init_top_bot_planes: imgBotField");
   37|       |
   38|      0|  for(i=0 ; i<rows/2 ; i++)
   39|      0|  {
   40|      0|    (*imgTopField)[i] =  imgFrame[2*i  ];
   41|      0|    (*imgBotField)[i] =  imgFrame[2*i+1];
   42|      0|  }
   43|       |
   44|      0|  return rows*sizeof(imgpel*);
   45|      0|}
   46|       |
   47|       | /*!
   48|       | ************************************************************************
   49|       | * \brief
   50|       | *    free 2-dimensional top and bottom fields without freeing target memory
   51|       | *
   52|       | * \par Output:
   53|       | *    memory size in bytes
   54|       | ************************************************************************/
   55|       |void free_top_bot_planes(imgpel **imgTopField, imgpel **imgBotField)
   56|      0|{
   57|      0|  free (imgTopField);
   58|      0|  free (imgBotField);
   59|      0|}
   60|       |
   61|       |
   62|       |/*!
   63|       | ************************************************************************
   64|       | * \brief
   65|       | *    Allocate 2D memory array -> imgpel array2D[rows][columns]
   66|       | *
   67|       | * \par Output:
   68|       | *    memory size in bytes
   69|       | ************************************************************************/
   70|       |int get_mem2Dpel(imgpel ***array2D, int rows, int columns)
   71|    602|{
   72|    602|  int i;
   73|       |      
   74|    602|  if((*array2D      = (imgpel**)calloc(rows,        sizeof(imgpel*))) == NULL)
   75|      0|    no_mem_exit("get_mem2Dpel: array2D");
   76|    602|  if(((*array2D)[0] = (imgpel* )calloc(rows*columns,sizeof(imgpel ))) == NULL)
   77|      0|    no_mem_exit("get_mem2Dpel: array2D");
   78|       |
   79|   222k|  for(i=1 ; i<rows ; i++)
   80|   222k|    (*array2D)[i] =  (*array2D)[i-1] + columns  ;
   81|       |
   82|    602|  return rows*columns*sizeof(imgpel);
   83|    602|}
   84|       |
   85|       |
   86|       |/*!
   87|       | ************************************************************************
   88|       | * \brief
   89|       | *    Allocate 3D memory array -> imgpel array3D[frames][rows][columns]
   90|       | *
   91|       | * \par Output:
   92|       | *    memory size in bytes
   93|       | ************************************************************************
   94|       | */
   95|       |int get_mem3Dpel(imgpel ****array3D, int frames, int rows, int columns)
   96|    172|{
   97|    172|  int  j;
   98|       |      
   99|    172|  if(((*array3D) = (imgpel***)calloc(frames,sizeof(imgpel**))) == NULL)
  100|      0|    no_mem_exit("get_mem3Dpel: array3D");
  101|       |
  102|    516|  for(j=0;j<frames;j++)
  103|    344|    get_mem2Dpel( (*array3D)+j, rows, columns ) ;
  104|       |
  105|    172|  return frames*rows*columns*sizeof(imgpel);
  106|    172|}
  107|       |
  108|       |/*!
  109|       | ************************************************************************
  110|       | * \brief
  111|       | *    free 2D memory array
  112|       | *    which was allocated with get_mem2Dpel()
  113|       | ************************************************************************
  114|       | */
  115|       |void free_mem2Dpel(imgpel **array2D)
  116|    602|{
  117|    602|  if (array2D)
  118|    602|  {
  119|    602|    if (array2D[0])
  120|    602|      free (array2D[0]);
  121|      0|    else error ("free_mem2Dpel: trying to free unused memory",100);
  122|       |      
  123|    602|    free (array2D);
  124|    602|  } else
  125|      0|  {
  126|      0|    error ("free_mem2Dpel: trying to free unused memory",100);
  127|      0|  }
  128|    602|}
  129|       |
  130|       |/*!
  131|       | ************************************************************************
  132|       | * \brief
  133|       | *    free 3D memory array
  134|       | *    which was allocated with get_mem3Dpel()
  135|       | ************************************************************************
  136|       | */
  137|       |void free_mem3Dpel(imgpel ***array3D, int frames)
  138|    172|{
  139|    172|  int i;
  140|       |      
  141|    172|  if (array3D)
  142|    172|  {
  143|    516|    for (i=0;i<frames;i++)
  144|    344|    { 
  145|    344|      free_mem2Dpel(array3D[i]);
  146|    344|    }
  147|    172|   free (array3D);
  148|    172|  } else
  149|      0|  {
  150|      0|    error ("free_mem3Dpel: trying to free unused memory",100);
  151|      0|  }
  152|    172|}
  153|       |
  154|       |/*!
  155|       | ************************************************************************
  156|       | * \brief
  157|       | *    Allocate 2D memory array -> unsigned char array2D[rows][columns]
  158|       | *
  159|       | * \par Output:
  160|       | *    memory size in bytes
  161|       | ************************************************************************/
  162|       |int get_mem2D(byte ***array2D, int rows, int columns)
  163|    344|{
  164|    344|  int i;
  165|       |
  166|    344|  if((*array2D      = (byte**)calloc(rows,        sizeof(byte*))) == NULL)
  167|      0|    no_mem_exit("get_mem2D: array2D");
  168|    344|  if(((*array2D)[0] = (byte* )calloc(columns*rows,sizeof(byte ))) == NULL)
  169|      0|    no_mem_exit("get_mem2D: array2D");
  170|       |
  171|  44.0k|  for(i=1;i<rows;i++)
  172|  43.6k|    (*array2D)[i] = (*array2D)[i-1] + columns ;
  173|       |
  174|    344|  return rows*columns;
  175|    344|}
  176|       |
  177|       |/*!
  178|       | ************************************************************************
  179|       | * \brief
  180|       | *    Allocate 2D memory array -> int array2D[rows][columns]
  181|       | *
  182|       | * \par Output:
  183|       | *    memory size in bytes
  184|       | ************************************************************************
  185|       | */
  186|       |int get_mem2Dint(int ***array2D, int rows, int columns)
  187|    660|{
  188|    660|  int i;
  189|       |  
  190|    660|  if((*array2D      = (int**)calloc(rows,        sizeof(int*))) == NULL)
  191|      0|    no_mem_exit("get_mem2Dint: array2D");
  192|    660|  if(((*array2D)[0] = (int* )calloc(rows*columns,sizeof(int ))) == NULL)
  193|      0|    no_mem_exit("get_mem2Dint: array2D");
  194|       |  
  195|  3.36k|  for(i=1 ; i<rows ; i++)
  196|  2.70k|    (*array2D)[i] =  (*array2D)[i-1] + columns  ;
  197|       |  
  198|    660|  return rows*columns*sizeof(int);
  199|    660|}
  200|       |
  201|       |/*!
  202|       | ************************************************************************
  203|       | * \brief
  204|       | *    Allocate 2D memory array -> int64 array2D[rows][columns]
  205|       | *
  206|       | * \par Output:
  207|       | *    memory size in bytes
  208|       | ************************************************************************
  209|       | */
  210|       |int get_mem2Dint64(int64 ***array2D, int rows, int columns)
  211|  2.05k|{
  212|  2.05k|  int i;
  213|       |
  214|  2.05k|  if((*array2D      = (int64**)calloc(rows,        sizeof(int64*))) == NULL)
  215|      0|    no_mem_exit("get_mem2Dint64: array2D");
  216|  2.05k|  if(((*array2D)[0] = (int64* )calloc(rows*columns,sizeof(int64 ))) == NULL)
  217|      0|    no_mem_exit("get_mem2Dint64: array2D");
  218|       |
  219|   262k|  for(i=1 ; i<rows ; i++)
  220|   260k|    (*array2D)[i] =  (*array2D)[i-1] + columns  ;
  221|       |
  222|  2.05k|  return rows*columns*sizeof(int64);
  223|  2.05k|}
  224|       |
  225|       |/*!
  226|       | ************************************************************************
  227|       | * \brief
  228|       | *    Allocate 3D memory array -> unsigned char array3D[frames][rows][columns]
  229|       | *
  230|       | * \par Output:
  231|       | *    memory size in bytes
  232|       | ************************************************************************
  233|       | */
  234|       |int get_mem3D(byte ****array3D, int frames, int rows, int columns)
  235|      0|{
  236|      0|  int  j;
  237|       |
  238|      0|  if(((*array3D) = (byte***)calloc(frames,sizeof(byte**))) == NULL)
  239|      0|    no_mem_exit("get_mem3D: array3D");
  240|       |
  241|      0|  for(j=0;j<frames;j++)
  242|      0|    get_mem2D( (*array3D)+j, rows, columns ) ;
  243|       |
  244|      0|  return frames*rows*columns;
  245|      0|}
  246|       |
  247|       |/*!
  248|       | ************************************************************************
  249|       | * \brief
  250|       | *    Allocate 3D memory array -> int array3D[frames][rows][columns]
  251|       | *
  252|       | * \par Output:
  253|       | *    memory size in bytes
  254|       | ************************************************************************
  255|       | */
  256|       |int get_mem3Dint(int ****array3D, int frames, int rows, int columns)
  257|      9|{
  258|      9|  int  j;
  259|       |
  260|      9|  if(((*array3D) = (int***)calloc(frames,sizeof(int**))) == NULL)
  261|      0|    no_mem_exit("get_mem3Dint: array3D");
  262|       |
  263|    665|  for(j=0;j<frames;j++)
  264|    656|    get_mem2Dint( (*array3D)+j, rows, columns ) ;
  265|       |
  266|      9|  return frames*rows*columns*sizeof(int);
  267|      9|}
  268|       |
  269|       |/*!
  270|       | ************************************************************************
  271|       | * \brief
  272|       | *    Allocate 3D memory array -> int64 array3D[frames][rows][columns]
  273|       | *
  274|       | * \par Output:
  275|       | *    memory size in bytes
  276|       | ************************************************************************
  277|       | */
  278|       |int get_mem3Dint64(int64 ****array3D, int frames, int rows, int columns)
  279|    343|{
  280|    343|  int  j;
  281|       |
  282|    343|  if(((*array3D) = (int64***)calloc(frames,sizeof(int64**))) == NULL)
  283|      0|    no_mem_exit("get_mem3Dint64: array3D");
  284|       |
  285|  2.39k|  for(j=0;j<frames;j++)
  286|  2.05k|    get_mem2Dint64( (*array3D)+j, rows, columns ) ;
  287|       |
  288|    343|  return frames*rows*columns*sizeof(int64);
  289|    343|}
  290|       |
  291|       |/*!
  292|       | ************************************************************************
  293|       | * \brief
  294|       | *    Allocate 4D memory array -> int array3D[frames][rows][columns][component]
  295|       | *
  296|       | * \par Output:
  297|       | *    memory size in bytes
  298|       | ************************************************************************
  299|       | */
  300|       |int get_mem4Dint(int *****array4D, int idx, int frames, int rows, int columns )
  301|      1|{
  302|      1|  int  j;
  303|       |
  304|      1|  if(((*array4D) = (int****)calloc(idx,sizeof(int**))) == NULL)
  305|      0|    no_mem_exit("get_mem4Dint: array4D");
  306|       |
  307|      9|  for(j=0;j<idx;j++)
  308|      8|    get_mem3Dint( (*array4D)+j, frames, rows, columns ) ;
  309|       |
  310|      1|  return idx*frames*rows*columns*sizeof(int);
  311|      1|}
  312|       |
  313|       |/*!
  314|       | ************************************************************************
  315|       | * \brief
  316|       | *    free 2D memory array
  317|       | *    which was allocated with get_mem2D()
  318|       | ************************************************************************
  319|       | */
  320|       |void free_mem2D(byte **array2D)
  321|    344|{
  322|    344|  if (array2D)
  323|    344|  {
  324|    344|    if (array2D[0])
  325|    344|      free (array2D[0]);
  326|      0|    else error ("free_mem2D: trying to free unused memory",100);
  327|       |
  328|    344|    free (array2D);
  329|    344|  } else
  330|      0|  {
  331|      0|    error ("free_mem2D: trying to free unused memory",100);
  332|      0|  }
  333|    344|}
  334|       |
  335|       |/*!
  336|       | ************************************************************************
  337|       | * \brief
  338|       | *    free 2D memory array
  339|       | *    which was allocated with get_mem2Dint()
  340|       | ************************************************************************
  341|       | */
  342|       |void free_mem2Dint(int **array2D)
  343|    660|{
  344|    660|  if (array2D)
  345|    660|  {
  346|    660|    if (array2D[0]) 
  347|    660|      free (array2D[0]);
  348|      0|    else error ("free_mem2Dint: trying to free unused memory",100);
  349|       |
  350|    660|    free (array2D);
  351|       |
  352|    660|  } else
  353|      0|  {
  354|      0|    error ("free_mem2Dint: trying to free unused memory",100);
  355|      0|  }
  356|    660|}
  357|       |
  358|       |/*!
  359|       | ************************************************************************
  360|       | * \brief
  361|       | *    free 2D memory array
  362|       | *    which was allocated with get_mem2Dint64()
  363|       | ************************************************************************
  364|       | */
  365|       |void free_mem2Dint64(int64 **array2D)
  366|  2.05k|{
  367|  2.05k|  if (array2D)
  368|  2.05k|  {
  369|  2.05k|    if (array2D[0]) 
  370|  2.05k|      free (array2D[0]);
  371|      0|    else error ("free_mem2Dint64: trying to free unused memory",100);
  372|       |
  373|  2.05k|    free (array2D);
  374|       |
  375|  2.05k|  } else
  376|      0|  {
  377|      0|    error ("free_mem2Dint64: trying to free unused memory",100);
  378|      0|  }
  379|  2.05k|}
  380|       |
  381|       |
  382|       |/*!
  383|       | ************************************************************************
  384|       | * \brief
  385|       | *    free 3D memory array
  386|       | *    which was allocated with get_mem3D()
  387|       | ************************************************************************
  388|       | */
  389|       |void free_mem3D(byte ***array3D, int frames)
  390|      0|{
  391|      0|  int i;
  392|       |
  393|      0|  if (array3D)
  394|      0|  {
  395|      0|    for (i=0;i<frames;i++)
  396|      0|    { 
  397|      0|      free_mem2D(array3D[i]);
  398|      0|    }
  399|      0|   free (array3D);
  400|      0|  } else
  401|      0|  {
  402|      0|    error ("free_mem3D: trying to free unused memory",100);
  403|      0|  }
  404|      0|}
  405|       |
  406|       |/*!
  407|       | ************************************************************************
  408|       | * \brief
  409|       | *    free 3D memory array 
  410|       | *    which was allocated with get_mem3Dint()
  411|       | ************************************************************************
  412|       | */
  413|       |void free_mem3Dint(int ***array3D, int frames)
  414|      9|{
  415|      9|  int i;
  416|       |
  417|      9|  if (array3D)
  418|      9|  {
  419|    665|    for (i=0;i<frames;i++)
  420|    656|    { 
  421|    656|      free_mem2Dint(array3D[i]);
  422|    656|    }
  423|      9|   free (array3D);
  424|      9|  } else
  425|      0|  {
  426|      0|    error ("free_mem3Dint: trying to free unused memory",100);
  427|      0|  }
  428|      9|}
  429|       |
  430|       |
  431|       |/*!
  432|       | ************************************************************************
  433|       | * \brief
  434|       | *    free 3D memory array 
  435|       | *    which was allocated with get_mem3Dint64()
  436|       | ************************************************************************
  437|       | */
  438|       |void free_mem3Dint64(int64 ***array3D, int frames)
  439|    343|{
  440|    343|  int i;
  441|       |
  442|    343|  if (array3D)
  443|    343|  {
  444|  2.39k|    for (i=0;i<frames;i++)
  445|  2.05k|    { 
  446|  2.05k|      free_mem2Dint64(array3D[i]);
  447|  2.05k|    }
  448|    343|   free (array3D);
  449|    343|  } else
  450|      0|  {
  451|      0|    error ("free_mem3Dint64: trying to free unused memory",100);
  452|      0|  }
  453|    343|}
  454|       |
  455|       |/*!
  456|       | ************************************************************************
  457|       | * \brief
  458|       | *    free 4D memory array 
  459|       | *    which was allocated with get_mem4Dint()
  460|       | ************************************************************************
  461|       | */
  462|       |void free_mem4Dint(int ****array4D, int idx, int frames )
  463|      1|{
  464|      1|  int  j;
  465|       |
  466|      1|  if (array4D)
  467|      1|  {
  468|      9|    for(j=0;j<idx;j++)
  469|      8|      free_mem3Dint( array4D[j], frames) ;
  470|      1|    free (array4D);
  471|      1|  } else
  472|      0|  {
  473|      0|    error ("free_mem4Dint: trying to free unused memory",100);
  474|      0|  }
  475|      1|}
  476|       |
  477|       |
  478|       |/*!
  479|       | ************************************************************************
  480|       | * \brief
  481|       | *    Exit program if memory allocation failed (using error())
  482|       | * \param where
  483|       | *    string indicating which memory allocation failed
  484|       | ************************************************************************
  485|       | */
  486|       |void no_mem_exit(char *where)
  487|      0|{
  488|      0|   snprintf(errortext, ET_SIZE, "Could not allocate memory: %s",where);
  489|      0|   error (errortext, 100);
  490|      0|}
  491|       |
  492|       |
  493|       |/*!
  494|       | ************************************************************************
  495|       | * \brief
  496|       | *    Allocate 2D short memory array -> short array2D[rows][columns]
  497|       | *
  498|       | * \par Output:
  499|       | *    memory size in bytes
  500|       | ************************************************************************
  501|       | */
  502|       |int get_mem2Dshort(short ***array2D, int rows, int columns)
  503|  44.3k|{
  504|  44.3k|  int i;
  505|       |  
  506|  44.3k|  if((*array2D      = (short**)calloc(rows,        sizeof(short*))) == NULL)
  507|      0|    no_mem_exit("get_mem2Dshort: array2D");
  508|  44.3k|  if(((*array2D)[0] = (short* )calloc(rows*columns,sizeof(short ))) == NULL)
  509|      0|    no_mem_exit("get_mem2Dshort: array2D");
  510|       |  
  511|  3.56M|  for(i=1 ; i<rows ; i++)
  512|  3.52M|    (*array2D)[i] =  (*array2D)[i-1] + columns  ;
  513|       |  
  514|  44.3k|  return rows*columns*sizeof(short);
  515|  44.3k|}
  516|       |
  517|       |/*!
  518|       | ************************************************************************
  519|       | * \brief
  520|       | *    Allocate 3D memory short array -> short array3D[frames][rows][columns]
  521|       | *
  522|       | * \par Output:
  523|       | *    memory size in bytes
  524|       | ************************************************************************
  525|       | */
  526|       |int get_mem3Dshort(short ****array3D, int frames, int rows, int columns)
  527|    517|{
  528|    517|  int  j;
  529|       |
  530|    517|  if(((*array3D) = (short***)calloc(frames,sizeof(short**))) == NULL)
  531|      0|    no_mem_exit("get_mem3Dshort: array3D");
  532|       |
  533|  44.8k|  for(j=0;j<frames;j++)
  534|  44.3k|    get_mem2Dshort( (*array3D)+j, rows, columns ) ;
  535|       |
  536|    517|  return frames*rows*columns*sizeof(short);
  537|    517|}
  538|       |
  539|       |/*!
  540|       | ************************************************************************
  541|       | * \brief
  542|       | *    Allocate 4D memory short array -> short array3D[frames][rows][columns][component]
  543|       | *
  544|       | * \par Output:
  545|       | *    memory size in bytes
  546|       | ************************************************************************
  547|       | */
  548|       |int get_mem4Dshort(short *****array4D, int idx, int frames, int rows, int columns )
  549|    172|{
  550|    172|  int  j;
  551|       |
  552|    172|  if(((*array4D) = (short****)calloc(idx,sizeof(short**))) == NULL)
  553|      0|    no_mem_exit("get_mem4Dshort: array4D");
  554|       |
  555|    516|  for(j=0;j<idx;j++)
  556|    344|    get_mem3Dshort( (*array4D)+j, frames, rows, columns ) ;
  557|       |
  558|    172|  return idx*frames*rows*columns*sizeof(short);
  559|    172|}
  560|       |
  561|       |/*!
  562|       | ************************************************************************
  563|       | * \brief
  564|       | *    free 2D short memory array
  565|       | *    which was allocated with get_mem2Dshort()
  566|       | ************************************************************************
  567|       | */
  568|       |void free_mem2Dshort(short **array2D)
  569|  44.3k|{
  570|  44.3k|  if (array2D)
  571|  44.3k|  {
  572|  44.3k|    if (array2D[0]) 
  573|  44.3k|      free (array2D[0]);
  574|      0|    else error ("free_mem2Dshort: trying to free unused memory",100);
  575|       |
  576|  44.3k|    free (array2D);
  577|       |
  578|  44.3k|  } else
  579|      0|  {
  580|      0|    error ("free_mem2Dshort: trying to free unused memory",100);
  581|      0|  }
  582|  44.3k|}
  583|       |
  584|       |/*!
  585|       | ************************************************************************
  586|       | * \brief
  587|       | *    free 3D short memory array 
  588|       | *    which was allocated with get_mem3Dshort()
  589|       | ************************************************************************
  590|       | */
  591|       |void free_mem3Dshort(short ***array3D, int frames)
  592|    517|{
  593|    517|  int i;
  594|       |
  595|    517|  if (array3D)
  596|    517|  {
  597|  44.8k|    for (i=0;i<frames;i++)
  598|  44.3k|    { 
  599|  44.3k|      free_mem2Dshort(array3D[i]);
  600|  44.3k|    }
  601|    517|   free (array3D);
  602|    517|  } else
  603|      0|  {
  604|      0|    error ("free_mem3Dshort: trying to free unused memory",100);
  605|      0|  }
  606|    517|}
  607|       |
  608|       |/*!
  609|       | ************************************************************************
  610|       | * \brief
  611|       | *    free 4D short memory array 
  612|       | *    which was allocated with get_mem4Dshort()
  613|       | ************************************************************************
  614|       | */
  615|       |void free_mem4Dshort(short ****array4D, int idx, int frames )
  616|    172|{
  617|    172|  int  j;
  618|       |
  619|    172|  if (array4D)
  620|    172|  {
  621|    516|    for(j=0;j<idx;j++)
  622|    344|      free_mem3Dshort( array4D[j], frames) ;
  623|    172|    free (array4D);
  624|    172|  } else
  625|      0|  {
  626|      0|    error ("free_mem4Dshort: trying to free unused memory",100);
  627|      0|  }
  628|    172|}

/home/xzp/speccpu2006-v1.0.1/benchspec/CPU2006/464.h264ref/run/build_base_ql_riscv_llvm17.0000/minmax.h:
    1|       |
    2|       |/*!
    3|       | ************************************************************************
    4|       | *  \file
    5|       | *     minmax.h
    6|       | *  \brief
    7|       | *     defines min and max macros for non WIN32 environments
    8|       | ************************************************************************
    9|       | */
   10|       |#ifndef _MINMAX_
   11|       |#define _MINMAX_
   12|       |
   13|       |#if !defined(WIN32) || defined(__GNUC__) || defined(SPEC_CPU_NEED_MINMAX)
   14|  4.26G|#define max(a, b) (((a) > (b)) ? (a) : (b))
   15|  2.98G|#define min(a, b) (((a) < (b)) ? (a) : (b))
   16|       |#endif
   17|       |
   18|       |#endif
   19|       |

/home/xzp/speccpu2006-v1.0.1/benchspec/CPU2006/464.h264ref/run/build_base_ql_riscv_llvm17.0000/mv-search.c:
    1|       |
    2|       |/*!
    3|       | *************************************************************************************
    4|       | * \file mv-search.c
    5|       | *
    6|       | * \brief
    7|       | *    Motion Vector Search, unified for B and P Pictures
    8|       | *
    9|       | * \author
   10|       | *    Main contributors (see contributors.h for copyright, address and affiliation details)
   11|       | *      - Stephan Wenger                  <stewe@cs.tu-berlin.de>
   12|       | *      - Inge Lille-Langoy               <inge.lille-langoy@telenor.com>
   13|       | *      - Rickard Sjoberg                 <rickard.sjoberg@era.ericsson.se>
   14|       | *      - Stephan Wenger                  <stewe@cs.tu-berlin.de>
   15|       | *      - Jani Lainema                    <jani.lainema@nokia.com>
   16|       | *      - Detlev Marpe                    <marpe@hhi.de>
   17|       | *      - Thomas Wedi                     <wedi@tnt.uni-hannover.de>
   18|       | *      - Heiko Schwarz                   <hschwarz@hhi.de>
   19|       | *      - Alexis Michael Tourapis         <alexismt@ieee.org>
   20|       | *
   21|       | *************************************************************************************
   22|       |*/
   23|       |
   24|       |#include "contributors.h"
   25|       |
   26|       |#include <stdlib.h>
   27|       |#include <math.h>
   28|       |#include <limits.h>
   29|       |
   30|       |#include "global.h"
   31|       |
   32|       |#include "image.h"
   33|       |#include "mv-search.h"
   34|       |#include "refbuf.h"
   35|       |#include "memalloc.h"
   36|       |#include "mb_access.h"
   37|       |#include "fast_me.h"
   38|       |
   39|       |#include <time.h>
   40|       |#include <sys/timeb.h>
   41|       |
   42|       |// These procedure pointers are used by motion_search() and one_eigthpel()
   43|       |static pel_t  (*PelY_14)     (pel_t**, int, int, int, int);
   44|       |static pel_t  (*PelY_14b)    (pel_t**, int, int, int, int);
   45|       |static pel_t *(*PelYline_11) (pel_t *, int, int, int, int);
   46|       |
   47|       |// Statistics, temporary
   48|       |int     max_mvd;
   49|       |int*    spiral_search_x;
   50|       |int*    spiral_search_y;
   51|       |int*    mvbits;
   52|       |int*    refbits;
   53|       |int*    byte_abs;
   54|       |int**** motion_cost;
   55|       |
   56|       |
   57|       |void SetMotionVectorPredictor (short  pmv[2],
   58|       |                               short  ***refPic,
   59|       |                               short  ****tmp_mv,
   60|       |                               short  ref_frame,
   61|       |                               int    list,
   62|       |                               int    block_x,
   63|       |                               int    block_y,
   64|       |                               int    blockshape_x,
   65|       |                               int    blockshape_y);
   66|       |
   67|       |#ifdef _FAST_FULL_ME_
   68|       |
   69|       |/*****
   70|       | *****  static variables for fast integer motion estimation
   71|       | *****
   72|       | */
   73|       |static int  **search_setup_done;  //!< flag if all block SAD's have been calculated yet
   74|       |static int  **search_center_x;    //!< absolute search center for fast full motion search
   75|       |static int  **search_center_y;    //!< absolute search center for fast full motion search
   76|       |static int  **pos_00;             //!< position of (0,0) vector
   77|       |static int  *****BlockSAD;        //!< SAD for all blocksize, ref. frames and motion vectors
   78|       |static int  **max_search_range;
   79|       |
   80|       |extern ColocatedParams *Co_located;
   81|       |
   82|       |/*!
   83|       | ***********************************************************************
   84|       | * \brief
   85|       | *    function creating arrays for fast integer motion estimation
   86|       | ***********************************************************************
   87|       | */
   88|       |void
   89|       |InitializeFastFullIntegerSearch ()
   90|      1|{
   91|      1|  int  i, j, k, list;
   92|      1|  int  search_range = input->search_range;
   93|      1|  int  max_pos      = (2*search_range+1) * (2*search_range+1);
   94|       |
   95|      1|  if ((BlockSAD = (int*****)malloc (2 * sizeof(int****))) == NULL)
   96|      0|    no_mem_exit ("InitializeFastFullIntegerSearch: BlockSAD");
   97|       |
   98|      3|  for (list=0; list<2;list++)
   99|      2|  {
  100|      2|    if ((BlockSAD[list] = (int****)malloc ((img->max_num_references+1) * sizeof(int***))) == NULL)
  101|      0|      no_mem_exit ("InitializeFastFullIntegerSearch: BlockSAD");
  102|     14|    for (i = 0; i <= img->max_num_references; i++)
  103|     12|    {
  104|     12|      if ((BlockSAD[list][i] = (int***)malloc (8 * sizeof(int**))) == NULL)
  105|      0|        no_mem_exit ("InitializeFastFullIntegerSearch: BlockSAD");
  106|     96|      for (j = 1; j < 8; j++)
  107|     84|      {
  108|     84|        if ((BlockSAD[list][i][j] = (int**)malloc (16 * sizeof(int*))) == NULL)
  109|      0|          no_mem_exit ("InitializeFastFullIntegerSearch: BlockSAD");
  110|  1.42k|        for (k = 0; k < 16; k++)
  111|  1.34k|        {
  112|  1.34k|          if ((BlockSAD[list][i][j][k] = (int*)malloc (max_pos * sizeof(int))) == NULL)
  113|      0|            no_mem_exit ("InitializeFastFullIntegerSearch: BlockSAD");
  114|  1.34k|        }
  115|     84|      }
  116|     12|    }
  117|      2|  }
  118|       |
  119|      1|  if ((search_setup_done = (int**)malloc (2*sizeof(int*)))==NULL)
  120|      0|    no_mem_exit ("InitializeFastFullIntegerSearch: search_setup_done");
  121|      1|  if ((search_center_x = (int**)malloc (2*sizeof(int*)))==NULL)
  122|      0|    no_mem_exit ("InitializeFastFullIntegerSearch: search_center_x");
  123|      1|  if ((search_center_y = (int**)malloc (2*sizeof(int*)))==NULL)
  124|      0|    no_mem_exit ("InitializeFastFullIntegerSearch: search_center_y");
  125|      1|  if ((pos_00 = (int**)malloc (2*sizeof(int*)))==NULL)
  126|      0|    no_mem_exit ("InitializeFastFullIntegerSearch: pos_00");
  127|      1|  if ((max_search_range = (int**)malloc (2*sizeof(int*)))==NULL)
  128|      0|    no_mem_exit ("InitializeFastFullIntegerSearch: max_search_range");
  129|       |
  130|      3|  for (list=0; list<2; list++)
  131|      2|  {
  132|      2|  if ((search_setup_done[list] = (int*)malloc ((img->max_num_references+1)*sizeof(int)))==NULL)
  133|      0|    no_mem_exit ("InitializeFastFullIntegerSearch: search_setup_done");
  134|      2|  if ((search_center_x[list] = (int*)malloc ((img->max_num_references+1)*sizeof(int)))==NULL)
  135|      0|    no_mem_exit ("InitializeFastFullIntegerSearch: search_center_x");
  136|      2|  if ((search_center_y[list] = (int*)malloc ((img->max_num_references+1)*sizeof(int)))==NULL)
  137|      0|    no_mem_exit ("InitializeFastFullIntegerSearch: search_center_y");
  138|      2|  if ((pos_00[list] = (int*)malloc ((img->max_num_references+1)*sizeof(int)))==NULL)
  139|      0|    no_mem_exit ("InitializeFastFullIntegerSearch: pos_00");
  140|      2|  if ((max_search_range[list] = (int*)malloc ((img->max_num_references+1)*sizeof(int)))==NULL)
  141|      0|    no_mem_exit ("InitializeFastFullIntegerSearch: max_search_range");
  142|      2|  }
  143|       |
  144|       |  // assign max search ranges for reference frames
  145|      1|  if (input->full_search == 2)
  146|      1|  {
  147|      3|    for (list=0;list<2;list++)
  148|     14|      for (i=0; i<=img->max_num_references; i++)  
  149|     12|        max_search_range[list][i] = search_range;
  150|      1|  }
  151|      0|  else
  152|      0|  {
  153|      0|    for (list=0;list<2;list++)
  154|      0|    {
  155|      0|      max_search_range[list][0] = max_search_range[list][img->max_num_references] = search_range;
  156|      0|      for (i=1; i< img->max_num_references; i++)  max_search_range[list][i] = search_range / 2;
  157|      0|    }
  158|      0|  }
  159|       |
  160|      1|}
  161|       |
  162|       |
  163|       |
  164|       |/*!
  165|       | ***********************************************************************
  166|       | * \brief
  167|       | *    function for deleting the arrays for fast integer motion estimation
  168|       | ***********************************************************************
  169|       | */
  170|       |void
  171|       |ClearFastFullIntegerSearch ()
  172|      1|{
  173|      1|  int  i, j, k, list;
  174|       |
  175|      3|  for (list=0; list<2; list++)
  176|      2|  {
  177|     14|    for (i = 0; i <= img->max_num_references; i++)
  178|     12|    {
  179|     96|      for (j = 1; j < 8; j++)
  180|     84|      {
  181|  1.42k|        for (k = 0; k < 16; k++)
  182|  1.34k|        {
  183|  1.34k|          free (BlockSAD[list][i][j][k]);
  184|  1.34k|        }
  185|     84|        free (BlockSAD[list][i][j]);
  186|     84|      }
  187|     12|      free (BlockSAD[list][i]);
  188|     12|    }
  189|      2|    free (BlockSAD[list]);
  190|      2|  }
  191|      1|  free (BlockSAD);
  192|       |
  193|      3|  for (list=0; list<2; list++)
  194|      2|  {
  195|      2|    free (search_setup_done[list]);
  196|      2|    free (search_center_x[list]);
  197|      2|    free (search_center_y[list]);
  198|      2|    free (pos_00[list]);
  199|      2|    free (max_search_range[list]);
  200|      2|  }
  201|      1|  free (search_setup_done);
  202|      1|  free (search_center_x);
  203|      1|  free (search_center_y);
  204|      1|  free (pos_00);
  205|      1|  free (max_search_range);
  206|       |
  207|      1|}
  208|       |
  209|       |
  210|       |/*!
  211|       | ***********************************************************************
  212|       | * \brief
  213|       | *    function resetting flags for fast integer motion estimation
  214|       | *    (have to be called in start_macroblock())
  215|       | ***********************************************************************
  216|       | */
  217|       |void
  218|       |ResetFastFullIntegerSearch ()
  219|   109k|{
  220|   109k|  int i,list;
  221|       |
  222|   328k|  for (list=0; list<2; list++)
  223|  1.53M|    for (i = 0; i <= img->max_num_references; i++)
  224|  1.31M|      search_setup_done [list][i] = 0;
  225|   109k|}
  226|       |
  227|       |/*!
  228|       | ***********************************************************************
  229|       | * \brief
  230|       | *    calculation of SAD for larger blocks on the basis of 4x4 blocks
  231|       | ***********************************************************************
  232|       | */
  233|       |void
  234|       |SetupLargerBlocks (int list, int refindex, int max_pos)
  235|   499k|{
  236|  13.6G|#define ADD_UP_BLOCKS()   _o=*_bo; _i=*_bi; _j=*_bj; for(pos=0;pos<max_pos;pos++) _o[pos] = _i[pos] + _j[pos];//xxzp unrool试试
  237|  9.49M|#define INCREMENT(inc)    _bo+=inc; _bi+=inc; _bj+=inc;
  238|       |
  239|   499k|  int    pos, **_bo, **_bi, **_bj;
  240|   499k|  register int *_o,   *_i,   *_j;
  241|       |
  242|       |  //--- blocktype 6 ---
  243|   499k|  _bo = BlockSAD[list][refindex][6];
  244|   499k|  _bi = BlockSAD[list][refindex][7];
  245|   499k|  _bj = _bi + 4;
  246|   499k|  ADD_UP_BLOCKS(); INCREMENT(1);
  247|   499k|  ADD_UP_BLOCKS(); INCREMENT(1);
  248|   499k|  ADD_UP_BLOCKS(); INCREMENT(1);
  249|   499k|  ADD_UP_BLOCKS(); INCREMENT(5);
  250|   499k|  ADD_UP_BLOCKS(); INCREMENT(1);
  251|   499k|  ADD_UP_BLOCKS(); INCREMENT(1);
  252|   499k|  ADD_UP_BLOCKS(); INCREMENT(1);
  253|   499k|  ADD_UP_BLOCKS();
  254|       |
  255|       |  //--- blocktype 5 ---
  256|   499k|  _bo = BlockSAD[list][refindex][5];
  257|   499k|  _bi = BlockSAD[list][refindex][7];
  258|   499k|  _bj = _bi + 1;
  259|   499k|  ADD_UP_BLOCKS(); INCREMENT(2);
  260|   499k|  ADD_UP_BLOCKS(); INCREMENT(2);
  261|   499k|  ADD_UP_BLOCKS(); INCREMENT(2);
  262|   499k|  ADD_UP_BLOCKS(); INCREMENT(2);
  263|   499k|  ADD_UP_BLOCKS(); INCREMENT(2);
  264|   499k|  ADD_UP_BLOCKS(); INCREMENT(2);
  265|   499k|  ADD_UP_BLOCKS(); INCREMENT(2);
  266|   499k|  ADD_UP_BLOCKS();
  267|       |
  268|       |  //--- blocktype 4 ---
  269|   499k|  _bo = BlockSAD[list][refindex][4];
  270|   499k|  _bi = BlockSAD[list][refindex][6];
  271|   499k|  _bj = _bi + 1;
  272|   499k|  ADD_UP_BLOCKS(); INCREMENT(2);
  273|   499k|  ADD_UP_BLOCKS(); INCREMENT(6);
  274|   499k|  ADD_UP_BLOCKS(); INCREMENT(2);
  275|   499k|  ADD_UP_BLOCKS();
  276|       |
  277|       |  //--- blocktype 3 ---
  278|   499k|  _bo = BlockSAD[list][refindex][3];
  279|   499k|  _bi = BlockSAD[list][refindex][4];
  280|   499k|  _bj = _bi + 8;
  281|   499k|  ADD_UP_BLOCKS(); INCREMENT(2);
  282|   499k|  ADD_UP_BLOCKS();
  283|       |
  284|       |  //--- blocktype 2 ---
  285|   499k|  _bo = BlockSAD[list][refindex][2];
  286|   499k|  _bi = BlockSAD[list][refindex][4];
  287|   499k|  _bj = _bi + 2;
  288|   499k|  ADD_UP_BLOCKS(); INCREMENT(8);
  289|   499k|  ADD_UP_BLOCKS();
  290|       |
  291|       |  //--- blocktype 1 ---
  292|   499k|  _bo = BlockSAD[list][refindex][1];
  293|   499k|  _bi = BlockSAD[list][refindex][3];
  294|   499k|  _bj = _bi + 2;
  295|   499k|  ADD_UP_BLOCKS();
  296|   499k|}
  297|       |
  298|       |
  299|       |/*!
  300|       | ***********************************************************************
  301|       | * \brief
  302|       | *    Setup the fast search for an macroblock
  303|       | ***********************************************************************
  304|       | */
  305|       |void SetupFastFullPelSearch (short ref, int list)  // <--  reference frame parameter, list0 or 1
  306|   499k|{
  307|   499k|  short   pmv[2];
  308|   499k|  pel_t   orig_blocks[256], *orgptr=orig_blocks, *refptr;
  309|   499k|  int     offset_x, offset_y, x, y, range_partly_outside, ref_x, ref_y, pos, abs_x, abs_y, bindex, blky;
  310|   499k|  int     LineSadBlk0, LineSadBlk1, LineSadBlk2, LineSadBlk3;
  311|   499k|  int     max_width, max_height;
  312|   499k|  int     img_width, img_height;
  313|       |
  314|   499k|  StorablePicture *ref_picture;
  315|   499k|  pel_t   *ref_pic;
  316|       |
  317|   499k|  int**   block_sad     = BlockSAD[list][ref][7];
  318|   499k|  int     search_range  = max_search_range[list][ref];
  319|   499k|  int     max_pos       = (2*search_range+1) * (2*search_range+1);
  320|       |
  321|   499k|  int     list_offset   = ((img->MbaffFrameFlag)&&(img->mb_data[img->current_mb_nr].mb_field))? img->current_mb_nr%2 ? 4 : 2 : 0;
  322|       |
  323|   499k|  int     apply_weights = ( (active_pps->weighted_pred_flag && (img->type == P_SLICE || img->type == SP_SLICE)) ||
  324|   499k|                            (active_pps->weighted_bipred_idc && (img->type == B_SLICE)));
  325|       |
  326|       |  
  327|   499k|  ref_picture     = listX[list+list_offset][ref];
  328|       |
  329|       |  //===== Use weighted Reference for ME ====
  330|   499k|  if (apply_weights && input->UseWeightedReferenceME)
  331|      0|    ref_pic       = ref_picture->imgY_11_w;
  332|   499k|  else
  333|   499k|    ref_pic       = ref_picture->imgY_11;
  334|       |
  335|   499k|  max_width     = ref_picture->size_x - 17;
  336|   499k|  max_height    = ref_picture->size_y - 17;
  337|       |  
  338|   499k|  img_width     = ref_picture->size_x;
  339|   499k|  img_height    = ref_picture->size_y;
  340|       |
  341|       |  //===== get search center: predictor of 16x16 block =====
  342|   499k|  SetMotionVectorPredictor (pmv, enc_picture->ref_idx, enc_picture->mv, ref, list, 0, 0, 16, 16);
  343|   499k|  search_center_x[list][ref] = pmv[0] / 4;
  344|   499k|  search_center_y[list][ref] = pmv[1] / 4;
  345|       |
  346|   499k|  if (!input->rdopt)
  347|      0|  {
  348|       |    //--- correct center so that (0,0) vector is inside ---
  349|      0|    search_center_x[list][ref] = max(-search_range, min(search_range, search_center_x[list][ref]));
  350|      0|    search_center_y[list][ref] = max(-search_range, min(search_range, search_center_y[list][ref]));
  351|      0|  }
  352|       |
  353|   499k|  search_center_x[list][ref] += img->opix_x;
  354|   499k|  search_center_y[list][ref] += img->opix_y;
  355|       |
  356|   499k|  offset_x = search_center_x[list][ref];
  357|   499k|  offset_y = search_center_y[list][ref];
  358|       |
  359|       |  //===== copy original block for fast access =====
  360|  8.49M|  for   (y = img->opix_y; y < img->opix_y+16; y++)
  361|   135M|    for (x = img->opix_x; x < img->opix_x+16; x++)
  362|   127M|      *orgptr++ = imgY_org [y][x];
  363|       |
  364|       |
  365|       |  //===== check if whole search range is inside image =====
  366|   499k|  if (offset_x >= search_range && offset_x <= max_width  - search_range &&
  367|   499k|      offset_y >= search_range && offset_y <= max_height - search_range   )
  368|   392k|  {
  369|   392k|    range_partly_outside = 0; PelYline_11 = FastLine16Y_11;
  370|   392k|  }
  371|   107k|  else
  372|   107k|  {
  373|   107k|    range_partly_outside = 1;
  374|   107k|  }
  375|       |
  376|       |  //===== determine position of (0,0)-vector =====
  377|   499k|  if (!input->rdopt)
  378|      0|  {
  379|      0|    ref_x = img->opix_x - offset_x;
  380|      0|    ref_y = img->opix_y - offset_y;
  381|       |
  382|      0|    for (pos = 0; pos < max_pos; pos++)
  383|      0|    {
  384|      0|      if (ref_x == spiral_search_x[pos] &&
  385|      0|          ref_y == spiral_search_y[pos])
  386|      0|      {
  387|      0|        pos_00[list][ref] = pos;
  388|      0|        break;
  389|      0|      }
  390|      0|    }
  391|      0|  }
  392|       |
  393|       |  //===== loop over search range (spiral search): get blockwise SAD =====
  394|   544M|  for (pos = 0; pos < max_pos; pos++)
  395|   544M|  {
  396|   544M|    abs_y = offset_y + spiral_search_y[pos];
  397|   544M|    abs_x = offset_x + spiral_search_x[pos];
  398|       |
  399|   544M|    if (range_partly_outside)
  400|   117M|    {
  401|   117M|      if (abs_y >= 0 && abs_y <= max_height &&
  402|   117M|          abs_x >= 0 && abs_x <= max_width    )
  403|  70.8M|      {
  404|  70.8M|        PelYline_11 = FastLine16Y_11;
  405|  70.8M|      }
  406|  46.1M|      else
  407|  46.1M|      {
  408|  46.1M|        PelYline_11 = UMVLine16Y_11;
  409|  46.1M|      }
  410|   117M|    }
  411|       |
  412|   544M|    orgptr = orig_blocks;
  413|   544M|    bindex = 0;
  414|  2.72G|    for (blky = 0; blky < 4; blky++)//xxzp 可以重点看看 不知道咋改
  415|  2.17G|    {
  416|  2.17G|      LineSadBlk0 = LineSadBlk1 = LineSadBlk2 = LineSadBlk3 = 0;
  417|  10.8G|      for (y = 0; y < 4; y++)
  418|  8.70G|      {
  419|  8.70G|        refptr = PelYline_11 (ref_pic, abs_y++, abs_x, img_height, img_width);
  420|       |
  421|  8.70G|        LineSadBlk0 += byte_abs [*refptr++ - *orgptr++];
  422|  8.70G|        LineSadBlk0 += byte_abs [*refptr++ - *orgptr++];
  423|  8.70G|        LineSadBlk0 += byte_abs [*refptr++ - *orgptr++];
  424|  8.70G|        LineSadBlk0 += byte_abs [*refptr++ - *orgptr++];
  425|  8.70G|        LineSadBlk1 += byte_abs [*refptr++ - *orgptr++];
  426|  8.70G|        LineSadBlk1 += byte_abs [*refptr++ - *orgptr++];
  427|  8.70G|        LineSadBlk1 += byte_abs [*refptr++ - *orgptr++];
  428|  8.70G|        LineSadBlk1 += byte_abs [*refptr++ - *orgptr++];
  429|  8.70G|        LineSadBlk2 += byte_abs [*refptr++ - *orgptr++];
  430|  8.70G|        LineSadBlk2 += byte_abs [*refptr++ - *orgptr++];
  431|  8.70G|        LineSadBlk2 += byte_abs [*refptr++ - *orgptr++];
  432|  8.70G|        LineSadBlk2 += byte_abs [*refptr++ - *orgptr++];
  433|  8.70G|        LineSadBlk3 += byte_abs [*refptr++ - *orgptr++];
  434|  8.70G|        LineSadBlk3 += byte_abs [*refptr++ - *orgptr++];
  435|  8.70G|        LineSadBlk3 += byte_abs [*refptr++ - *orgptr++];
  436|  8.70G|        LineSadBlk3 += byte_abs [*refptr++ - *orgptr++];
  437|  8.70G|      }
  438|  2.17G|      block_sad[bindex++][pos] = LineSadBlk0;
  439|  2.17G|      block_sad[bindex++][pos] = LineSadBlk1;
  440|  2.17G|      block_sad[bindex++][pos] = LineSadBlk2;
  441|  2.17G|      block_sad[bindex++][pos] = LineSadBlk3;
  442|  2.17G|    }
  443|   544M|  }
  444|       |
  445|       |
  446|       |  //===== combine SAD's for larger block types =====
  447|   499k|  SetupLargerBlocks (list, ref, max_pos);
  448|       |
  449|       |
  450|       |  //===== set flag marking that search setup have been done =====
  451|   499k|  search_setup_done[list][ref] = 1;
  452|   499k|}
  453|       |#endif // _FAST_FULL_ME_
  454|       |
  455|       |/*!
  456|       | ************************************************************************
  457|       | * \brief
  458|       | *    Set motion vector predictor
  459|       | ************************************************************************
  460|       | */
  461|       |void SetMotionVectorPredictor (short  pmv[2],
  462|       |                               short  ***refPic,
  463|       |                               short  ****tmp_mv,
  464|       |                               short  ref_frame,
  465|       |                               int    list,
  466|       |                               int    block_x,
  467|       |                               int    block_y,
  468|       |                               int    blockshape_x,
  469|       |                               int    blockshape_y)
  470|  21.1M|{
  471|  21.1M|  int mb_x                 = 4*block_x;
  472|  21.1M|  int mb_y                 = 4*block_y;
  473|  21.1M|  int mb_nr                = img->current_mb_nr;
  474|       |
  475|  21.1M|  int mv_a, mv_b, mv_c, pred_vec=0;
  476|  21.1M|  int mvPredType, rFrameL, rFrameU, rFrameUR;
  477|  21.1M|  int hv;
  478|       |
  479|  21.1M|  PixelPos block_a, block_b, block_c, block_d;
  480|       |
  481|  21.1M|  int SAD_a=0, SAD_b=0, SAD_c=0, SAD_d=0;
  482|  21.1M|  int temp_pred_SAD[2];
  483|       |
  484|  21.1M|  if (input->FMEnable) pred_SAD_space=0;
  485|       |
  486|  21.1M|  getLuma4x4Neighbour(mb_nr, block_x, block_y,           -1,  0, &block_a);
  487|  21.1M|  getLuma4x4Neighbour(mb_nr, block_x, block_y,            0, -1, &block_b);
  488|  21.1M|  getLuma4x4Neighbour(mb_nr, block_x, block_y, blockshape_x, -1, &block_c);
  489|  21.1M|  getLuma4x4Neighbour(mb_nr, block_x, block_y,           -1, -1, &block_d);
  490|       |
  491|  21.1M|  if (mb_y > 0)
  492|  12.4M|  {
  493|  12.4M|    if (mb_x < 8)  // first column of 8x8 blocks
  494|  6.49M|    {
  495|  6.49M|      if (mb_y==8)
  496|  3.49M|      {
  497|  3.49M|        if (blockshape_x == 16)      block_c.available  = 0;
  498|  2.99M|        else                         block_c.available &= 1;
  499|  3.49M|      }
  500|  2.99M|      else
  501|  2.99M|      {
  502|  2.99M|        if (mb_x+blockshape_x != 8)  block_c.available &= 1;
  503|  1.99M|        else                         block_c.available  = 0;
  504|  2.99M|      }
  505|  6.49M|    }
  506|  5.99M|    else
  507|  5.99M|    {
  508|  5.99M|      if (mb_x+blockshape_x != 16)   block_c.available &= 1;
  509|  3.99M|      else                           block_c.available  = 0;
  510|  5.99M|    }
  511|  12.4M|  }
  512|       |
  513|  21.1M|  if (!block_c.available)
  514|  7.04M|  {
  515|  7.04M|    block_c=block_d;
  516|  7.04M|  }
  517|       |
  518|  21.1M|  mvPredType = MVPRED_MEDIAN;
  519|       |
  520|  21.1M|  if (!img->MbaffFrameFlag)
  521|  21.1M|  {
  522|  21.1M|    rFrameL    = block_a.available    ? refPic[list][block_a.pos_x][block_a.pos_y] : -1;
  523|  21.1M|    rFrameU    = block_b.available    ? refPic[list][block_b.pos_x][block_b.pos_y] : -1;
  524|  21.1M|    rFrameUR   = block_c.available    ? refPic[list][block_c.pos_x][block_c.pos_y] : -1;
  525|  21.1M|  }
  526|      0|  else
  527|      0|  {
  528|      0|    if (img->mb_data[img->current_mb_nr].mb_field)
  529|      0|    {
  530|      0|      rFrameL    = block_a.available    ? 
  531|      0|        img->mb_data[block_a.mb_addr].mb_field ? 
  532|      0|        refPic[list][block_a.pos_x][block_a.pos_y]:
  533|      0|        refPic[list][block_a.pos_x][block_a.pos_y] * 2: 
  534|      0|        -1;
  535|      0|      rFrameU    = block_b.available    ? 
  536|      0|        img->mb_data[block_b.mb_addr].mb_field ? 
  537|      0|        refPic[list][block_b.pos_x][block_b.pos_y]:
  538|      0|        refPic[list][block_b.pos_x][block_b.pos_y] * 2: 
  539|      0|        -1;
  540|      0|      rFrameUR    = block_c.available    ? 
  541|      0|        img->mb_data[block_c.mb_addr].mb_field ? 
  542|      0|        refPic[list][block_c.pos_x][block_c.pos_y]:
  543|      0|        refPic[list][block_c.pos_x][block_c.pos_y] * 2: 
  544|      0|        -1;
  545|      0|    }
  546|      0|    else
  547|      0|    {
  548|      0|      rFrameL    = block_a.available    ? 
  549|      0|        img->mb_data[block_a.mb_addr].mb_field ? 
  550|      0|        refPic[list][block_a.pos_x][block_a.pos_y] >>1:
  551|      0|        refPic[list][block_a.pos_x][block_a.pos_y] : 
  552|      0|        -1;
  553|      0|      rFrameU    = block_b.available    ? 
  554|      0|        img->mb_data[block_b.mb_addr].mb_field ? 
  555|      0|        refPic[list][block_b.pos_x][block_b.pos_y] >>1:
  556|      0|        refPic[list][block_b.pos_x][block_b.pos_y] : 
  557|      0|        -1;
  558|      0|      rFrameUR    = block_c.available    ? 
  559|      0|        img->mb_data[block_c.mb_addr].mb_field ? 
  560|      0|        refPic[list][block_c.pos_x][block_c.pos_y] >>1:
  561|      0|        refPic[list][block_c.pos_x][block_c.pos_y] : 
  562|      0|        -1;
  563|      0|    }
  564|      0|  }
  565|       |
  566|       |  /* Prediction if only one of the neighbors uses the reference frame
  567|       |   * we are checking
  568|       |   */
  569|  21.1M|  if(rFrameL == ref_frame && rFrameU != ref_frame && rFrameUR != ref_frame)       mvPredType = MVPRED_L;
  570|  17.7M|  else if(rFrameL != ref_frame && rFrameU == ref_frame && rFrameUR != ref_frame)  mvPredType = MVPRED_U;
  571|  16.0M|  else if(rFrameL != ref_frame && rFrameU != ref_frame && rFrameUR == ref_frame)  mvPredType = MVPRED_UR;
  572|       |  // Directional predictions 
  573|  21.1M|  if(blockshape_x == 8 && blockshape_y == 16)
  574|   999k|  {
  575|   999k|    if(mb_x == 0)
  576|   499k|    {
  577|   499k|      if(rFrameL == ref_frame)
  578|   101k|        mvPredType = MVPRED_L;
  579|   499k|    }
  580|   499k|    else
  581|   499k|    {
  582|   499k|      if( rFrameUR == ref_frame)
  583|  99.3k|        mvPredType = MVPRED_UR;
  584|   499k|    }
  585|   999k|  }
  586|  20.1M|  else if(blockshape_x == 16 && blockshape_y == 8)
  587|   999k|  {
  588|   999k|    if(mb_y == 0)
  589|   499k|    {
  590|   499k|      if(rFrameU == ref_frame)
  591|  99.4k|        mvPredType = MVPRED_U;
  592|   499k|    }
  593|   499k|    else
  594|   499k|    {
  595|   499k|      if(rFrameL == ref_frame)
  596|   101k|        mvPredType = MVPRED_L;
  597|   499k|    }
  598|   999k|  }
  599|       |
  600|  63.3M|  for (hv=0; hv < 2; hv++)
  601|  42.2M|  {
  602|  42.2M|    if (!img->MbaffFrameFlag || hv==0)
  603|  42.2M|    {
  604|  42.2M|      mv_a = block_a.available  ? tmp_mv[list][block_a.pos_x][block_a.pos_y][hv] : 0;
  605|  42.2M|      mv_b = block_b.available  ? tmp_mv[list][block_b.pos_x][block_b.pos_y][hv] : 0;
  606|  42.2M|      mv_c = block_c.available  ? tmp_mv[list][block_c.pos_x][block_c.pos_y][hv] : 0;
  607|  42.2M|    }
  608|      0|    else
  609|      0|    {
  610|      0|      if (img->mb_data[img->current_mb_nr].mb_field)
  611|      0|      {
  612|      0|        mv_a = block_a.available  ? img->mb_data[block_a.mb_addr].mb_field?
  613|      0|          tmp_mv[list][block_a.pos_x][block_a.pos_y][hv]:
  614|      0|          tmp_mv[list][block_a.pos_x][block_a.pos_y][hv] / 2: 
  615|      0|          0;
  616|      0|        mv_b = block_b.available  ? img->mb_data[block_b.mb_addr].mb_field?
  617|      0|          tmp_mv[list][block_b.pos_x][block_b.pos_y][hv]:
  618|      0|          tmp_mv[list][block_b.pos_x][block_b.pos_y][hv] / 2: 
  619|      0|          0;
  620|      0|        mv_c = block_c.available  ? img->mb_data[block_c.mb_addr].mb_field?
  621|      0|          tmp_mv[list][block_c.pos_x][block_c.pos_y][hv]:
  622|      0|          tmp_mv[list][block_c.pos_x][block_c.pos_y][hv] / 2: 
  623|      0|          0;
  624|      0|      }
  625|      0|      else
  626|      0|      {
  627|      0|        mv_a = block_a.available  ? img->mb_data[block_a.mb_addr].mb_field?
  628|      0|          tmp_mv[list][block_a.pos_x][block_a.pos_y][hv] * 2:
  629|      0|          tmp_mv[list][block_a.pos_x][block_a.pos_y][hv]: 
  630|      0|          0;
  631|      0|        mv_b = block_b.available  ? img->mb_data[block_b.mb_addr].mb_field?
  632|      0|          tmp_mv[list][block_b.pos_x][block_b.pos_y][hv] * 2:
  633|      0|          tmp_mv[list][block_b.pos_x][block_b.pos_y][hv]: 
  634|      0|          0;
  635|      0|        mv_c = block_c.available  ? img->mb_data[block_c.mb_addr].mb_field?
  636|      0|          tmp_mv[list][block_c.pos_x][block_c.pos_y][hv] * 2:
  637|      0|          tmp_mv[list][block_c.pos_x][block_c.pos_y][hv]: 
  638|      0|          0;
  639|      0|      }
  640|      0|    }
  641|       |
  642|  42.2M|  if(input->FMEnable)
  643|      0|  {
  644|      0|    SAD_a = block_a.available ? ((list==1) ? all_bwmincost[block_a.pos_x][block_a.pos_y][0][FME_blocktype][0]:all_mincost[block_a.pos_x][block_a.pos_y][ref_frame][FME_blocktype][0]):0;
  645|      0|    SAD_b = block_b.available ? ((list==1) ? all_bwmincost[block_b.pos_x][block_b.pos_y][0][FME_blocktype][0]:all_mincost[block_b.pos_x][block_b.pos_y][ref_frame][FME_blocktype][0]):0;
  646|      0|    SAD_d = block_d.available ? ((list==1) ? all_bwmincost[block_d.pos_x][block_d.pos_y][0][FME_blocktype][0]:all_mincost[block_d.pos_x][block_d.pos_y][ref_frame][FME_blocktype][0]):0;
  647|      0|    SAD_c = block_c.available ? ((list==1) ? all_bwmincost[block_c.pos_x][block_c.pos_y][0][FME_blocktype][0]:all_mincost[block_c.pos_x][block_c.pos_y][ref_frame][FME_blocktype][0]):SAD_d;
  648|      0|  }
  649|       |
  650|  42.2M|    switch (mvPredType)
  651|  42.2M|    {
  652|  31.3M|    case MVPRED_MEDIAN:
  653|  31.3M|      if(!(block_b.available || block_c.available))
  654|   505k|      {
  655|   505k|        pred_vec = mv_a;
  656|   505k|        if(input->FMEnable) temp_pred_SAD[hv] = SAD_a;
  657|   505k|      }
  658|  30.8M|      else
  659|  30.8M|      {
  660|  30.8M|        pred_vec = mv_a+mv_b+mv_c-min(mv_a,min(mv_b,mv_c))-max(mv_a,max(mv_b,mv_c));
  661|  30.8M|      }
  662|  31.3M|      if(input->FMEnable)
  663|      0|      {
  664|      0|         if (pred_vec == mv_a && SAD_a != 0) temp_pred_SAD[hv] = SAD_a;
  665|      0|         else if (pred_vec == mv_b && SAD_b!=0) temp_pred_SAD[hv] = SAD_b;
  666|      0|              else temp_pred_SAD[hv] = SAD_c;
  667|      0|      }
  668|  31.3M|      break;
  669|  7.17M|    case MVPRED_L:
  670|  7.17M|      pred_vec = mv_a;
  671|  7.17M|      if(input->FMEnable) temp_pred_SAD[hv] = SAD_a;
  672|  7.17M|      break;
  673|  3.43M|    case MVPRED_U:
  674|  3.43M|      pred_vec = mv_b;
  675|  3.43M|      if(input->FMEnable) temp_pred_SAD[hv] = SAD_b;
  676|  3.43M|      break;
  677|   278k|    case MVPRED_UR:
  678|   278k|      pred_vec = mv_c;
  679|   278k|      if(input->FMEnable) temp_pred_SAD[hv] = SAD_c;
  680|   278k|      break;
  681|      0|    default:
  682|      0|      break;
  683|  42.2M|    }
  684|       |
  685|  42.2M|    pmv[hv] = pred_vec;
  686|       |    
  687|  42.2M|  }
  688|       |
  689|  21.1M|  if(input->FMEnable) pred_SAD_space = temp_pred_SAD[0]>temp_pred_SAD[1]?temp_pred_SAD[1]:temp_pred_SAD[0];
  690|  21.1M|}
  691|       |
  692|       |/*!
  693|       |************************************************************************
  694|       |* \brief
  695|       |*    Initialize the motion search
  696|       |************************************************************************
  697|       |*/
  698|       |void
  699|       |Init_Motion_Search_Module ()
  700|      1|{
  701|      1|  int bits, i, imin, imax, k, l;
  702|       |  
  703|      1|  int byte_abs_range             = (img->max_imgpel_value > img->max_imgpel_value_uv) ? (img->max_imgpel_value + 1) * 2 : (img->max_imgpel_value_uv + 1) * 2;
  704|      1|  int search_range               = input->search_range;
  705|      1|  int number_of_reference_frames = img->max_num_references;
  706|      1|  int max_search_points          = max(9, (2*search_range+1)*(2*search_range+1));
  707|      1|  int max_ref_bits               = 1 + 2 * (int)floor(log(max(16,number_of_reference_frames+1)) / log(2) + 1e-10);
  708|      1|  int max_ref                    = (1<<((max_ref_bits>>1)+1))-1;
  709|      1|  int number_of_subpel_positions = 4 * (2*search_range+3);
  710|      1|  int max_mv_bits                = 3 + 2 * (int)ceil (log(number_of_subpel_positions+1) / log(2) + 1e-10);
  711|      1|  max_mvd                        = (1<<( max_mv_bits >>1)   )-1;
  712|       |
  713|       |
  714|       |  //=====   CREATE ARRAYS   =====
  715|       |  //-----------------------------
  716|      1|  if ((spiral_search_x = (int*)calloc(max_search_points, sizeof(int))) == NULL)
  717|      0|    no_mem_exit("Init_Motion_Search_Module: spiral_search_x");
  718|      1|  if ((spiral_search_y = (int*)calloc(max_search_points, sizeof(int))) == NULL)
  719|      0|    no_mem_exit("Init_Motion_Search_Module: spiral_search_y");
  720|      1|  if ((mvbits = (int*)calloc(2*max_mvd+1, sizeof(int))) == NULL)
  721|      0|    no_mem_exit("Init_Motion_Search_Module: mvbits");
  722|      1|  if ((refbits = (int*)calloc(max_ref, sizeof(int))) == NULL)
  723|      0|    no_mem_exit("Init_Motion_Search_Module: refbits");
  724|      1|  if ((byte_abs = (int*)calloc(byte_abs_range, sizeof(int))) == NULL)
  725|      0|    no_mem_exit("Init_Motion_Search_Module: byte_abs");
  726|       |
  727|      1|  get_mem4Dint (&motion_cost, 8, 2, img->max_num_references+1, 4);
  728|       |
  729|       |  //--- set array offsets ---
  730|      1|  mvbits   += max_mvd;
  731|      1|  byte_abs += byte_abs_range/2;
  732|       |
  733|       |
  734|       |  //=====   INIT ARRAYS   =====
  735|       |  //---------------------------
  736|       |  //--- init array: motion vector bits ---
  737|      1|  mvbits[0] = 1;
  738|     10|  for (bits=3; bits<=max_mv_bits; bits+=2)
  739|      9|  {
  740|      9|    imax = 1    << (bits >> 1);
  741|      9|    imin = imax >> 1;
  742|       |
  743|    520|    for (i = imin; i < imax; i++)   mvbits[-i] = mvbits[i] = bits;
  744|      9|  }
  745|       |  //--- init array: reference frame bits ---
  746|      1|  refbits[0] = 1;
  747|      5|  for (bits=3; bits<=max_ref_bits; bits+=2)
  748|      4|  {
  749|      4|    imax = (1   << ((bits >> 1) + 1)) - 1;
  750|      4|    imin = imax >> 1;
  751|       |
  752|     34|    for (i = imin; i < imax; i++)   refbits[i] = bits;
  753|      4|  }
  754|       |  //--- init array: absolute value ---
  755|      1|  byte_abs[0] = 0;
  756|    256|  for (i=1; i<byte_abs_range/2; i++)   byte_abs[i] = byte_abs[-i] = i;
  757|       |  //--- init array: search pattern ---
  758|      1|  spiral_search_x[0] = spiral_search_y[0] = 0;
  759|     17|  for (k=1, l=1; l<=max(1,search_range); l++)
  760|     16|  {
  761|    272|    for (i=-l+1; i< l; i++)
  762|    256|    {
  763|    256|      spiral_search_x[k] =  i;  spiral_search_y[k++] = -l;
  764|    256|      spiral_search_x[k] =  i;  spiral_search_y[k++] =  l;
  765|    256|    }
  766|    304|    for (i=-l;   i<=l; i++)
  767|    288|    {
  768|    288|      spiral_search_x[k] = -l;  spiral_search_y[k++] =  i;
  769|    288|      spiral_search_x[k] =  l;  spiral_search_y[k++] =  i;
  770|    288|    }
  771|     16|  }
  772|       |
  773|      1|#ifdef _FAST_FULL_ME_
  774|      1|  if(!input->FMEnable)
  775|      1|    InitializeFastFullIntegerSearch ();
  776|      1|#endif
  777|      1|}
  778|       |
  779|       |
  780|       |/*!
  781|       | ************************************************************************
  782|       | * \brief
  783|       | *    Free memory used by motion search
  784|       | ************************************************************************
  785|       | */
  786|       |void
  787|       |Clear_Motion_Search_Module ()
  788|      1|{
  789|       |  //--- correct array offset ---
  790|      1|  mvbits   -= max_mvd;
  791|      1|  byte_abs -= (img->max_imgpel_value > img->max_imgpel_value_uv) ? (img->max_imgpel_value + 1) : (img->max_imgpel_value_uv + 1);
  792|       |
  793|       |  //--- delete arrays ---
  794|      1|  free (spiral_search_x);
  795|      1|  free (spiral_search_y);
  796|      1|  free (mvbits);
  797|      1|  free (refbits);
  798|      1|  free (byte_abs);
  799|      1|  free_mem4Dint (motion_cost, 8, 2);
  800|       |
  801|      1|#ifdef _FAST_FULL_ME_
  802|      1|  if(!input->FMEnable)
  803|      1|    ClearFastFullIntegerSearch ();
  804|      1|#endif
  805|      1|}
  806|       |
  807|       |
  808|       |
  809|       |/*!
  810|       | ***********************************************************************
  811|       | * \brief
  812|       | *    Full pixel block motion search
  813|       | ***********************************************************************
  814|       | */
  815|       |int                                               //  ==> minimum motion cost after search
  816|       |FullPelBlockMotionSearch (pel_t**   orig_pic,     // <--  original pixel values for the AxB block
  817|       |                          short       ref,          // <--  reference frame (0... or -1 (backward))
  818|       |                          int       list,
  819|       |                          int       pic_pix_x,    // <--  absolute x-coordinate of regarded AxB block
  820|       |                          int       pic_pix_y,    // <--  absolute y-coordinate of regarded AxB block
  821|       |                          int       blocktype,    // <--  block type (1-16x16 ... 7-4x4)
  822|       |                          short       pred_mv_x,    // <--  motion vector predictor (x) in sub-pel units
  823|       |                          short       pred_mv_y,    // <--  motion vector predictor (y) in sub-pel units
  824|       |                          short*      mv_x,         // <--> in: search center (x) / out: motion vector (x) - in pel units
  825|       |                          short*      mv_y,         // <--> in: search center (y) / out: motion vector (y) - in pel units
  826|       |                          int       search_range, // <--  1-d search range in pel units
  827|       |                          int       min_mcost,    // <--  minimum motion cost (cost for center or huge value)
  828|       |                          double    lambda)       // <--  lagrangian parameter for determining motion cost
  829|      0|{
  830|      0|  int   pos, cand_x, cand_y, y, x4, mcost;
  831|       |  
  832|      0|  pel_t *orig_line, *ref_line;
  833|      0|  pel_t *(*get_ref_line)(int, pel_t*, int, int, int, int);
  834|       |
  835|      0|  int   list_offset   = ((img->MbaffFrameFlag)&&(img->mb_data[img->current_mb_nr].mb_field))? img->current_mb_nr%2 ? 4 : 2 : 0;
  836|      0|  pel_t *ref_pic      = listX[list+list_offset][ref]->imgY_11;
  837|      0|  int   img_width     = listX[list+list_offset][ref]->size_x;
  838|      0|  int   img_height    = listX[list+list_offset][ref]->size_y;
  839|       |
  840|      0|  int   best_pos      = 0;                                        // position with minimum motion cost
  841|      0|  int   max_pos       = (2*search_range+1)*(2*search_range+1);    // number of search positions
  842|      0|  int   lambda_factor = LAMBDA_FACTOR (lambda);                   // factor for determining lagragian motion cost
  843|      0|  int   blocksize_y   = input->blc_size[blocktype][1];            // vertical block size
  844|      0|  int   blocksize_x   = input->blc_size[blocktype][0];            // horizontal block size
  845|      0|  int   blocksize_x4  = blocksize_x >> 2;                         // horizontal block size in 4-pel units
  846|      0|  int   pred_x        = (pic_pix_x << 2) + pred_mv_x;       // predicted position x (in sub-pel units)
  847|      0|  int   pred_y        = (pic_pix_y << 2) + pred_mv_y;       // predicted position y (in sub-pel units)
  848|      0|  int   center_x      = pic_pix_x + *mv_x;                        // center position x (in pel units)
  849|      0|  int   center_y      = pic_pix_y + *mv_y;                        // center position y (in pel units)
  850|      0|  int   check_for_00  = (blocktype==1 && !input->rdopt && img->type!=B_SLICE && ref==0);
  851|       |
  852|      0|  int  apply_weights = ( (active_pps->weighted_pred_flag && (img->type == P_SLICE || img->type == SP_SLICE)) ||
  853|      0|                         (active_pps->weighted_bipred_idc && (img->type == B_SLICE)));  
  854|       |
  855|       |  //===== Use weighted Reference for ME ====
  856|      0|  if (apply_weights && input->UseWeightedReferenceME)
  857|      0|    ref_pic       = listX[list+list_offset][ref]->imgY_11_w;
  858|      0|  else
  859|      0|    ref_pic       = listX[list+list_offset][ref]->imgY_11;
  860|       |
  861|       |  //===== set function for getting reference picture lines =====
  862|      0|  if ((center_x > search_range) && (center_x < img->width -1-search_range-blocksize_x) &&
  863|      0|      (center_y > search_range) && (center_y < img->height-1-search_range-blocksize_y)   )
  864|      0|  {
  865|      0|     get_ref_line = FastLineX;
  866|      0|  }
  867|      0|  else
  868|      0|  {
  869|      0|     get_ref_line = UMVLineX;
  870|      0|  }
  871|       |
  872|       |
  873|       |  //===== loop over all search positions =====
  874|      0|  for (pos=0; pos<max_pos; pos++)
  875|      0|  {
  876|       |    //--- set candidate position (absolute position in pel units) ---
  877|      0|    cand_x = center_x + spiral_search_x[pos];
  878|      0|    cand_y = center_y + spiral_search_y[pos];
  879|       |
  880|       |    //--- initialize motion cost (cost for motion vector) and check ---
  881|      0|    mcost = MV_COST (lambda_factor, 2, cand_x, cand_y, pred_x, pred_y);
  882|      0|    if (check_for_00 && cand_x==pic_pix_x && cand_y==pic_pix_y)
  883|      0|    {
  884|      0|      mcost -= WEIGHTED_COST (lambda_factor, 16);
  885|      0|    }
  886|      0|    if (mcost >= min_mcost)   continue;
  887|       |
  888|       |    //--- add residual cost to motion cost ---
  889|      0|    for (y=0; y<blocksize_y; y++)
  890|      0|    {
  891|      0|      ref_line  = get_ref_line (blocksize_x, ref_pic, cand_y+y, cand_x, img_height, img_width);
  892|      0|      orig_line = orig_pic [y];
  893|       |
  894|      0|      for (x4=0; x4<blocksize_x4; x4++)
  895|      0|      {
  896|      0|        mcost += byte_abs[ *orig_line++ - *ref_line++ ];
  897|      0|        mcost += byte_abs[ *orig_line++ - *ref_line++ ];
  898|      0|        mcost += byte_abs[ *orig_line++ - *ref_line++ ];
  899|      0|        mcost += byte_abs[ *orig_line++ - *ref_line++ ];
  900|      0|      }
  901|       |
  902|      0|      if (mcost >= min_mcost)
  903|      0|      {
  904|      0|        break;
  905|      0|      }
  906|      0|    }
  907|       |
  908|       |    //--- check if motion cost is less than minimum cost ---
  909|      0|    if (mcost < min_mcost)
  910|      0|    {
  911|      0|      best_pos  = pos;
  912|      0|      min_mcost = mcost;
  913|      0|    }
  914|      0|  }
  915|       |
  916|       |
  917|       |  //===== set best motion vector and return minimum motion cost =====
  918|      0|  if (best_pos)
  919|      0|  {
  920|      0|    *mv_x += spiral_search_x[best_pos];
  921|      0|    *mv_y += spiral_search_y[best_pos];
  922|      0|  }
  923|      0|  return min_mcost;
  924|      0|}
  925|       |
  926|       |
  927|       |#ifdef _FAST_FULL_ME_
  928|       |/*!
  929|       | ***********************************************************************
  930|       | * \brief
  931|       | *    Fast Full pixel block motion search
  932|       | ***********************************************************************
  933|       | */
  934|       |int                                                   //  ==> minimum motion cost after search
  935|       |FastFullPelBlockMotionSearch (pel_t**   orig_pic,     // <--  not used
  936|       |                              short     ref,          // <--  reference frame (0... or -1 (backward))
  937|       |                              int       list,
  938|       |                              int       pic_pix_x,    // <--  absolute x-coordinate of regarded AxB block
  939|       |                              int       pic_pix_y,    // <--  absolute y-coordinate of regarded AxB block
  940|       |                              int       blocktype,    // <--  block type (1-16x16 ... 7-4x4)
  941|       |                              short     pred_mv_x,    // <--  motion vector predictor (x) in sub-pel units
  942|       |                              short     pred_mv_y,    // <--  motion vector predictor (y) in sub-pel units
  943|       |                              short*    mv_x,         //  --> motion vector (x) - in pel units
  944|       |                              short*    mv_y,         //  --> motion vector (y) - in pel units
  945|       |                              int       search_range, // <--  1-d search range in pel units
  946|       |                              int       min_mcost,    // <--  minimum motion cost (cost for center or huge value)
  947|       |                              double    lambda)       // <--  lagrangian parameter for determining motion cost
  948|  20.4M|{
  949|  20.4M|  int   pos, offset_x, offset_y, cand_x, cand_y, mcost;
  950|       |
  951|  20.4M|  int   max_pos       = (2*search_range+1)*(2*search_range+1);              // number of search positions
  952|  20.4M|  int   lambda_factor = LAMBDA_FACTOR (lambda);                             // factor for determining lagragian motion cost
  953|  20.4M|  int   best_pos      = 0;                                                  // position with minimum motion cost
  954|  20.4M|  int   block_index;                                                        // block index for indexing SAD array
  955|  20.4M|  int*  block_sad;                                                          // pointer to SAD array
  956|       |
  957|  20.4M|  block_index   = (pic_pix_y-img->opix_y)+((pic_pix_x-img->opix_x)>>2); // block index for indexing SAD array
  958|  20.4M|  block_sad     = BlockSAD[list][ref][blocktype][block_index];         // pointer to SAD array
  959|       |
  960|       |  //===== set up fast full integer search if needed / set search center =====
  961|  20.4M|  if (!search_setup_done[list][ref])
  962|   499k|  {
  963|   499k|    SetupFastFullPelSearch (ref, list);
  964|   499k|  }
  965|       |
  966|  20.4M|  offset_x = search_center_x[list][ref] - img->opix_x;
  967|  20.4M|  offset_y = search_center_y[list][ref] - img->opix_y;
  968|       |
  969|       |  //===== cost for (0,0)-vector: it is done before, because MVCost can be negative =====
  970|  20.4M|  if (!input->rdopt)
  971|      0|  {
  972|      0|    mcost = block_sad[pos_00[list][ref]] + MV_COST (lambda_factor, 2, 0, 0, pred_mv_x, pred_mv_y);
  973|       |
  974|      0|    if (mcost < min_mcost)
  975|      0|    {
  976|      0|      min_mcost = mcost;
  977|      0|      best_pos  = pos_00[list][ref];
  978|      0|    }
  979|      0|  }
  980|       |
  981|       |  //===== loop over all search positions =====
  982|  22.3G|  for (pos=0; pos<max_pos; pos++, block_sad++)//xxzp for
  983|  22.3G|  {
  984|       |    //--- check residual cost ---
  985|  22.3G|    if (*block_sad < min_mcost)
  986|  9.82G|    {
  987|       |      //--- get motion vector cost ---
  988|  9.82G|      cand_x = offset_x + spiral_search_x[pos];
  989|  9.82G|      cand_y = offset_y + spiral_search_y[pos];
  990|  9.82G|      mcost  = *block_sad;
  991|  9.82G|      mcost += MV_COST (lambda_factor, 2, cand_x, cand_y, pred_mv_x, pred_mv_y);
  992|       |
  993|       |      //--- check motion cost ---
  994|  9.82G|      if (mcost < min_mcost)
  995|   155M|      {
  996|   155M|        min_mcost = mcost;
  997|   155M|        best_pos  = pos;
  998|   155M|      }
  999|  9.82G|    }
 1000|  22.3G|  }
 1001|       |
 1002|       |  //===== set best motion vector and return minimum motion cost =====
 1003|  20.4M|  *mv_x = offset_x + spiral_search_x[best_pos];
 1004|  20.4M|  *mv_y = offset_y + spiral_search_y[best_pos];
 1005|  20.4M|  return min_mcost;
 1006|  20.4M|}
 1007|       |#endif
 1008|       |
 1009|       |
 1010|       |/*!
 1011|       | ***********************************************************************
 1012|       | * \brief
 1013|       | *    Calculate SA(T)D
 1014|       | ***********************************************************************
 1015|       | */
 1016|       |int
 1017|       |SATD (int* diff, int use_hadamard)
 1018|   749M|{
 1019|   749M|  int k, satd = 0, m[16], dd, d[16];
 1020|       |  
 1021|   749M|  if (use_hadamard)
 1022|   749M|  {
 1023|       |    /*===== hadamard transform =====*/
 1024|   749M|    m[ 0] = diff[ 0] + diff[12];
 1025|   749M|    m[ 4] = diff[ 4] + diff[ 8];
 1026|   749M|    m[ 8] = diff[ 4] - diff[ 8];
 1027|   749M|    m[12] = diff[ 0] - diff[12];
 1028|   749M|    m[ 1] = diff[ 1] + diff[13];
 1029|   749M|    m[ 5] = diff[ 5] + diff[ 9];
 1030|   749M|    m[ 9] = diff[ 5] - diff[ 9];
 1031|   749M|    m[13] = diff[ 1] - diff[13];
 1032|   749M|    m[ 2] = diff[ 2] + diff[14];
 1033|   749M|    m[ 6] = diff[ 6] + diff[10];
 1034|   749M|    m[10] = diff[ 6] - diff[10];
 1035|   749M|    m[14] = diff[ 2] - diff[14];
 1036|   749M|    m[ 3] = diff[ 3] + diff[15];
 1037|   749M|    m[ 7] = diff[ 7] + diff[11];
 1038|   749M|    m[11] = diff[ 7] - diff[11];
 1039|   749M|    m[15] = diff[ 3] - diff[15];
 1040|       |    
 1041|   749M|    d[ 0] = m[ 0] + m[ 4];
 1042|   749M|    d[ 8] = m[ 0] - m[ 4];
 1043|   749M|    d[ 4] = m[ 8] + m[12];
 1044|   749M|    d[12] = m[12] - m[ 8];
 1045|   749M|    d[ 1] = m[ 1] + m[ 5];
 1046|   749M|    d[ 9] = m[ 1] - m[ 5];
 1047|   749M|    d[ 5] = m[ 9] + m[13];
 1048|   749M|    d[13] = m[13] - m[ 9];
 1049|   749M|    d[ 2] = m[ 2] + m[ 6];
 1050|   749M|    d[10] = m[ 2] - m[ 6];
 1051|   749M|    d[ 6] = m[10] + m[14];
 1052|   749M|    d[14] = m[14] - m[10];
 1053|   749M|    d[ 3] = m[ 3] + m[ 7];
 1054|   749M|    d[11] = m[ 3] - m[ 7];
 1055|   749M|    d[ 7] = m[11] + m[15];
 1056|   749M|    d[15] = m[15] - m[11];
 1057|       |    
 1058|   749M|    m[ 0] = d[ 0] + d[ 3];
 1059|   749M|    m[ 1] = d[ 1] + d[ 2];
 1060|   749M|    m[ 2] = d[ 1] - d[ 2];
 1061|   749M|    m[ 3] = d[ 0] - d[ 3];
 1062|   749M|    m[ 4] = d[ 4] + d[ 7];
 1063|   749M|    m[ 5] = d[ 5] + d[ 6];
 1064|   749M|    m[ 6] = d[ 5] - d[ 6];
 1065|   749M|    m[ 7] = d[ 4] - d[ 7];
 1066|   749M|    m[ 8] = d[ 8] + d[11];
 1067|   749M|    m[ 9] = d[ 9] + d[10];
 1068|   749M|    m[10] = d[ 9] - d[10];
 1069|   749M|    m[11] = d[ 8] - d[11];
 1070|   749M|    m[12] = d[12] + d[15];
 1071|   749M|    m[13] = d[13] + d[14];
 1072|   749M|    m[14] = d[13] - d[14];
 1073|   749M|    m[15] = d[12] - d[15];
 1074|       |    
 1075|   749M|    d[ 0] = m[ 0] + m[ 1];
 1076|   749M|    d[ 1] = m[ 0] - m[ 1];
 1077|   749M|    d[ 2] = m[ 2] + m[ 3];
 1078|   749M|    d[ 3] = m[ 3] - m[ 2];
 1079|   749M|    d[ 4] = m[ 4] + m[ 5];
 1080|   749M|    d[ 5] = m[ 4] - m[ 5];
 1081|   749M|    d[ 6] = m[ 6] + m[ 7];
 1082|   749M|    d[ 7] = m[ 7] - m[ 6];
 1083|   749M|    d[ 8] = m[ 8] + m[ 9];
 1084|   749M|    d[ 9] = m[ 8] - m[ 9];
 1085|   749M|    d[10] = m[10] + m[11];
 1086|   749M|    d[11] = m[11] - m[10];
 1087|   749M|    d[12] = m[12] + m[13];
 1088|   749M|    d[13] = m[12] - m[13];
 1089|   749M|    d[14] = m[14] + m[15];
 1090|   749M|    d[15] = m[15] - m[14];
 1091|       |    
 1092|       |    /*===== sum up =====*/
 1093|  12.7G|    for (dd=d[k=0]; k<16; dd=d[++k])//xxzp unrool
 1094|  11.9G|    {
 1095|  11.9G|      satd += (dd < 0 ? -dd : dd);
 1096|  11.9G|    }
 1097|   749M|    satd = ((satd+1)>>1);
 1098|   749M|  }
 1099|      0|  else
 1100|      0|  {
 1101|       |    /*===== sum up =====*/
 1102|      0|    for (k = 0; k < 16; k++)
 1103|      0|    {
 1104|      0|      satd += byte_abs [diff [k]];
 1105|      0|    }
 1106|      0|  }
 1107|       |  
 1108|   749M|  return satd;
 1109|   749M|}
 1110|       |
 1111|       |/*!
 1112|       | ***********************************************************************
 1113|       | * \brief
 1114|       | *    Calculate SA(T)D for 8x8
 1115|       | ***********************************************************************
 1116|       | */
 1117|       |int
 1118|       |SATD8X8 (int* diff, int use_hadamard)
 1119|      0|{
 1120|      0|  int i, j, sad=0;
 1121|      0|  int m1[8][8], m2[8][8], m3[8][8];
 1122|       |
 1123|      0|  if(use_hadamard)
 1124|      0|  {
 1125|       |    //horizontal
 1126|      0|    for (j=0; j < 8; j++)
 1127|      0|    {
 1128|      0|      m2[j][0] = diff[(j<<3)  ] + diff[(j<<3)+4];
 1129|      0|      m2[j][1] = diff[(j<<3)+1] + diff[(j<<3)+5];
 1130|      0|      m2[j][2] = diff[(j<<3)+2] + diff[(j<<3)+6];
 1131|      0|      m2[j][3] = diff[(j<<3)+3] + diff[(j<<3)+7];
 1132|      0|      m2[j][4] = diff[(j<<3)  ] - diff[(j<<3)+4];
 1133|      0|      m2[j][5] = diff[(j<<3)+1] - diff[(j<<3)+5];
 1134|      0|      m2[j][6] = diff[(j<<3)+2] - diff[(j<<3)+6];
 1135|      0|      m2[j][7] = diff[(j<<3)+3] - diff[(j<<3)+7];
 1136|       |
 1137|      0|      m1[j][0] = m2[j][0] + m2[j][2];
 1138|      0|      m1[j][1] = m2[j][1] + m2[j][3];
 1139|      0|      m1[j][2] = m2[j][0] - m2[j][2];
 1140|      0|      m1[j][3] = m2[j][1] - m2[j][3];
 1141|      0|      m1[j][4] = m2[j][4] + m2[j][6];
 1142|      0|      m1[j][5] = m2[j][5] + m2[j][7];
 1143|      0|      m1[j][6] = m2[j][4] - m2[j][6];
 1144|      0|      m1[j][7] = m2[j][5] - m2[j][7];
 1145|       |
 1146|      0|      m2[j][0] = m1[j][0] + m1[j][1];
 1147|      0|      m2[j][1] = m1[j][0] - m1[j][1];
 1148|      0|      m2[j][2] = m1[j][2] + m1[j][3];
 1149|      0|      m2[j][3] = m1[j][2] - m1[j][3];
 1150|      0|      m2[j][4] = m1[j][4] + m1[j][5];
 1151|      0|      m2[j][5] = m1[j][4] - m1[j][5];
 1152|      0|      m2[j][6] = m1[j][6] + m1[j][7];
 1153|      0|      m2[j][7] = m1[j][6] - m1[j][7];
 1154|      0|    }
 1155|       |
 1156|       |    //vertical
 1157|      0|    for (i=0; i < 8; i++)
 1158|      0|    {
 1159|      0|      m3[0][i] = m2[0][i] + m2[4][i];
 1160|      0|      m3[1][i] = m2[1][i] + m2[5][i];
 1161|      0|      m3[2][i] = m2[2][i] + m2[6][i];
 1162|      0|      m3[3][i] = m2[3][i] + m2[7][i];
 1163|      0|      m3[4][i] = m2[0][i] - m2[4][i];
 1164|      0|      m3[5][i] = m2[1][i] - m2[5][i];
 1165|      0|      m3[6][i] = m2[2][i] - m2[6][i];
 1166|      0|      m3[7][i] = m2[3][i] - m2[7][i];
 1167|       |
 1168|      0|      m1[0][i] = m3[0][i] + m3[2][i];
 1169|      0|      m1[1][i] = m3[1][i] + m3[3][i];
 1170|      0|      m1[2][i] = m3[0][i] - m3[2][i];
 1171|      0|      m1[3][i] = m3[1][i] - m3[3][i];
 1172|      0|      m1[4][i] = m3[4][i] + m3[6][i];
 1173|      0|      m1[5][i] = m3[5][i] + m3[7][i];
 1174|      0|      m1[6][i] = m3[4][i] - m3[6][i];
 1175|      0|      m1[7][i] = m3[5][i] - m3[7][i];
 1176|       |
 1177|      0|      m2[0][i] = m1[0][i] + m1[1][i];
 1178|      0|      m2[1][i] = m1[0][i] - m1[1][i];
 1179|      0|      m2[2][i] = m1[2][i] + m1[3][i];
 1180|      0|      m2[3][i] = m1[2][i] - m1[3][i];
 1181|      0|      m2[4][i] = m1[4][i] + m1[5][i];
 1182|      0|      m2[5][i] = m1[4][i] - m1[5][i];
 1183|      0|      m2[6][i] = m1[6][i] + m1[7][i];
 1184|      0|      m2[7][i] = m1[6][i] - m1[7][i];
 1185|      0|    }
 1186|      0|    for (j=0; j < 8; j++)
 1187|      0|      for (i=0; i < 8; i++)
 1188|      0|        sad += (absm(m2[j][i]));
 1189|      0|    sad=((sad+2)>>2);
 1190|      0|  }
 1191|      0|  else
 1192|      0|  {
 1193|      0|    for(i=0; i<64; i++)
 1194|      0|      sad += byte_abs [diff [i]];
 1195|      0|  }
 1196|       |
 1197|      0|    return sad;
 1198|      0|}
 1199|       |
 1200|       |/*!
 1201|       | ***********************************************************************
 1202|       | * \brief
 1203|       | *    Calculate SA(T)D for 8x8
 1204|       | ***********************************************************************
 1205|       | */
 1206|       |int
 1207|       |find_SATD (int curr_diff[MB_BLOCK_SIZE][MB_BLOCK_SIZE], int use_hadamard, int blocktype)
 1208|      0|{
 1209|      0|  int i, j, k, x, y, sad=0;
 1210|      0|  int block_size_x = input->blc_size[blocktype][0];
 1211|      0|  int block_size_y = input->blc_size[blocktype][1];
 1212|      0|  int block_size = (blocktype>4) ? 4:8;
 1213|      0|  int diff[MB_BLOCK_SIZE*MB_BLOCK_SIZE];
 1214|       |
 1215|      0|  k=0;
 1216|      0|  for(y=0; y<block_size_y; y+=block_size)
 1217|      0|    for(x=0; x<block_size_x; x+=block_size)
 1218|      0|      for(j=y; j<y+block_size; j++)
 1219|      0|        for(i=x; i<x+block_size; i++, k++)
 1220|      0|          diff[k]=curr_diff[j][i];
 1221|       |
 1222|      0|  if(use_hadamard)
 1223|      0|  {
 1224|      0|    switch(blocktype)
 1225|      0|    {
 1226|       |    //16x16
 1227|      0|    case 1: 
 1228|      0|            sad  = SATD8X8 (diff, input->hadamard);
 1229|      0|            sad += SATD8X8 (&diff[64], input->hadamard);
 1230|      0|            sad += SATD8X8 (&diff[128], input->hadamard);
 1231|      0|            sad += SATD8X8 (&diff[192], input->hadamard);
 1232|      0|            break;
 1233|       |    //16x8 8x16
 1234|      0|    case 2:
 1235|      0|    case 3: sad  = SATD8X8 (diff, input->hadamard);
 1236|      0|            sad += SATD8X8 (&diff[64], input->hadamard);
 1237|      0|            break;
 1238|       |    //8x8
 1239|      0|    case 4: sad  = SATD8X8 (diff, input->hadamard);
 1240|      0|            break;
 1241|       |    //8x4 4x8
 1242|      0|    case 5:
 1243|      0|    case 6: sad  = SATD (diff, input->hadamard);
 1244|      0|            sad += SATD (&diff[16], input->hadamard);
 1245|      0|            break;
 1246|       |    //4x4
 1247|      0|    case 7: sad  = SATD (diff, input->hadamard);
 1248|      0|            break;
 1249|      0|    default:sad=-1;
 1250|      0|            break;
 1251|      0|    }
 1252|      0|  }
 1253|      0|  else
 1254|      0|  {
 1255|      0|    for(i=0; i<(block_size_y*block_size_x); i++)
 1256|      0|      sad += byte_abs[diff[i]];
 1257|      0|  }
 1258|       |
 1259|      0|  return sad;
 1260|      0|}
 1261|       |
 1262|       |/*!
 1263|       | ***********************************************************************
 1264|       | * \brief
 1265|       | *    Sub pixel block motion search
 1266|       | ***********************************************************************
 1267|       | */
 1268|       |int                                               //  ==> minimum motion cost after search
 1269|       |SubPelBlockMotionSearch (pel_t**   orig_pic,      // <--  original pixel values for the AxB block
 1270|       |                         short     ref,           // <--  reference frame (0... or -1 (backward))
 1271|       |                         int       list,          // <--  reference picture list 
 1272|       |                         int       pic_pix_x,     // <--  absolute x-coordinate of regarded AxB block
 1273|       |                         int       pic_pix_y,     // <--  absolute y-coordinate of regarded AxB block
 1274|       |                         int       blocktype,     // <--  block type (1-16x16 ... 7-4x4)
 1275|       |                         short     pred_mv_x,     // <--  motion vector predictor (x) in sub-pel units
 1276|       |                         short     pred_mv_y,     // <--  motion vector predictor (y) in sub-pel units
 1277|       |                         short*    mv_x,          // <--> in: search center (x) / out: motion vector (x) - in pel units
 1278|       |                         short*    mv_y,          // <--> in: search center (y) / out: motion vector (y) - in pel units
 1279|       |                         int       search_pos2,   // <--  search positions for    half-pel search  (default: 9)
 1280|       |                         int       search_pos4,   // <--  search positions for quarter-pel search  (default: 9)
 1281|       |                         int       min_mcost,     // <--  minimum motion cost (cost for center or huge value)
 1282|       |                         double    lambda         // <--  lagrangian parameter for determining motion cost
 1283|       |                         )
 1284|  20.4M|{
 1285|  20.4M|  int   curr_diff[MB_BLOCK_SIZE][MB_BLOCK_SIZE], i, j, k;
 1286|  20.4M|  int   diff[16], *d;
 1287|  20.4M|  int   pos, best_pos, mcost, abort_search;
 1288|  20.4M|  int   y0, x0, ry0, rx0, ry;
 1289|  20.4M|  int   cand_mv_x, cand_mv_y;
 1290|  20.4M|  int   max_pos_x4, max_pos_y4;
 1291|  20.4M|  pel_t *orig_line;
 1292|  20.4M|  pel_t **ref_pic;      
 1293|  20.4M|  StorablePicture *ref_picture;
 1294|  20.4M|  int   lambda_factor   = LAMBDA_FACTOR (lambda);
 1295|  20.4M|  int   mv_shift        = 0;
 1296|  20.4M|  int   check_position0 = (blocktype==1 && *mv_x==0 && *mv_y==0 && input->hadamard && !input->rdopt && img->type!=B_SLICE && ref==0);
 1297|  20.4M|  int   blocksize_x     = input->blc_size[blocktype][0];
 1298|  20.4M|  int   blocksize_y     = input->blc_size[blocktype][1];
 1299|  20.4M|  int   pic4_pix_x      = (pic_pix_x << 2);
 1300|  20.4M|  int   pic4_pix_y      = (pic_pix_y << 2);
 1301|  20.4M|  int   min_pos2        = (input->hadamard ? (input->hadamardqpel ? 1 : 0) : 1);
 1302|  20.4M|  int   max_pos2        = (input->hadamard ? max(1,search_pos2) : search_pos2);
 1303|  20.4M|  int   list_offset     = ((img->MbaffFrameFlag)&&(img->mb_data[img->current_mb_nr].mb_field))? img->current_mb_nr%2 ? 4 : 2 : 0;
 1304|       |
 1305|  20.4M|  int  apply_weights = ( (active_pps->weighted_pred_flag && (img->type == P_SLICE || img->type == SP_SLICE)) ||
 1306|  20.4M|                         (active_pps->weighted_bipred_idc && (img->type == B_SLICE)));  
 1307|       |
 1308|  20.4M|  int   img_width, img_height;
 1309|       |  
 1310|  20.4M|  int   halfpelhadamard       = input->hadamardqpel ? 0 : input->hadamard;
 1311|  20.4M|  int   qpelstart             = input->hadamardqpel ? 0 : 1;
 1312|       |
 1313|  20.4M|  ref_picture     = listX[list+list_offset][ref];
 1314|       |
 1315|       |  //===== Use weighted Reference for ME ====
 1316|  20.4M|  if (apply_weights && input->UseWeightedReferenceME)
 1317|      0|  {
 1318|      0|    ref_pic = listX[list+list_offset][ref]->imgY_ups_w;
 1319|      0|  }
 1320|  20.4M|  else
 1321|  20.4M|    ref_pic = listX[list+list_offset][ref]->imgY_ups;
 1322|       |
 1323|  20.4M|  img_width  = ref_picture->size_x;
 1324|  20.4M|  img_height = ref_picture->size_y;
 1325|       |
 1326|  20.4M|  max_pos_x4      = ((ref_picture->size_x - blocksize_x+1)<<2);
 1327|  20.4M|  max_pos_y4      = ((ref_picture->size_y - blocksize_y+1)<<2);
 1328|       |  
 1329|       |  /*********************************
 1330|       |   *****                       *****
 1331|       |   *****  HALF-PEL REFINEMENT  *****
 1332|       |   *****                       *****
 1333|       |   *********************************/
 1334|       |  //===== convert search center to quarter-pel units =====
 1335|  20.4M|  *mv_x <<= 2;
 1336|  20.4M|  *mv_y <<= 2;
 1337|       |  //===== set function for getting pixel values =====
 1338|  20.4M|  if ((pic4_pix_x + *mv_x > 1) && (pic4_pix_x + *mv_x < max_pos_x4 - 2) &&
 1339|  20.4M|      (pic4_pix_y + *mv_y > 1) && (pic4_pix_y + *mv_y < max_pos_y4 - 2)   )
 1340|  19.6M|  {
 1341|  19.6M|    PelY_14 = FastPelY_14;
 1342|  19.6M|  }
 1343|   887k|  else
 1344|   887k|  {
 1345|   887k|    PelY_14 = UMVPelY_14;
 1346|   887k|  }
 1347|       |  //===== loop over search positions =====
 1348|   204M|  for (best_pos = 0, pos = min_pos2; pos < max_pos2; pos++)
 1349|   184M|  {
 1350|   184M|    cand_mv_x = *mv_x + (spiral_search_x[pos] << 1);    // quarter-pel units
 1351|   184M|    cand_mv_y = *mv_y + (spiral_search_y[pos] << 1);    // quarter-pel units
 1352|       |
 1353|       |    //----- set motion vector cost -----
 1354|   184M|    mcost = MV_COST (lambda_factor, mv_shift, cand_mv_x, cand_mv_y, pred_mv_x, pred_mv_y);
 1355|   184M|    if (check_position0 && pos==0)
 1356|      0|    {
 1357|      0|      mcost -= WEIGHTED_COST (lambda_factor, 16);
 1358|      0|    }
 1359|       |
 1360|   184M|    if (mcost >= min_mcost) continue;
 1361|       |
 1362|       |    //----- add up SATD -----
 1363|   338M|    for (y0=0, abort_search=0; y0<blocksize_y && !abort_search; y0+=4)
 1364|   206M|    {
 1365|   206M|      ry0 = ((pic_pix_y+y0)<<2) + cand_mv_y;
 1366|       |
 1367|   474M|      for (x0=0; x0<blocksize_x; x0+=4)
 1368|   368M|      {
 1369|   368M|        rx0 = ((pic_pix_x+x0)<<2) + cand_mv_x;
 1370|   368M|        d   = diff;
 1371|       |
 1372|   368M|        orig_line = orig_pic [y0  ];    ry=ry0;
 1373|   368M|        *d++      = orig_line[x0  ]  -  PelY_14 (ref_pic, ry, rx0   , img_height, img_width);
 1374|   368M|        *d++      = orig_line[x0+1]  -  PelY_14 (ref_pic, ry, rx0+ 4, img_height, img_width);
 1375|   368M|        *d++      = orig_line[x0+2]  -  PelY_14 (ref_pic, ry, rx0+ 8, img_height, img_width);
 1376|   368M|        *d++      = orig_line[x0+3]  -  PelY_14 (ref_pic, ry, rx0+12, img_height, img_width);
 1377|       |
 1378|   368M|        orig_line = orig_pic [y0+1];    ry=ry0+4;
 1379|   368M|        *d++      = orig_line[x0  ]  -  PelY_14 (ref_pic, ry, rx0   , img_height, img_width);
 1380|   368M|        *d++      = orig_line[x0+1]  -  PelY_14 (ref_pic, ry, rx0+ 4, img_height, img_width);
 1381|   368M|        *d++      = orig_line[x0+2]  -  PelY_14 (ref_pic, ry, rx0+ 8, img_height, img_width);
 1382|   368M|        *d++      = orig_line[x0+3]  -  PelY_14 (ref_pic, ry, rx0+12, img_height, img_width);
 1383|       |
 1384|   368M|        orig_line = orig_pic [y0+2];    ry=ry0+8;
 1385|   368M|        *d++      = orig_line[x0  ]  -  PelY_14 (ref_pic, ry, rx0   , img_height, img_width);
 1386|   368M|        *d++      = orig_line[x0+1]  -  PelY_14 (ref_pic, ry, rx0+ 4, img_height, img_width);
 1387|   368M|        *d++      = orig_line[x0+2]  -  PelY_14 (ref_pic, ry, rx0+ 8, img_height, img_width);
 1388|   368M|        *d++      = orig_line[x0+3]  -  PelY_14 (ref_pic, ry, rx0+12, img_height, img_width);
 1389|       |
 1390|   368M|        orig_line = orig_pic [y0+3];    ry=ry0+12;
 1391|   368M|        *d++      = orig_line[x0  ]  -  PelY_14 (ref_pic, ry, rx0   , img_height, img_width);
 1392|   368M|        *d++      = orig_line[x0+1]  -  PelY_14 (ref_pic, ry, rx0+ 4, img_height, img_width);
 1393|   368M|        *d++      = orig_line[x0+2]  -  PelY_14 (ref_pic, ry, rx0+ 8, img_height, img_width);
 1394|   368M|        *d        = orig_line[x0+3]  -  PelY_14 (ref_pic, ry, rx0+12, img_height, img_width);
 1395|       |
 1396|   368M|        if (!input->AllowTransform8x8)
 1397|   368M|        {
 1398|   368M|          if ((mcost += SATD (diff, halfpelhadamard)) > min_mcost)
 1399|   100M|          {
 1400|   100M|            abort_search = 1;
 1401|   100M|            break;
 1402|   100M|          }
 1403|   368M|        }
 1404|      0|        else
 1405|      0|        {
 1406|      0|          for(j=0, k=0; j<4; j++)
 1407|      0|            for(i=0; i<4; i++, k++)
 1408|      0|              curr_diff[y0+j][x0+i] = diff[k];
 1409|      0|        }
 1410|   368M|       }
 1411|   206M|    }
 1412|       |
 1413|   131M|    if(input->AllowTransform8x8)
 1414|      0|      mcost += find_SATD (curr_diff, halfpelhadamard, blocktype);
 1415|       |
 1416|   131M|    if (mcost < min_mcost)
 1417|  27.7M|    {
 1418|  27.7M|      min_mcost = mcost;
 1419|  27.7M|      best_pos  = pos;
 1420|  27.7M|    }
 1421|   131M|  }
 1422|  20.4M|  if (best_pos)
 1423|  5.56M|  {
 1424|  5.56M|    *mv_x += (spiral_search_x [best_pos] << 1);
 1425|  5.56M|    *mv_y += (spiral_search_y [best_pos] << 1);
 1426|  5.56M|  }
 1427|       |
 1428|       |
 1429|  20.4M|  if (input->hadamardqpel)
 1430|      0|    min_mcost = INT_MAX;
 1431|       |
 1432|       |  /************************************
 1433|       |   *****                          *****
 1434|       |   *****  QUARTER-PEL REFINEMENT  *****
 1435|       |   *****                          *****
 1436|       |   ************************************/
 1437|       |  //===== set function for getting pixel values =====
 1438|  20.4M|  if ((pic4_pix_x + *mv_x > 1) && (pic4_pix_x + *mv_x < max_pos_x4 - 1) &&
 1439|  20.4M|      (pic4_pix_y + *mv_y > 1) && (pic4_pix_y + *mv_y < max_pos_y4 - 1)   )
 1440|  19.6M|  {
 1441|  19.6M|    PelY_14 = FastPelY_14;
 1442|  19.6M|  }
 1443|   881k|  else
 1444|   881k|  {
 1445|   881k|    PelY_14 = UMVPelY_14;
 1446|   881k|  }
 1447|       |  //===== loop over search positions =====
 1448|   184M|  for (best_pos = 0, pos = qpelstart; pos < search_pos4; pos++)
 1449|   163M|  {
 1450|   163M|    cand_mv_x = *mv_x + spiral_search_x[pos];    // quarter-pel units
 1451|   163M|    cand_mv_y = *mv_y + spiral_search_y[pos];    // quarter-pel units
 1452|       |
 1453|       |    //----- set motion vector cost -----
 1454|   163M|    mcost = MV_COST (lambda_factor, mv_shift, cand_mv_x, cand_mv_y, pred_mv_x, pred_mv_y);
 1455|       |
 1456|   163M|    if (mcost >= min_mcost) continue;
 1457|       |
 1458|       |    //----- add up SATD -----
 1459|   350M|    for (y0=0, abort_search=0; y0<blocksize_y && !abort_search; y0+=4)
 1460|   213M|    {
 1461|   213M|      ry0 = ((pic_pix_y+y0)<<2) + cand_mv_y;
 1462|       |
 1463|   464M|      for (x0=0; x0<blocksize_x; x0+=4)
 1464|   374M|      {
 1465|   374M|        rx0 = ((pic_pix_x+x0)<<2) + cand_mv_x;
 1466|   374M|        d   = diff;
 1467|       |
 1468|   374M|        orig_line = orig_pic [y0  ];    ry=ry0;
 1469|   374M|        *d++      = orig_line[x0  ]  -  PelY_14 (ref_pic, ry, rx0   , img_height, img_width);
 1470|   374M|        *d++      = orig_line[x0+1]  -  PelY_14 (ref_pic, ry, rx0+ 4, img_height, img_width);
 1471|   374M|        *d++      = orig_line[x0+2]  -  PelY_14 (ref_pic, ry, rx0+ 8, img_height, img_width);
 1472|   374M|        *d++      = orig_line[x0+3]  -  PelY_14 (ref_pic, ry, rx0+12, img_height, img_width);
 1473|       |
 1474|   374M|        orig_line = orig_pic [y0+1];    ry=ry0+4;
 1475|   374M|        *d++      = orig_line[x0  ]  -  PelY_14 (ref_pic, ry, rx0   , img_height, img_width);
 1476|   374M|        *d++      = orig_line[x0+1]  -  PelY_14 (ref_pic, ry, rx0+ 4, img_height, img_width);
 1477|   374M|        *d++      = orig_line[x0+2]  -  PelY_14 (ref_pic, ry, rx0+ 8, img_height, img_width);
 1478|   374M|        *d++      = orig_line[x0+3]  -  PelY_14 (ref_pic, ry, rx0+12, img_height, img_width);
 1479|       |
 1480|   374M|        orig_line = orig_pic [y0+2];    ry=ry0+8;
 1481|   374M|        *d++      = orig_line[x0  ]  -  PelY_14 (ref_pic, ry, rx0   , img_height, img_width);
 1482|   374M|        *d++      = orig_line[x0+1]  -  PelY_14 (ref_pic, ry, rx0+ 4, img_height, img_width);
 1483|   374M|        *d++      = orig_line[x0+2]  -  PelY_14 (ref_pic, ry, rx0+ 8, img_height, img_width);
 1484|   374M|        *d++      = orig_line[x0+3]  -  PelY_14 (ref_pic, ry, rx0+12, img_height, img_width);
 1485|       |
 1486|   374M|        orig_line = orig_pic [y0+3];    ry=ry0+12;
 1487|   374M|        *d++      = orig_line[x0  ]  -  PelY_14 (ref_pic, ry, rx0   , img_height, img_width);
 1488|   374M|        *d++      = orig_line[x0+1]  -  PelY_14 (ref_pic, ry, rx0+ 4, img_height, img_width);
 1489|   374M|        *d++      = orig_line[x0+2]  -  PelY_14 (ref_pic, ry, rx0+ 8, img_height, img_width);
 1490|   374M|        *d        = orig_line[x0+3]  -  PelY_14 (ref_pic, ry, rx0+12, img_height, img_width);
 1491|       |
 1492|   374M|        if (!input->AllowTransform8x8)
 1493|   374M|        {
 1494|   374M|          if ((mcost += SATD (diff, input->hadamard)) > min_mcost)
 1495|   123M|          {
 1496|   123M|            abort_search = 1;
 1497|   123M|            break;
 1498|   123M|          }
 1499|   374M|        }
 1500|      0|        else
 1501|      0|        {
 1502|      0|          for(j=0, k=0; j<4; j++)
 1503|      0|            for(i=0; i<4; i++, k++)
 1504|      0|              curr_diff[y0+j][x0+i] = diff[k];
 1505|      0|        }
 1506|   374M|      }
 1507|   213M|    }
 1508|       |
 1509|   136M|    if(input->AllowTransform8x8)
 1510|      0|      mcost += find_SATD (curr_diff, input->hadamard, blocktype);
 1511|       |
 1512|   136M|    if (mcost < min_mcost)
 1513|  8.41M|    {
 1514|  8.41M|      min_mcost = mcost;
 1515|  8.41M|      best_pos  = pos;
 1516|  8.41M|    }
 1517|   136M|  }
 1518|  20.4M|  if (best_pos)
 1519|  6.18M|  {
 1520|  6.18M|    *mv_x += spiral_search_x [best_pos];
 1521|  6.18M|    *mv_y += spiral_search_y [best_pos];
 1522|  6.18M|  }
 1523|       |
 1524|       |  //===== return minimum motion cost =====
 1525|  20.4M|  return min_mcost;
 1526|  20.4M|}
 1527|       |
 1528|       |#if BI_PREDICTION
 1529|       |
 1530|       |/*!
 1531|       | ***********************************************************************
 1532|       | * \brief
 1533|       | *    Full pixel block motion search
 1534|       | ***********************************************************************
 1535|       | */
 1536|       |int                                               //  ==> minimum motion cost after search
 1537|       |FullPelBlockMotionBiPred (pel_t**   orig_pic,     // <--  original pixel values for the AxB block
 1538|       |                          short       ref,          // <--  reference frame (0... or -1 (backward))
 1539|       |                          int       list,
 1540|       |                          int       pic_pix_x,    // <--  absolute x-coordinate of regarded AxB block
 1541|       |                          int       pic_pix_y,    // <--  absolute y-coordinate of regarded AxB block
 1542|       |                          int       blocktype,    // <--  block type (1-16x16 ... 7-4x4)
 1543|       |                          int       iteration,    
 1544|       |                          short     pred_mv_x1,    // <--  motion vector predictor (x) in sub-pel units
 1545|       |                          short     pred_mv_y1,    // <--  motion vector predictor (y) in sub-pel units
 1546|       |                          short     pred_mv_x2,    // <--  motion vector predictor (x) in sub-pel units
 1547|       |                          short     pred_mv_y2,    // <--  motion vector predictor (y) in sub-pel units
 1548|       |                          short*    mv_x,         // <--> in: search center (x) / out: motion vector (x) - in pel units
 1549|       |                          short*    mv_y,         // <--> in: search center (y) / out: motion vector (y) - in pel units
 1550|       |                          short*    s_mv_x,         // <--> in: search center (x) / out: motion vector (x) - in pel units
 1551|       |                          short*    s_mv_y,         // <--> in: search center (y) / out: motion vector (y) - in pel units
 1552|       |                          int       search_range, // <--  1-d search range in pel units
 1553|       |                          int       min_mcost,    // <--  minimum motion cost (cost for center or huge value)
 1554|       |                          double    lambda)       // <--  lagrangian parameter for determining motion cost
 1555|      0|{
 1556|      0|  int   pos, cand_x, cand_y, y, x4, mcost;
 1557|       |  
 1558|      0|  pel_t *orig_line, *ref2_line, *ref1_line;
 1559|      0|  pel_t *(*get_ref_line1)(int, pel_t*, int, int, int, int);
 1560|      0|  pel_t *(*get_ref_line2)(int, pel_t*, int, int, int, int);
 1561|       |
 1562|      0|  int   list_offset   = ((img->MbaffFrameFlag)&&(img->mb_data[img->current_mb_nr].mb_field))? img->current_mb_nr%2 ? 4 : 2 : 0;
 1563|      0|  pel_t *ref1_pic     = listX[list + list_offset          ][ref]->imgY_11;
 1564|      0|  pel_t *ref2_pic     = listX[list ==0? 1 + list_offset: list_offset][ 0 ]->imgY_11;  
 1565|      0|  int   img_width     = listX[list+list_offset            ][ref]->size_x;
 1566|      0|  int   img_height    = listX[list+list_offset            ][ref]->size_y;
 1567|       |
 1568|      0|  int   best_pos      = 0;                                        // position with minimum motion cost
 1569|      0|  int   max_pos       = (2*search_range+1)*(2*search_range+1);    // number of search positions
 1570|      0|  int   lambda_factor = LAMBDA_FACTOR (lambda);                   // factor for determining lagragian motion cost
 1571|      0|  int   blocksize_y   = input->blc_size[blocktype][1];            // vertical block size
 1572|      0|  int   blocksize_x   = input->blc_size[blocktype][0];            // horizontal block size
 1573|      0|  int   blocksize_x4  = blocksize_x >> 2;                         // horizontal block size in 4-pel units
 1574|      0|  int   pred_x1        = (pic_pix_x << 2) + pred_mv_x1;       // predicted position x (in sub-pel units)
 1575|      0|  int   pred_y1        = (pic_pix_y << 2) + pred_mv_y1;       // predicted position y (in sub-pel units)
 1576|      0|  int   pred_x2        = (pic_pix_x << 2) + pred_mv_x2;       // predicted position x (in sub-pel units)
 1577|      0|  int   pred_y2        = (pic_pix_y << 2) + pred_mv_y2;       // predicted position y (in sub-pel units)
 1578|      0|  short center_x      = pic_pix_x + *mv_x;                      // center position x (in pel units)
 1579|      0|  short center_y      = pic_pix_y + *mv_y;                      // center position y (in pel units)
 1580|      0|  short ref1_center_x = pic_pix_x + *s_mv_x;                      // mvx of second pred (in pel units)
 1581|      0|  short ref1_center_y = pic_pix_y + *s_mv_y;                      // mvy of second pred (in pel units)
 1582|       |  
 1583|       |  
 1584|      0|  int   bi_diff; 
 1585|      0|  short apply_weights   = (active_pps->weighted_bipred_idc>0);  
 1586|      0|  short weightSpic = (apply_weights ? (list == 0? wbp_weight[list_offset    ][ref][0  ][0]: wbp_weight[list_offset + 1][0  ][ref][0]) : 1<<luma_log_weight_denom);
 1587|      0|  short weightRpic = (apply_weights ? (list == 0? wbp_weight[list_offset + 1][ref][0  ][0]: wbp_weight[list_offset    ][0  ][ref][0]) : 1<<luma_log_weight_denom);
 1588|      0|  short offsetSpic = (apply_weights ? (list == 0?  wp_offset[list_offset    ][ref]     [0]:  wp_offset[list_offset + 1][0  ]     [0]) : 0);
 1589|      0|  short offsetRpic = (apply_weights ? (list == 0?  wp_offset[list_offset + 1][ref]     [0]:  wp_offset[list_offset    ][0  ]     [0]) : 0);
 1590|      0|  short weightedpel,pixel1,pixel2;
 1591|      0|  short offsetBi=(offsetRpic + offsetSpic + 1)>>1;
 1592|       |  //===== set function for getting reference picture lines =====
 1593|      0|  if ((center_x > search_range) && (center_x < img->width -1-search_range-blocksize_x) &&
 1594|      0|    (center_y > search_range) && (center_y < img->height-1-search_range-blocksize_y)   )
 1595|      0|  {
 1596|      0|    get_ref_line2 = FastLineX;
 1597|      0|  }
 1598|      0|  else
 1599|      0|  {
 1600|      0|    get_ref_line2 = UMVLineX;
 1601|      0|  }
 1602|       |  
 1603|       |  //===== set function for getting reference picture lines =====
 1604|      0|  if ((ref1_center_x > search_range) && (ref1_center_x < img->width -1-search_range-blocksize_x) &&
 1605|      0|      (ref1_center_y > search_range) && (ref1_center_y < img->height-1-search_range-blocksize_y)   )
 1606|      0|  {
 1607|      0|    get_ref_line1 = FastLineX;
 1608|      0|  }
 1609|      0|  else
 1610|      0|  {
 1611|      0|    get_ref_line1 = UMVLineX;
 1612|      0|  }
 1613|       |
 1614|       |  //===== loop over all search positions =====
 1615|      0|  for (pos=0; pos<max_pos; pos++)
 1616|      0|  {
 1617|       |    //--- set candidate position (absolute position in pel units) ---
 1618|      0|    cand_x = center_x + spiral_search_x[pos];
 1619|      0|    cand_y = center_y + spiral_search_y[pos];
 1620|       |
 1621|       |    //--- initialize motion cost (cost for motion vector) and check ---
 1622|      0|    mcost =  MV_COST (lambda_factor, 2, ref1_center_x, ref1_center_y, pred_x1, pred_y1);
 1623|      0|    mcost += MV_COST (lambda_factor, 2,        cand_x,        cand_y, pred_x2, pred_y2);
 1624|       |
 1625|      0|    if (mcost >= min_mcost)   continue;
 1626|       |
 1627|       |    //--- add residual cost to motion cost ---
 1628|      0|    if (apply_weights)
 1629|      0|    {
 1630|      0|      for (y=0; y<blocksize_y; y++)
 1631|      0|      {
 1632|      0|        ref2_line  = get_ref_line2 (blocksize_x, ref2_pic,        cand_y+y,        cand_x, img_height, img_width);
 1633|      0|        ref1_line  = get_ref_line1 (blocksize_x, ref1_pic, ref1_center_y+y, ref1_center_x, img_height, img_width);
 1634|      0|        orig_line = orig_pic [y];
 1635|       |        
 1636|      0|        for (x4=0; x4<blocksize_x4; x4++)
 1637|      0|        { 
 1638|      0|          pixel1=weightSpic * (*ref1_line++);
 1639|      0|          pixel2=weightRpic * (*ref2_line++);
 1640|      0|          weightedpel =  Clip3 (0, img->max_imgpel_value ,((pixel1 + pixel2 +
 1641|      0|                                2 * wp_luma_round) >> (luma_log_weight_denom + 1)) + (offsetBi));
 1642|      0|          bi_diff = (*orig_line++)  - weightedpel;
 1643|      0|          mcost += byte_abs[bi_diff];
 1644|       |          
 1645|      0|          pixel1=weightSpic * (*ref1_line++);
 1646|      0|          pixel2=weightRpic * (*ref2_line++);
 1647|      0|          weightedpel =  Clip3 (0, img->max_imgpel_value ,((pixel1 + pixel2 +
 1648|      0|                                2 * wp_luma_round) >> (luma_log_weight_denom + 1)) + (offsetBi));
 1649|      0|          bi_diff = (*orig_line++)  - weightedpel;
 1650|      0|          mcost += byte_abs[bi_diff];
 1651|       |          
 1652|      0|          pixel1=weightSpic * (*ref1_line++);
 1653|      0|          pixel2=weightRpic * (*ref2_line++);
 1654|      0|          weightedpel =  Clip3 (0, img->max_imgpel_value ,((pixel1 + pixel2 +
 1655|      0|                                2 * wp_luma_round) >> (luma_log_weight_denom + 1)) + (offsetBi));
 1656|      0|          bi_diff = (*orig_line++)  - weightedpel;
 1657|      0|          mcost += byte_abs[bi_diff];
 1658|       |          
 1659|      0|          pixel1=weightSpic * (*ref1_line++);
 1660|      0|          pixel2=weightRpic * (*ref2_line++);
 1661|      0|          weightedpel =  Clip3 (0, img->max_imgpel_value ,((pixel1 + pixel2 +
 1662|      0|                                2 * wp_luma_round) >> (luma_log_weight_denom + 1)) + (offsetBi));
 1663|      0|          bi_diff = (*orig_line++)  - weightedpel;
 1664|      0|          mcost += byte_abs[bi_diff];
 1665|      0|        }    
 1666|       |      
 1667|      0|        if (mcost >= min_mcost)
 1668|      0|        {
 1669|      0|          break;
 1670|      0|        }        
 1671|      0|      }
 1672|      0|    }
 1673|      0|    else
 1674|      0|    {
 1675|      0|      for (y=0; y<blocksize_y; y++)
 1676|      0|      {
 1677|      0|        ref2_line = get_ref_line2 (blocksize_x, ref2_pic,        cand_y+y,        cand_x, img_height, img_width);
 1678|      0|        ref1_line = get_ref_line1 (blocksize_x, ref1_pic, ref1_center_y+y, ref1_center_x, img_height, img_width);
 1679|      0|        orig_line = orig_pic [y];
 1680|       |        
 1681|      0|        for (x4=0; x4<blocksize_x4; x4++)
 1682|      0|        {         
 1683|      0|          bi_diff = (*orig_line++) - (((*ref1_line++) + *ref2_line++)>>1) ;
 1684|      0|          mcost += byte_abs[bi_diff];
 1685|      0|          bi_diff = (*orig_line++) - (((*ref1_line++) + *ref2_line++)>>1) ;
 1686|      0|          mcost += byte_abs[bi_diff];
 1687|      0|          bi_diff = (*orig_line++) - (((*ref1_line++) + *ref2_line++)>>1) ;
 1688|      0|          mcost += byte_abs[bi_diff];
 1689|      0|          bi_diff = (*orig_line++) - (((*ref1_line++) + *ref2_line++)>>1) ;
 1690|      0|          mcost += byte_abs[bi_diff];
 1691|      0|        }    
 1692|       |        
 1693|      0|        if (mcost >= min_mcost)
 1694|      0|        {
 1695|      0|          break;
 1696|      0|        }
 1697|      0|      }
 1698|      0|    }
 1699|       |    
 1700|       |    //--- check if motion cost is less than minimum cost ---
 1701|      0|    if (mcost < min_mcost)
 1702|      0|    {
 1703|      0|      best_pos  = pos;
 1704|      0|      min_mcost = mcost;
 1705|      0|    }
 1706|      0|  }
 1707|       |
 1708|       |
 1709|       |  //===== set best motion vector and return minimum motion cost =====
 1710|      0|  if (best_pos)
 1711|      0|  {
 1712|      0|    *mv_x += spiral_search_x[best_pos];
 1713|      0|    *mv_y += spiral_search_y[best_pos];
 1714|      0|  }
 1715|      0|  return min_mcost;
 1716|      0|}
 1717|       |
 1718|       |/*!
 1719|       |***********************************************************************
 1720|       |* \brief
 1721|       |*    Sub pixel block motion search
 1722|       |***********************************************************************
 1723|       |*/
 1724|       |int                                               //  ==> minimum motion cost after search
 1725|       |SubPelBlockSearchBiPred (pel_t**   orig_pic,      // <--  original pixel values for the AxB block
 1726|       |                         short       ref,           // <--  reference frame (0... or -1 (backward))
 1727|       |                         int       list,          // <--  reference picture list 
 1728|       |                         int       pic_pix_x,     // <--  absolute x-coordinate of regarded AxB block
 1729|       |                         int       pic_pix_y,     // <--  absolute y-coordinate of regarded AxB block
 1730|       |                         int       blocktype,     // <--  block type (1-16x16 ... 7-4x4)
 1731|       |                         short     pred_mv_x,     // <--  motion vector predictor (x) in sub-pel units
 1732|       |                         short     pred_mv_y,     // <--  motion vector predictor (y) in sub-pel units
 1733|       |                         short*    mv_x,          // <--> in: search center (x) / out: motion vector (x) - in pel units
 1734|       |                         short*    mv_y,          // <--> in: search center (y) / out: motion vector (y) - in pel units
 1735|       |                         short*    s_mv_x,          // <--> in: search center (x) / out: motion vector (x) - in pel units
 1736|       |                         short*    s_mv_y,          // <--> in: search center (y) / out: motion vector (y) - in pel units
 1737|       |                         int       search_pos2,   // <--  search positions for    half-pel search  (default: 9)
 1738|       |                         int       search_pos4,   // <--  search positions for quarter-pel search  (default: 9)
 1739|       |                         int       min_mcost,     // <--  minimum motion cost (cost for center or huge value)
 1740|       |                         double    lambda         // <--  lagrangian parameter for determining motion cost
 1741|       |                         )
 1742|      0|{
 1743|      0|  int   curr_diff[MB_BLOCK_SIZE][MB_BLOCK_SIZE], i, j, k;
 1744|      0|  int   diff[16], *d;  
 1745|      0|  short pos, best_pos, mcost, abort_search;
 1746|      0|  short y0, x0, ry0, rx0, ry;
 1747|      0|  short sy0, sy, sx0;
 1748|      0|  short cand_mv_x, cand_mv_y;
 1749|      0|  short max_pos_x4, max_pos_y4;
 1750|      0|  pel_t *orig_line;
 1751|       |  
 1752|      0|  StorablePicture *ref_picture;
 1753|       |
 1754|      0|  int   lambda_factor   = LAMBDA_FACTOR (lambda);
 1755|      0|  short mv_shift        = 0;
 1756|      0|  short blocksize_x     = input->blc_size[blocktype][0];
 1757|      0|  short blocksize_y     = input->blc_size[blocktype][1];
 1758|      0|  short pic4_pix_x      = (pic_pix_x << 2);
 1759|      0|  short pic4_pix_y      = (pic_pix_y << 2);
 1760|      0|  short min_pos2        = (input->hadamard ? 0 : 1);
 1761|      0|  short max_pos2        = (input->hadamard ? max(1,search_pos2) : search_pos2);
 1762|      0|  short list_offset     = ((img->MbaffFrameFlag)&&(img->mb_data[img->current_mb_nr].mb_field))? img->current_mb_nr%2 ? 4 : 2 : 0;
 1763|       |
 1764|      0|  short apply_weights =  (active_pps->weighted_bipred_idc );  
 1765|      0|  short weightSpic = (apply_weights ? (list == 0? wbp_weight[list_offset    ][ref][0  ][0]: wbp_weight[list_offset + 1][0  ][ref][0]) : 1);
 1766|      0|  short weightRpic = (apply_weights ? (list == 0? wbp_weight[list_offset + 1][ref][0  ][0]: wbp_weight[list_offset    ][0  ][ref][0]) : 1);
 1767|      0|  short offsetSpic = (apply_weights ? (list == 0?  wp_offset[list_offset    ][ref]     [0]:  wp_offset[list_offset + 1][0  ]     [0]) : 0);
 1768|      0|  short offsetRpic = (apply_weights ? (list == 0?  wp_offset[list_offset + 1][ref]     [0]:  wp_offset[list_offset    ][0  ]     [0]) : 0);
 1769|       |
 1770|      0|  short offsetBi=(offsetRpic + offsetSpic + 1)>>1;
 1771|      0|  int   weightedpel;
 1772|       |
 1773|      0|  int   img_width, img_height;
 1774|       |
 1775|      0|  int   halfpelhadamard = input->hadamardqpel ? 0 : input->hadamard;
 1776|      0|  int   qpelstart = input->hadamardqpel ? 0 : 1;
 1777|       |
 1778|      0|  pel_t **ref1_pic      = listX[list+list_offset                    ][ref]->imgY_ups;      
 1779|      0|  pel_t **ref2_pic      = listX[list==0? 1 +list_offset: list_offset][0  ]->imgY_ups;  
 1780|       |  
 1781|      0|  ref_picture     = listX[list+list_offset][ref];
 1782|       |  
 1783|       |    
 1784|      0|  img_width  = ref_picture->size_x;
 1785|      0|  img_height = ref_picture->size_y;
 1786|       |
 1787|      0|  max_pos_x4      = ((ref_picture->size_x - blocksize_x+1)<<2);
 1788|      0|  max_pos_y4      = ((ref_picture->size_y - blocksize_y+1)<<2);
 1789|       |  
 1790|       |  /*********************************
 1791|       |   *****                       *****
 1792|       |   *****  HALF-PEL REFINEMENT  *****
 1793|       |   *****                       *****
 1794|       |   *********************************/
 1795|       |  //===== convert search center to quarter-pel units =====
 1796|       |
 1797|       |
 1798|      0|  *mv_x <<= 2;
 1799|      0|  *mv_y <<= 2;
 1800|       |  //===== set function for getting pixel values =====
 1801|      0|  if ((pic4_pix_x + *mv_x > 1) && (pic4_pix_x + *mv_x < max_pos_x4 - 2) &&
 1802|      0|      (pic4_pix_y + *mv_y > 1) && (pic4_pix_y + *mv_y < max_pos_y4 - 2)   )
 1803|      0|  {
 1804|      0|    PelY_14 = FastPelY_14;
 1805|      0|  }
 1806|      0|  else
 1807|      0|  {
 1808|      0|    PelY_14 = UMVPelY_14;
 1809|      0|  }
 1810|       |
 1811|      0|  if ((pic4_pix_x + *s_mv_x > 1) && (pic4_pix_x + *s_mv_x < max_pos_x4 - 2) &&
 1812|      0|      (pic4_pix_y + *s_mv_y > 1) && (pic4_pix_y + *s_mv_y < max_pos_y4 - 2)   )
 1813|      0|  {
 1814|      0|    PelY_14b = FastPelY_14;
 1815|      0|  }
 1816|      0|  else
 1817|      0|  {
 1818|      0|    PelY_14b = UMVPelY_14;
 1819|      0|  }
 1820|       |
 1821|       |  //===== loop over search positions =====
 1822|      0|  for (best_pos = 0, pos = min_pos2; pos < max_pos2; pos++)
 1823|      0|  {
 1824|      0|    cand_mv_x = *mv_x + (spiral_search_x[pos] << 1);    // quarter-pel units
 1825|      0|    cand_mv_y = *mv_y + (spiral_search_y[pos] << 1);    // quarter-pel units
 1826|       |    
 1827|       |    //----- set motion vector cost -----
 1828|      0|    mcost = MV_COST (lambda_factor, mv_shift, cand_mv_x, cand_mv_y, pred_mv_x, pred_mv_y);
 1829|       |  
 1830|       |    //----- add up SATD -----
 1831|      0|    for (y0=0, abort_search=0; y0<blocksize_y && !abort_search; y0+=4)
 1832|      0|    {
 1833|      0|      sy0 = ((pic_pix_y + y0)<<2) + *s_mv_y;
 1834|      0|      ry0 = ((pic_pix_y + y0)<<2) + cand_mv_y;
 1835|       |      
 1836|      0|      if (apply_weights)
 1837|      0|      {
 1838|      0|        for (x0=0; x0<blocksize_x; x0+=4)
 1839|      0|        {
 1840|      0|          sx0 = ((pic_pix_x + x0)<<2) + *s_mv_x ;
 1841|      0|          rx0 = ((pic_pix_x + x0)<<2) + cand_mv_x;
 1842|      0|          d   = diff;
 1843|       |          
 1844|      0|          sy=sy0;
 1845|      0|          ry=ry0;          
 1846|      0|          orig_line = orig_pic [y0  ];    
 1847|      0|          weightedpel =  Clip3 (0, img->max_imgpel_value , ((weightSpic * PelY_14b (ref1_pic, sy, sx0 , img_height, img_width) + 
 1848|      0|                                                             weightRpic * PelY_14 (ref2_pic, ry, rx0   , img_height, img_width) + 
 1849|      0|                                                             2 * wp_luma_round) >> (luma_log_weight_denom + 1)) + (offsetBi));
 1850|      0|          *d++      = (orig_line[x0  ] - weightedpel);
 1851|      0|          weightedpel =  Clip3 (0, img->max_imgpel_value , ((weightSpic * PelY_14b (ref1_pic, sy, sx0+ 4  , img_height, img_width) + 
 1852|      0|                                                             weightRpic * PelY_14 (ref2_pic, ry, rx0+ 4, img_height, img_width) + 
 1853|      0|                                                             2 * wp_luma_round) >> (luma_log_weight_denom + 1)) + (offsetBi));
 1854|      0|          *d++      = (orig_line[x0+1] - weightedpel);
 1855|      0|          weightedpel =  Clip3 (0, img->max_imgpel_value , ((weightSpic * PelY_14b (ref1_pic, sy, sx0+ 8  , img_height, img_width) + 
 1856|      0|                                                             weightRpic * PelY_14 (ref2_pic, ry, rx0+ 8, img_height, img_width) + 
 1857|      0|                                                             2 * wp_luma_round) >> (luma_log_weight_denom + 1)) + (offsetBi));
 1858|      0|          *d++      = (orig_line[x0+2] - weightedpel);
 1859|      0|          weightedpel =  Clip3 (0, img->max_imgpel_value , ((weightSpic * PelY_14b (ref1_pic, sy, sx0+ 12  ,img_height, img_width) + 
 1860|      0|                                                             weightRpic * PelY_14 (ref2_pic, ry, rx0+ 12,img_height, img_width) + 
 1861|      0|                                                             2 * wp_luma_round) >> (luma_log_weight_denom + 1)) + (offsetBi));
 1862|      0|          *d++      = (orig_line[x0+3] - weightedpel);
 1863|       |          
 1864|      0|          sy=sy0+4;
 1865|      0|          ry=ry0+4;
 1866|      0|          orig_line = orig_pic [y0+1];    
 1867|      0|          weightedpel =  Clip3 (0, img->max_imgpel_value , ((weightSpic * PelY_14b (ref1_pic, sy, sx0 , img_height, img_width) + 
 1868|      0|                                                             weightRpic * PelY_14 (ref2_pic, ry, rx0   , img_height, img_width) + 
 1869|      0|                                                             2 * wp_luma_round) >> (luma_log_weight_denom + 1)) + (offsetBi));
 1870|      0|          *d++      = (orig_line[x0  ] - weightedpel);
 1871|      0|          weightedpel =  Clip3 (0, img->max_imgpel_value , ((weightSpic * PelY_14b (ref1_pic, sy, sx0+ 4  , img_height, img_width) + 
 1872|      0|                                                             weightRpic * PelY_14 (ref2_pic, ry, rx0+ 4, img_height, img_width) + 
 1873|      0|                                                             2 * wp_luma_round) >> (luma_log_weight_denom + 1)) + (offsetBi));
 1874|      0|          *d++      = (orig_line[x0+1] - weightedpel);
 1875|      0|          weightedpel =  Clip3 (0, img->max_imgpel_value , ((weightSpic * PelY_14b (ref1_pic, sy, sx0+ 8  , img_height, img_width) + 
 1876|      0|                                                             weightRpic * PelY_14 (ref2_pic, ry, rx0+ 8, img_height, img_width) + 
 1877|      0|                                                             2 * wp_luma_round) >> (luma_log_weight_denom + 1)) + (offsetBi));
 1878|      0|          *d++      = (orig_line[x0+2] - weightedpel);
 1879|      0|          weightedpel =  Clip3 (0, img->max_imgpel_value , ((weightSpic * PelY_14b (ref1_pic, sy, sx0+ 12  ,img_height, img_width) + 
 1880|      0|                                                             weightRpic * PelY_14 (ref2_pic, ry, rx0+ 12,img_height, img_width) + 
 1881|      0|                                                             2 * wp_luma_round) >> (luma_log_weight_denom + 1)) + (offsetBi));
 1882|      0|          *d++      = (orig_line[x0+3] - weightedpel);
 1883|       |          
 1884|      0|          sy=sy0+8;
 1885|      0|          ry=ry0+8;
 1886|      0|          orig_line = orig_pic [y0+2];    
 1887|      0|          weightedpel =  Clip3 (0, img->max_imgpel_value , ((weightSpic * PelY_14b (ref1_pic, sy, sx0     , img_height, img_width) + 
 1888|      0|                                                             weightRpic * PelY_14 (ref2_pic, ry, rx0   , img_height, img_width) + 
 1889|      0|                                                             2 * wp_luma_round) >> (luma_log_weight_denom + 1)) + (offsetBi));
 1890|      0|          *d++      = (orig_line[x0  ] - weightedpel);
 1891|      0|          weightedpel =  Clip3 (0, img->max_imgpel_value , ((weightSpic * PelY_14b (ref1_pic, sy, sx0+ 4  , img_height, img_width) + 
 1892|      0|                                                             weightRpic * PelY_14 (ref2_pic, ry, rx0+ 4, img_height, img_width) + 
 1893|      0|                                                             2 * wp_luma_round) >> (luma_log_weight_denom + 1)) + (offsetBi));
 1894|      0|          *d++      = (orig_line[x0+1] - weightedpel);
 1895|      0|          weightedpel =  Clip3 (0, img->max_imgpel_value , ((weightSpic * PelY_14b (ref1_pic, sy, sx0+ 8  , img_height, img_width) + 
 1896|      0|                                                             weightRpic * PelY_14 (ref2_pic, ry, rx0+ 8, img_height, img_width) + 
 1897|      0|                                                             2 * wp_luma_round) >> (luma_log_weight_denom + 1)) + (offsetBi));
 1898|      0|          *d++      = (orig_line[x0+2] - weightedpel);
 1899|      0|          weightedpel =  Clip3 (0, img->max_imgpel_value , ((weightSpic * PelY_14b (ref1_pic, sy, sx0+ 12  ,img_height, img_width) + 
 1900|      0|                                                             weightRpic * PelY_14 (ref2_pic, ry, rx0+ 12,img_height, img_width) + 
 1901|      0|                                                             2 * wp_luma_round) >> (luma_log_weight_denom + 1)) + (offsetBi));
 1902|      0|          *d++      = (orig_line[x0+3] - weightedpel);
 1903|       |          
 1904|      0|          sy=sy0+12; 
 1905|      0|          ry=ry0+12;
 1906|      0|          orig_line = orig_pic [y0+3];    
 1907|      0|          weightedpel =  Clip3 (0, img->max_imgpel_value , ((weightSpic * PelY_14b (ref1_pic, sy, sx0     , img_height, img_width) +
 1908|      0|                                                             weightRpic * PelY_14 (ref2_pic, ry, rx0   , img_height, img_width) + 
 1909|      0|                                                             2 * wp_luma_round) >> (luma_log_weight_denom + 1)) + (offsetBi));
 1910|      0|          *d++      = (orig_line[x0  ] - weightedpel);
 1911|      0|          weightedpel =  Clip3 (0, img->max_imgpel_value , ((weightSpic * PelY_14b (ref1_pic, sy, sx0+ 4  , img_height, img_width) + 
 1912|      0|                                                             weightRpic * PelY_14 (ref2_pic, ry, rx0+ 4, img_height, img_width) + 
 1913|      0|                                                             2 * wp_luma_round) >> (luma_log_weight_denom + 1)) + (offsetBi));
 1914|      0|          *d++      = (orig_line[x0+1] - weightedpel);
 1915|      0|          weightedpel =  Clip3 (0, img->max_imgpel_value , ((weightSpic * PelY_14b (ref1_pic, sy, sx0+ 8  , img_height, img_width) + 
 1916|      0|                                                             weightRpic * PelY_14 (ref2_pic, ry, rx0+ 8, img_height, img_width) + 
 1917|      0|                                                             2 * wp_luma_round) >> (luma_log_weight_denom + 1)) + (offsetBi));
 1918|      0|          *d++      = (orig_line[x0+2] - weightedpel);
 1919|      0|          weightedpel =  Clip3 (0, img->max_imgpel_value , ((weightSpic * PelY_14b (ref1_pic, sy, sx0+ 12  ,img_height, img_width) + 
 1920|      0|                                                             weightRpic * PelY_14 (ref2_pic, ry, rx0+ 12,img_height, img_width) + 
 1921|      0|                                                             2 * wp_luma_round) >> (luma_log_weight_denom + 1)) + (offsetBi));
 1922|      0|          *d        = (orig_line[x0+3] - weightedpel);
 1923|       |          
 1924|       |          
 1925|      0|          if (!input->AllowTransform8x8)
 1926|      0|          {
 1927|      0|            if ((mcost += SATD (diff, halfpelhadamard)) > min_mcost)
 1928|      0|            {
 1929|      0|              abort_search = 1;
 1930|      0|              break;
 1931|      0|            }
 1932|      0|          }
 1933|      0|          else
 1934|      0|          {
 1935|      0|            for(j=0, k=0; j<4; j++)
 1936|      0|              for(i=0; i<4; i++, k++)
 1937|      0|                curr_diff[y0+j][x0+i] = diff[k];
 1938|      0|          }
 1939|       |        
 1940|      0|        }
 1941|      0|      }
 1942|      0|      else
 1943|      0|      {
 1944|      0|        for (x0=0; x0<blocksize_x; x0+=4)
 1945|      0|        {
 1946|      0|          sx0 = ((pic_pix_x + x0)<<2) + *s_mv_x;
 1947|      0|          rx0 = ((pic_pix_x + x0)<<2) + cand_mv_x;
 1948|      0|          d   = diff;
 1949|       |          
 1950|      0|          sy=sy0; 
 1951|      0|          ry=ry0;
 1952|      0|          orig_line = orig_pic [y0  ];    
 1953|      0|          *d++      = (orig_line[x0  ] - ((PelY_14b (ref1_pic, sy, sx0     , img_height, img_width) +  PelY_14 (ref2_pic, ry, rx0   , img_height, img_width))>>1));
 1954|      0|          *d++      = (orig_line[x0+1] - ((PelY_14b (ref1_pic, sy, sx0+ 4  , img_height, img_width) +  PelY_14 (ref2_pic, ry, rx0+ 4, img_height, img_width))>>1));
 1955|      0|          *d++      = (orig_line[x0+2] - ((PelY_14b (ref1_pic, sy, sx0+ 8  , img_height, img_width) +  PelY_14 (ref2_pic, ry, rx0+ 8, img_height, img_width))>>1));
 1956|      0|          *d++      = (orig_line[x0+3] - ((PelY_14b (ref1_pic, sy, sx0+ 12 , img_height, img_width) +  PelY_14 (ref2_pic, ry, rx0+12, img_height, img_width))>>1));
 1957|       |          
 1958|      0|          sy=sy0+4; 
 1959|      0|          ry=ry0+4;
 1960|      0|          orig_line = orig_pic [y0+1];    
 1961|      0|          *d++      = (orig_line[x0  ] - ((PelY_14b (ref1_pic, sy, sx0     , img_height, img_width) +  PelY_14 (ref2_pic, ry, rx0   , img_height, img_width))>>2));
 1962|      0|          *d++      = (orig_line[x0+1] - ((PelY_14b (ref1_pic, sy, sx0+ 4  , img_height, img_width) +  PelY_14 (ref2_pic, ry, rx0+ 4, img_height, img_width))>>2));
 1963|      0|          *d++      = (orig_line[x0+2] - ((PelY_14b (ref1_pic, sy, sx0+ 8  , img_height, img_width) +  PelY_14 (ref2_pic, ry, rx0+ 8, img_height, img_width))>>2));
 1964|      0|          *d++      = (orig_line[x0+3] - ((PelY_14b (ref1_pic, sy, sx0+ 12 , img_height, img_width) +  PelY_14 (ref2_pic, ry, rx0+12, img_height, img_width))>>2));
 1965|       |          
 1966|      0|          sy=sy0+8; 
 1967|      0|          ry=ry0+8;
 1968|      0|          orig_line = orig_pic [y0+2];    
 1969|      0|          *d++      = (orig_line[x0  ] - ((PelY_14b (ref1_pic, sy, sx0     , img_height, img_width) +  PelY_14 (ref2_pic, ry, rx0   , img_height, img_width))>>1));
 1970|      0|          *d++      = (orig_line[x0+1] - ((PelY_14b (ref1_pic, sy, sx0+ 4  , img_height, img_width) +  PelY_14 (ref2_pic, ry, rx0+ 4, img_height, img_width))>>1));
 1971|      0|          *d++      = (orig_line[x0+2] - ((PelY_14b (ref1_pic, sy, sx0+ 8  , img_height, img_width) +  PelY_14 (ref2_pic, ry, rx0+ 8, img_height, img_width))>>1));
 1972|      0|          *d++      = (orig_line[x0+3] - ((PelY_14b (ref1_pic, sy, sx0+ 12 , img_height, img_width) +  PelY_14 (ref2_pic, ry, rx0+12, img_height, img_width))>>1));
 1973|       |          
 1974|      0|          sy=sy0+12; 
 1975|      0|          ry=ry0+12;
 1976|      0|          orig_line = orig_pic [y0+3];    
 1977|      0|          *d++      = (orig_line[x0  ] - ((PelY_14b (ref1_pic, sy, sx0     , img_height, img_width) +  PelY_14 (ref2_pic, ry, rx0   , img_height, img_width))>>1));
 1978|      0|          *d++      = (orig_line[x0+1] - ((PelY_14b (ref1_pic, sy, sx0+ 4  , img_height, img_width) +  PelY_14 (ref2_pic, ry, rx0+ 4, img_height, img_width))>>1));
 1979|      0|          *d++      = (orig_line[x0+2] - ((PelY_14b (ref1_pic, sy, sx0+ 8  , img_height, img_width) +  PelY_14 (ref2_pic, ry, rx0+ 8, img_height, img_width))>>1));
 1980|      0|          *d        = (orig_line[x0+3] - ((PelY_14b (ref1_pic, sy, sx0+ 12 , img_height, img_width) +  PelY_14 (ref2_pic, ry, rx0+12, img_height, img_width))>>1));
 1981|       |          
 1982|       |          
 1983|      0|          if (!input->AllowTransform8x8)
 1984|      0|          {
 1985|      0|            if ((mcost += SATD (diff, halfpelhadamard)) > min_mcost)
 1986|      0|            {
 1987|      0|              abort_search = 1;
 1988|      0|              break;
 1989|      0|            }
 1990|      0|          }
 1991|      0|          else
 1992|      0|          {
 1993|      0|            for(j=0, k=0; j<4; j++)
 1994|      0|              for(i=0; i<4; i++, k++)
 1995|      0|                curr_diff[y0+j][x0+i] = diff[k];
 1996|      0|          }
 1997|       |
 1998|      0|        }
 1999|      0|      }
 2000|      0|    }
 2001|       |    
 2002|      0|    if(input->AllowTransform8x8)
 2003|      0|      mcost += find_SATD (curr_diff, halfpelhadamard, blocktype);
 2004|       |
 2005|       |
 2006|      0|    if (mcost < min_mcost)
 2007|      0|    {
 2008|      0|      min_mcost = mcost;
 2009|      0|      best_pos  = pos;
 2010|      0|    }
 2011|      0|  }
 2012|      0|  if (best_pos)
 2013|      0|  {
 2014|      0|    *mv_x += (spiral_search_x [best_pos] << 1);
 2015|      0|    *mv_y += (spiral_search_y [best_pos] << 1);
 2016|      0|  }
 2017|       |
 2018|      0|  if (input->hadamardqpel)
 2019|      0|    min_mcost = INT_MAX;
 2020|       |    
 2021|       |  /************************************
 2022|       |  *****                          *****
 2023|       |  *****  QUARTER-PEL REFINEMENT  *****
 2024|       |  *****                          *****
 2025|       |  ************************************/
 2026|       |  //===== set function for getting pixel values =====
 2027|      0|  if ((pic4_pix_x + *mv_x > 1) && (pic4_pix_x + *mv_x < max_pos_x4 - 1) &&
 2028|      0|    (pic4_pix_y + *mv_y > 1) && (pic4_pix_y + *mv_y < max_pos_y4 - 1)   )
 2029|      0|  {
 2030|      0|    PelY_14 = FastPelY_14;
 2031|      0|  }
 2032|      0|  else
 2033|      0|  {
 2034|      0|    PelY_14 = UMVPelY_14;
 2035|      0|  }
 2036|       |  //===== loop over search positions =====
 2037|      0|  for (best_pos = 0, pos = qpelstart; pos < search_pos4; pos++)
 2038|      0|  {
 2039|      0|    cand_mv_x = *mv_x + spiral_search_x[pos];    // quarter-pel units
 2040|      0|    cand_mv_y = *mv_y + spiral_search_y[pos];    // quarter-pel units
 2041|       |    
 2042|       |    //----- set motion vector cost -----
 2043|      0|    mcost = MV_COST (lambda_factor, mv_shift, cand_mv_x, cand_mv_y, pred_mv_x, pred_mv_y);
 2044|       |    
 2045|       |    //----- add up SATD -----
 2046|      0|    for (y0=0, abort_search=0; y0<blocksize_y && !abort_search; y0+=4)
 2047|      0|    {
 2048|      0|      sy0 = ((pic_pix_y + y0)<<2) + *s_mv_y;      
 2049|      0|      ry0 = ((pic_pix_y + y0)<<2) + cand_mv_y;
 2050|       |
 2051|      0|      if (apply_weights)
 2052|      0|      {
 2053|       |          
 2054|      0|        for (x0=0; x0<blocksize_x; x0+=4)
 2055|      0|        {
 2056|      0|          sy  = sy0;
 2057|      0|          sx0 = ((pic_pix_x + x0)<<2) + *s_mv_x;
 2058|      0|          rx0 = ((pic_pix_x + x0)<<2) + cand_mv_x;
 2059|      0|          d   = diff;
 2060|       |          
 2061|      0|          sy=sy0;
 2062|      0|          orig_line = orig_pic [y0  ];    ry=ry0;          
 2063|      0|          weightedpel =  Clip3 (0, img->max_imgpel_value , 
 2064|      0|                                ((weightSpic * PelY_14b (ref1_pic, sy, sx0     , img_height, img_width) + 
 2065|      0|                                  weightRpic * PelY_14 (ref2_pic, ry, rx0     , img_height, img_width) + 
 2066|      0|                                  2 * wp_luma_round) >> (luma_log_weight_denom + 1)) + (offsetBi));
 2067|      0|          *d++      = (orig_line[x0  ] - weightedpel);
 2068|      0|          weightedpel =  Clip3 (0, img->max_imgpel_value , 
 2069|      0|                                ((weightSpic * PelY_14b (ref1_pic, sy, sx0+ 4  , img_height, img_width) + 
 2070|      0|                                  weightRpic * PelY_14 (ref2_pic, ry, rx0+ 4  , img_height, img_width) + 
 2071|      0|                                  2 * wp_luma_round) >> (luma_log_weight_denom + 1)) + (offsetBi));
 2072|      0|          *d++      = (orig_line[x0+1] - weightedpel);
 2073|      0|          weightedpel =  Clip3 (0, img->max_imgpel_value , 
 2074|      0|                                ((weightSpic * PelY_14b (ref1_pic, sy, sx0+ 8  , img_height, img_width) + 
 2075|      0|                                  weightRpic * PelY_14 (ref2_pic, ry, rx0+ 8  , img_height, img_width) + 
 2076|      0|                                  2 * wp_luma_round) >> (luma_log_weight_denom + 1)) + (offsetBi));
 2077|      0|          *d++      = (orig_line[x0+2] - weightedpel);
 2078|      0|          weightedpel =  Clip3 (0, img->max_imgpel_value , 
 2079|      0|                                ((weightSpic * PelY_14b (ref1_pic, sy, sx0+ 12 , img_height, img_width) + 
 2080|      0|                                  weightRpic * PelY_14 (ref2_pic, ry, rx0+ 12 , img_height, img_width) + 
 2081|      0|                                  2 * wp_luma_round) >> (luma_log_weight_denom + 1)) + (offsetBi));
 2082|      0|          *d++      = (orig_line[x0+3] - weightedpel);
 2083|       |          
 2084|      0|          sy=sy0+4;
 2085|      0|          orig_line = orig_pic [y0+1];    ry=ry0+4;
 2086|      0|          weightedpel =  Clip3 (0, img->max_imgpel_value , 
 2087|      0|                                ((weightSpic * PelY_14b (ref1_pic, sy, sx0     , img_height, img_width) + 
 2088|      0|                                  weightRpic * PelY_14 (ref2_pic, ry, rx0     , img_height, img_width) + 
 2089|      0|                                  2 * wp_luma_round) >> (luma_log_weight_denom + 1)) + (offsetBi));
 2090|      0|          *d++      = (orig_line[x0  ] - weightedpel);
 2091|      0|          weightedpel =  Clip3 (0, img->max_imgpel_value , 
 2092|      0|                                ((weightSpic * PelY_14b (ref1_pic, sy, sx0+ 4  , img_height, img_width) + 
 2093|      0|                                  weightRpic * PelY_14 (ref2_pic, ry, rx0+ 4  , img_height, img_width) + 
 2094|      0|                                  2 * wp_luma_round) >> (luma_log_weight_denom + 1)) + (offsetBi));
 2095|      0|          *d++      = (orig_line[x0+1] - weightedpel);
 2096|      0|          weightedpel =  Clip3 (0, img->max_imgpel_value , 
 2097|      0|                                ((weightSpic * PelY_14b (ref1_pic, sy, sx0+ 8  , img_height, img_width) + 
 2098|      0|                                  weightRpic * PelY_14 (ref2_pic, ry, rx0+ 8  , img_height, img_width) + 
 2099|      0|                                  2 * wp_luma_round) >> (luma_log_weight_denom + 1)) + (offsetBi));
 2100|      0|          *d++      = (orig_line[x0+2] - weightedpel);
 2101|      0|          weightedpel =  Clip3 (0, img->max_imgpel_value , 
 2102|      0|                                ((weightSpic * PelY_14b (ref1_pic, sy, sx0+ 12 , img_height, img_width) + 
 2103|      0|                                  weightRpic * PelY_14 (ref2_pic, ry, rx0+ 12 , img_height, img_width) + 
 2104|      0|                                  2 * wp_luma_round) >> (luma_log_weight_denom + 1)) + (offsetBi));
 2105|      0|          *d++      = (orig_line[x0+3] - weightedpel);
 2106|       |          
 2107|      0|          sy=sy0+8;
 2108|      0|          orig_line = orig_pic [y0+2];    ry=ry0+8;
 2109|      0|          weightedpel =  Clip3 (0, img->max_imgpel_value , 
 2110|      0|                                ((weightSpic * PelY_14b (ref1_pic, sy, sx0     , img_height, img_width) + 
 2111|      0|                                  weightRpic * PelY_14 (ref2_pic, ry, rx0     , img_height, img_width) + 
 2112|      0|                                  2 * wp_luma_round) >> (luma_log_weight_denom + 1)) + (offsetBi));
 2113|      0|          *d++      = (orig_line[x0  ] - weightedpel);
 2114|      0|          weightedpel =  Clip3 (0, img->max_imgpel_value , 
 2115|      0|                                ((weightSpic * PelY_14b (ref1_pic, sy, sx0+ 4  , img_height, img_width) + 
 2116|      0|                                  weightRpic * PelY_14 (ref2_pic, ry, rx0+ 4  , img_height, img_width) + 
 2117|      0|                                  2 * wp_luma_round) >> (luma_log_weight_denom + 1)) + (offsetBi));
 2118|      0|          *d++      = (orig_line[x0+1] - weightedpel);
 2119|      0|          weightedpel =  Clip3 (0, img->max_imgpel_value , 
 2120|      0|                                ((weightSpic * PelY_14b (ref1_pic, sy, sx0+ 8  , img_height, img_width) + 
 2121|      0|                                  weightRpic * PelY_14 (ref2_pic, ry, rx0+ 8  , img_height, img_width) + 
 2122|      0|                                  2 * wp_luma_round) >> (luma_log_weight_denom + 1)) + (offsetBi));
 2123|      0|          *d++      = (orig_line[x0+2] - weightedpel);
 2124|      0|          weightedpel =  Clip3 (0, img->max_imgpel_value , 
 2125|      0|                                ((weightSpic * PelY_14b (ref1_pic, sy, sx0+ 12 , img_height, img_width) + 
 2126|      0|                                  weightRpic * PelY_14 (ref2_pic, ry, rx0+ 12 , img_height, img_width) + 
 2127|      0|                                  2 * wp_luma_round) >> (luma_log_weight_denom + 1)) + (offsetBi));
 2128|      0|          *d++      = (orig_line[x0+3] - weightedpel);
 2129|       |          
 2130|      0|          sy=sy0+12;
 2131|      0|          orig_line = orig_pic [y0+3];    ry=ry0+12;
 2132|      0|          weightedpel =  Clip3 (0, img->max_imgpel_value , 
 2133|      0|                                ((weightSpic * PelY_14b (ref1_pic, sy, sx0     , img_height, img_width) + 
 2134|      0|                                  weightRpic * PelY_14 (ref2_pic, ry, rx0     , img_height, img_width) + 
 2135|      0|                                  2 * wp_luma_round) >> (luma_log_weight_denom + 1))  + (offsetBi));
 2136|      0|          *d++      = (orig_line[x0  ] - weightedpel);
 2137|      0|          weightedpel =  Clip3 (0, img->max_imgpel_value , 
 2138|      0|                                ((weightSpic * PelY_14b (ref1_pic, sy, sx0+ 4  , img_height, img_width) + 
 2139|      0|                                  weightRpic * PelY_14 (ref2_pic, ry, rx0+ 4  , img_height, img_width) + 
 2140|      0|                                  2 * wp_luma_round) >> (luma_log_weight_denom + 1)) + (offsetBi));
 2141|      0|          *d++      = (orig_line[x0+1] - weightedpel);
 2142|      0|          weightedpel =  Clip3 (0, img->max_imgpel_value , 
 2143|      0|                                ((weightSpic * PelY_14b (ref1_pic, sy, sx0+ 8  , img_height, img_width) + 
 2144|      0|                                  weightRpic * PelY_14 (ref2_pic, ry, rx0+ 8  , img_height, img_width) + 
 2145|      0|                                  2 * wp_luma_round) >> (luma_log_weight_denom + 1)) + (offsetBi));
 2146|      0|          *d++      = (orig_line[x0+2] - weightedpel);
 2147|      0|          weightedpel =  Clip3 (0, img->max_imgpel_value , 
 2148|      0|                                ((weightSpic * PelY_14b (ref1_pic, sy, sx0+ 12 , img_height, img_width) + 
 2149|      0|                                  weightRpic * PelY_14 (ref2_pic, ry, rx0+ 12 , img_height, img_width) + 
 2150|      0|                                  2 * wp_luma_round) >> (luma_log_weight_denom + 1)) + (offsetBi));
 2151|      0|          *d        = (orig_line[x0+3] - weightedpel);
 2152|       |          
 2153|       |          
 2154|      0|          if (!input->AllowTransform8x8)
 2155|      0|          {
 2156|      0|            if ((mcost += SATD (diff, input->hadamard)) > min_mcost)
 2157|      0|            {
 2158|      0|              abort_search = 1;
 2159|      0|              break;
 2160|      0|            }
 2161|      0|          }
 2162|      0|          else
 2163|      0|          {
 2164|      0|            for(j=0, k=0; j<4; j++)
 2165|      0|              for(i=0; i<4; i++, k++)
 2166|      0|                curr_diff[y0+j][x0+i] = diff[k];
 2167|      0|          }
 2168|      0|       }
 2169|      0|      }
 2170|      0|      else
 2171|      0|      {      
 2172|      0|        for (x0=0; x0<blocksize_x; x0+=4)
 2173|      0|        {
 2174|       |         
 2175|      0|          sx0 = ((pic_pix_x + x0)<<2) + *s_mv_x;
 2176|      0|          rx0 = ((pic_pix_x + x0)<<2) + cand_mv_x;
 2177|      0|          d   = diff;
 2178|       |
 2179|      0|          sy  = sy0; 
 2180|      0|          ry  = ry0;
 2181|      0|          orig_line = orig_pic [y0  ];    
 2182|      0|          *d++      = (orig_line[x0  ] - ((PelY_14b (ref1_pic, sy, sx0     , img_height, img_width) +  PelY_14 (ref2_pic, ry, rx0   , img_height, img_width))>>1));
 2183|      0|          *d++      = (orig_line[x0+1] - ((PelY_14b (ref1_pic, sy, sx0+ 4  , img_height, img_width) +  PelY_14 (ref2_pic, ry, rx0+ 4, img_height, img_width))>>1));
 2184|      0|          *d++      = (orig_line[x0+2] - ((PelY_14b (ref1_pic, sy, sx0+ 8  , img_height, img_width) +  PelY_14 (ref2_pic, ry, rx0+ 8, img_height, img_width))>>1));
 2185|      0|          *d++      = (orig_line[x0+3] - ((PelY_14b (ref1_pic, sy, sx0+ 12 , img_height, img_width) +  PelY_14 (ref2_pic, ry, rx0+12, img_height, img_width))>>1));
 2186|       |          
 2187|      0|          sy  = sy0+4;        
 2188|      0|          ry  = ry0+4;
 2189|      0|          orig_line = orig_pic [y0+1];    
 2190|      0|          *d++      = (orig_line[x0  ] - ((PelY_14b (ref1_pic, sy, sx0     , img_height, img_width) +  PelY_14 (ref2_pic, ry, rx0   , img_height, img_width))>>1));
 2191|      0|          *d++      = (orig_line[x0+1] - ((PelY_14b (ref1_pic, sy, sx0+ 4  , img_height, img_width) +  PelY_14 (ref2_pic, ry, rx0+ 4, img_height, img_width))>>1));
 2192|      0|          *d++      = (orig_line[x0+2] - ((PelY_14b (ref1_pic, sy, sx0+ 8  , img_height, img_width) +  PelY_14 (ref2_pic, ry, rx0+ 8, img_height, img_width))>>1));
 2193|      0|          *d++      = (orig_line[x0+3] - ((PelY_14b (ref1_pic, sy, sx0+ 12 , img_height, img_width) +  PelY_14 (ref2_pic, ry, rx0+12, img_height, img_width))>>1));
 2194|       |          
 2195|      0|          sy  = sy0+8;                
 2196|      0|          ry  = ry0+8;
 2197|      0|          orig_line = orig_pic [y0+2];    
 2198|      0|          *d++      = (orig_line[x0  ] - ((PelY_14b (ref1_pic, sy, sx0     , img_height, img_width) +  PelY_14 (ref2_pic, ry, rx0   , img_height, img_width))>>1));
 2199|      0|          *d++      = (orig_line[x0+1] - ((PelY_14b (ref1_pic, sy, sx0+ 4  , img_height, img_width) +  PelY_14 (ref2_pic, ry, rx0+ 4, img_height, img_width))>>1));
 2200|      0|          *d++      = (orig_line[x0+2] - ((PelY_14b (ref1_pic, sy, sx0+ 8  , img_height, img_width) +  PelY_14 (ref2_pic, ry, rx0+ 8, img_height, img_width))>>1));
 2201|      0|          *d++      = (orig_line[x0+3] - ((PelY_14b (ref1_pic, sy, sx0+ 12 , img_height, img_width) +  PelY_14 (ref2_pic, ry, rx0+12, img_height, img_width))>>1));
 2202|       |          
 2203|      0|          sy  = sy0+12;                
 2204|      0|          ry  = ry0+12;
 2205|      0|          orig_line = orig_pic [y0+3];   
 2206|      0|          *d++      = (orig_line[x0  ] - ((PelY_14b (ref1_pic, sy, sx0     , img_height, img_width) +  PelY_14 (ref2_pic, ry, rx0   , img_height, img_width))>>1));
 2207|      0|          *d++      = (orig_line[x0+1] - ((PelY_14b (ref1_pic, sy, sx0+ 4  , img_height, img_width) +  PelY_14 (ref2_pic, ry, rx0+ 4, img_height, img_width))>>1));
 2208|      0|          *d++      = (orig_line[x0+2] - ((PelY_14b (ref1_pic, sy, sx0+ 8  , img_height, img_width) +  PelY_14 (ref2_pic, ry, rx0+ 8, img_height, img_width))>>1));
 2209|      0|          *d        = (orig_line[x0+3] - ((PelY_14b (ref1_pic, sy, sx0+ 12 , img_height, img_width) +  PelY_14 (ref2_pic, ry, rx0+12, img_height, img_width))>>1));
 2210|       |          
 2211|       |          
 2212|      0|          if (!input->AllowTransform8x8)
 2213|      0|          {
 2214|      0|            if ((mcost += SATD (diff, input->hadamard)) > min_mcost)
 2215|      0|            {
 2216|      0|              abort_search = 1;
 2217|      0|              break;
 2218|      0|            }
 2219|      0|          }
 2220|      0|          else
 2221|      0|          {
 2222|      0|            for(j=0, k=0; j<4; j++)
 2223|      0|              for(i=0; i<4; i++, k++)
 2224|      0|                curr_diff[y0+j][x0+i] = diff[k];
 2225|      0|          }
 2226|      0|        }
 2227|      0|      }
 2228|      0|    }
 2229|       |
 2230|      0|    if(input->AllowTransform8x8)
 2231|      0|      mcost += find_SATD (curr_diff, input->hadamard, blocktype);
 2232|       |    
 2233|      0|    if (mcost < min_mcost)
 2234|      0|    {
 2235|      0|      min_mcost = mcost;
 2236|      0|      best_pos  = pos;
 2237|      0|    }
 2238|      0|  }
 2239|      0|  if (best_pos)
 2240|      0|  {
 2241|      0|    *mv_x += spiral_search_x [best_pos];
 2242|      0|    *mv_y += spiral_search_y [best_pos];
 2243|      0|  }
 2244|       |  
 2245|       |  //===== return minimum motion cost =====
 2246|      0|  return min_mcost;
 2247|      0|}
 2248|       |
 2249|       |/*!
 2250|       | ***********************************************************************
 2251|       | * \brief
 2252|       | *    Motion Cost for Bidirectional modes
 2253|       | ***********************************************************************
 2254|       | */
 2255|       |int BPredPartitionCost (int   blocktype,
 2256|       |                        int   block8x8,
 2257|       |                        short fw_ref,
 2258|       |                        short bw_ref,
 2259|       |                        int   lambda_factor,
 2260|       |                        int   list)
 2261|      0|{
 2262|      0|  static int  bx0[5][4] = {{0,0,0,0}, {0,0,0,0}, {0,0,0,0}, {0,2,0,0}, {0,2,0,2}};
 2263|      0|  static int  by0[5][4] = {{0,0,0,0}, {0,0,0,0}, {0,2,0,0}, {0,0,0,0}, {0,0,2,2}};
 2264|       |
 2265|      0|  int   diff[64];
 2266|      0|  int   curr_blk[MB_BLOCK_SIZE][MB_BLOCK_SIZE]; // ABT pred.error buffer
 2267|      0|  int   bsx       = min(input->blc_size[blocktype][0],8);
 2268|      0|  int   bsy       = min(input->blc_size[blocktype][1],8);
 2269|       |
 2270|      0|  int   pic_pix_x, pic_pix_y, block_x, block_y;
 2271|      0|  int   v, h, mcost, i, j, k;
 2272|      0|  int   mvd_bits  = 0;
 2273|      0|  int   parttype  = (blocktype<4?blocktype:4);
 2274|      0|  int   step_h0   = (input->part_size[ parttype][0]);
 2275|      0|  int   step_v0   = (input->part_size[ parttype][1]);
 2276|      0|  int   step_h    = (input->part_size[blocktype][0]);
 2277|      0|  int   step_v    = (input->part_size[blocktype][1]);
 2278|      0|  int   bxx, byy;                               // indexing curr_blk
 2279|       |
 2280|      0|  short   ******all_mv = list ? img->bipred_mv1 : img->bipred_mv2;
 2281|      0|  short   ******  p_mv = img->pred_mv;
 2282|       |
 2283|       |    //----- cost for motion vector bits -----
 2284|      0|  for (v=by0[parttype][block8x8]; v<by0[parttype][block8x8]+step_v0; v+=step_v)
 2285|      0|  for (h=bx0[parttype][block8x8]; h<bx0[parttype][block8x8]+step_h0; h+=step_h)
 2286|      0|  {
 2287|      0|    mvd_bits += mvbits[ all_mv [h][v][LIST_0][fw_ref][blocktype][0] - p_mv[h][v][LIST_0][fw_ref][blocktype][0] ];
 2288|      0|    mvd_bits += mvbits[ all_mv [h][v][LIST_0][fw_ref][blocktype][1] - p_mv[h][v][LIST_0][fw_ref][blocktype][1] ];
 2289|       |
 2290|      0|    mvd_bits += mvbits[ all_mv [h][v][LIST_1][bw_ref][blocktype][0] - p_mv[h][v][LIST_1][bw_ref][blocktype][0] ];
 2291|      0|    mvd_bits += mvbits[ all_mv [h][v][LIST_1][bw_ref][blocktype][1] - p_mv[h][v][LIST_1][bw_ref][blocktype][1] ];
 2292|      0|  }
 2293|       |
 2294|      0|  mcost = WEIGHTED_COST (lambda_factor, mvd_bits);
 2295|       |
 2296|       |  //----- cost of residual signal -----
 2297|      0|  for (byy=0, v=by0[parttype][block8x8]; v<by0[parttype][block8x8]+step_v0; byy+=4, v++)
 2298|      0|  {
 2299|      0|    pic_pix_y = img->opix_y + (block_y = (v<<2));
 2300|       |
 2301|      0|    for (bxx=0, h=bx0[parttype][block8x8]; h<bx0[parttype][block8x8]+step_h0; bxx+=4, h++)
 2302|      0|    {
 2303|      0|      pic_pix_x = img->opix_x + (block_x = (h<<2));
 2304|       |
 2305|      0|      LumaPrediction4x4Bi (block_x, block_y, 2, blocktype, blocktype, fw_ref, bw_ref, list);
 2306|       |
 2307|      0|      for (k=j=0; j<4; j++)
 2308|      0|      for (  i=0; i<4; i++, k++)
 2309|      0|      {
 2310|      0|        diff[k] = curr_blk[byy+j][bxx+i] = 
 2311|      0|        imgY_org[pic_pix_y+j][pic_pix_x+i] - img->mpr[i+block_x][j+block_y];
 2312|       |
 2313|      0|      }
 2314|      0|      if ((!input->AllowTransform8x8) || (blocktype>4)) // tchen 4-29-04
 2315|      0|        mcost += SATD (diff, input->hadamard);
 2316|       |
 2317|      0|    }
 2318|      0|  }
 2319|      0|  if (input->AllowTransform8x8 && (blocktype<=4))  // tchen 4-29-04
 2320|      0|  {
 2321|      0|    for (byy=0; byy<input->blc_size[parttype][1]; byy+=bsy)
 2322|      0|      for (bxx=0; bxx<input->blc_size[parttype][0]; bxx+=bsx)
 2323|      0|      {
 2324|      0|        k=0;
 2325|      0|        for (i=0;i<8;i++)
 2326|      0|          for (j=0;j<8;j++)
 2327|      0|            diff[k++] = curr_blk[i+byy][j+bxx];
 2328|       |
 2329|      0|        mcost += SATD8X8(diff, input->hadamard);
 2330|      0|      }
 2331|      0|  }
 2332|       |
 2333|      0|  return mcost;
 2334|      0|}
 2335|       |
 2336|       |
 2337|       |
 2338|       |#endif
 2339|       |
 2340|       |
 2341|       |/*!
 2342|       | ***********************************************************************
 2343|       | * \brief
 2344|       | *    Block motion search
 2345|       | ***********************************************************************
 2346|       | */
 2347|       |int                                         //!< minimum motion cost after search
 2348|       |BlockMotionSearch (short     ref,           //!< reference idx
 2349|       |                   int       list,          //!< reference pciture list
 2350|       |                   int       mb_x,          //!< x-coordinate inside macroblock
 2351|       |                   int       mb_y,          //!< y-coordinate inside macroblock
 2352|       |                   int       blocktype,     //!< block type (1-16x16 ... 7-4x4)
 2353|       |                   int       search_range,  //!< 1-d search range for integer-position search
 2354|       |                   double    lambda         //!< lagrangian parameter for determining motion cost
 2355|       |                   )
 2356|  20.4M|{
 2357|  20.4M|  static pel_t   orig_val [256];
 2358|  20.4M|  static pel_t  *orig_pic  [16] = {orig_val,     orig_val+ 16, orig_val+ 32, orig_val+ 48,
 2359|  20.4M|                                   orig_val+ 64, orig_val+ 80, orig_val+ 96, orig_val+112,
 2360|  20.4M|                                   orig_val+128, orig_val+144, orig_val+160, orig_val+176,
 2361|  20.4M|                                   orig_val+192, orig_val+208, orig_val+224, orig_val+240};
 2362|       |
 2363|  20.4M|  short     pred_mv_x, pred_mv_y, mv_x, mv_y;
 2364|  20.4M|  int       i, j;
 2365|       |
 2366|  20.4M|  int       max_value = INT_MAX;
 2367|  20.4M|  int       min_mcost = max_value;
 2368|       |
 2369|  20.4M|  int       block_x   = (mb_x>>2);
 2370|  20.4M|  int       block_y   = (mb_y>>2);
 2371|       |  
 2372|  20.4M|  int       bsx       = input->blc_size[blocktype][0];
 2373|  20.4M|  int       bsy       = input->blc_size[blocktype][1];
 2374|       |
 2375|  20.4M|  int       pic_pix_x = img->opix_x + mb_x;
 2376|  20.4M|  int       pic_pix_y = img->opix_y + mb_y;
 2377|       |
 2378|  20.4M|  short*    pred_mv;
 2379|       |
 2380|  20.4M|  short***    mv_array  = enc_picture->mv[list];
 2381|  20.4M|  short****** all_mv    = img->all_mv;
 2382|       |
 2383|       |#ifdef WIN32
 2384|       |  struct _timeb tstruct1;
 2385|       |  struct _timeb tstruct2;
 2386|       |#else
 2387|  20.4M|  struct timeb tstruct1;
 2388|  20.4M|  struct timeb tstruct2;
 2389|  20.4M|#endif
 2390|       |  
 2391|  20.4M|  int me_tmp_time;
 2392|       |
 2393|  20.4M|  int  N_Bframe=0, n_Bframe=0;
 2394|       |
 2395|  20.4M|#if defined(SPEC_CPU)
 2396|  20.4M|  tstruct1.time = 0;
 2397|  20.4M|  tstruct1.millitm = 0;
 2398|  20.4M|  tstruct1.timezone = 0;
 2399|  20.4M|  tstruct1.dstflag = 0;
 2400|       |#else  
 2401|       |#ifdef WIN32
 2402|       |  _ftime( &tstruct1 );    // start time ms
 2403|       |#else
 2404|       |  ftime(&tstruct1);
 2405|       |#endif
 2406|       |#endif /* !SPEC_CPU */
 2407|       |
 2408|  20.4M|  if(input->FMEnable)
 2409|      0|  {
 2410|      0|    N_Bframe = input->successive_Bframe;
 2411|      0|    n_Bframe =(N_Bframe) ? ((Bframe_ctr%N_Bframe)+1) : 0 ;
 2412|      0|  }
 2413|       |
 2414|  20.4M|  pred_mv = img->pred_mv[block_x][block_y][list][ref][blocktype];
 2415|       |
 2416|       |  //==================================
 2417|       |  //=====   GET ORIGINAL BLOCK   =====
 2418|       |  //==================================
 2419|   148M|  for (j = 0; j < bsy; j++)
 2420|   127M|  {
 2421|  1.02G|    for (i = 0; i < bsx; i++) //xxzp 两次访存变为一次访存
 2422|   895M|    {
 2423|   895M|      orig_pic[j][i] = imgY_org[pic_pix_y+j][pic_pix_x+i];
 2424|   895M|    }
 2425|   127M|  }
 2426|       |
 2427|  20.4M|  if(input->FMEnable)
 2428|      0|  {
 2429|       |    
 2430|      0|    if(blocktype>6)
 2431|      0|    {
 2432|      0|      pred_MV_uplayer[0] = all_mv[block_x][block_y][list][ref][5][0];
 2433|      0|      pred_MV_uplayer[1] = all_mv[block_x][block_y][list][ref][5][1];
 2434|      0|      pred_SAD_uplayer    = (list==1) ? (all_bwmincost[(img->pix_x>>2)+block_x][(img->pix_y>>2)+block_y][0][5][0]) : (all_mincost[(img->pix_x>>2)+block_x][(img->pix_y>>2)+block_y][ref][5][0]);
 2435|      0|      pred_SAD_uplayer   /= 2; 
 2436|       |      
 2437|      0|    }
 2438|      0|    else if(blocktype>4)
 2439|      0|    {
 2440|      0|      pred_MV_uplayer[0] = all_mv[block_x][block_y][list][ref][4][0];
 2441|      0|      pred_MV_uplayer[1] = all_mv[block_x][block_y][list][ref][4][1];
 2442|      0|      pred_SAD_uplayer    = (list==1) ? (all_bwmincost[(img->pix_x>>2)+block_x][(img->pix_y>>2)+block_y][0][4][0]) : (all_mincost[(img->pix_x>>2)+block_x][(img->pix_y>>2)+block_y][ref][4][0]);
 2443|      0|      pred_SAD_uplayer   /= 2; 
 2444|       |      
 2445|      0|    }
 2446|      0|    else if(blocktype == 4)
 2447|      0|    {
 2448|      0|      pred_MV_uplayer[0] = all_mv[block_x][block_y][list][ref][2][0];
 2449|      0|      pred_MV_uplayer[1] = all_mv[block_x][block_y][list][ref][2][1];
 2450|      0|      pred_SAD_uplayer    = (list==1) ? (all_bwmincost[(img->pix_x>>2)+block_x][(img->pix_y>>2)+block_y][0][2][0]) : (all_mincost[(img->pix_x>>2)+block_x][(img->pix_y>>2)+block_y][ref][2][0]);
 2451|      0|      pred_SAD_uplayer   /= 2; 
 2452|      0|    }
 2453|      0|    else if(blocktype > 1)
 2454|      0|    {
 2455|      0|      pred_MV_uplayer[0] = all_mv[block_x][block_y][list][ref][1][0];
 2456|      0|      pred_MV_uplayer[1] = all_mv[block_x][block_y][list][ref][1][1];
 2457|      0|      pred_SAD_uplayer    = (list==1) ? (all_bwmincost[(img->pix_x>>2)+block_x][(img->pix_y>>2)+block_y][0][1][0]) : (all_mincost[(img->pix_x>>2)+block_x][(img->pix_y>>2)+block_y][ref][1][0]);
 2458|      0|      pred_SAD_uplayer   /= 2; 
 2459|      0|    }
 2460|       |    
 2461|      0|    if ((img->type==B_SLICE)&& (img->nal_reference_idc>0))
 2462|      0|    {
 2463|      0|      if(blocktype>6)
 2464|      0|      {
 2465|      0|        pred_MV_uplayer[0] = all_mv[block_x][block_y][list][ref][5][0];
 2466|      0|        pred_MV_uplayer[1] = all_mv[block_x][block_y][list][ref][5][1];
 2467|      0|        pred_SAD_uplayer    = (list==1) ? (all_bwmincost[(img->pix_x>>2)+block_x][(img->pix_y>>2)+block_y][0][5][0]) : (all_mincost[(img->pix_x>>2)+block_x][(img->pix_y>>2)+block_y][ref][5][0]);
 2468|      0|        pred_SAD_uplayer   /= 2; 
 2469|      0|      }
 2470|      0|      else if(blocktype>4)
 2471|      0|      {
 2472|      0|        pred_MV_uplayer[0] = all_mv[block_x][block_y][list][ref][4][0];
 2473|      0|        pred_MV_uplayer[1] = all_mv[block_x][block_y][list][ref][4][1];
 2474|      0|        pred_SAD_uplayer    = (list==1) ? (all_bwmincost[(img->pix_x>>2)+block_x][(img->pix_y>>2)+block_y][0][4][0]) : (all_mincost[(img->pix_x>>2)+block_x][(img->pix_y>>2)+block_y][ref][4][0]);
 2475|      0|        pred_SAD_uplayer   /= 2; 
 2476|      0|      }
 2477|      0|      else if(blocktype == 4)
 2478|      0|      {
 2479|      0|        pred_MV_uplayer[0] = all_mv[block_x][block_y][list][ref][2][0];
 2480|      0|        pred_MV_uplayer[1] = all_mv[block_x][block_y][list][ref][2][1];
 2481|      0|        pred_SAD_uplayer    = (list==1) ? (all_bwmincost[(img->pix_x>>2)+block_x][(img->pix_y>>2)+block_y][0][2][0]) : (all_mincost[(img->pix_x>>2)+block_x][(img->pix_y>>2)+block_y][ref][2][0]);
 2482|      0|        pred_SAD_uplayer   /= 2; 
 2483|      0|      }
 2484|      0|      else if(blocktype > 1)
 2485|      0|      {
 2486|      0|        pred_MV_uplayer[0] = all_mv[block_x][block_y][list][ref][1][0];
 2487|      0|        pred_MV_uplayer[1] = all_mv[block_x][block_y][list][ref][1][1];
 2488|      0|        pred_SAD_uplayer    = (list==1) ? (all_bwmincost[(img->pix_x>>2)+block_x][(img->pix_y>>2)+block_y][0][1][0]) : (all_mincost[(img->pix_x>>2)+block_x][(img->pix_y>>2)+block_y][ref][1][0]);
 2489|      0|        pred_SAD_uplayer   /= 2; 
 2490|      0|      }
 2491|      0|    }
 2492|       |    
 2493|      0|    pred_SAD_uplayer = flag_intra_SAD ? 0 : pred_SAD_uplayer;// for irregular motion
 2494|       |    
 2495|       |    //Coordinate prediction
 2496|      0|    if (img->number > ref+1)
 2497|      0|    {
 2498|      0|      pred_SAD_time = all_mincost[(img->pix_x>>2)+block_x][(img->pix_y>>2)+block_y][ref][blocktype][0];
 2499|      0|      pred_MV_time[0] = all_mincost[(img->pix_x>>2)+block_x][(img->pix_y>>2)+block_y][ref][blocktype][1];
 2500|      0|      pred_MV_time[1] = all_mincost[(img->pix_x>>2)+block_x][(img->pix_y>>2)+block_y][ref][blocktype][2];
 2501|      0|    }
 2502|       |    
 2503|      0|    if(list==1 && (Bframe_ctr%N_Bframe) > 1) 
 2504|      0|    {
 2505|      0|      pred_SAD_time = all_bwmincost[(img->pix_x>>2)+block_x][(img->pix_y>>2)+block_y][ref][blocktype][0];
 2506|      0|      pred_MV_time[0] = (int)(all_bwmincost[(img->pix_x>>2)+block_x][(img->pix_y>>2)+block_y][0][blocktype][1] * ((n_Bframe==1) ? (N_Bframe) : (N_Bframe-n_Bframe+1.0)/(N_Bframe-n_Bframe+2.0)) );//should add a factor
 2507|      0|      pred_MV_time[1] = (int)(all_bwmincost[(img->pix_x>>2)+block_x][(img->pix_y>>2)+block_y][0][blocktype][2] *((n_Bframe==1) ? (N_Bframe) : (N_Bframe-n_Bframe+1.0)/(N_Bframe-n_Bframe+2.0)) );//should add a factor
 2508|      0|    }
 2509|       |    
 2510|      0|    if (input->PicInterlace == FIELD_CODING) 
 2511|      0|    {
 2512|      0|      if (img->type == P_SLICE && ref > 1)
 2513|      0|      {
 2514|      0|        pred_SAD_ref = all_mincost[(img->pix_x>>2)+block_x][(img->pix_y>>2)+block_y][(ref-2)][blocktype][0];
 2515|      0|        pred_SAD_ref = flag_intra_SAD ? 0 : pred_SAD_ref;//add this for irregular motion
 2516|      0|        pred_MV_ref[0] = all_mincost[(img->pix_x>>2)+block_x][(img->pix_y>>2)+block_y][(ref-2)][blocktype][1];
 2517|      0|        pred_MV_ref[0] = (int)(pred_MV_ref[0]*((ref>>1)+1)/(float)((ref>>1)));
 2518|      0|        pred_MV_ref[1] = all_mincost[(img->pix_x>>2)+block_x][(img->pix_y>>2)+block_y][(ref-2)][blocktype][2];
 2519|      0|        pred_MV_ref[1] = (int)(pred_MV_ref[1]*((ref>>1)+1)/(float)((ref>>1)));
 2520|      0|      }
 2521|      0|      if (img->type == B_SLICE && list==0 && (ref==0 || ref==1) )
 2522|      0|      {
 2523|      0|        pred_SAD_ref = all_bwmincost[(img->pix_x>>2)+block_x][(img->pix_y>>2)+block_y][0][blocktype][0];
 2524|      0|        pred_SAD_ref = flag_intra_SAD ? 0 : pred_SAD_ref;//add this for irregular motion
 2525|      0|        pred_MV_ref[0] =(int) (all_bwmincost[(img->pix_x>>2)+block_x][(img->pix_y>>2)+block_y][ref][blocktype][1]*(-n_Bframe)/(N_Bframe-n_Bframe+1.0f)); //should add a factor
 2526|      0|        pred_MV_ref[1] =(int) ( all_bwmincost[(img->pix_x>>2)+block_x][(img->pix_y>>2)+block_y][ref][blocktype][2]*(-n_Bframe)/(N_Bframe-n_Bframe+1.0f)); 
 2527|      0|      }
 2528|      0|    }
 2529|      0|    else //frame case
 2530|      0|    {
 2531|      0|      if (ref > 0)
 2532|      0|      {//field_mode top_field
 2533|      0|        pred_SAD_ref = all_mincost[(img->pix_x>>2)+block_x][(img->pix_y>>2)+block_y][(ref-1)][blocktype][0];
 2534|      0|        pred_SAD_ref = flag_intra_SAD ? 0 : pred_SAD_ref;//add this for irregular motion
 2535|      0|        pred_MV_ref[0] = all_mincost[(img->pix_x>>2)+block_x][(img->pix_y>>2)+block_y][(ref-1)][blocktype][1];
 2536|      0|        pred_MV_ref[0] = (int)(pred_MV_ref[0]*(ref+1)/(float)(ref));
 2537|      0|        pred_MV_ref[1] = all_mincost[(img->pix_x>>2)+block_x][(img->pix_y>>2)+block_y][(ref-1)][blocktype][2];
 2538|      0|        pred_MV_ref[1] = (int)(pred_MV_ref[1]*(ref+1)/(float)(ref));
 2539|      0|      }
 2540|      0|      if (img->type == B_SLICE && (list==0 && ref==0)) //B frame forward prediction, first ref
 2541|      0|      {
 2542|      0|        pred_SAD_ref = all_bwmincost[(img->pix_x>>2)+block_x][(img->pix_y>>2)+block_y][0][blocktype][0];
 2543|      0|        pred_SAD_ref = flag_intra_SAD ? 0 : pred_SAD_ref;//add this for irregular motion
 2544|      0|        pred_MV_ref[0] =(int) (all_bwmincost[(img->pix_x>>2)+block_x][(img->pix_y>>2)+block_y][ref][blocktype][1]*(-n_Bframe)/(N_Bframe-n_Bframe+1.0f)); //should add a factor
 2545|      0|        pred_MV_ref[1] =(int) ( all_bwmincost[(img->pix_x>>2)+block_x][(img->pix_y>>2)+block_y][ref][blocktype][2]*(-n_Bframe)/(N_Bframe-n_Bframe+1.0f)); 
 2546|      0|      }
 2547|      0|    }
 2548|      0| }
 2549|       |
 2550|       |  //===========================================
 2551|       |  //=====   GET MOTION VECTOR PREDICTOR   =====
 2552|       |  //===========================================
 2553|       |
 2554|  20.4M|  if(input->FMEnable)
 2555|      0|    FME_blocktype=blocktype;
 2556|       |
 2557|  20.4M|  SetMotionVectorPredictor (pred_mv, enc_picture->ref_idx, enc_picture->mv, ref, list, block_x, block_y, bsx, bsy);
 2558|       |
 2559|  20.4M|  pred_mv_x = pred_mv[0];
 2560|  20.4M|  pred_mv_y = pred_mv[1];
 2561|       |
 2562|       |  //==================================
 2563|       |  //=====   INTEGER-PEL SEARCH   =====
 2564|       |  //==================================
 2565|       |
 2566|  20.4M|  if(input->FMEnable)
 2567|      0|  {
 2568|      0|    mv_x = pred_mv_x / 4;
 2569|      0|    mv_y = pred_mv_y / 4;
 2570|      0|    if (!input->rdopt)
 2571|      0|    {
 2572|       |      //--- adjust search center so that the (0,0)-vector is inside ---
 2573|      0|      mv_x = max (-search_range, min (search_range, mv_x));
 2574|      0|      mv_y = max (-search_range, min (search_range, mv_y));
 2575|      0|    }
 2576|       |    
 2577|      0|    min_mcost = FastIntegerPelBlockMotionSearch(orig_pic, ref, list, pic_pix_x, pic_pix_y, blocktype,
 2578|      0|                                                pred_mv_x, pred_mv_y, &mv_x, &mv_y, search_range,
 2579|      0|                                                min_mcost, lambda);
 2580|       |    //FAST MOTION ESTIMATION. ZHIBO CHEN 2003.3
 2581|      0|    for (i=0; i < (bsx>>2); i++)
 2582|      0|    {
 2583|      0|      for (j=0; j < (bsy>>2); j++)
 2584|      0|      {
 2585|      0|        if(list == 0) 
 2586|      0|          all_mincost[(img->pix_x>>2)+block_x+i][(img->pix_y>>2)+block_y+j][ref][blocktype][0] = min_mcost;
 2587|      0|        else
 2588|      0|          all_bwmincost[(img->pix_x>>2)+block_x+i][(img->pix_y>>2)+block_y+j][ref][blocktype][0] = min_mcost; 
 2589|      0|      }
 2590|      0|    }
 2591|      0|  }
 2592|  20.4M|  else
 2593|  20.4M|  {
 2594|       |#ifndef _FAST_FULL_ME_
 2595|       |
 2596|       |    //--- set search center ---
 2597|       |    mv_x = pred_mv_x / 4;
 2598|       |    mv_y = pred_mv_y / 4;
 2599|       |    if (!input->rdopt)
 2600|       |    {
 2601|       |      //--- adjust search center so that the (0,0)-vector is inside ---
 2602|       |      mv_x = max (-search_range, min (search_range, mv_x));
 2603|       |      mv_y = max (-search_range, min (search_range, mv_y));
 2604|       |    }
 2605|       |    
 2606|       |    //--- perform motion search ---
 2607|       |    min_mcost = FullPelBlockMotionSearch     (orig_pic, ref, list, pic_pix_x, pic_pix_y, blocktype,
 2608|       |                                              pred_mv_x, pred_mv_y, &mv_x, &mv_y, search_range,
 2609|       |                                              min_mcost, lambda);
 2610|       |
 2611|       |#else
 2612|       |
 2613|       |    // comments:   - orig_pic is not used  -> be careful
 2614|       |    //             - search center is automatically determined
 2615|  20.4M|    min_mcost = FastFullPelBlockMotionSearch (orig_pic, ref, list, pic_pix_x, pic_pix_y, blocktype,
 2616|  20.4M|                                              pred_mv_x, pred_mv_y, &mv_x, &mv_y, search_range,
 2617|  20.4M|                                              min_mcost, lambda);
 2618|       |
 2619|  20.4M|#endif // #ifndef _FAST_FULL_ME_
 2620|  20.4M|  }
 2621|       |
 2622|       |
 2623|       |  //==============================
 2624|       |  //=====   SUB-PEL SEARCH   =====
 2625|       |  //==============================
 2626|  20.4M|  if (input->hadamard && !input->hadamardqpel)
 2627|  20.4M|  {
 2628|  20.4M|    min_mcost = max_value;
 2629|  20.4M|  }
 2630|       |
 2631|  20.4M|  if(input->FMEnable)
 2632|      0|  {
 2633|      0|    if(blocktype >3)
 2634|      0|    {
 2635|      0|      min_mcost =  FastSubPelBlockMotionSearch (orig_pic, ref, list, pic_pix_x, pic_pix_y, blocktype,
 2636|      0|                                                pred_mv_x, pred_mv_y, &mv_x, &mv_y, 9, 9,
 2637|      0|                                                min_mcost, lambda, /*useABT*/0);
 2638|      0|    }
 2639|      0|    else
 2640|      0|    {
 2641|      0|      min_mcost =  SubPelBlockMotionSearch (orig_pic, ref, list, pic_pix_x, pic_pix_y, blocktype,
 2642|      0|                                            pred_mv_x, pred_mv_y, &mv_x, &mv_y, 9, 9,
 2643|      0|                                            min_mcost, lambda);
 2644|      0|    }
 2645|       |
 2646|       |
 2647|      0|    for (i=0; i < (bsx>>2); i++)
 2648|      0|    {
 2649|      0|      for (j=0; j < (bsy>>2); j++)
 2650|      0|      {
 2651|      0|        if(list == 0)
 2652|      0|        {
 2653|      0|          all_mincost[(img->pix_x>>2)+block_x+i][(img->pix_y>>2)+block_y+j][ref][blocktype][1] = mv_x;
 2654|      0|          all_mincost[(img->pix_x>>2)+block_x+i][(img->pix_y>>2)+block_y+j][ref][blocktype][2] = mv_y;
 2655|      0|        }
 2656|      0|        else
 2657|      0|        {
 2658|      0|          all_bwmincost[(img->pix_x>>2)+block_x+i][(img->pix_y>>2)+block_y+j][ref][blocktype][1] = mv_x;
 2659|      0|          all_bwmincost[(img->pix_x>>2)+block_x+i][(img->pix_y>>2)+block_y+j][ref][blocktype][2] = mv_y;
 2660|       |          
 2661|      0|        }
 2662|      0|      }
 2663|      0|    }
 2664|      0|  }
 2665|  20.4M|  else
 2666|  20.4M|  {        
 2667|  20.4M|    if (input->hadamard && !input->hadamardqpel)
 2668|  20.4M|    {
 2669|  20.4M|      min_mcost = max_value;
 2670|  20.4M|    }
 2671|       |    
 2672|  20.4M|    min_mcost =  SubPelBlockMotionSearch (orig_pic, ref, list, pic_pix_x, pic_pix_y, blocktype,
 2673|  20.4M|      pred_mv_x, pred_mv_y, &mv_x, &mv_y, 9, 9,
 2674|  20.4M|      min_mcost, lambda);            
 2675|  20.4M| }
 2676|       |
 2677|  20.4M|  if (!input->rdopt)
 2678|      0|  {
 2679|       |    // Get the skip mode cost
 2680|      0|    if (blocktype == 1 && (img->type == P_SLICE||img->type == SP_SLICE))
 2681|      0|    {
 2682|      0|      int cost;
 2683|       |
 2684|      0|      FindSkipModeMotionVector ();
 2685|       |
 2686|      0|      cost  = GetSkipCostMB (lambda);
 2687|      0|      cost -= (int)floor(8*lambda+0.4999);
 2688|       |
 2689|      0|      if (cost < min_mcost)
 2690|      0|      {
 2691|      0|        min_mcost = cost;
 2692|      0|        mv_x      = img->all_mv [0][0][0][0][0][0];
 2693|      0|        mv_y      = img->all_mv [0][0][0][0][0][1];
 2694|      0|      }
 2695|      0|    }
 2696|      0|  }
 2697|       |
 2698|       |  //===============================================
 2699|       |  //=====   SET MV'S AND RETURN MOTION COST   =====
 2700|       |  //===============================================
 2701|       |
 2702|  20.4M|  if(input->FMEnable)
 2703|      0|  {
 2704|      0|    int h4x4blkno = (img->pix_x>>2)+block_x;  
 2705|      0|    int v4x4blkno = (img->pix_y>>2)+block_y;
 2706|      0|    for (i=0; i < (bsx>>2); i++)
 2707|      0|    {
 2708|      0|      for (j=0; j < (bsy>>2); j++)
 2709|      0|      {
 2710|      0|        all_mv[block_x+i][block_y+j][list][ref][blocktype][0] = mv_x;
 2711|      0|        all_mv[block_x+i][block_y+j][list][ref][blocktype][1] = mv_y;
 2712|      0|        mv_array[h4x4blkno+i][v4x4blkno+j][0] = mv_x;
 2713|      0|        mv_array[h4x4blkno+i][v4x4blkno+j][1] = mv_y;
 2714|      0|      }
 2715|      0|    }
 2716|      0|  }
 2717|  20.4M|  else
 2718|  20.4M|  {    
 2719|  52.4M|    for (i=0; i < (bsx>>2); i++)
 2720|  31.9M|    {
 2721|  87.9M|      for (j=0; j < (bsy>>2); j++)
 2722|  55.9M|      {
 2723|  55.9M|        all_mv[block_x+i][block_y+j][list][ref][blocktype][0] = mv_x;
 2724|  55.9M|        all_mv[block_x+i][block_y+j][list][ref][blocktype][1] = mv_y;
 2725|  55.9M|      }
 2726|  31.9M|    }
 2727|  20.4M|  }
 2728|  20.4M|#if BI_PREDICTION        
 2729|  20.4M|  if (img->type==B_SLICE && input->BiPredMotionEstimation!=0 && (blocktype == 1) && (ref==0))
 2730|      0|  {
 2731|       |        
 2732|      0|    short   ******bipred_mv = list ? img->bipred_mv1 : img->bipred_mv2;
 2733|      0|    int     min_mcostbi = max_value;
 2734|      0|    short   bimv_x, bimv_y, tempmv_x ,tempmv_y;
 2735|      0|    short   pred_mv_x1, pred_mv_y1;
 2736|      0|    short   pred_mv_x2 = 0, pred_mv_y2 = 0;
 2737|      0|    short   iterlist=list;
 2738|      0|    short   pred_mv_bi[2];
 2739|       |
 2740|      0|    SetMotionVectorPredictor (pred_mv_bi, enc_picture->ref_idx, enc_picture->mv, 0, (list == LIST_0? LIST_1: LIST_0), block_x, block_y, bsx, bsy);
 2741|       |
 2742|      0|    mv_x=(mv_x + 2)>>2;
 2743|      0|    mv_y=(mv_y + 2)>>2;
 2744|       |     
 2745|      0|    for (i=0;i<=input->BiPredMERefinements;i++)
 2746|      0|    {
 2747|      0|      if (i%2)
 2748|      0|      {
 2749|      0|        pred_mv_x2=pred_mv[0];
 2750|      0|        pred_mv_y2=pred_mv[1]; 
 2751|      0|        pred_mv_x1=pred_mv_bi[0];
 2752|      0|        pred_mv_y1=pred_mv_bi[1]; 
 2753|      0|        tempmv_x=bimv_x;
 2754|      0|        tempmv_y=bimv_y;        
 2755|      0|        bimv_x=mv_x;
 2756|      0|        bimv_y=mv_y;
 2757|      0|        iterlist= (list == LIST_0? LIST_1: LIST_0);
 2758|       |        
 2759|      0|      }
 2760|      0|      else
 2761|      0|      {
 2762|      0|        pred_mv_x1=pred_mv[0];
 2763|      0|        pred_mv_y1=pred_mv[1]; 
 2764|      0|        pred_mv_x2=pred_mv_bi[0];
 2765|      0|        pred_mv_y2=pred_mv_bi[1]; 
 2766|       |
 2767|      0|        if (i!=0)
 2768|      0|        {
 2769|      0|          tempmv_x=bimv_x;
 2770|      0|          tempmv_y=bimv_y;        
 2771|      0|          bimv_x=mv_x;
 2772|      0|          bimv_y=mv_y;
 2773|      0|        }
 2774|      0|        else
 2775|      0|        {
 2776|      0|          tempmv_x=mv_x;
 2777|      0|          tempmv_y=mv_y;        
 2778|      0|          bimv_x = (pred_mv_x2 + 2)>>2;
 2779|      0|          bimv_y = (pred_mv_y2 + 2)>>2;
 2780|      0|        }
 2781|       |
 2782|      0|        iterlist=list;
 2783|      0|      }
 2784|       |
 2785|      0|      min_mcostbi = FullPelBlockMotionBiPred (orig_pic, ref, iterlist, pic_pix_x, pic_pix_y, blocktype, i,
 2786|      0|                                              pred_mv_x1, pred_mv_y1, pred_mv_x2, pred_mv_y2, 
 2787|      0|                                              &bimv_x, &bimv_y, &tempmv_x, &tempmv_y, input->BiPredMESearchRange>>i,
 2788|      0|                                              min_mcostbi, lambda );
 2789|      0|      mv_x=tempmv_x;
 2790|      0|      mv_y=tempmv_y;        
 2791|       |
 2792|      0|    }
 2793|       |    
 2794|      0|    tempmv_x=tempmv_x << 2;
 2795|      0|    tempmv_y=tempmv_y << 2;
 2796|       |
 2797|      0|    if (input->BiPredMESubPel)
 2798|      0|    {
 2799|      0|      if (input->hadamard)
 2800|      0|      {
 2801|      0|        min_mcostbi = max_value;
 2802|      0|      }
 2803|       |      
 2804|      0|      min_mcostbi =  SubPelBlockSearchBiPred (orig_pic, 0, iterlist, pic_pix_x, pic_pix_y, blocktype,
 2805|      0|                                              pred_mv_x2, pred_mv_y2, &bimv_x, &bimv_y, &tempmv_x, &tempmv_y, 9, 9,
 2806|      0|                                              min_mcostbi, lambda * 0.5);
 2807|      0|    }
 2808|      0|    else
 2809|      0|    {
 2810|      0|      bimv_x=bimv_x << 2;
 2811|      0|      bimv_y=bimv_y << 2;
 2812|      0|    }
 2813|       |
 2814|      0|    if (input->BiPredMESubPel==2)
 2815|      0|    {
 2816|      0|      if (input->hadamard)
 2817|      0|      {
 2818|      0|        min_mcostbi = max_value;
 2819|      0|      }
 2820|       |      
 2821|      0|      min_mcostbi =  SubPelBlockSearchBiPred (orig_pic, 0, (iterlist == LIST_0? LIST_1: LIST_0), pic_pix_x, pic_pix_y, blocktype,
 2822|      0|        pred_mv_x, pred_mv_y, &mv_x, &mv_y, &bimv_x, &bimv_y, 9, 9,
 2823|      0|        min_mcostbi, lambda * 0.5);      
 2824|      0|    }
 2825|      0|    else
 2826|      0|    {
 2827|      0|      mv_x=tempmv_x;
 2828|      0|      mv_y=tempmv_y;            
 2829|      0|    }
 2830|       |
 2831|      0|    for (i=0; i < (bsx>>2); i++)
 2832|      0|    {
 2833|      0|      for (j=0; j < (bsy>>2); j++)
 2834|      0|      {
 2835|      0|        bipred_mv[block_x+i][block_y+j][iterlist                          ][0][blocktype][0] = mv_x;
 2836|      0|        bipred_mv[block_x+i][block_y+j][iterlist                          ][0][blocktype][1] = mv_y;
 2837|      0|        bipred_mv[block_x+i][block_y+j][iterlist == LIST_0? LIST_1: LIST_0][0][blocktype][0] = bimv_x;
 2838|      0|        bipred_mv[block_x+i][block_y+j][iterlist == LIST_0? LIST_1: LIST_0][0][blocktype][1] = bimv_y;        
 2839|      0|      }
 2840|      0|    }
 2841|      0|  }
 2842|       |  
 2843|  20.4M|#endif
 2844|       |
 2845|  20.4M|#if defined(SPEC_CPU)
 2846|  20.4M|  tstruct2.time = 0;
 2847|  20.4M|  tstruct2.millitm = 0;
 2848|  20.4M|  tstruct2.timezone = 0;
 2849|  20.4M|  tstruct2.dstflag = 0;
 2850|       |#else
 2851|       |#ifdef WIN32
 2852|       |      _ftime(&tstruct2);   // end time ms
 2853|       |#else
 2854|       |      ftime(&tstruct2);    // end time ms
 2855|       |#endif
 2856|       |#endif /* !SPEC_CPU */
 2857|       |      
 2858|  20.4M|      me_tmp_time=(tstruct2.time*1000+tstruct2.millitm) - (tstruct1.time*1000+tstruct1.millitm); 
 2859|  20.4M|      me_tot_time += me_tmp_time;
 2860|  20.4M|      me_time += me_tmp_time;
 2861|       |
 2862|  20.4M|  return min_mcost;
 2863|  20.4M|}
 2864|       |
 2865|       |
 2866|       |/*!
 2867|       | ***********************************************************************
 2868|       | * \brief
 2869|       | *    Motion Cost for Bidirectional modes
 2870|       | ***********************************************************************
 2871|       | */
 2872|       |int BIDPartitionCost (int   blocktype,
 2873|       |                      int   block8x8,
 2874|       |                      short fw_ref,
 2875|       |                      short bw_ref,
 2876|       |                      int   lambda_factor)
 2877|  1.14M|{
 2878|  1.14M|  static int  bx0[5][4] = {{0,0,0,0}, {0,0,0,0}, {0,0,0,0}, {0,2,0,0}, {0,2,0,2}};
 2879|  1.14M|  static int  by0[5][4] = {{0,0,0,0}, {0,0,0,0}, {0,2,0,0}, {0,0,0,0}, {0,0,2,2}};
 2880|       |
 2881|       |  // tchen 4-29-04
 2882|  1.14M|  int   diff[64];
 2883|  1.14M|  int   curr_blk[MB_BLOCK_SIZE][MB_BLOCK_SIZE]; // ABT pred.error buffer
 2884|  1.14M|  int   bsx       = min(input->blc_size[blocktype][0],8);
 2885|  1.14M|  int   bsy       = min(input->blc_size[blocktype][1],8);
 2886|       |  // tchen 4-29-04 end
 2887|  1.14M|   int   pic_pix_x, pic_pix_y, block_x, block_y;
 2888|  1.14M|  int   v, h, mcost, i, j, k;
 2889|  1.14M|  int   mvd_bits  = 0;
 2890|  1.14M|  int   parttype  = (blocktype<4?blocktype:4);
 2891|  1.14M|  int   step_h0   = (input->part_size[ parttype][0]);
 2892|  1.14M|  int   step_v0   = (input->part_size[ parttype][1]);
 2893|  1.14M|  int   step_h    = (input->part_size[blocktype][0]);
 2894|  1.14M|  int   step_v    = (input->part_size[blocktype][1]);
 2895|  1.14M|  int   bxx, byy;                               // indexing curr_blk
 2896|       |
 2897|  1.14M|  short   ******all_mv = img->all_mv;
 2898|  1.14M|  short   ******  p_mv = img->pred_mv;
 2899|       |
 2900|       |  //----- cost for motion vector bits -----
 2901|  2.72M|  for (v=by0[parttype][block8x8]; v<by0[parttype][block8x8]+step_v0; v+=step_v)
 2902|  3.80M|  for (h=bx0[parttype][block8x8]; h<bx0[parttype][block8x8]+step_h0; h+=step_h)
 2903|  2.23M|  {
 2904|  2.23M|    mvd_bits += mvbits[ all_mv [h][v][LIST_0][fw_ref][blocktype][0] - p_mv[h][v][LIST_0][fw_ref][blocktype][0] ];
 2905|  2.23M|    mvd_bits += mvbits[ all_mv [h][v][LIST_0][fw_ref][blocktype][1] - p_mv[h][v][LIST_0][fw_ref][blocktype][1] ];
 2906|       |
 2907|  2.23M|    mvd_bits += mvbits[ all_mv [h][v][LIST_1][bw_ref][blocktype][0] - p_mv[h][v][LIST_1][bw_ref][blocktype][0] ];
 2908|  2.23M|    mvd_bits += mvbits[ all_mv [h][v][LIST_1][bw_ref][blocktype][1] - p_mv[h][v][LIST_1][bw_ref][blocktype][1] ];
 2909|  2.23M|  }
 2910|       |
 2911|  1.14M|  mcost = WEIGHTED_COST (lambda_factor, mvd_bits);
 2912|       |
 2913|       |  //----- cost of residual signal -----
 2914|  3.75M|  for (byy=0, v=by0[parttype][block8x8]; v<by0[parttype][block8x8]+step_v0; byy+=4, v++)
 2915|  2.61M|  {
 2916|  2.61M|    pic_pix_y = img->opix_y + (block_y = (v<<2));
 2917|       |
 2918|  8.70M|    for (bxx=0, h=bx0[parttype][block8x8]; h<bx0[parttype][block8x8]+step_h0; bxx+=4, h++)
 2919|  6.09M|    {
 2920|  6.09M|      pic_pix_x = img->opix_x + (block_x = (h<<2));
 2921|       |
 2922|  6.09M|      LumaPrediction4x4 (block_x, block_y, 2, blocktype, blocktype, fw_ref, bw_ref);
 2923|       |
 2924|  30.4M|      for (k=j=0; j<4; j++)
 2925|   121M|      for (  i=0; i<4; i++, k++)
 2926|  97.4M|      {
 2927|  97.4M|        diff[k] = curr_blk[byy+j][bxx+i] = 
 2928|  97.4M|        imgY_org[pic_pix_y+j][pic_pix_x+i] - img->mpr[i+block_x][j+block_y];
 2929|  97.4M|      }
 2930|  6.09M|      if ((!input->AllowTransform8x8) || (blocktype>4)) // tchen 4-29-04
 2931|  6.09M|        mcost += SATD (diff, input->hadamard);
 2932|  6.09M|    }
 2933|  2.61M|  }
 2934|       |
 2935|  1.14M|  if (input->AllowTransform8x8 && (blocktype<=4))  // tchen 4-29-04
 2936|      0|  {
 2937|      0|    for (byy=0; byy<input->blc_size[parttype][1]; byy+=bsy)
 2938|      0|      for (bxx=0; bxx<input->blc_size[parttype][0]; bxx+=bsx)
 2939|      0|      {
 2940|      0|        k=0;
 2941|      0|        for (i=0;i<8;i++)
 2942|      0|          for (j=0;j<8;j++)
 2943|      0|            diff[k++] = curr_blk[i+byy][j+bxx];
 2944|       |
 2945|      0|        mcost += SATD8X8(diff, input->hadamard);
 2946|      0|      }
 2947|      0|  }
 2948|  1.14M|  return mcost;
 2949|  1.14M|}
 2950|       |
 2951|       |/*!
 2952|       | ************************************************************************
 2953|       | * \brief
 2954|       | *    Get cost for skip mode for an macroblock
 2955|       | ************************************************************************
 2956|       | */
 2957|       |int GetSkipCostMB (double lambda)
 2958|      0|{
 2959|      0|  int block_y, block_x, pic_pix_y, pic_pix_x, i, j, k;
 2960|      0|  int diff[16];
 2961|      0|  int cost = 0;
 2962|       |
 2963|       |  //T.Nishi(MEI ACC) 04-28-2004
 2964|      0|  int curr_diff[8][8], diff8x8[64];
 2965|      0|  int mb_x, mb_y;
 2966|      0|  int block;  
 2967|      0|  for(block=0;block<4;block++)
 2968|      0|  {
 2969|      0|    mb_y    = (block/2)<<3;
 2970|      0|    mb_x    = (block%2)<<3;
 2971|      0|    for (block_y=mb_y; block_y<mb_y+8; block_y+=4)
 2972|      0|    {
 2973|      0|      pic_pix_y = img->opix_y + block_y;
 2974|       |
 2975|      0|      for (block_x=mb_x; block_x<mb_x+8; block_x+=4)
 2976|      0|      {
 2977|      0|        pic_pix_x = img->opix_x + block_x;
 2978|       |
 2979|       |        //===== prediction of 4x4 block =====
 2980|      0|        LumaPrediction4x4 (block_x, block_y, 0, 0, 0, 0, 0);
 2981|       |
 2982|       |        //===== get displaced frame difference ======                
 2983|      0|        for (k=j=0; j<4; j++)
 2984|      0|        for (i=0; i<4; i++, k++)
 2985|      0|        {
 2986|      0|          diff[k] = curr_diff[block_y-mb_y+j][block_x-mb_x+i] = imgY_org[pic_pix_y+j][pic_pix_x+i] - img->mpr[i+block_x][j+block_y];
 2987|      0|        }
 2988|       |
 2989|      0|        if(!((input->rdopt==0)&&(input->AllowTransform8x8)))
 2990|      0|          cost += SATD (diff, input->hadamard);
 2991|      0|      }
 2992|      0|    }
 2993|       |
 2994|      0|    if((input->rdopt==0)&&(input->AllowTransform8x8))
 2995|      0|    {
 2996|      0|      k=0;
 2997|      0|      for(j=0; j<8; j++)
 2998|      0|        for(i=0; i<8; i++, k++)
 2999|      0|          diff8x8[k]=curr_diff[j][i];
 3000|       |
 3001|      0|      cost += SATD8X8 (diff8x8, input->hadamard);
 3002|      0|    }
 3003|      0|  }
 3004|       |
 3005|      0|  return cost;
 3006|       |  //T.Nishi(MEI ACC) 04-28-2004 end
 3007|      0|}
 3008|       |
 3009|       |/*!
 3010|       | ************************************************************************
 3011|       | * \brief
 3012|       | *    Find motion vector for the Skip mode
 3013|       | ************************************************************************
 3014|       | */
 3015|       |void FindSkipModeMotionVector ()
 3016|  36.4k|{
 3017|  36.4k|  int   bx, by;
 3018|  36.4k|  short ******all_mv = img->all_mv;
 3019|       |
 3020|  36.4k|  short pmv[2];
 3021|       |
 3022|  36.4k|  int zeroMotionAbove;
 3023|  36.4k|  int zeroMotionLeft;
 3024|  36.4k|  PixelPos mb_a, mb_b;
 3025|  36.4k|  int      a_mv_y = 0;
 3026|  36.4k|  int      a_ref_idx = 0;
 3027|  36.4k|  int      b_mv_y = 0;
 3028|  36.4k|  int      b_ref_idx = 0;
 3029|       |
 3030|  36.4k|  Macroblock *currMB = &img->mb_data[img->current_mb_nr];
 3031|       |  
 3032|  36.4k|  getLuma4x4Neighbour(img->current_mb_nr,0,0,-1, 0,&mb_a);
 3033|  36.4k|  getLuma4x4Neighbour(img->current_mb_nr,0,0, 0,-1,&mb_b);
 3034|       |  
 3035|  36.4k|  if (mb_a.available)
 3036|  35.3k|  {
 3037|  35.3k|    a_mv_y    = enc_picture->mv[LIST_0][mb_a.pos_x][mb_a.pos_y][1];
 3038|  35.3k|    a_ref_idx = enc_picture->ref_idx[LIST_0][mb_a.pos_x][mb_a.pos_y];
 3039|       |    
 3040|  35.3k|    if (currMB->mb_field && !img->mb_data[mb_a.mb_addr].mb_field)
 3041|      0|    {
 3042|      0|      a_mv_y    /=2;
 3043|      0|      a_ref_idx *=2;
 3044|      0|    }
 3045|  35.3k|    if (!currMB->mb_field && img->mb_data[mb_a.mb_addr].mb_field)
 3046|      0|    {
 3047|      0|      a_mv_y    *=2;
 3048|      0|      a_ref_idx >>=1;
 3049|      0|    }
 3050|  35.3k|  }
 3051|       |  
 3052|  36.4k|  if (mb_b.available)
 3053|  34.6k|  {
 3054|  34.6k|    b_mv_y    = enc_picture->mv[LIST_0][mb_b.pos_x][mb_b.pos_y][1];
 3055|  34.6k|    b_ref_idx = enc_picture->ref_idx[LIST_0][mb_b.pos_x][mb_b.pos_y];
 3056|       |    
 3057|  34.6k|    if (currMB->mb_field && !img->mb_data[mb_b.mb_addr].mb_field)
 3058|      0|    {
 3059|      0|      b_mv_y    /=2;
 3060|      0|      b_ref_idx *=2;
 3061|      0|    }
 3062|  34.6k|    if (!currMB->mb_field && img->mb_data[mb_b.mb_addr].mb_field)
 3063|      0|    {
 3064|      0|      b_mv_y    *=2;
 3065|      0|      b_ref_idx >>=1;
 3066|      0|    }
 3067|  34.6k|  }
 3068|       |  
 3069|  36.4k|  zeroMotionLeft  = !mb_a.available ? 1 : a_ref_idx==0 && enc_picture->mv[LIST_0][mb_a.pos_x][mb_a.pos_y][0]==0 && a_mv_y==0 ? 1 : 0;
 3070|  36.4k|  zeroMotionAbove = !mb_b.available ? 1 : b_ref_idx==0 && enc_picture->mv[LIST_0][mb_b.pos_x][mb_b.pos_y][0]==0 && b_mv_y==0 ? 1 : 0;
 3071|       |  
 3072|  36.4k|  if (zeroMotionAbove || zeroMotionLeft)
 3073|  5.19k|  {
 3074|  25.9k|    for (by = 0;by < 4;by++)
 3075|   103k|      for (bx = 0;bx < 4;bx++)
 3076|  83.0k|      {
 3077|  83.0k|        all_mv [bx][by][0][0][0][0] = 0;
 3078|  83.0k|        all_mv [bx][by][0][0][0][1] = 0;
 3079|  83.0k|      }
 3080|  5.19k|  }
 3081|  31.2k|  else
 3082|  31.2k|  {
 3083|  31.2k|    SetMotionVectorPredictor (pmv, enc_picture->ref_idx, enc_picture->mv, 0, LIST_0, 0, 0, 16, 16);
 3084|   156k|    for (by = 0;by < 4;by++)
 3085|   625k|      for (bx = 0;bx < 4;bx++)
 3086|   500k|      {
 3087|   500k|        all_mv [bx][by][0][0][0][0] = pmv[0];
 3088|   500k|        all_mv [bx][by][0][0][0][1] = pmv[1];
 3089|   500k|      }
 3090|  31.2k|  }
 3091|  36.4k|}
 3092|       |
 3093|       |/*!
 3094|       | ************************************************************************
 3095|       | * \brief
 3096|       | *    Get cost for direct mode for an 8x8 block
 3097|       | ************************************************************************
 3098|       | */
 3099|       |int Get_Direct_Cost8x8 (int block, int *cost8x8)
 3100|      0|{
 3101|      0|  int block_y, block_x, pic_pix_y, pic_pix_x, i, j, k;
 3102|      0|  int curr_diff[8][8], diff8x8[64];
 3103|      0|  int diff[16];
 3104|      0|  int cost  = 0;
 3105|      0|  int mb_y  = (block/2)<<3;
 3106|      0|  int mb_x  = (block%2)<<3;
 3107|       |
 3108|      0|  for (block_y=mb_y; block_y<mb_y+8; block_y+=4)
 3109|      0|  {
 3110|      0|    pic_pix_y = img->opix_y + block_y;
 3111|       |
 3112|      0|    for (block_x=mb_x; block_x<mb_x+8; block_x+=4)
 3113|      0|    {
 3114|      0|      pic_pix_x = img->opix_x + block_x;
 3115|       |
 3116|      0|      if (direct_pdir[pic_pix_x>>2][pic_pix_y>>2]<0)
 3117|      0|      {
 3118|      0|        *cost8x8=INT_MAX;
 3119|      0|        return INT_MAX; //mode not allowed 
 3120|      0|      }
 3121|       |
 3122|       |      //===== prediction of 4x4 block =====
 3123|       |
 3124|      0|      LumaPrediction4x4 (block_x, block_y, direct_pdir[pic_pix_x>>2][pic_pix_y>>2], 0, 0, 
 3125|      0|                         direct_ref_idx[LIST_0][pic_pix_x>>2][pic_pix_y>>2], 
 3126|      0|                         direct_ref_idx[LIST_1][pic_pix_x>>2][pic_pix_y>>2]);
 3127|       |
 3128|       |      //===== get displaced frame difference ======                
 3129|      0|      for (k=j=0; j<4; j++)
 3130|      0|        for (i=0; i<4; i++, k++)
 3131|      0|        {
 3132|      0|          diff[k] = curr_diff[block_y-mb_y+j][block_x-mb_x+i] =
 3133|      0|          imgY_org[pic_pix_y+j][pic_pix_x+i] - img->mpr[i+block_x][j+block_y];
 3134|      0|        }
 3135|       |
 3136|      0|      cost += SATD (diff, input->hadamard);
 3137|      0|    }
 3138|      0|  }
 3139|       |
 3140|      0|  if((input->rdopt==0)&&(input->AllowTransform8x8))
 3141|      0|  {
 3142|      0|    k=0;
 3143|      0|    for(j=0; j<8; j++)
 3144|      0|      for(i=0; i<8; i++, k++)
 3145|      0|        diff8x8[k]=curr_diff[j][i];
 3146|       |
 3147|      0|    *cost8x8 += SATD8X8 (diff8x8, input->hadamard);
 3148|      0|  }
 3149|       |
 3150|      0|  return cost;
 3151|      0|}
 3152|       |
 3153|       |
 3154|       |
 3155|       |/*!
 3156|       | ************************************************************************
 3157|       | * \brief
 3158|       | *    Get cost for direct mode for an macroblock
 3159|       | ************************************************************************
 3160|       | */
 3161|       |int Get_Direct_CostMB (double lambda)
 3162|      0|{
 3163|      0|  int i;
 3164|      0|  int cost = 0;
 3165|      0|  int cost8x8 = 0;
 3166|       |  
 3167|      0|  for (i=0; i<4; i++)
 3168|      0|  {
 3169|      0|    cost += Get_Direct_Cost8x8 (i, &cost8x8);
 3170|      0|    if ((cost == INT_MAX) || (cost8x8 == INT_MAX)) return cost;
 3171|      0|  }
 3172|       |
 3173|       |  // T.Nishi(MEI ACC) 04-28-2004
 3174|      0|  switch(input->AllowTransform8x8)
 3175|      0|  {
 3176|      0|  case 1: // Mixture of 8x8 & 4x4 transform
 3177|      0|          if((cost8x8 < cost)||
 3178|      0|            !(input->InterSearch8x4 &&
 3179|      0|            input->InterSearch4x8 &&
 3180|      0|            input->InterSearch4x4)
 3181|      0|            )
 3182|      0|          {
 3183|      0|            cost = cost8x8; //return 8x8 cost
 3184|      0|          }
 3185|      0|          break;
 3186|      0|  case 2: // 8x8 Transform only
 3187|      0|          cost = cost8x8;
 3188|      0|          break;
 3189|      0|  default: // 4x4 Transform only
 3190|      0|          break;
 3191|      0|  }
 3192|       |
 3193|      0|  return cost;
 3194|       |  // T.Nishi(MEI ACC) 04-28-2004 end
 3195|      0|}
 3196|       |
 3197|       |
 3198|       |/*!
 3199|       | ************************************************************************
 3200|       | * \brief
 3201|       | *    Motion search for a partition
 3202|       | ************************************************************************
 3203|       | */
 3204|       |void
 3205|       |PartitionMotionSearch (int    blocktype,
 3206|       |                       int    block8x8,
 3207|       |                       double lambda)
 3208|  1.90M|{
 3209|  1.90M|  static int  bx0[5][4] = {{0,0,0,0}, {0,0,0,0}, {0,0,0,0}, {0,2,0,0}, {0,2,0,2}};
 3210|  1.90M|  static int  by0[5][4] = {{0,0,0,0}, {0,0,0,0}, {0,2,0,0}, {0,0,0,0}, {0,0,2,2}};
 3211|       |
 3212|  1.90M|  short **ref_array, ***mv_array;
 3213|  1.90M|  short ref;
 3214|  1.90M|  int   v, h, mcost, search_range, i, j;
 3215|  1.90M|  int   pic_block_x, pic_block_y;
 3216|  1.90M|  int   bslice    = (img->type==B_SLICE);
 3217|  1.90M|  int   parttype  = (blocktype<4?blocktype:4);
 3218|  1.90M|  int   step_h0   = (input->part_size[ parttype][0]);
 3219|  1.90M|  int   step_v0   = (input->part_size[ parttype][1]);
 3220|  1.90M|  int   step_h    = (input->part_size[blocktype][0]);
 3221|  1.90M|  int   step_v    = (input->part_size[blocktype][1]);
 3222|  1.90M|  int   list;
 3223|  1.90M|  int   numlists;
 3224|  1.90M|  int   list_offset;
 3225|       |
 3226|  1.90M|  if (img->mb_data[img->current_mb_nr].mb_field)
 3227|      0|  {
 3228|      0|    if(img->current_mb_nr%2)
 3229|      0|      list_offset = 4; // bottom field mb
 3230|      0|    else
 3231|      0|      list_offset = 2; // top field mb
 3232|      0|  }
 3233|  1.90M|  else
 3234|  1.90M|  {
 3235|  1.90M|    list_offset = 0;  // no mb aff or frame mb
 3236|  1.90M|  }
 3237|       |
 3238|  1.90M|  numlists=bslice?2:1;
 3239|       |
 3240|       |  //===== LOOP OVER REFERENCE FRAMES =====
 3241|  4.95M|  for (list=0; list<numlists;list++)
 3242|  3.05M|  {
 3243|  13.5M|    for (ref=0; ref < listXsize[list+list_offset]; ref++)
 3244|  10.4M|    {
 3245|       |        //----- set search range ---
 3246|  10.4M|#ifdef _FULL_SEARCH_RANGE_
 3247|  10.4M|        if      (input->full_search == 2) search_range = input->search_range;
 3248|      0|        else if (input->full_search == 1) search_range = input->search_range /  (min(ref,1)+1);
 3249|      0|        else                              search_range = input->search_range / ((min(ref,1)+1) * min(2,blocktype));
 3250|       |#else
 3251|       |        search_range = input->search_range / ((min(ref,1)+1) * min(2,blocktype));
 3252|       |#endif
 3253|       |        
 3254|       |        //----- set arrays -----
 3255|  10.4M|        ref_array = enc_picture->ref_idx[list];
 3256|  10.4M|        mv_array  = enc_picture->mv[list];
 3257|       |        
 3258|       |        //----- init motion cost -----
 3259|  10.4M|        motion_cost[blocktype][list][ref][block8x8] = 0;
 3260|       |        
 3261|       |        //===== LOOP OVER SUB MACRO BLOCK partitions
 3262|  24.9M|        for (v=by0[parttype][block8x8]; v<by0[parttype][block8x8]+step_v0; v+=step_v)
 3263|  14.4M|        {
 3264|  14.4M|          pic_block_y = img->block_y + v;
 3265|       |          
 3266|  34.9M|          for (h=bx0[parttype][block8x8]; h<bx0[parttype][block8x8]+step_h0; h+=step_h)
 3267|  20.4M|          {
 3268|  20.4M|            pic_block_x = img->block_x + h;
 3269|       |            
 3270|       |            //--- motion search for block ---
 3271|       |
 3272|  20.4M|            mcost = BlockMotionSearch     (ref, list, h<<2, v<<2, blocktype, search_range, lambda);
 3273|  20.4M|            motion_cost[blocktype][list][ref][block8x8] += mcost;
 3274|       |            
 3275|       |            //--- set motion vectors and reference frame (for motion vector prediction) ---
 3276|  52.4M|            for (j=0; j<step_v; j++)
 3277|  87.9M|              for (i=0; i<step_h; i++)
 3278|  55.9M|              {
 3279|  55.9M|                mv_array  [pic_block_x+i][pic_block_y+j][0] = img->all_mv[h][v][list][ref][blocktype][0];
 3280|  55.9M|                mv_array  [pic_block_x+i][pic_block_y+j][1] = img->all_mv[h][v][list][ref][blocktype][1];
 3281|  55.9M|                ref_array [pic_block_x+i][pic_block_y+j]    = ref;
 3282|  55.9M|              }
 3283|  20.4M|          }
 3284|  14.4M|        }
 3285|  10.4M|    }
 3286|  3.05M|  }
 3287|  1.90M|}
 3288|       |
 3289|       |
 3290|       |
 3291|       |
 3292|       |
 3293|       |extern int* last_P_no;
 3294|       |/*********************************************
 3295|       | *****                                   *****
 3296|       | *****  Calculate Direct Motion Vectors  *****
 3297|       | *****                                   *****
 3298|       | *********************************************/
 3299|       |void Get_Direct_Motion_Vectors ()
 3300|  54.4k|{
 3301|       |
 3302|  54.4k|  int   block_x, block_y, pic_block_x, pic_block_y, opic_block_x, opic_block_y;
 3303|  54.4k|  short ******all_mvs = img->all_mv;
 3304|  54.4k|  int   mv_scale;
 3305|  54.4k|  byte  **   moving_block;
 3306|  54.4k|  short ****   co_located_mv;
 3307|  54.4k|  short ***    co_located_ref_idx;
 3308|  54.4k|  int64 ***    co_located_ref_id;
 3309|  54.4k|  Macroblock *currMB = &img->mb_data[img->current_mb_nr];
 3310|       |
 3311|  54.4k|  if ((img->MbaffFrameFlag)&&(currMB->mb_field))
 3312|      0|  {
 3313|      0|    if(img->current_mb_nr%2)
 3314|      0|    {
 3315|      0|      moving_block = Co_located->bottom_moving_block;
 3316|      0|      co_located_mv = Co_located->bottom_mv;
 3317|      0|      co_located_ref_idx = Co_located->bottom_ref_idx;
 3318|      0|      co_located_ref_id = Co_located->bottom_ref_pic_id;
 3319|      0|    }
 3320|      0|    else
 3321|      0|    {
 3322|      0|      moving_block = Co_located->top_moving_block;
 3323|      0|      co_located_mv = Co_located->top_mv;
 3324|      0|      co_located_ref_idx = Co_located->top_ref_idx;
 3325|      0|      co_located_ref_id = Co_located->top_ref_pic_id;
 3326|      0|    }
 3327|      0|  }
 3328|  54.4k|  else
 3329|  54.4k|  {
 3330|  54.4k|    moving_block = Co_located->moving_block;
 3331|  54.4k|    co_located_mv = Co_located->mv;
 3332|  54.4k|    co_located_ref_idx = Co_located->ref_idx;
 3333|  54.4k|    co_located_ref_id = Co_located->ref_pic_id;
 3334|  54.4k|  }
 3335|       |
 3336|  54.4k|  if (img->direct_spatial_mv_pred_flag)  //spatial direct mode copy from decoder
 3337|  54.4k|  {
 3338|       |    
 3339|  54.4k|    short fw_rFrameL, fw_rFrameU, fw_rFrameUL, fw_rFrameUR;
 3340|  54.4k|    short bw_rFrameL, bw_rFrameU, bw_rFrameUL, bw_rFrameUR; 
 3341|  54.4k|    short fw_rFrame,bw_rFrame;
 3342|  54.4k|    short pmvfw[2]={0,0},pmvbw[2]={0,0};
 3343|       |
 3344|  54.4k|    PixelPos mb_left, mb_up, mb_upleft, mb_upright;              
 3345|       |    
 3346|  54.4k|    getLuma4x4Neighbour(img->current_mb_nr,0,0,-1, 0,&mb_left);
 3347|  54.4k|    getLuma4x4Neighbour(img->current_mb_nr,0,0, 0,-1,&mb_up);
 3348|  54.4k|    getLuma4x4Neighbour(img->current_mb_nr,0,0,16, -1,&mb_upright);
 3349|  54.4k|    getLuma4x4Neighbour(img->current_mb_nr,0,0, -1,-1,&mb_upleft);
 3350|       |
 3351|  54.4k|    if (!img->MbaffFrameFlag)
 3352|  54.4k|    {
 3353|  54.4k|      fw_rFrameL = mb_left.available ? enc_picture->ref_idx[LIST_0][mb_left.pos_x][mb_left.pos_y] : -1;
 3354|  54.4k|      fw_rFrameU = mb_up.available ? enc_picture->ref_idx[LIST_0][mb_up.pos_x][mb_up.pos_y] : -1;
 3355|  54.4k|      fw_rFrameUL = mb_upleft.available ? enc_picture->ref_idx[LIST_0][mb_upleft.pos_x][mb_upleft.pos_y] : -1;
 3356|  54.4k|      fw_rFrameUR = mb_upright.available ? enc_picture->ref_idx[LIST_0][mb_upright.pos_x][mb_upright.pos_y] : fw_rFrameUL;      
 3357|       |      
 3358|  54.4k|      bw_rFrameL = mb_left.available ? enc_picture->ref_idx[LIST_1][mb_left.pos_x][mb_left.pos_y] : -1;
 3359|  54.4k|      bw_rFrameU = mb_up.available ? enc_picture->ref_idx[LIST_1][mb_up.pos_x][mb_up.pos_y] : -1;
 3360|  54.4k|      bw_rFrameUL = mb_upleft.available ? enc_picture->ref_idx[LIST_1][mb_upleft.pos_x][mb_upleft.pos_y] : -1;
 3361|  54.4k|      bw_rFrameUR = mb_upright.available ? enc_picture->ref_idx[LIST_1][mb_upright.pos_x][mb_upright.pos_y] : bw_rFrameUL;      
 3362|  54.4k|    }
 3363|      0|    else
 3364|      0|    {
 3365|      0|      if (currMB->mb_field)
 3366|      0|      {
 3367|      0|        fw_rFrameL = mb_left.available ? 
 3368|      0|          img->mb_data[mb_left.mb_addr].mb_field  || enc_picture->ref_idx[LIST_0][mb_left.pos_x][mb_left.pos_y] < 0? 
 3369|      0|          enc_picture->ref_idx[LIST_0][mb_left.pos_x][mb_left.pos_y] : 
 3370|      0|          enc_picture->ref_idx[LIST_0][mb_left.pos_x][mb_left.pos_y] * 2: -1;
 3371|       |
 3372|      0|        fw_rFrameU = mb_up.available ? 
 3373|      0|          img->mb_data[mb_up.mb_addr].mb_field || enc_picture->ref_idx[LIST_0][mb_up.pos_x][mb_up.pos_y] < 0? 
 3374|      0|          enc_picture->ref_idx[LIST_0][mb_up.pos_x][mb_up.pos_y] : 
 3375|      0|        enc_picture->ref_idx[LIST_0][mb_up.pos_x][mb_up.pos_y] * 2: -1;
 3376|       |
 3377|      0|        fw_rFrameUL = mb_upleft.available ? 
 3378|      0|          img->mb_data[mb_upleft.mb_addr].mb_field || enc_picture->ref_idx[LIST_0][mb_upleft.pos_x][mb_upleft.pos_y] < 0?         
 3379|      0|          enc_picture->ref_idx[LIST_0][mb_upleft.pos_x][mb_upleft.pos_y] : 
 3380|      0|        enc_picture->ref_idx[LIST_0][mb_upleft.pos_x][mb_upleft.pos_y] *2: -1;      
 3381|       |
 3382|      0|        fw_rFrameUR = mb_upright.available ? 
 3383|      0|          img->mb_data[mb_upright.mb_addr].mb_field || enc_picture->ref_idx[LIST_0][mb_upright.pos_x][mb_upright.pos_y] < 0?
 3384|      0|          enc_picture->ref_idx[LIST_0][mb_upright.pos_x][mb_upright.pos_y] : 
 3385|      0|        enc_picture->ref_idx[LIST_0][mb_upright.pos_x][mb_upright.pos_y] * 2: fw_rFrameUL;      
 3386|       |        
 3387|      0|        bw_rFrameL = mb_left.available ? 
 3388|      0|          img->mb_data[mb_left.mb_addr].mb_field || enc_picture->ref_idx[LIST_1][mb_left.pos_x][mb_left.pos_y] < 0? 
 3389|      0|          enc_picture->ref_idx[LIST_1][mb_left.pos_x][mb_left.pos_y] : 
 3390|      0|        enc_picture->ref_idx[LIST_1][mb_left.pos_x][mb_left.pos_y] * 2: -1;
 3391|       |
 3392|      0|        bw_rFrameU = mb_up.available ? 
 3393|      0|          img->mb_data[mb_up.mb_addr].mb_field || enc_picture->ref_idx[LIST_1][mb_up.pos_x][mb_up.pos_y] < 0? 
 3394|      0|          enc_picture->ref_idx[LIST_1][mb_up.pos_x][mb_up.pos_y] : 
 3395|      0|        enc_picture->ref_idx[LIST_1][mb_up.pos_x][mb_up.pos_y] * 2: -1;
 3396|       |
 3397|      0|        bw_rFrameUL = mb_upleft.available ? 
 3398|      0|          img->mb_data[mb_upleft.mb_addr].mb_field || enc_picture->ref_idx[LIST_1][mb_upleft.pos_x][mb_upleft.pos_y] < 0?         
 3399|      0|          enc_picture->ref_idx[LIST_1][mb_upleft.pos_x][mb_upleft.pos_y] : 
 3400|      0|        enc_picture->ref_idx[LIST_1][mb_upleft.pos_x][mb_upleft.pos_y] *2: -1;      
 3401|       |
 3402|      0|        bw_rFrameUR = mb_upright.available ? 
 3403|      0|          img->mb_data[mb_upright.mb_addr].mb_field || enc_picture->ref_idx[LIST_1][mb_upright.pos_x][mb_upright.pos_y] < 0?         
 3404|      0|          enc_picture->ref_idx[LIST_1][mb_upright.pos_x][mb_upright.pos_y] : 
 3405|      0|        enc_picture->ref_idx[LIST_1][mb_upright.pos_x][mb_upright.pos_y] * 2: bw_rFrameUL;              
 3406|      0|      }
 3407|      0|      else
 3408|      0|      {
 3409|      0|        fw_rFrameL = mb_left.available ? 
 3410|      0|          img->mb_data[mb_left.mb_addr].mb_field || enc_picture->ref_idx[LIST_0][mb_left.pos_x][mb_left.pos_y]  < 0 ?
 3411|      0|          enc_picture->ref_idx[LIST_0][mb_left.pos_x][mb_left.pos_y] >> 1 : 
 3412|      0|        enc_picture->ref_idx[LIST_0][mb_left.pos_x][mb_left.pos_y]: -1;
 3413|       |        
 3414|      0|        fw_rFrameU = mb_up.available ? 
 3415|      0|          img->mb_data[mb_up.mb_addr].mb_field || enc_picture->ref_idx[LIST_0][mb_up.pos_x][mb_up.pos_y] < 0 ?
 3416|      0|          enc_picture->ref_idx[LIST_0][mb_up.pos_x][mb_up.pos_y] >> 1 :  
 3417|      0|        enc_picture->ref_idx[LIST_0][mb_up.pos_x][mb_up.pos_y] : -1;
 3418|       |        
 3419|      0|        fw_rFrameUL = mb_upleft.available ? 
 3420|      0|          img->mb_data[mb_upleft.mb_addr].mb_field || enc_picture->ref_idx[LIST_0][mb_upleft.pos_x][mb_upleft.pos_y] < 0 ?
 3421|      0|          enc_picture->ref_idx[LIST_0][mb_upleft.pos_x][mb_upleft.pos_y]>> 1 : 
 3422|      0|        enc_picture->ref_idx[LIST_0][mb_upleft.pos_x][mb_upleft.pos_y] : -1;      
 3423|       |        
 3424|      0|        fw_rFrameUR = mb_upright.available ? 
 3425|      0|          img->mb_data[mb_upright.mb_addr].mb_field || enc_picture->ref_idx[LIST_0][mb_upright.pos_x][mb_upright.pos_y] < 0 ? 
 3426|      0|          enc_picture->ref_idx[LIST_0][mb_upright.pos_x][mb_upright.pos_y] >> 1 :  
 3427|      0|        enc_picture->ref_idx[LIST_0][mb_upright.pos_x][mb_upright.pos_y] : fw_rFrameUL;      
 3428|       |        
 3429|      0|        bw_rFrameL = mb_left.available ? 
 3430|      0|          img->mb_data[mb_left.mb_addr].mb_field || enc_picture->ref_idx[LIST_1][mb_left.pos_x][mb_left.pos_y] < 0 ?
 3431|      0|          enc_picture->ref_idx[LIST_1][mb_left.pos_x][mb_left.pos_y] >> 1 :  
 3432|      0|        enc_picture->ref_idx[LIST_1][mb_left.pos_x][mb_left.pos_y] : -1;
 3433|       |        
 3434|      0|        bw_rFrameU = mb_up.available ? 
 3435|      0|          img->mb_data[mb_up.mb_addr].mb_field || enc_picture->ref_idx[LIST_1][mb_up.pos_x][mb_up.pos_y] < 0 ?
 3436|      0|          enc_picture->ref_idx[LIST_1][mb_up.pos_x][mb_up.pos_y] >> 1 : 
 3437|      0|        enc_picture->ref_idx[LIST_1][mb_up.pos_x][mb_up.pos_y] : -1;
 3438|       |        
 3439|      0|        bw_rFrameUL = mb_upleft.available ? 
 3440|      0|          img->mb_data[mb_upleft.mb_addr].mb_field || enc_picture->ref_idx[LIST_1][mb_upleft.pos_x][mb_upleft.pos_y] < 0 ?
 3441|      0|          enc_picture->ref_idx[LIST_1][mb_upleft.pos_x][mb_upleft.pos_y] >> 1 : 
 3442|      0|        enc_picture->ref_idx[LIST_1][mb_upleft.pos_x][mb_upleft.pos_y] : -1;      
 3443|       |        
 3444|      0|        bw_rFrameUR = mb_upright.available ? 
 3445|      0|          img->mb_data[mb_upright.mb_addr].mb_field || enc_picture->ref_idx[LIST_1][mb_upright.pos_x][mb_upright.pos_y] < 0 ?
 3446|      0|          enc_picture->ref_idx[LIST_1][mb_upright.pos_x][mb_upright.pos_y] >> 1: 
 3447|      0|        enc_picture->ref_idx[LIST_1][mb_upright.pos_x][mb_upright.pos_y] : bw_rFrameUL;      
 3448|      0|      }
 3449|      0|    }
 3450|       |    
 3451|  54.4k|    fw_rFrame = (fw_rFrameL >= 0 && fw_rFrameU >= 0) ? min(fw_rFrameL,fw_rFrameU): max(fw_rFrameL,fw_rFrameU);
 3452|  54.4k|    fw_rFrame = (fw_rFrame >= 0 && fw_rFrameUR >= 0) ? min(fw_rFrame,fw_rFrameUR): max(fw_rFrame,fw_rFrameUR);
 3453|       |    
 3454|  54.4k|    bw_rFrame = (bw_rFrameL >= 0 && bw_rFrameU >= 0) ? min(bw_rFrameL,bw_rFrameU): max(bw_rFrameL,bw_rFrameU);
 3455|  54.4k|    bw_rFrame = (bw_rFrame >= 0 && bw_rFrameUR >= 0) ? min(bw_rFrame,bw_rFrameUR): max(bw_rFrame,bw_rFrameUR);        
 3456|       |    
 3457|  54.4k|    if (fw_rFrame >=0)
 3458|  43.7k|      SetMotionVectorPredictor (pmvfw, enc_picture->ref_idx, enc_picture->mv, fw_rFrame, LIST_0, 0, 0, 16, 16);
 3459|       |    
 3460|  54.4k|    if (bw_rFrame >=0)
 3461|  39.5k|      SetMotionVectorPredictor (pmvbw, enc_picture->ref_idx, enc_picture->mv, bw_rFrame, LIST_1, 0, 0, 16, 16);
 3462|       |
 3463|   272k|    for (block_y=0; block_y<4; block_y++)
 3464|   217k|    {
 3465|   217k|      pic_block_y  = (img->pix_y>>2) + block_y;
 3466|   217k|      opic_block_y = (img->opix_y>>2) + block_y;
 3467|       |      
 3468|  1.08M|      for (block_x=0; block_x<4; block_x++)
 3469|   870k|      {
 3470|   870k|        pic_block_x  = (img->pix_x>>2) + block_x;
 3471|   870k|        opic_block_x = (img->opix_x>>2) + block_x;
 3472|       |
 3473|   870k|        if (fw_rFrame >=0)
 3474|   699k|        {
 3475|   699k|          if (!fw_rFrame  && !moving_block[opic_block_x][opic_block_y])
 3476|  27.3k|          {
 3477|  27.3k|            all_mvs [block_x][block_y][LIST_0][0][0][0] = 0;
 3478|  27.3k|            all_mvs [block_x][block_y][LIST_0][0][0][1] = 0;            
 3479|  27.3k|            direct_ref_idx[LIST_0][pic_block_x][pic_block_y]=0;       
 3480|  27.3k|          }
 3481|   672k|          else
 3482|   672k|          {
 3483|   672k|            all_mvs [block_x][block_y][LIST_0][fw_rFrame][0][0] = pmvfw[0];
 3484|   672k|            all_mvs [block_x][block_y][LIST_0][fw_rFrame][0][1] = pmvfw[1];
 3485|   672k|            direct_ref_idx[LIST_0][pic_block_x][pic_block_y]=fw_rFrame;              
 3486|   672k|          }
 3487|   699k|        }
 3488|   170k|        else
 3489|   170k|        {
 3490|   170k|          all_mvs [block_x][block_y][LIST_0][0][0][0] = 0;
 3491|   170k|          all_mvs [block_x][block_y][LIST_0][0][0][1] = 0;
 3492|   170k|          direct_ref_idx[LIST_0][pic_block_x][pic_block_y]=-1;          
 3493|   170k|        }
 3494|       |
 3495|   870k|        if (bw_rFrame >=0)
 3496|   632k|        {
 3497|   632k|          if(bw_rFrame==0 && !moving_block[opic_block_x][opic_block_y])
 3498|  26.3k|          {                  
 3499|  26.3k|            all_mvs [block_x][block_y][LIST_1][0][0][0] = 0;
 3500|  26.3k|            all_mvs [block_x][block_y][LIST_1][0][0][1] = 0;
 3501|  26.3k|            direct_ref_idx[LIST_1][pic_block_x][pic_block_y]=bw_rFrame;     
 3502|  26.3k|          }
 3503|   606k|          else
 3504|   606k|          {
 3505|   606k|            all_mvs [block_x][block_y][LIST_1][bw_rFrame][0][0] = pmvbw[0];
 3506|   606k|            all_mvs [block_x][block_y][LIST_1][bw_rFrame][0][1] = pmvbw[1];
 3507|   606k|            direct_ref_idx[LIST_1][pic_block_x][pic_block_y]=bw_rFrame;
 3508|   606k|          }               
 3509|   632k|        }
 3510|   237k|        else
 3511|   237k|        {      
 3512|   237k|          direct_ref_idx[LIST_1][pic_block_x][pic_block_y]=-1;
 3513|       |
 3514|   237k|          all_mvs [block_x][block_y][LIST_1][0][0][0] = 0;
 3515|   237k|          all_mvs [block_x][block_y][LIST_1][0][0][1] = 0;
 3516|   237k|        }
 3517|       |        
 3518|   870k|        if (fw_rFrame < 0 && bw_rFrame < 0)
 3519|  1.66k|        {
 3520|  1.66k|          direct_ref_idx[LIST_0][pic_block_x][pic_block_y] = 
 3521|  1.66k|          direct_ref_idx[LIST_1][pic_block_x][pic_block_y] = 0;
 3522|  1.66k|        }
 3523|       |
 3524|   870k|        if      (direct_ref_idx[LIST_1][pic_block_x][pic_block_y]==-1) direct_pdir[pic_block_x][pic_block_y] = 0;
 3525|   634k|        else if (direct_ref_idx[LIST_0][pic_block_x][pic_block_y]==-1) direct_pdir[pic_block_x][pic_block_y] = 1;
 3526|   465k|        else                                                           direct_pdir[pic_block_x][pic_block_y] = 2;
 3527|   870k|      }
 3528|   217k|    }
 3529|  54.4k|  }
 3530|      0|  else
 3531|      0|  {
 3532|       |    //temporal direct mode copy from decoder
 3533|      0|    for (block_y=0; block_y<4; block_y++)
 3534|      0|    {
 3535|      0|      pic_block_y  = (img->pix_y>>2) + block_y;
 3536|      0|      opic_block_y = (img->opix_y>>2) + block_y;
 3537|       |      
 3538|      0|      for (block_x=0; block_x<4; block_x++)
 3539|      0|      {
 3540|      0|        int refList; 
 3541|      0|        int ref_idx; 
 3542|       |
 3543|      0|        int list_offset = ((img->MbaffFrameFlag)&&(currMB->mb_field))? img->current_mb_nr%2 ? 4 : 2 : 0;
 3544|       |
 3545|      0|        pic_block_x  = (img->pix_x>>2) + block_x;
 3546|      0|        opic_block_x = (img->opix_x>>2) + block_x;
 3547|       |        
 3548|      0|        refList = (co_located_ref_idx[LIST_0][opic_block_x][opic_block_y]== -1 ? LIST_1 : LIST_0);
 3549|      0|        ref_idx = co_located_ref_idx[refList][opic_block_x][opic_block_y];
 3550|       |              
 3551|       |        // next P is intra mode
 3552|      0|        if (ref_idx==-1)
 3553|      0|        {
 3554|      0|          all_mvs [block_x][block_y][LIST_0][0][0][0] = 0;
 3555|      0|          all_mvs [block_x][block_y][LIST_0][0][0][1] = 0;
 3556|      0|          all_mvs [block_x][block_y][LIST_1][0][0][0] = 0;
 3557|      0|          all_mvs [block_x][block_y][LIST_1][0][0][1] = 0;
 3558|      0|          direct_ref_idx[LIST_0][pic_block_x][pic_block_y] = 0;
 3559|      0|          direct_ref_idx[LIST_1][pic_block_x][pic_block_y] = 0;
 3560|      0|          direct_pdir[pic_block_x][pic_block_y] = 2;
 3561|      0|        }
 3562|       |        // next P is skip or inter mode
 3563|      0|        else 
 3564|      0|        {
 3565|      0|          int mapped_idx=INVALIDINDEX;
 3566|      0|          int iref; 
 3567|       |
 3568|      0|          {
 3569|      0|            for (iref=0;iref<min(img->num_ref_idx_l0_active,listXsize[LIST_0+list_offset]);iref++)
 3570|      0|            {
 3571|      0|              if (enc_picture->ref_pic_num[LIST_0 +list_offset][iref]==co_located_ref_id[refList ][opic_block_x][opic_block_y])
 3572|      0|              {
 3573|      0|                mapped_idx=iref;
 3574|      0|                break;
 3575|      0|              }
 3576|      0|              else //! invalid index. Default to zero even though this case should not happen
 3577|      0|              {                        
 3578|      0|                mapped_idx=INVALIDINDEX;
 3579|      0|              }
 3580|      0|            }
 3581|      0|          }
 3582|       |
 3583|      0|          if (mapped_idx !=INVALIDINDEX)
 3584|      0|          {
 3585|      0|            mv_scale = img->mvscale[LIST_0+list_offset][mapped_idx];
 3586|       |            
 3587|      0|            if (mv_scale==9999)
 3588|      0|            {
 3589|       |              // forward
 3590|      0|              all_mvs [block_x][block_y][LIST_0][0][0][0] = co_located_mv[refList][opic_block_x][opic_block_y][0];
 3591|      0|              all_mvs [block_x][block_y][LIST_0][0][0][1] = co_located_mv[refList][opic_block_x][opic_block_y][1];
 3592|       |              // backward
 3593|      0|              all_mvs [block_x][block_y][LIST_1][       0][0][0] = 0;
 3594|      0|              all_mvs [block_x][block_y][LIST_1][       0][0][1] = 0;
 3595|      0|            }else
 3596|      0|            {
 3597|       |              // forward
 3598|      0|              all_mvs [block_x][block_y][LIST_0][mapped_idx][0][0] = (mv_scale * co_located_mv[refList][opic_block_x][opic_block_y][0] + 128) >> 8;
 3599|      0|              all_mvs [block_x][block_y][LIST_0][mapped_idx][0][1] = (mv_scale * co_located_mv[refList][opic_block_x][opic_block_y][1] + 128) >> 8;
 3600|       |              // backward
 3601|      0|              all_mvs [block_x][block_y][LIST_1][       0][0][0] = ((mv_scale - 256)* co_located_mv[refList][opic_block_x][opic_block_y][0] + 128) >> 8;
 3602|      0|              all_mvs [block_x][block_y][LIST_1][       0][0][1] = ((mv_scale - 256)* co_located_mv[refList][opic_block_x][opic_block_y][1] + 128) >> 8;
 3603|      0|            }
 3604|      0|            direct_ref_idx[LIST_0][pic_block_x][pic_block_y] = mapped_idx;
 3605|      0|            direct_ref_idx[LIST_1][pic_block_x][pic_block_y] = 0;
 3606|      0|            direct_pdir[pic_block_x][pic_block_y] = 2;
 3607|      0|          }
 3608|      0|          else
 3609|      0|          {
 3610|      0|            direct_ref_idx[LIST_0][pic_block_x][pic_block_y] = -1;
 3611|      0|            direct_ref_idx[LIST_1][pic_block_x][pic_block_y] = -1;
 3612|      0|            direct_pdir[pic_block_x][pic_block_y] = -1;
 3613|      0|          }
 3614|      0|        }
 3615|      0|      }
 3616|      0|    }
 3617|      0|  }
 3618|  54.4k|}
 3619|       |
 3620|       |/*!
 3621|       | ************************************************************************
 3622|       | * \brief
 3623|       | *    control the sign of a with b
 3624|       | ************************************************************************
 3625|       | */
 3626|       |int sign(int a,int b)
 3627|   161M|{
 3628|   161M|  int x;
 3629|   161M|  x=absm(a);
 3630|   161M|  if (b >= 0)
 3631|  93.6M|    return x;
 3632|  67.9M|  else
 3633|  67.9M|    return -x;
 3634|   161M|}
 3635|       |

/home/xzp/speccpu2006-v1.0.1/benchspec/CPU2006/464.h264ref/run/build_base_ql_riscv_llvm17.0000/nal.c:
    1|       |
    2|       |/*!
    3|       | **************************************************************************************
    4|       | * \file
    5|       | *    nal.c
    6|       | * \brief
    7|       | *    Handles the operations on converting String of Data Bits (SODB)
    8|       | *    to Raw Byte Sequence Payload (RBSP), and then 
    9|       | *    onto Encapsulate Byte Sequence Payload (EBSP).
   10|       | *  \date 14 June 2002
   11|       | * \author
   12|       | *    Main contributors (see contributors.h for copyright, address and affiliation details) 
   13|       | *      - Shankar Regunathan                  <shanre@microsoft.de>
   14|       | *      - Stephan Wenger                      <stewe@cs.tu-berlin.de>
   15|       | ***************************************************************************************
   16|       | */
   17|       |
   18|       |
   19|       |#include "contributors.h"
   20|       |
   21|       |#include <stdlib.h>
   22|       |#include <assert.h>
   23|       |
   24|       |#include "global.h"
   25|       |
   26|       | /*!
   27|       | ************************************************************************
   28|       | * \brief
   29|       | *    Converts String Of Data Bits (SODB) to Raw Byte Sequence 
   30|       | *    Packet (RBSP)
   31|       | * \param currStream
   32|       | *        Bitstream which contains data bits.
   33|       | * \return None
   34|       | * \note currStream is byte-aligned at the end of this function
   35|       | *    
   36|       | ************************************************************************
   37|       |*/
   38|       |
   39|       |static byte *NAL_Payload_buffer;
   40|       |
   41|       |void SODBtoRBSP(Bitstream *currStream)
   42|      2|{
   43|      2|  currStream->byte_buf <<= 1;
   44|      2|  currStream->byte_buf |= 1;
   45|      2|  currStream->bits_to_go--;
   46|      2|  currStream->byte_buf <<= currStream->bits_to_go;
   47|      2|  currStream->streamBuffer[currStream->byte_pos++] = currStream->byte_buf;
   48|      2|  currStream->bits_to_go = 8;
   49|      2|  currStream->byte_buf = 0;
   50|      2|}
   51|       |
   52|       |
   53|       |/*!
   54|       |************************************************************************
   55|       |*  \brief
   56|       |*     This function converts a RBSP payload to an EBSP payload
   57|       |*     
   58|       |*  \param streamBuffer
   59|       |*       pointer to data bits
   60|       |*  \param begin_bytepos
   61|       |*            The byte position after start-code, after which stuffing to
   62|       |*            prevent start-code emulation begins.
   63|       |*  \param end_bytepos
   64|       |*           Size of streamBuffer in bytes.
   65|       |*  \param min_num_bytes
   66|       |*           Minimum number of bytes in payload. Should be 0 for VLC entropy
   67|       |*           coding mode. Determines number of stuffed words for CABAC mode.
   68|       |*  \return 
   69|       |*           Size of streamBuffer after stuffing.
   70|       |*  \note
   71|       |*      NAL_Payload_buffer is used as temporary buffer to store data.
   72|       |*
   73|       |*
   74|       |************************************************************************
   75|       |*/
   76|       |
   77|       |int RBSPtoEBSP(byte *streamBuffer, int begin_bytepos, int end_bytepos, int min_num_bytes)
   78|    173|{
   79|       |  
   80|    173|  int i, j, count;
   81|       |
   82|   175k|  for(i = begin_bytepos; i < end_bytepos; i++)
   83|   175k|    NAL_Payload_buffer[i] = streamBuffer[i];
   84|       |
   85|    173|  count = 0;
   86|    173|  j = begin_bytepos;
   87|   175k|  for(i = begin_bytepos; i < end_bytepos; i++) 
   88|   175k|  {
   89|   175k|    if(count == ZEROBYTES_SHORTSTARTCODE && !(NAL_Payload_buffer[i] & 0xFC)) 
   90|      5|    {
   91|      5|      streamBuffer[j] = 0x03;
   92|      5|      j++;
   93|      5|      count = 0;   
   94|      5|    }
   95|   175k|    streamBuffer[j] = NAL_Payload_buffer[i];
   96|   175k|    if(NAL_Payload_buffer[i] == 0x00)      
   97|    820|      count++;
   98|   174k|    else 
   99|   174k|      count = 0;
  100|   175k|    j++;
  101|   175k|  }
  102|    303|  while (j < begin_bytepos+min_num_bytes) {
  103|    130|    streamBuffer[j] = 0x00; // cabac stuffing word
  104|    130|    streamBuffer[j+1] = 0x00;
  105|    130|    streamBuffer[j+2] = 0x03;
  106|    130|    j += 3;
  107|    130|    stats->bit_use_stuffingBits[img->type]+=16;
  108|    130|  }
  109|    173|  return j;
  110|    173|}
  111|       |
  112|       | /*!
  113|       | ************************************************************************
  114|       | * \brief
  115|       | *    Initializes NAL module (allocates NAL_Payload_buffer)
  116|       | ************************************************************************
  117|       |*/
  118|       |
  119|       |void AllocNalPayloadBuffer()
  120|      1|{
  121|      1|  const int buffer_size = ((input->img_width+img->auto_crop_right) * (input->img_height+img->auto_crop_bottom) * 4); // AH 190202: There can be data expansion with 
  122|       |                                                          // low QP values. So, we make sure that buffer 
  123|       |                                                          // does not overflow. 4 is probably safe multiplier.
  124|      1|  FreeNalPayloadBuffer();
  125|       |
  126|      1|  NAL_Payload_buffer = (byte *) calloc(buffer_size, sizeof(byte));
  127|      1|  assert (NAL_Payload_buffer != NULL);
  128|      1|}
  129|       |
  130|       |
  131|       | /*!
  132|       | ************************************************************************
  133|       | * \brief
  134|       | *   Finits NAL module (frees NAL_Payload_buffer)
  135|       | ************************************************************************
  136|       |*/
  137|       |
  138|       |void FreeNalPayloadBuffer()
  139|      2|{
  140|      2|  if(NAL_Payload_buffer)
  141|      1|  {
  142|      1|    free(NAL_Payload_buffer);
  143|      1|    NAL_Payload_buffer=NULL;
  144|      1|  }
  145|      2|}

/home/xzp/speccpu2006-v1.0.1/benchspec/CPU2006/464.h264ref/run/build_base_ql_riscv_llvm17.0000/nalu.c:
    1|       |
    2|       |/*!
    3|       | ************************************************************************
    4|       | * \file  nalu.c
    5|       | *
    6|       | * \brief
    7|       | *    Common NALU support functions
    8|       | *
    9|       | * \author
   10|       | *    Main contributors (see contributors.h for copyright, address and affiliation details)
   11|       | *    - Stephan Wenger   <stewe@cs.tu-berlin.de>
   12|       | ************************************************************************
   13|       | */
   14|       |
   15|       |#include <assert.h>
   16|       |#include <memory.h>
   17|       |
   18|       |#include "global.h"
   19|       |#include "nalu.h"
   20|       |
   21|       |#if defined(SPEC_CPU)
   22|       |int (*WriteNALU)(NALU_t *n);     //! Hides the write function in Annex B or RTP
   23|       |#endif
   24|       |
   25|       |
   26|       |
   27|       |/*! 
   28|       | *************************************************************************************
   29|       | * \brief
   30|       | *    Converts an RBSP to a NALU
   31|       | *
   32|       | * \param rbsp
   33|       | *    byte buffer with the rbsp
   34|       | * \param nalu
   35|       | *    nalu structure to be filled
   36|       | * \param rbsp_size
   37|       | *    size of the rbsp in bytes
   38|       | * \param nal_unit_type
   39|       | *    as in JVT doc
   40|       | * \param nal_reference_idc
   41|       | *    as in JVT doc
   42|       | * \param min_num_bytes
   43|       | *    some incomprehensible CABAC stuff
   44|       | * \param UseAnnexbLongStartcode
   45|       | *    when 1 and when using AnnexB bytestreams, then use a long startcode prefix
   46|       | *
   47|       | * \return
   48|       | *    length of the NALU in bytes
   49|       | *************************************************************************************
   50|       | */
   51|       |
   52|       |int RBSPtoNALU (char *rbsp, NALU_t *nalu, int rbsp_size, int nal_unit_type, int nal_reference_idc, 
   53|       |                int min_num_bytes, int UseAnnexbLongStartcode)
   54|      2|{
   55|      2|  int len;
   56|       |
   57|      2|  assert (nalu != NULL);
   58|      2|  assert (nal_reference_idc <=3 && nal_reference_idc >=0);
   59|      2|  assert (nal_unit_type > 0 && nal_unit_type <= 10);
   60|      2|  assert (rbsp_size < MAXRBSPSIZE);
   61|       |
   62|      2|  nalu->forbidden_bit = 0;
   63|      2|  nalu->nal_reference_idc = nal_reference_idc;
   64|      2|  nalu->nal_unit_type = nal_unit_type;
   65|      2|  nalu->startcodeprefix_len = UseAnnexbLongStartcode?4:3;
   66|      2|  nalu->buf[0] =
   67|      2|    nalu->forbidden_bit << 7      |
   68|      2|    nalu->nal_reference_idc << 5  |
   69|      2|    nalu->nal_unit_type;
   70|       |
   71|      2|  memcpy (&nalu->buf[1], rbsp, rbsp_size);
   72|       |// printf ("First Byte %x\n", nalu->buf[0]);
   73|       |// printf ("RBSPtoNALU: Before: NALU len %d\t RBSP %x %x %x %x\n", rbsp_size, (unsigned) nalu->buf[1], (unsigned) nalu->buf[2], (unsigned) nalu->buf[3], (unsigned) nalu->buf[4]);
   74|       |
   75|      2|  len = 1 + RBSPtoEBSP (&nalu->buf[1], 0, rbsp_size, min_num_bytes);
   76|       |
   77|       |// printf ("RBSPtoNALU: After : NALU len %d\t EBSP %x %x %x %x\n", rbsp_size, (unsigned) nalu->buf[1], (unsigned) nalu->buf[2], (unsigned) nalu->buf[3], (unsigned) nalu->buf[4]);
   78|       |// printf ("len %d\n\n", len);
   79|      2|  nalu->len = len;
   80|       |
   81|      2|  return len;
   82|      2|}
   83|       |
   84|       |

/home/xzp/speccpu2006-v1.0.1/benchspec/CPU2006/464.h264ref/run/build_base_ql_riscv_llvm17.0000/nalucommon.c:
    1|       |
    2|       |/*!
    3|       | ************************************************************************
    4|       | * \file  nalucommon.c
    5|       | *
    6|       | * \brief
    7|       | *    Common NALU support functions
    8|       | *
    9|       | * \author
   10|       | *    Main contributors (see contributors.h for copyright, address and affiliation details)
   11|       | *    - Stephan Wenger   <stewe@cs.tu-berlin.de>
   12|       | ************************************************************************
   13|       | */
   14|       |
   15|       |#include <stdlib.h>
   16|       |
   17|       |#include "global.h"
   18|       |#include "nalu.h"
   19|       |
   20|       |
   21|       |/*! 
   22|       | *************************************************************************************
   23|       | * \brief
   24|       | *    Allocates memory for a NALU
   25|       | *
   26|       | * \param buffersize
   27|       | *     size of NALU buffer 
   28|       | *
   29|       | * \return
   30|       | *    pointer to a NALU
   31|       | *************************************************************************************
   32|       | */
   33|       | 
   34|       |
   35|       |NALU_t *AllocNALU(int buffersize)
   36|    173|{
   37|    173|  NALU_t *n;
   38|       |
   39|    173|  if ((n = (NALU_t*)calloc (1, sizeof (NALU_t))) == NULL) no_mem_exit ("AllocNALU: n");
   40|       |
   41|    173|  n->max_size=buffersize;
   42|       |
   43|    173|  if ((n->buf = (byte*)calloc (buffersize, sizeof (byte))) == NULL) no_mem_exit ("AllocNALU: n->buf");
   44|       |  
   45|    173|  return n;
   46|    173|}
   47|       |
   48|       |
   49|       |/*! 
   50|       | *************************************************************************************
   51|       | * \brief
   52|       | *    Frees a NALU
   53|       | *
   54|       | * \param n 
   55|       | *    NALU to be freed
   56|       | *
   57|       | *************************************************************************************
   58|       | */
   59|       |
   60|       |void FreeNALU(NALU_t *n)
   61|    173|{
   62|    173|  if (n)
   63|    173|  {
   64|    173|    if (n->buf)
   65|    173|    {
   66|    173|      free(n->buf);
   67|    173|      n->buf=NULL;
   68|    173|    }
   69|    173|    free (n);
   70|    173|  }
   71|    173|}
   72|       |

/home/xzp/speccpu2006-v1.0.1/benchspec/CPU2006/464.h264ref/run/build_base_ql_riscv_llvm17.0000/nalucommon.h:
    1|       |
    2|       |/*!
    3|       | **************************************************************************************
    4|       | * \file
    5|       | *    nalucommon.h.h
    6|       | * \brief
    7|       | *    NALU handling common to encoder and decoder
    8|       | *  \date 25 November 2002
    9|       | * \author
   10|       | *    Main contributors (see contributors.h for copyright, address and affiliation details) 
   11|       | *      - Stephan Wenger        <stewe@cs.tu-berlin.de>
   12|       | ***************************************************************************************
   13|       | */
   14|       |
   15|       |
   16|       |#ifndef _NALUCOMMON_H_
   17|       |#define _NALUCOMMON_H_
   18|       |
   19|       |#define MAXRBSPSIZE 64000
   20|       |
   21|    170|#define NALU_TYPE_SLICE    1
   22|      0|#define NALU_TYPE_DPA      2
   23|       |#define NALU_TYPE_DPB      3
   24|       |#define NALU_TYPE_DPC      4
   25|      1|#define NALU_TYPE_IDR      5
   26|       |#define NALU_TYPE_SEI      6
   27|      1|#define NALU_TYPE_SPS      7
   28|      1|#define NALU_TYPE_PPS      8
   29|       |#define NALU_TYPE_AUD      9
   30|       |#define NALU_TYPE_EOSEQ    10
   31|       |#define NALU_TYPE_EOSTREAM 11
   32|       |#define NALU_TYPE_FILL     12
   33|       |
   34|      3|#define NALU_PRIORITY_HIGHEST     3
   35|     85|#define NALU_PRIORITY_HIGH        2
   36|       |#define NALU_PRIRITY_LOW          1
   37|     85|#define NALU_PRIORITY_DISPOSABLE  0
   38|       |
   39|       |
   40|       |typedef struct 
   41|       |{
   42|       |  int startcodeprefix_len;      //! 4 for parameter sets and first slice in picture, 3 for everything else (suggested)
   43|       |  unsigned len;                 //! Length of the NAL unit (Excluding the start code, which does not belong to the NALU)
   44|       |  unsigned max_size;            //! Nal Unit Buffer size
   45|       |  int nal_unit_type;            //! NALU_TYPE_xxxx
   46|       |  int nal_reference_idc;        //! NALU_PRIORITY_xxxx
   47|       |  int forbidden_bit;            //! should be always FALSE
   48|       |  byte *buf;        //! conjtains the first byte followed by the EBSP
   49|       |} NALU_t;
   50|       |
   51|       |
   52|       |NALU_t *AllocNALU();
   53|       |void FreeNALU(NALU_t *n);
   54|       |
   55|       |#endif

/home/xzp/speccpu2006-v1.0.1/benchspec/CPU2006/464.h264ref/run/build_base_ql_riscv_llvm17.0000/output.c:
    1|       |
    2|       |/*!
    3|       | ************************************************************************
    4|       | * \file output.c
    5|       | *
    6|       | * \brief
    7|       | *    Output an image and Trance support
    8|       | *
    9|       | * \author
   10|       | *    Main contributors (see contributors.h for copyright, address and affiliation details)
   11|       | *    - Karsten Suehring               <suehring@hhi.de>
   12|       | ************************************************************************
   13|       | */
   14|       |
   15|       |#include "contributors.h"
   16|       |
   17|       |#include <stdlib.h>
   18|       |#include <assert.h>
   19|       |#include <string.h>
   20|       |
   21|       |#ifdef WIN32
   22|       |#include <io.h>
   23|       |#else
   24|       |#include <unistd.h>
   25|       |#endif
   26|       |
   27|       |#include "global.h"
   28|       |#include "image.h"
   29|       |
   30|       |void write_out_picture(StorablePicture *p, int p_out);
   31|       |
   32|       |FrameStore* out_buffer;
   33|       |
   34|       |
   35|       |/*!
   36|       | ************************************************************************
   37|       | * \brief
   38|       | *      checks if the System is big- or little-endian
   39|       | * \return
   40|       | *      0, little-endian (e.g. Intel architectures)
   41|       | *      1, big-endian (e.g. SPARC, MIPS, PowerPC)
   42|       | ************************************************************************
   43|       | */
   44|       |int testEndian()
   45|    513|{
   46|    513|  short s;
   47|    513|  byte *p;
   48|       |
   49|    513|  p=(byte*)&s;
   50|       |
   51|    513|  s=1;
   52|       |
   53|    513|  return (*p==0);
   54|    513|}
   55|       |
   56|       |
   57|       |/*!
   58|       | ************************************************************************
   59|       | * \brief
   60|       | *    Convert image plane to temporary buffer for file writing
   61|       | * \param imgX
   62|       | *    Pointer to image plane
   63|       | * \param buf
   64|       | *    Buffer for file output
   65|       | * \param size_x
   66|       | *    horizontal size
   67|       | * \param size_y
   68|       | *    vertical size
   69|       | * \param crop_left
   70|       | *    pixels to crop from left
   71|       | * \param crop_right
   72|       | *    pixels to crop from right
   73|       | * \param crop_top
   74|       | *    pixels to crop from top
   75|       | * \param crop_bottom
   76|       | *    pixels to crop from bottom
   77|       | ************************************************************************
   78|       | */
   79|       |void img2buf (imgpel** imgX, unsigned char* buf, int size_x, int size_y, int symbol_size_in_bytes, int crop_left, int crop_right, int crop_top, int crop_bottom)
   80|      0|{
   81|      0|  int i,j;
   82|       |
   83|      0|  int twidth  = size_x - crop_left - crop_right;
   84|      0|  int theight = size_y - crop_top - crop_bottom;
   85|       |
   86|      0|  int size = 0;
   87|       |
   88|      0|  unsigned char  ui8;
   89|      0|  unsigned short tmp16, ui16;
   90|      0|  unsigned long  tmp32, ui32;
   91|       |
   92|      0|  if (( sizeof(char) == sizeof (imgpel)) && ( sizeof(char) == symbol_size_in_bytes))
   93|      0|  {
   94|       |    // imgpel == pixel_in_file == 1 byte -> simple copy
   95|      0|    for(i=0;i<theight;i++)
   96|      0|      memcpy(buf+crop_left+(i*twidth),&(imgX[i+crop_top][crop_left]), twidth);
   97|       |    
   98|      0|  }
   99|      0|  else
  100|      0|  {
  101|       |    // sizeof (imgpel) > sizeof(char)
  102|      0|    if (testEndian())
  103|      0|    {
  104|       |      // big endian
  105|      0|      switch (symbol_size_in_bytes)
  106|      0|      {
  107|      0|      case 1:
  108|      0|        {
  109|      0|          for(i=crop_top;i<size_y-crop_bottom;i++)
  110|      0|            for(j=crop_left;j<size_x-crop_right;j++)
  111|      0|            {
  112|      0|              ui8 = (unsigned char) (imgX[i][j]);
  113|      0|              buf[(j-crop_left+((i-crop_top)*(twidth)))] = ui8;
  114|      0|            }
  115|      0|          break;
  116|      0|        }
  117|      0|      case 2:
  118|      0|        {
  119|      0|          for(i=crop_top;i<size_y-crop_bottom;i++)
  120|      0|            for(j=crop_left;j<size_x-crop_right;j++)
  121|      0|            {
  122|      0|              tmp16 = (unsigned short) (imgX[i][j]);
  123|      0|              ui16  = (tmp16 >> 8) | ((tmp16&0xFF)<<8);
  124|      0|              memcpy(buf+((j-crop_left+((i-crop_top)*(twidth)))*2),&(ui16), 2);
  125|      0|            }
  126|      0|          break;
  127|      0|        }
  128|      0|      case 4:
  129|      0|        {
  130|      0|          for(i=crop_top;i<size_y-crop_bottom;i++)
  131|      0|            for(j=crop_left;j<size_x-crop_right;j++)
  132|      0|            {
  133|      0|              tmp32 = (unsigned long) (imgX[i][j]);
  134|      0|              ui32  = ((tmp32&0xFF00)<<8) | ((tmp32&0xFF)<<24) | ((tmp32&0xFF0000)>>8) | ((tmp32&0xFF000000)>>24);
  135|      0|              memcpy(buf+((j-crop_left+((i-crop_top)*(twidth)))*4),&(ui32), 4);
  136|      0|            }
  137|      0|          break;
  138|      0|        }
  139|      0|      default:
  140|      0|        {
  141|      0|           error ("writing only to formats of 8, 16 or 32 bit allowed on big endian architecture", 500);
  142|      0|           break;
  143|      0|        }
  144|      0|      }
  145|       |
  146|      0|    }
  147|      0|    else
  148|      0|    {
  149|       |      // little endian
  150|      0|      if (sizeof (imgpel) < symbol_size_in_bytes)
  151|      0|      {
  152|       |        // this should not happen. we should not have smaller imgpel than our source material.
  153|      0|        size = sizeof (imgpel);
  154|       |        // clear buffer
  155|      0|        memset (buf, 0, (twidth*theight*symbol_size_in_bytes));
  156|      0|      }
  157|      0|      else
  158|      0|      {
  159|      0|        size = symbol_size_in_bytes;
  160|      0|      }
  161|       |
  162|      0|      for(i=crop_top;i<size_y-crop_bottom;i++)
  163|      0|        for(j=crop_left;j<size_x-crop_right;j++)
  164|      0|        {
  165|      0|          memcpy(buf+((j-crop_left+((i-crop_top)*(twidth)))*symbol_size_in_bytes),&(imgX[i][j]), size);
  166|      0|        }
  167|       |
  168|      0|    }
  169|      0|  }
  170|      0|}
  171|       |
  172|       |/*!
  173|       | ************************************************************************
  174|       | * \brief
  175|       | *    Writes out a storable picture without doing any output modifications
  176|       | * \param p
  177|       | *    Picture to be written
  178|       | * \param p_out
  179|       | *    Output file
  180|       | * \param real_structure
  181|       | *    real picture structure
  182|       | ************************************************************************
  183|       | */
  184|       |void write_picture(StorablePicture *p, int p_out, int real_structure)
  185|      0|{
  186|      0|  write_out_picture(p, p_out);
  187|      0|}
  188|       |
  189|       |/*!
  190|       | ************************************************************************
  191|       | * \brief
  192|       | *    Writes out a storable picture
  193|       | * \param p
  194|       | *    Picture to be written
  195|       | * \param p_out
  196|       | *    Output file
  197|       | ************************************************************************
  198|       | */
  199|       |void write_out_picture(StorablePicture *p, int p_out)
  200|      0|{
  201|      0|  int SubWidthC  [4]= { 1, 2, 2, 1};
  202|      0|  int SubHeightC [4]= { 1, 2, 1, 1};
  203|       |
  204|      0|  int crop_left, crop_right, crop_top, crop_bottom;
  205|      0|  int symbol_size_in_bytes = img->pic_unit_size_on_disk/8;
  206|      0|  Boolean rgb_output = (input->rgb_input_flag && input->yuv_format==3);
  207|      0|  unsigned char *buf;
  208|       |
  209|      0|  if (p->non_existing)
  210|      0|    return;
  211|       |
  212|      0|  if (p->frame_cropping_flag)
  213|      0|  {
  214|      0|    crop_left   = SubWidthC[p->chroma_format_idc] * p->frame_cropping_rect_left_offset;
  215|      0|    crop_right  = SubWidthC[p->chroma_format_idc] * p->frame_cropping_rect_right_offset;
  216|      0|    crop_top    = SubHeightC[p->chroma_format_idc]*( 2 - p->frame_mbs_only_flag ) *  p->frame_cropping_rect_top_offset;
  217|      0|    crop_bottom = SubHeightC[p->chroma_format_idc]*( 2 - p->frame_mbs_only_flag ) *   p->frame_cropping_rect_bottom_offset;
  218|      0|  }
  219|      0|  else
  220|      0|  {
  221|      0|    crop_left = crop_right = crop_top = crop_bottom = 0;
  222|      0|  }
  223|       |
  224|       |  //printf ("write frame size: %dx%d\n", p->size_x-crop_left-crop_right,p->size_y-crop_top-crop_bottom );
  225|       |  
  226|       |  // KS: this buffer should actually be allocated only once, but this is still much faster than the previous version
  227|      0|  if (NULL == (buf = malloc (p->size_x*p->size_y*symbol_size_in_bytes))) no_mem_exit("write_out_picture: buf");
  228|       |
  229|      0|  if(rgb_output)
  230|      0|  {
  231|      0|    crop_left   = p->frame_cropping_rect_left_offset;
  232|      0|    crop_right  = p->frame_cropping_rect_right_offset;
  233|      0|    crop_top    = ( 2 - p->frame_mbs_only_flag ) *  p->frame_cropping_rect_top_offset;
  234|      0|    crop_bottom = ( 2 - p->frame_mbs_only_flag ) *   p->frame_cropping_rect_bottom_offset;
  235|       |
  236|      0|    img2buf (p->imgUV[1], buf, p->size_x_cr, p->size_y_cr, symbol_size_in_bytes, crop_left, crop_right, crop_top, crop_bottom);
  237|      0|    write(p_out, buf, (p->size_y_cr-crop_bottom-crop_top)*(p->size_x_cr-crop_right-crop_left)*symbol_size_in_bytes);
  238|       |
  239|      0|    if (active_sps->frame_cropping_flag)
  240|      0|    {
  241|      0|      crop_left   = SubWidthC[p->chroma_format_idc] * p->frame_cropping_rect_left_offset;
  242|      0|      crop_right  = SubWidthC[p->chroma_format_idc] * p->frame_cropping_rect_right_offset;
  243|      0|      crop_top    = SubHeightC[p->chroma_format_idc]*( 2 - p->frame_mbs_only_flag ) *  p->frame_cropping_rect_top_offset;
  244|      0|      crop_bottom = SubHeightC[p->chroma_format_idc]*( 2 - p->frame_mbs_only_flag ) *   p->frame_cropping_rect_bottom_offset;
  245|      0|    }
  246|      0|    else
  247|      0|    {
  248|      0|      crop_left = crop_right = crop_top = crop_bottom = 0;
  249|      0|    }
  250|      0|  }
  251|       |  
  252|      0|  img2buf (p->imgY, buf, p->size_x, p->size_y, symbol_size_in_bytes, crop_left, crop_right, crop_top, crop_bottom);
  253|      0|  write(p_out, buf, (p->size_y-crop_bottom-crop_top)*(p->size_x-crop_right-crop_left)*symbol_size_in_bytes);
  254|       |
  255|      0|  if (p->chroma_format_idc!=YUV400)
  256|      0|  {
  257|      0|    crop_left   = p->frame_cropping_rect_left_offset;
  258|      0|    crop_right  = p->frame_cropping_rect_right_offset;
  259|      0|    crop_top    = ( 2 - p->frame_mbs_only_flag ) *  p->frame_cropping_rect_top_offset;
  260|      0|    crop_bottom = ( 2 - p->frame_mbs_only_flag ) *   p->frame_cropping_rect_bottom_offset;
  261|       |    
  262|      0|    img2buf (p->imgUV[0], buf, p->size_x_cr, p->size_y_cr, symbol_size_in_bytes, crop_left, crop_right, crop_top, crop_bottom);
  263|      0|    write(p_out, buf, (p->size_y_cr-crop_bottom-crop_top)*(p->size_x_cr-crop_right-crop_left)*symbol_size_in_bytes);
  264|       |    
  265|      0|    if (!rgb_output)
  266|      0|    {
  267|      0|      img2buf (p->imgUV[1], buf, p->size_x_cr, p->size_y_cr, symbol_size_in_bytes, crop_left, crop_right, crop_top, crop_bottom);
  268|      0|      write(p_out, buf, (p->size_y_cr-crop_bottom-crop_top)*(p->size_x_cr-crop_right-crop_left)*symbol_size_in_bytes);
  269|      0|    }
  270|      0|  }
  271|       |
  272|      0|  free(buf);
  273|       |    
  274|       |//  fsync(p_out);
  275|      0|}
  276|       |
  277|       |/*!
  278|       | ************************************************************************
  279|       | * \brief
  280|       | *    Initialize output buffer for direct output
  281|       | ************************************************************************
  282|       | */
  283|       |void init_out_buffer()
  284|      1|{
  285|      1|  out_buffer = alloc_frame_store();
  286|      1|}
  287|       |
  288|       |/*!
  289|       | ************************************************************************
  290|       | * \brief
  291|       | *    Uninitialize output buffer for direct output
  292|       | ************************************************************************
  293|       | */
  294|       |void uninit_out_buffer()
  295|      1|{
  296|      1|  free_frame_store(out_buffer);
  297|      1|  out_buffer=NULL;
  298|      1|}
  299|       |
  300|       |/*!
  301|       | ************************************************************************
  302|       | * \brief
  303|       | *    Initialize picture memory with (Y:0,U:128,V:128)
  304|       | ************************************************************************
  305|       | */
  306|       |void clear_picture(StorablePicture *p)
  307|      0|{
  308|      0|  int i;
  309|       |
  310|      0|  for(i=0;i<p->size_y;i++)
  311|      0|    memset(p->imgY[i], img->dc_pred_value, p->size_x*sizeof(imgpel));
  312|      0|  for(i=0;i<p->size_y_cr;i++)
  313|      0|    memset(p->imgUV[0][i], img->dc_pred_value ,p->size_x_cr*sizeof(imgpel));
  314|      0|  for(i=0;i<p->size_y_cr;i++)
  315|      0|    memset(p->imgUV[1][i], img->dc_pred_value ,p->size_x_cr*sizeof(imgpel));
  316|      0|}
  317|       |
  318|       |/*!
  319|       | ************************************************************************
  320|       | * \brief
  321|       | *    Write out not paired direct output fields. A second empty field is generated
  322|       | *    and combined into the frame buffer.
  323|       | * \param fs
  324|       | *    FrameStore that contains a single field
  325|       | * \param p_out
  326|       | *    Output file
  327|       | ************************************************************************
  328|       | */
  329|       |void write_unpaired_field(FrameStore* fs, int p_out)
  330|      0|{
  331|      0|  StorablePicture *p;
  332|      0|  assert (fs->is_used<3);
  333|      0|  if(fs->is_used &1)
  334|      0|  {
  335|       |    // we have a top field
  336|       |    // construct an empty bottom field
  337|      0|    p = fs->top_field;
  338|      0|    fs->bottom_field = alloc_storable_picture(BOTTOM_FIELD, p->size_x, p->size_y, p->size_x_cr, p->size_y_cr);
  339|      0|    clear_picture(fs->bottom_field);
  340|      0|    dpb_combine_field(fs);
  341|      0|    write_picture (fs->frame, p_out, TOP_FIELD);
  342|      0|  }
  343|       |
  344|      0|  if(fs->is_used &2)
  345|      0|  {
  346|       |    // we have a bottom field
  347|       |    // construct an empty top field
  348|      0|    p = fs->bottom_field;
  349|      0|    fs->top_field = alloc_storable_picture(TOP_FIELD, p->size_x, p->size_y, p->size_x_cr, p->size_y_cr);
  350|      0|    clear_picture(fs->top_field);
  351|      0|    dpb_combine_field(fs);
  352|      0|    write_picture (fs->frame, p_out, BOTTOM_FIELD);
  353|      0|  }
  354|       |
  355|      0|  fs->is_used=3;
  356|      0|}
  357|       |
  358|       |/*!
  359|       | ************************************************************************
  360|       | * \brief
  361|       | *    Write out unpaired fields from output buffer.
  362|       | * \param p_out
  363|       | *    Output file
  364|       | ************************************************************************
  365|       | */
  366|       |void flush_direct_output(int p_out)
  367|      0|{
  368|      0|  write_unpaired_field(out_buffer, p_out);
  369|       |
  370|      0|  free_storable_picture(out_buffer->frame);
  371|      0|  out_buffer->frame = NULL;
  372|      0|  free_storable_picture(out_buffer->top_field);
  373|      0|  out_buffer->top_field = NULL;
  374|      0|  free_storable_picture(out_buffer->bottom_field);
  375|      0|  out_buffer->bottom_field = NULL;
  376|      0|  out_buffer->is_used = 0;
  377|      0|}
  378|       |
  379|       |
  380|       |/*!
  381|       | ************************************************************************
  382|       | * \brief
  383|       | *    Write a frame (from FrameStore)
  384|       | * \param fs
  385|       | *    FrameStore containing the frame
  386|       | * \param p_out
  387|       | *    Output file
  388|       | ************************************************************************
  389|       | */
  390|       |void write_stored_frame( FrameStore *fs,int p_out)
  391|      0|{
  392|       |  // make sure no direct output field is pending
  393|      0|  flush_direct_output(p_out);
  394|       |
  395|      0|  if (fs->is_used<3)
  396|      0|  {
  397|      0|    write_unpaired_field(fs, p_out);
  398|      0|  }
  399|      0|  else
  400|      0|  {
  401|      0|    write_picture(fs->frame, p_out, FRAME);
  402|      0|  }
  403|       |
  404|      0|  fs->is_output = 1;
  405|      0|}
  406|       |
  407|       |/*!
  408|       | ************************************************************************
  409|       | * \brief
  410|       | *    Directly output a picture without storing it in the DPB. Fields 
  411|       | *    are buffered before they are written to the file.
  412|       | * \param p
  413|       | *    Picture for output
  414|       | * \param p_out
  415|       | *    Output file
  416|       | ************************************************************************
  417|       | */
  418|       |void direct_output(StorablePicture *p, int p_out)
  419|      0|{
  420|      0|  if (p->structure==FRAME)
  421|      0|  {
  422|       |    // we have a frame (or complementary field pair)
  423|       |    // so output it directly
  424|      0|    flush_direct_output(p_out);
  425|      0|    write_picture (p, p_out, FRAME);
  426|      0|    free_storable_picture(p);
  427|      0|    return;
  428|      0|  }
  429|       |
  430|      0|  if (p->structure == TOP_FIELD)
  431|      0|  {
  432|      0|    if (out_buffer->is_used &1)
  433|      0|      flush_direct_output(p_out);
  434|      0|    out_buffer->top_field = p;
  435|      0|    out_buffer->is_used |= 1;
  436|      0|  }
  437|       |
  438|      0|  if (p->structure == BOTTOM_FIELD)
  439|      0|  {
  440|      0|    if (out_buffer->is_used &2)
  441|      0|      flush_direct_output(p_out);
  442|      0|    out_buffer->bottom_field = p;
  443|      0|    out_buffer->is_used |= 2;
  444|      0|  }
  445|       |
  446|      0|  if (out_buffer->is_used == 3)
  447|      0|  {
  448|       |    // we have both fields, so output them
  449|      0|    dpb_combine_field(out_buffer);
  450|      0|    write_picture (out_buffer->frame, p_out, FRAME);
  451|      0|    free_storable_picture(out_buffer->frame);
  452|      0|    out_buffer->frame = NULL;
  453|      0|    free_storable_picture(out_buffer->top_field);
  454|      0|    out_buffer->top_field = NULL;
  455|      0|    free_storable_picture(out_buffer->bottom_field);
  456|      0|    out_buffer->bottom_field = NULL;
  457|      0|    out_buffer->is_used = 0;
  458|      0|  }
  459|      0|}
  460|       |

/home/xzp/speccpu2006-v1.0.1/benchspec/CPU2006/464.h264ref/run/build_base_ql_riscv_llvm17.0000/parset.c:
    1|       |
    2|       |/*!
    3|       | **************************************************************************************
    4|       | * \file
    5|       | *    parset.c
    6|       | * \brief
    7|       | *    Picture and Sequence Parameter set generation and handling
    8|       | *  \date 25 November 2002
    9|       | * \author
   10|       | *    Main contributors (see contributors.h for copyright, address and affiliation details) 
   11|       | *      - Stephan Wenger        <stewe@cs.tu-berlin.de>
   12|       | *
   13|       | **************************************************************************************
   14|       | */
   15|       |
   16|       |#include <stdlib.h>
   17|       |#include <assert.h>
   18|       |#include <string.h>
   19|       | 
   20|       |#include "global.h"
   21|       |
   22|       |#include "contributors.h"
   23|       |#include "mbuffer.h"
   24|       |#include "parset.h"
   25|       |#include "vlc.h"
   26|       |
   27|       |// Local helpers
   28|       |static int IdentifyProfile();
   29|       |static int IdentifyLevel();
   30|       |static int GenerateVUISequenceParameters();
   31|       |
   32|       |extern ColocatedParams *Co_located;
   33|       |
   34|       |seq_parameter_set_rbsp_t SeqParSet[MAXSPS];
   35|       |pic_parameter_set_rbsp_t PicParSet[MAXPPS];
   36|       |
   37|       |static const byte ZZ_SCAN[16]  =
   38|       |{  0,  1,  4,  8,  5,  2,  3,  6,  9, 12, 13, 10,  7, 11, 14, 15
   39|       |};
   40|       |
   41|       |static const byte ZZ_SCAN8[64] =
   42|       |{  0,  1,  8, 16,  9,  2,  3, 10, 17, 24, 32, 25, 18, 11,  4,  5,
   43|       |   12, 19, 26, 33, 40, 48, 41, 34, 27, 20, 13,  6,  7, 14, 21, 28,
   44|       |   35, 42, 49, 56, 57, 50, 43, 36, 29, 22, 15, 23, 30, 37, 44, 51,
   45|       |   58, 59, 52, 45, 38, 31, 39, 46, 53, 60, 61, 54, 47, 55, 62, 63
   46|       |};
   47|       |
   48|       |
   49|       |/*! 
   50|       | *************************************************************************************
   51|       | * \brief
   52|       | *    generates a sequence and picture parameter set and stores these in global
   53|       | *    active_sps and active_pps
   54|       | *
   55|       | * \return
   56|       | *    A NALU containing the Sequence ParameterSet
   57|       | *
   58|       | *************************************************************************************
   59|       |*/
   60|       |void GenerateParameterSets ()
   61|      1|{
   62|      1|  seq_parameter_set_rbsp_t *sps = NULL; 
   63|      1|  pic_parameter_set_rbsp_t *pps = NULL;
   64|       |
   65|      1|  sps = AllocSPS();
   66|      1|  pps = AllocPPS();
   67|       |
   68|      1|  GenerateSequenceParameterSet(sps, 0);
   69|       |
   70|      1|  if (input->GenerateMultiplePPS)
   71|      0|  {
   72|      0|    if (sps->profile_idc >= FREXT_HP)
   73|      0|    {
   74|      0|      GeneratePictureParameterSet( pps, sps, 0, 0, 0, input->cb_qp_index_offset, input->cr_qp_index_offset);
   75|      0|      memcpy (&PicParSet[0], pps, sizeof (pic_parameter_set_rbsp_t));
   76|      0|      GeneratePictureParameterSet( pps, sps, 1, 1, 1, input->cb_qp_index_offset, input->cr_qp_index_offset);
   77|      0|      memcpy (&PicParSet[1], pps, sizeof (pic_parameter_set_rbsp_t));
   78|      0|      GeneratePictureParameterSet( pps, sps, 2, 1, 2, input->cb_qp_index_offset, input->cr_qp_index_offset);
   79|      0|      memcpy (&PicParSet[2], pps, sizeof (pic_parameter_set_rbsp_t));
   80|       |
   81|      0|    }
   82|      0|    else
   83|      0|    {
   84|      0|      GeneratePictureParameterSet( pps, sps, 0, 0, 0, input->chroma_qp_index_offset, 0);
   85|      0|      memcpy (&PicParSet[0], pps, sizeof (pic_parameter_set_rbsp_t));
   86|      0|      GeneratePictureParameterSet( pps, sps, 1, 1, 1, input->chroma_qp_index_offset, 0);
   87|      0|      memcpy (&PicParSet[1], pps, sizeof (pic_parameter_set_rbsp_t));
   88|      0|      GeneratePictureParameterSet( pps, sps, 2, 1, 2, input->chroma_qp_index_offset, 0);
   89|      0|      memcpy (&PicParSet[2], pps, sizeof (pic_parameter_set_rbsp_t));
   90|      0|    }
   91|      0|  }
   92|      1|  else
   93|      1|  {
   94|      1|    if (sps->profile_idc >= FREXT_HP)
   95|      0|      GeneratePictureParameterSet( pps, sps, 0, input->WeightedPrediction, input->WeightedBiprediction, 
   96|      0|                                   input->cb_qp_index_offset, input->cr_qp_index_offset);
   97|      1|    else
   98|      1|      GeneratePictureParameterSet( pps, sps, 0, input->WeightedPrediction, input->WeightedBiprediction,
   99|      1|                                   input->chroma_qp_index_offset, 0);
  100|       |    
  101|      1|    memcpy (&PicParSet[0], pps, sizeof (pic_parameter_set_rbsp_t));
  102|       |
  103|      1|  }
  104|       |
  105|      1|  active_sps = sps;
  106|      1|  active_pps = &PicParSet[0];
  107|      1|}
  108|       |
  109|       |/*! 
  110|       |*************************************************************************************
  111|       |* \brief
  112|       |*    frees global parameter sets active_sps and active_pps
  113|       |*
  114|       |* \return
  115|       |*    A NALU containing the Sequence ParameterSet
  116|       |*
  117|       |*************************************************************************************
  118|       |*/
  119|       |void FreeParameterSets ()
  120|      1|{
  121|       |
  122|      1|  FreeSPS (active_sps);
  123|       |  //FreePPS (active_pps);
  124|      1|}
  125|       |
  126|       |/*! 
  127|       |*************************************************************************************
  128|       |* \brief
  129|       |*    int GenerateSeq_parameter_set_NALU ();
  130|       |*
  131|       |* \note
  132|       |*    Uses the global variables through GenerateSequenceParameterSet()
  133|       |*    and GeneratePictureParameterSet
  134|       |*
  135|       |* \return
  136|       |*    A NALU containing the Sequence ParameterSet
  137|       |*
  138|       |*************************************************************************************
  139|       |*/
  140|       |
  141|       |NALU_t *GenerateSeq_parameter_set_NALU ()
  142|      1|{
  143|      1|  NALU_t *n = AllocNALU(64000);
  144|      1|  int RBSPlen = 0;
  145|      1|  int NALUlen;
  146|      1|  byte rbsp[MAXRBSPSIZE];
  147|       |
  148|      1|  RBSPlen = GenerateSeq_parameter_set_rbsp (active_sps, rbsp);
  149|      1|  NALUlen = RBSPtoNALU (rbsp, n, RBSPlen, NALU_TYPE_SPS, NALU_PRIORITY_HIGHEST, 0, 1);
  150|      1|  n->startcodeprefix_len = 4;
  151|       |
  152|      1|  return n;
  153|      1|}
  154|       |
  155|       |
  156|       |/*! 
  157|       |*************************************************************************************
  158|       |* \brief
  159|       |*    NALU_t *GeneratePic_parameter_set_NALU (int PPS_id);
  160|       |*
  161|       |* \note
  162|       |*    Uses the global variables through GenerateSequenceParameterSet()
  163|       |*    and GeneratePictureParameterSet
  164|       |*
  165|       |* \return
  166|       |*    A NALU containing the Picture Parameter Set
  167|       |*
  168|       |*************************************************************************************
  169|       |*/
  170|       |
  171|       |NALU_t *GeneratePic_parameter_set_NALU(int PPS_id)
  172|      1|{
  173|      1|  NALU_t *n = AllocNALU(64000);
  174|      1|  int RBSPlen = 0;
  175|      1|  int NALUlen;
  176|      1|  byte rbsp[MAXRBSPSIZE];
  177|       |
  178|      1|  RBSPlen = GeneratePic_parameter_set_rbsp (&PicParSet[PPS_id], rbsp);
  179|      1|  NALUlen = RBSPtoNALU (rbsp, n, RBSPlen, NALU_TYPE_PPS, NALU_PRIORITY_HIGHEST, 0, 1);
  180|      1|  n->startcodeprefix_len = 4;
  181|       |
  182|      1|  return n;
  183|      1|}
  184|       |
  185|       |
  186|       |/*!
  187|       | ************************************************************************
  188|       | * \brief
  189|       | *    GenerateSequenceParameterSet: extracts info from global variables and
  190|       | *    generates sequence parameter set structure
  191|       | *
  192|       | * \param sps
  193|       | *    Sequence parameter set to be filled
  194|       | *
  195|       | * \par
  196|       | *    Function reads all kinds of values from several global variables,
  197|       | *    including input-> and image-> and fills in the sps.  Many
  198|       | *    values are current hard-coded to defaults.
  199|       | *
  200|       | ************************************************************************
  201|       | */
  202|       |
  203|       |void GenerateSequenceParameterSet(seq_parameter_set_rbsp_t *sps, int SPS_id)
  204|      1|{
  205|      1|  unsigned i;
  206|      1|  int SubWidthC  [4]= { 1, 2, 2, 1};
  207|      1|  int SubHeightC [4]= { 1, 2, 1, 1};
  208|       |
  209|      1|  int frext_profile = ((IdentifyProfile()==FREXT_HP) || 
  210|      1|                      (IdentifyProfile()==FREXT_Hi10P) ||
  211|      1|                      (IdentifyProfile()==FREXT_Hi422) ||
  212|      1|                      (IdentifyProfile()==FREXT_Hi444));
  213|       |
  214|       |  // *************************************************************************
  215|       |  // Sequence Parameter Set
  216|       |  // *************************************************************************
  217|      1|  assert (sps != NULL);
  218|       |  // Profile and Level should be calculated using the info from the config
  219|       |  // file.  Calculation is hidden in IndetifyProfile() and IdentifyLevel()
  220|      1|  sps->profile_idc = IdentifyProfile();
  221|      1|  sps->level_idc = IdentifyLevel();
  222|       |
  223|       |  // needs to be set according to profile
  224|      1|  sps->constrained_set0_flag = 0;
  225|      1|  sps->constrained_set1_flag = 0;
  226|      1|  sps->constrained_set2_flag = 0;
  227|      1|  sps->constrained_set3_flag = 0;
  228|       |
  229|       |  // Parameter Set ID hard coded to zero
  230|      1|  sps->seq_parameter_set_id = 0;
  231|       |
  232|       |  // Fidelity Range Extensions stuff
  233|      1|  sps->bit_depth_luma_minus8   = input->BitDepthLuma - 8;
  234|      1|  sps->bit_depth_chroma_minus8 = input->BitDepthChroma - 8;
  235|      1|  img->lossless_qpprime_flag = input->lossless_qpprime_y_zero_flag & (sps->profile_idc==FREXT_Hi444);
  236|      1|  img->residue_transform_flag = input->residue_transform_flag;
  237|       |  
  238|       |  //! POC stuff:
  239|       |  //! The following values are hard-coded in init_poc().  Apparently,
  240|       |  //! the poc implementation covers only a subset of the poc functionality.
  241|       |  //! Here, the same subset is implemented.  Changes in the POC stuff have
  242|       |  //! also to be reflected here
  243|      1|  sps->log2_max_frame_num_minus4 = log2_max_frame_num_minus4;
  244|      1|  sps->log2_max_pic_order_cnt_lsb_minus4 = log2_max_pic_order_cnt_lsb_minus4;
  245|       |  
  246|      1|  sps->pic_order_cnt_type = input->pic_order_cnt_type;
  247|      1|  sps->num_ref_frames_in_pic_order_cnt_cycle = img->num_ref_frames_in_pic_order_cnt_cycle;
  248|      1|  sps->delta_pic_order_always_zero_flag = img->delta_pic_order_always_zero_flag;
  249|      1|  sps->offset_for_non_ref_pic = img->offset_for_non_ref_pic;
  250|      1|  sps->offset_for_top_to_bottom_field = img->offset_for_top_to_bottom_field;
  251|       |
  252|      2|  for (i=0; i<img->num_ref_frames_in_pic_order_cnt_cycle; i++)
  253|      1|  {
  254|      1|    sps->offset_for_ref_frame[i] = img->offset_for_ref_frame[i];
  255|      1|  }
  256|       |  // End of POC stuff
  257|       |
  258|       |  // Number of Reference Frames
  259|      1|  sps->num_ref_frames = input->num_ref_frames;
  260|       |
  261|       |  //required_frame_num_update_behaviour_flag hardcoded to zero
  262|      1|  sps->gaps_in_frame_num_value_allowed_flag = FALSE;    // double check
  263|       |
  264|      1|  sps->frame_mbs_only_flag = !(input->PicInterlace || input->MbInterlace);
  265|       |
  266|       |  // Picture size, finally a simple one :-)
  267|      1|  sps->pic_width_in_mbs_minus1 = ((input->img_width+img->auto_crop_right)/16) -1;
  268|      1|  sps->pic_height_in_map_units_minus1 = (((input->img_height+img->auto_crop_bottom)/16)/ (2 - sps->frame_mbs_only_flag)) - 1;
  269|       |
  270|       |  // a couple of flags, simple
  271|      1|  sps->mb_adaptive_frame_field_flag = (FRAME_CODING != input->MbInterlace);
  272|      1|  sps->direct_8x8_inference_flag = input->directInferenceFlag;
  273|       |  
  274|       |  // Sequence VUI not implemented, signalled as not present
  275|      1|  sps->vui_parameters_present_flag = (input->rgb_input_flag && input->yuv_format==3);
  276|       |
  277|      1|  sps->chroma_format_idc = input->yuv_format;
  278|       |
  279|       |  // This should be moved somewhere else.
  280|      1|  {
  281|      1|    int PicWidthInMbs, PicHeightInMapUnits, FrameHeightInMbs;
  282|      1|    int width, height;
  283|      1|    PicWidthInMbs = (sps->pic_width_in_mbs_minus1 +1);
  284|      1|    PicHeightInMapUnits = (sps->pic_height_in_map_units_minus1 +1);
  285|      1|    FrameHeightInMbs = ( 2 - sps->frame_mbs_only_flag ) * PicHeightInMapUnits;
  286|       |    
  287|      1|    width = PicWidthInMbs * MB_BLOCK_SIZE;
  288|      1|    height = FrameHeightInMbs * MB_BLOCK_SIZE;
  289|       |    
  290|      1|    Co_located = alloc_colocated (width, height,sps->mb_adaptive_frame_field_flag);
  291|       |    
  292|      1|  }
  293|       |
  294|       |  // Fidelity Range Extensions stuff
  295|      1|  if(frext_profile)
  296|      0|  {
  297|       |
  298|      0|    sps->seq_scaling_matrix_present_flag = (input->ScalingMatrixPresentFlag&1);
  299|      0|    for(i=0; i<8; i++)
  300|      0|    {
  301|      0|      if(i<6)
  302|      0|        sps->seq_scaling_list_present_flag[i] = (input->ScalingListPresentFlag[i]&1);
  303|      0|      else
  304|      0|      {
  305|      0|        if(input->AllowTransform8x8)
  306|      0|          sps->seq_scaling_list_present_flag[i] = (input->ScalingListPresentFlag[i]&1);
  307|      0|        else
  308|      0|          sps->seq_scaling_list_present_flag[i] = 0;
  309|      0|      }
  310|      0|    }
  311|      0|  }
  312|      1|  else
  313|      1|  {
  314|      1|    sps->seq_scaling_matrix_present_flag = 0;
  315|      9|    for(i=0; i<8; i++)
  316|      8|      sps->seq_scaling_list_present_flag[i] = 0;
  317|       |
  318|      1|  }
  319|       |
  320|       |
  321|      1|  if (img->auto_crop_right || img->auto_crop_bottom)
  322|      0|  {
  323|      0|    sps->frame_cropping_flag = TRUE;
  324|      0|    sps->frame_cropping_rect_left_offset=0;
  325|      0|    sps->frame_cropping_rect_top_offset=0;
  326|      0|    sps->frame_cropping_rect_right_offset=  (img->auto_crop_right / SubWidthC[sps->chroma_format_idc]);
  327|      0|    sps->frame_cropping_rect_bottom_offset= (img->auto_crop_bottom / (SubHeightC[sps->chroma_format_idc] * (2 - sps->frame_mbs_only_flag)));
  328|      0|    if (img->auto_crop_right % SubWidthC[sps->chroma_format_idc])
  329|      0|    {
  330|      0|      error("automatic frame cropping (width) not possible",500);
  331|      0|    }
  332|      0|    if (img->auto_crop_bottom % (SubHeightC[sps->chroma_format_idc] * (2 - sps->frame_mbs_only_flag)))
  333|      0|    {
  334|      0|      error("automatic frame cropping (height) not possible",500);
  335|      0|    }
  336|      0|  }
  337|      1|  else
  338|      1|  {
  339|      1|    sps->frame_cropping_flag = FALSE;
  340|      1|  }
  341|      1|};
  342|       |
  343|       |/*!
  344|       | ************************************************************************
  345|       | * \brief
  346|       | *    GeneratePictureParameterSet: 
  347|       | *    Generates a Picture Parameter Set structure
  348|       | *
  349|       | * \param pps
  350|       | *    Picture parameter set to be filled
  351|       | *
  352|       | * \par
  353|       | *    Regarding the QP
  354|       | *    The previous software versions coded the absolute QP only in the 
  355|       | *    slice header.  This is kept, and the offset in the PPS is coded 
  356|       | *    even if we could save bits by intelligently using this field.
  357|       | *
  358|       | ************************************************************************
  359|       | */
  360|       |
  361|       |void GeneratePictureParameterSet( pic_parameter_set_rbsp_t *pps, seq_parameter_set_rbsp_t *sps, int PPS_id, 
  362|       |                                 int WeightedPrediction, int WeightedBiprediction, 
  363|       |                                 int cb_qp_index_offset, int cr_qp_index_offset)
  364|      1|{
  365|      1|  unsigned i;
  366|       |
  367|      1|  int frext_profile = ((IdentifyProfile()==FREXT_HP) || 
  368|      1|                      (IdentifyProfile()==FREXT_Hi10P) ||
  369|      1|                      (IdentifyProfile()==FREXT_Hi422) ||
  370|      1|                      (IdentifyProfile()==FREXT_Hi444));
  371|       |
  372|       |  // *************************************************************************
  373|       |  // Picture Parameter Set 
  374|       |  // *************************************************************************
  375|       |
  376|      1|  pps->seq_parameter_set_id = sps->seq_parameter_set_id;
  377|      1|  pps->pic_parameter_set_id = PPS_id;
  378|      1|  pps->entropy_coding_mode_flag = (input->symbol_mode==UVLC?0:1);
  379|       |
  380|       |  // Fidelity Range Extensions stuff
  381|      1|  if(frext_profile)
  382|      0|  {
  383|      0|    pps->transform_8x8_mode_flag = input->AllowTransform8x8 ? 1:0;
  384|      0|    pps->pic_scaling_matrix_present_flag = (input->ScalingMatrixPresentFlag&2)>>1;
  385|      0|    for(i=0; i<8; i++)
  386|      0|    {
  387|      0|      if(i<6)
  388|      0|        pps->pic_scaling_list_present_flag[i] = (input->ScalingListPresentFlag[i]&2)>>1;
  389|      0|      else
  390|      0|      {
  391|      0|        if(pps->transform_8x8_mode_flag)
  392|      0|          pps->pic_scaling_list_present_flag[i] = (input->ScalingListPresentFlag[i]&2)>>1;
  393|      0|        else
  394|      0|          pps->pic_scaling_list_present_flag[i] = 0;
  395|      0|      }
  396|      0|    }
  397|      0|  }
  398|      1|  else
  399|      1|  {
  400|      1|    pps->pic_scaling_matrix_present_flag = 0;
  401|      9|    for(i=0; i<8; i++)
  402|      8|      pps->pic_scaling_list_present_flag[i] = 0;
  403|       |
  404|      1|    pps->transform_8x8_mode_flag = input->AllowTransform8x8 = 0;
  405|      1|  }
  406|       |
  407|       |  // JVT-Fxxx (by Stephan Wenger, make this flag unconditional
  408|      1|  pps->pic_order_present_flag = img->pic_order_present_flag;
  409|       |
  410|       |
  411|       |  // Begin FMO stuff
  412|      1|  pps->num_slice_groups_minus1 = input->num_slice_groups_minus1;
  413|       |
  414|       |	
  415|       |  //! Following set the parameter for different slice group types
  416|      1|  if (pps->num_slice_groups_minus1 > 0)
  417|      0|    switch (input->slice_group_map_type)
  418|      0|    {
  419|      0|    case 0:
  420|       |			
  421|      0|      pps->slice_group_map_type = 0;
  422|      0|      for(i=0; i<=pps->num_slice_groups_minus1; i++)
  423|      0|      {
  424|      0|        pps->run_length_minus1[i]=input->run_length_minus1[i];
  425|      0|      }
  426|       |			
  427|      0|      break;
  428|      0|    case 1:
  429|      0|      pps->slice_group_map_type = 1;
  430|      0|      break;
  431|      0|    case 2:
  432|       |      // i loops from 0 to num_slice_groups_minus1-1, because no info for background needed
  433|      0|      pps->slice_group_map_type = 2;
  434|      0|      for(i=0; i<pps->num_slice_groups_minus1; i++)
  435|      0|      {
  436|      0|        pps->top_left[i] = input->top_left[i];
  437|      0|        pps->bottom_right[i] = input->bottom_right[i];      
  438|      0|      }
  439|      0|     break;
  440|      0|    case 3:
  441|      0|    case 4:
  442|      0|    case 5:
  443|      0|      pps->slice_group_map_type = input->slice_group_map_type;
  444|       |			
  445|      0|      pps->slice_group_change_direction_flag = input->slice_group_change_direction_flag;
  446|      0|      pps->slice_group_change_rate_minus1 = input->slice_group_change_rate_minus1;
  447|      0|      break;
  448|      0|    case 6:
  449|      0|      pps->slice_group_map_type = 6;   
  450|      0|      pps->pic_size_in_map_units_minus1 = 
  451|      0|				(((input->img_height+img->auto_crop_bottom)/MB_BLOCK_SIZE)/(2-sps->frame_mbs_only_flag))
  452|      0|				*((input->img_width+img->auto_crop_right)/MB_BLOCK_SIZE) -1;
  453|       |			
  454|      0|      for (i=0;i<=pps->pic_size_in_map_units_minus1; i++)
  455|      0|        pps->slice_group_id[i] = input->slice_group_id[i];
  456|       |			
  457|      0|      break;
  458|      0|    default:
  459|      0|      printf ("Parset.c: slice_group_map_type invalid, default\n");
  460|      0|      assert (0==1);
  461|      0|    }
  462|       |// End FMO stuff
  463|       |
  464|      1|  pps->num_ref_idx_l0_active_minus1 = sps->frame_mbs_only_flag ? (sps->num_ref_frames-1) : (2 * sps->num_ref_frames - 1) ;   // set defaults
  465|      1|  pps->num_ref_idx_l1_active_minus1 = sps->frame_mbs_only_flag ? (sps->num_ref_frames-1) : (2 * sps->num_ref_frames - 1) ;   // set defaults
  466|       |  
  467|      1|  pps->weighted_pred_flag = WeightedPrediction;
  468|      1|  pps->weighted_bipred_idc = WeightedBiprediction;
  469|       |
  470|      1|  pps->pic_init_qp_minus26 = 0;         // hard coded to zero, QP lives in the slice header
  471|      1|  pps->pic_init_qs_minus26 = 0;
  472|       |
  473|      1|  pps->chroma_qp_index_offset = cb_qp_index_offset; 
  474|      1|  if (frext_profile)
  475|      0|  {
  476|      0|    pps->cb_qp_index_offset     = cb_qp_index_offset;
  477|      0|    pps->cr_qp_index_offset     = cr_qp_index_offset;
  478|      0|  }
  479|      1|  else
  480|      1|    pps->cb_qp_index_offset = pps->cr_qp_index_offset = pps->chroma_qp_index_offset;
  481|       |
  482|      1|  pps->deblocking_filter_control_present_flag = input->LFSendParameters;
  483|      1|  pps->constrained_intra_pred_flag = input->UseConstrainedIntraPred;
  484|       |  
  485|      1|  pps->redundant_pic_cnt_present_flag = 0;
  486|      1|};
  487|       |
  488|       |/*! 
  489|       | *************************************************************************************
  490|       | * \brief
  491|       | *    syntax for scaling list matrix values
  492|       | *
  493|       | * \param scalingListinput
  494|       | *    input scaling list
  495|       | * \param scalingList
  496|       | *    scaling list to be used
  497|       | * \param sizeOfScalingList
  498|       | *    size of the scaling list
  499|       | * \param UseDefaultScalingMatrix
  500|       | *    usage of default Scaling Matrix
  501|       | * \param partition
  502|       | *    partition info for writing syntax
  503|       | *
  504|       | * \return
  505|       | *    size of the RBSP in bytes
  506|       | *
  507|       | *************************************************************************************
  508|       | */
  509|       |int Scaling_List(short *scalingListinput, short *scalingList, int sizeOfScalingList, short *UseDefaultScalingMatrix, DataPartition *partition)
  510|      0|{
  511|      0|  int j, scanj;
  512|      0|  int len=0;
  513|      0|  int delta_scale, lastScale, nextScale;
  514|       |
  515|      0|  lastScale = 8;
  516|      0|  nextScale = 8;
  517|       |
  518|      0|  for(j=0; j<sizeOfScalingList; j++)
  519|      0|  {
  520|      0|    scanj = (sizeOfScalingList==16) ? ZZ_SCAN[j]:ZZ_SCAN8[j];
  521|       |
  522|      0|    if(nextScale!=0)
  523|      0|    {
  524|      0|      delta_scale = scalingListinput[scanj]-lastScale; // Calculate delta from the scalingList data from the input file
  525|      0|      if(delta_scale>127)
  526|      0|        delta_scale=delta_scale-256;
  527|      0|      else if(delta_scale<-128)
  528|      0|        delta_scale=delta_scale+256;
  529|       |
  530|      0|      len+=se_v ("   : delta_sl   ",                      delta_scale,                       partition);
  531|      0|      nextScale = scalingListinput[scanj];
  532|      0|      *UseDefaultScalingMatrix|=(scanj==0 && nextScale==0); // Check first matrix value for zero
  533|      0|    }
  534|       |
  535|      0|    scalingList[scanj] = (nextScale==0) ? lastScale:nextScale; // Update the actual scalingList matrix with the correct values
  536|      0|    lastScale = scalingList[scanj];
  537|      0|  }
  538|       |
  539|      0|  return len;
  540|      0|}
  541|       |
  542|       |
  543|       |/*! 
  544|       | *************************************************************************************
  545|       | * \brief
  546|       | *    int GenerateSeq_parameter_set_rbsp (seq_parameter_set_rbsp_t *sps, char *rbsp);
  547|       | *
  548|       | * \param sps
  549|       | *    sequence parameter structure
  550|       | * \param rbsp
  551|       | *    buffer to be filled with the rbsp, size should be at least MAXIMUMPARSETRBSPSIZE
  552|       | *
  553|       | * \return
  554|       | *    size of the RBSP in bytes
  555|       | *
  556|       | * \note
  557|       | *    Sequence Parameter VUI function is called, but the function implements
  558|       | *    an exit (-1)
  559|       | *************************************************************************************
  560|       | */
  561|       |int GenerateSeq_parameter_set_rbsp (seq_parameter_set_rbsp_t *sps, char *rbsp)
  562|      1|{
  563|      1|  DataPartition *partition;
  564|      1|  int len = 0, LenInBytes;
  565|      1|  unsigned i;
  566|       |
  567|      1|  assert (rbsp != NULL);
  568|       |  // In order to use the entropy coding functions from golomb.c we need 
  569|       |  // to allocate a partition structure.  It will be freed later in this
  570|       |  // function
  571|      1|  if ((partition=calloc(1,sizeof(DataPartition)))==NULL) no_mem_exit("SeqParameterSet:partition");
  572|      1|  if ((partition->bitstream=calloc(1, sizeof(Bitstream)))==NULL) no_mem_exit("SeqParameterSet:bitstream");
  573|       |  // .. and use the rbsp provided (or allocated above) for the data
  574|      1|  partition->bitstream->streamBuffer = rbsp;
  575|      1|  partition->bitstream->bits_to_go = 8;
  576|       |
  577|      1|  len+=u_v  (8, "SPS: profile_idc",                             sps->profile_idc,                               partition);
  578|       |
  579|      1|  len+=u_1  ("SPS: constrained_set0_flag",                      sps->constrained_set0_flag,    partition);
  580|      1|  len+=u_1  ("SPS: constrained_set1_flag",                      sps->constrained_set1_flag,    partition);
  581|      1|  len+=u_1  ("SPS: constrained_set2_flag",                      sps->constrained_set2_flag,    partition);
  582|      1|  len+=u_1  ("SPS: constrained_set3_flag",                      sps->constrained_set3_flag,    partition);
  583|      1|  len+=u_v  (4, "SPS: reserved_zero_4bits",                     0,                             partition);
  584|       |
  585|      1|  len+=u_v  (8, "SPS: level_idc",                               sps->level_idc,                                 partition);
  586|       |
  587|      1|  len+=ue_v ("SPS: seq_parameter_set_id",                    sps->seq_parameter_set_id,                      partition);
  588|       |
  589|       |  // Fidelity Range Extensions stuff
  590|      1|  if((sps->profile_idc==FREXT_HP) || 
  591|      1|     (sps->profile_idc==FREXT_Hi10P) ||
  592|      1|     (sps->profile_idc==FREXT_Hi422) ||
  593|      1|     (sps->profile_idc==FREXT_Hi444))
  594|      0|  {
  595|      0|    len+=ue_v ("SPS: chroma_format_idc",                        sps->chroma_format_idc,                          partition);
  596|      0|    if(img->yuv_format == 3)
  597|      0|      len+=u_1  ("SPS: residue_transform_flag",                 img->residue_transform_flag,                     partition);
  598|      0|    len+=ue_v ("SPS: bit_depth_luma_minus8",                    sps->bit_depth_luma_minus8,                      partition);
  599|      0|    len+=ue_v ("SPS: bit_depth_chroma_minus8",                  sps->bit_depth_chroma_minus8,                    partition);
  600|      0|    len+=u_1  ("SPS: lossless_qpprime_y_zero_flag",             img->lossless_qpprime_flag,                      partition);
  601|       |    //other chroma info to be added in the future
  602|       |
  603|      0|    len+=u_1 ("SPS: seq_scaling_matrix_present_flag",           sps->seq_scaling_matrix_present_flag,            partition);
  604|       |
  605|      0|    if(sps->seq_scaling_matrix_present_flag)
  606|      0|    {
  607|      0|      for(i=0; i<8; i++)
  608|      0|      {
  609|      0|        len+=u_1 ("SPS: seq_scaling_list_present_flag",         sps->seq_scaling_list_present_flag[i],           partition);
  610|      0|        if(sps->seq_scaling_list_present_flag[i])
  611|      0|        {
  612|      0|          if(i<6)
  613|      0|            len+=Scaling_List(ScalingList4x4input[i], ScalingList4x4[i], 16, &UseDefaultScalingMatrix4x4Flag[i], partition);
  614|      0|          else
  615|      0|            len+=Scaling_List(ScalingList8x8input[i-6], ScalingList8x8[i-6], 64, &UseDefaultScalingMatrix8x8Flag[i-6], partition);
  616|      0|        }
  617|      0|      }
  618|      0|    }
  619|      0|  }
  620|       |
  621|      1|  len+=ue_v ("SPS: log2_max_frame_num_minus4",               sps->log2_max_frame_num_minus4,                 partition);
  622|      1|  len+=ue_v ("SPS: pic_order_cnt_type",                      sps->pic_order_cnt_type,                        partition);
  623|       |
  624|      1|  if (sps->pic_order_cnt_type == 0)
  625|      1|    len+=ue_v ("SPS: log2_max_pic_order_cnt_lsb_minus4",     sps->log2_max_pic_order_cnt_lsb_minus4,         partition);
  626|      0|  else if (sps->pic_order_cnt_type == 1)
  627|      0|  {
  628|      0|    len+=u_1  ("SPS: delta_pic_order_always_zero_flag",        sps->delta_pic_order_always_zero_flag,          partition);
  629|      0|    len+=se_v ("SPS: offset_for_non_ref_pic",                  sps->offset_for_non_ref_pic,                    partition);
  630|      0|    len+=se_v ("SPS: offset_for_top_to_bottom_field",          sps->offset_for_top_to_bottom_field,            partition);
  631|      0|    len+=ue_v ("SPS: num_ref_frames_in_pic_order_cnt_cycle",   sps->num_ref_frames_in_pic_order_cnt_cycle,     partition);
  632|      0|    for (i=0; i<sps->num_ref_frames_in_pic_order_cnt_cycle; i++)
  633|      0|      len+=se_v ("SPS: offset_for_ref_frame",                  sps->offset_for_ref_frame[i],                      partition);
  634|      0|  }
  635|      1|  len+=ue_v ("SPS: num_ref_frames",                          sps->num_ref_frames,                            partition);
  636|      1|  len+=u_1  ("SPS: gaps_in_frame_num_value_allowed_flag",    sps->gaps_in_frame_num_value_allowed_flag,      partition);
  637|      1|  len+=ue_v ("SPS: pic_width_in_mbs_minus1",                 sps->pic_width_in_mbs_minus1,                   partition);
  638|      1|  len+=ue_v ("SPS: pic_height_in_map_units_minus1",          sps->pic_height_in_map_units_minus1,            partition);
  639|      1|  len+=u_1  ("SPS: frame_mbs_only_flag",                     sps->frame_mbs_only_flag,                       partition);
  640|      1|  if (!sps->frame_mbs_only_flag)
  641|      0|  {
  642|      0|    len+=u_1  ("SPS: mb_adaptive_frame_field_flag",            sps->mb_adaptive_frame_field_flag,              partition);
  643|      0|  }
  644|      1|  len+=u_1  ("SPS: direct_8x8_inference_flag",               sps->direct_8x8_inference_flag,                 partition);
  645|       |
  646|      1|  len+=u_1  ("SPS: frame_cropping_flag",                      sps->frame_cropping_flag,                       partition);
  647|      1|  if (sps->frame_cropping_flag)
  648|      0|  {
  649|      0|    len+=ue_v ("SPS: frame_cropping_rect_left_offset",          sps->frame_cropping_rect_left_offset,           partition);
  650|      0|    len+=ue_v ("SPS: frame_cropping_rect_right_offset",         sps->frame_cropping_rect_right_offset,          partition);
  651|      0|    len+=ue_v ("SPS: frame_cropping_rect_top_offset",           sps->frame_cropping_rect_top_offset,            partition);
  652|      0|    len+=ue_v ("SPS: frame_cropping_rect_bottom_offset",        sps->frame_cropping_rect_bottom_offset,         partition);
  653|      0|  }
  654|       |
  655|      1|  len+=u_1  ("SPS: vui_parameters_present_flag",             sps->vui_parameters_present_flag,               partition);
  656|      1|  if (sps->vui_parameters_present_flag)
  657|      0|    len+=GenerateVUISequenceParameters(partition);    // currently a dummy, asserting
  658|       |
  659|      1|  SODBtoRBSP(partition->bitstream);     // copies the last couple of bits into the byte buffer
  660|       |  
  661|      1|  LenInBytes=partition->bitstream->byte_pos;
  662|       |
  663|      1|  free (partition->bitstream);
  664|      1|  free (partition);
  665|       |  
  666|      1|  return LenInBytes;
  667|      1|}
  668|       |
  669|       |
  670|       |/*! 
  671|       | ***********************************************************************************************
  672|       | * \brief
  673|       | *    int GeneratePic_parameter_set_rbsp (pic_parameter_set_rbsp_t *sps, char *rbsp);
  674|       | *
  675|       | * \param pps
  676|       | *    picture parameter structure
  677|       | * \param rbsp
  678|       | *    buffer to be filled with the rbsp, size should be at least MAXIMUMPARSETRBSPSIZE
  679|       | *
  680|       | * \return
  681|       | *    size of the RBSP in bytes, negative in case of an error
  682|       | *
  683|       | * \note
  684|       | *    Picture Parameter VUI function is called, but the function implements
  685|       | *    an exit (-1)
  686|       | ************************************************************************************************
  687|       | */
  688|       | 
  689|       |int GeneratePic_parameter_set_rbsp (pic_parameter_set_rbsp_t *pps, char *rbsp)
  690|      1|{
  691|      1|  DataPartition *partition;
  692|      1|  int len = 0, LenInBytes;
  693|      1|  unsigned i;
  694|      1|  unsigned NumberBitsPerSliceGroupId;
  695|      1|  int profile_idc;
  696|       |
  697|      1|  assert (rbsp != NULL);
  698|       |
  699|       |  // In order to use the entropy coding functions from golomb.c we need 
  700|       |  // to allocate a partition structure.  It will be freed later in this
  701|       |  // function
  702|      1|  if ((partition=calloc(1,sizeof(DataPartition)))==NULL) no_mem_exit("PicParameterSet:partition");
  703|      1|  if ((partition->bitstream=calloc(1, sizeof(Bitstream)))==NULL) no_mem_exit("PicParameterSet:bitstream");
  704|       |  // .. and use the rbsp provided (or allocated above) for the data
  705|      1|  partition->bitstream->streamBuffer = rbsp;
  706|      1|  partition->bitstream->bits_to_go = 8;
  707|       |  //sw paff
  708|      1|  pps->pic_order_present_flag = img->pic_order_present_flag;
  709|       |
  710|      1|  len+=ue_v ("PPS: pic_parameter_set_id",                    pps->pic_parameter_set_id,                      partition);
  711|      1|  len+=ue_v ("PPS: seq_parameter_set_id",                    pps->seq_parameter_set_id,                      partition);
  712|      1|  len+=u_1  ("PPS: entropy_coding_mode_flag",                pps->entropy_coding_mode_flag,                  partition);
  713|      1|  len+=u_1  ("PPS: pic_order_present_flag",                  pps->pic_order_present_flag,                    partition);
  714|      1|  len+=ue_v ("PPS: num_slice_groups_minus1",                 pps->num_slice_groups_minus1,                   partition);
  715|       |
  716|       |  // FMO stuff
  717|      1|  if(pps->num_slice_groups_minus1 > 0 )
  718|      0|  {
  719|      0|    len+=ue_v ("PPS: slice_group_map_type",                 pps->slice_group_map_type,                   partition);
  720|      0|    if (pps->slice_group_map_type == 0)
  721|      0|      for (i=0; i<=pps->num_slice_groups_minus1; i++)
  722|      0|        len+=ue_v ("PPS: run_length_minus1[i]",                           pps->run_length_minus1[i],                             partition);
  723|      0|    else if (pps->slice_group_map_type==2)
  724|      0|      for (i=0; i<pps->num_slice_groups_minus1; i++)
  725|      0|      {
  726|       |
  727|      0|        len+=ue_v ("PPS: top_left[i]",                          pps->top_left[i],                           partition);
  728|      0|        len+=ue_v ("PPS: bottom_right[i]",                      pps->bottom_right[i],                       partition);
  729|      0|      }
  730|      0|    else if (pps->slice_group_map_type == 3 ||
  731|      0|             pps->slice_group_map_type == 4 ||
  732|      0|             pps->slice_group_map_type == 5) 
  733|      0|    {
  734|      0|      len+=u_1  ("PPS: slice_group_change_direction_flag",         pps->slice_group_change_direction_flag,         partition);
  735|      0|      len+=ue_v ("PPS: slice_group_change_rate_minus1",            pps->slice_group_change_rate_minus1,            partition);
  736|      0|    } 
  737|      0|    else if (pps->slice_group_map_type == 6)
  738|      0|    {
  739|      0|      if (pps->num_slice_groups_minus1>=4)
  740|      0|        NumberBitsPerSliceGroupId=3;
  741|      0|      else if (pps->num_slice_groups_minus1>=2)
  742|      0|        NumberBitsPerSliceGroupId=2;
  743|      0|      else if (pps->num_slice_groups_minus1>=1)
  744|      0|        NumberBitsPerSliceGroupId=1;
  745|      0|      else
  746|      0|        NumberBitsPerSliceGroupId=0;
  747|       |        
  748|      0|      len+=ue_v ("PPS: pic_size_in_map_units_minus1",          pps->pic_size_in_map_units_minus1,             partition);
  749|      0|      for(i=0; i<=pps->pic_size_in_map_units_minus1; i++)
  750|      0|        len+= u_v  (NumberBitsPerSliceGroupId, "PPS: >slice_group_id[i]",                            pps->slice_group_id[i],                         partition);
  751|      0|    }
  752|      0|  }
  753|       |  // End of FMO stuff
  754|       |
  755|      1|  len+=ue_v ("PPS: num_ref_idx_l0_active_minus1",             pps->num_ref_idx_l0_active_minus1,              partition);
  756|      1|  len+=ue_v ("PPS: num_ref_idx_l1_active_minus1",             pps->num_ref_idx_l1_active_minus1,              partition);
  757|      1|  len+=u_1  ("PPS: weighted_pred_flag",                       pps->weighted_pred_flag,                        partition);
  758|      1|  len+=u_v  (2, "PPS: weighted_bipred_idc",                   pps->weighted_bipred_idc,                       partition);
  759|      1|  len+=se_v ("PPS: pic_init_qp_minus26",                      pps->pic_init_qp_minus26,                       partition);
  760|      1|  len+=se_v ("PPS: pic_init_qs_minus26",                      pps->pic_init_qs_minus26,                       partition);
  761|       |
  762|      1|  profile_idc = IdentifyProfile();
  763|      1|  if((profile_idc==FREXT_HP) || 
  764|      1|     (profile_idc==FREXT_Hi10P) ||
  765|      1|     (profile_idc==FREXT_Hi422) ||
  766|      1|     (profile_idc==FREXT_Hi444))
  767|      0|    len+=se_v ("PPS: chroma_qp_index_offset",                 pps->cb_qp_index_offset,                        partition);
  768|      1|  else
  769|      1|    len+=se_v ("PPS: chroma_qp_index_offset",                 pps->chroma_qp_index_offset,                    partition);
  770|       |
  771|      1|  len+=u_1  ("PPS: deblocking_filter_control_present_flag",   pps->deblocking_filter_control_present_flag,    partition);
  772|      1|  len+=u_1  ("PPS: constrained_intra_pred_flag",              pps->constrained_intra_pred_flag,               partition);
  773|      1|  len+=u_1  ("PPS: redundant_pic_cnt_present_flag",           pps->redundant_pic_cnt_present_flag,            partition);
  774|       |
  775|       |  // Fidelity Range Extensions stuff
  776|      1|  if((profile_idc==FREXT_HP) || 
  777|      1|     (profile_idc==FREXT_Hi10P) ||
  778|      1|     (profile_idc==FREXT_Hi422) ||
  779|      1|     (profile_idc==FREXT_Hi444))
  780|      0|  {
  781|      0|    len+=u_1  ("PPS: transform_8x8_mode_flag",                pps->transform_8x8_mode_flag,                   partition);
  782|       |    
  783|      0|    len+=u_1  ("PPS: pic_scaling_matrix_present_flag",        pps->pic_scaling_matrix_present_flag,           partition);
  784|       |
  785|      0|    if(pps->pic_scaling_matrix_present_flag)
  786|      0|    {
  787|      0|      for(i=0; i<(6+((unsigned)pps->transform_8x8_mode_flag<<1)); i++)
  788|      0|      {
  789|      0|        len+=u_1  ("PPS: pic_scaling_list_present_flag",      pps->pic_scaling_list_present_flag[i],          partition);
  790|       |
  791|      0|        if(pps->pic_scaling_list_present_flag[i])
  792|      0|        {
  793|      0|          if(i<6)
  794|      0|            len+=Scaling_List(ScalingList4x4input[i], ScalingList4x4[i], 16, &UseDefaultScalingMatrix4x4Flag[i], partition);
  795|      0|          else
  796|      0|            len+=Scaling_List(ScalingList8x8input[i-6], ScalingList8x8[i-6], 64, &UseDefaultScalingMatrix8x8Flag[i-6], partition);
  797|      0|        }
  798|      0|      }
  799|      0|    }
  800|      0|    len+=se_v ("PPS: second_chroma_qp_index_offset",          pps->cr_qp_index_offset,                        partition);
  801|      0|  }
  802|       |
  803|      1|  SODBtoRBSP(partition->bitstream);     // copies the last couple of bits into the byte buffer
  804|       |  
  805|      1|  LenInBytes=partition->bitstream->byte_pos;
  806|       |
  807|       |  // Get rid of the helper structures
  808|      1|  free (partition->bitstream);
  809|      1|  free (partition);
  810|       |
  811|      1|  return LenInBytes;
  812|      1|}
  813|       |
  814|       |
  815|       |
  816|       |/*! 
  817|       | *************************************************************************************
  818|       | * \brief
  819|       | *    Returns the Profile
  820|       | *
  821|       | * \return
  822|       | *    Profile according to Annex A
  823|       | *
  824|       | * \note
  825|       | *    Function is currently a dummy.  Should "calculate" the profile from those
  826|       | *    config file parameters.  E.g.
  827|       | *
  828|       | *    Profile = Baseline;
  829|       | *    if (CABAC Used || Interlace used) Profile=Main;
  830|       | *    if (!Cabac Used) && (Bframes | SPframes) Profile = Streaming;
  831|       | *
  832|       | *************************************************************************************
  833|       | */
  834|       |int IdentifyProfile()
  835|     10|{
  836|     10|  return input->ProfileIDC;
  837|     10|};
  838|       |
  839|       |/*! 
  840|       | *************************************************************************************
  841|       | * \brief
  842|       | *    Returns the Level
  843|       | *
  844|       | * \return
  845|       | *    Level according to Annex A
  846|       | *
  847|       | * \note
  848|       | *    This function is currently a dummy, but should calculate the level out of 
  849|       | *    the config file parameters (primarily the picture size)
  850|       | *************************************************************************************
  851|       | */
  852|       |int IdentifyLevel()
  853|      1|{
  854|      1|  return input->LevelIDC;
  855|      1|};
  856|       |
  857|       |
  858|       |/*! 
  859|       | *************************************************************************************
  860|       | * \brief
  861|       | *    Function body for VUI Parameter generation (to be done)
  862|       | *
  863|       | * \return
  864|       | *    exits with error message
  865|       | *************************************************************************************
  866|       | */
  867|       |static int GenerateVUISequenceParameters(DataPartition *partition)
  868|      0|{
  869|      0|  int len=0;
  870|       |
  871|       |  // special case to signal the RGB format
  872|      0|  if(input->rgb_input_flag && input->yuv_format==3)
  873|      0|  { 
  874|       |    //still pretty much a dummy VUI
  875|      0|    printf ("test: writing Sequence Parameter VUI to signal RGB format\n");
  876|      0|    len+=u_1 ("VUI: aspect_ratio_info_present_flag", 0, partition);
  877|      0|    len+=u_1 ("VUI: overscan_info_present_flag", 0, partition);
  878|      0|    len+=u_1 ("VUI: video_signal_type_present_flag", 1, partition);
  879|      0|    len+=u_v (3, "VUI: video format", 2, partition);
  880|      0|    len+=u_1 ("VUI: video_full_range_flag", 1, partition);
  881|      0|    len+=u_1 ("VUI: color_description_present_flag", 1, partition);
  882|      0|    len+=u_v (8, "VUI: colour primaries", 2, partition);
  883|      0|    len+=u_v (8, "VUI: transfer characteristics", 2, partition);
  884|      0|    len+=u_v (8, "VUI: matrix coefficients", 0, partition);
  885|      0|    len+=u_1 ("VUI: chroma_loc_info_present_flag", 0, partition);
  886|      0|    len+=u_1 ("VUI: timing_info_present_flag", 0, partition);
  887|      0|    len+=u_1 ("VUI: nal_hrd_parameters_present_flag", 0, partition);
  888|      0|    len+=u_1 ("VUI: vcl_hrd_parameters_present_flag", 0, partition);
  889|      0|    len+=u_1 ("VUI: pic_struc_present_flag", 0, partition);
  890|      0|    len+=u_1 ("VUI: bitstream_restriction_flag", 0, partition);
  891|       |
  892|      0|    return len;
  893|      0|  }
  894|      0|  else 
  895|      0|  {
  896|      0|    printf ("Sequence Parameter VUI not yet implemented, this should never happen, exit\n");
  897|      0|    exit (-1);
  898|      0|  }
  899|      0|}
  900|       |

/home/xzp/speccpu2006-v1.0.1/benchspec/CPU2006/464.h264ref/run/build_base_ql_riscv_llvm17.0000/parsetcommon.c:
    1|       |
    2|       |/*!
    3|       | **************************************************************************************
    4|       | * \file
    5|       | *    parset.c
    6|       | * \brief
    7|       | *    Picture and Sequence Parameter set generation and handling
    8|       | *  \date 25 November 2002
    9|       | * \author
   10|       | *    Main contributors (see contributors.h for copyright, address and affiliation details) 
   11|       | *      - Stephan Wenger        <stewe@cs.tu-berlin.de>
   12|       | *
   13|       | **************************************************************************************
   14|       | */
   15|       |#include <stdlib.h>
   16|       |#include <assert.h>
   17|       |#include <memory.h>
   18|       |
   19|       |#include "global.h"
   20|       |#include "memalloc.h"
   21|       |
   22|       |/*! 
   23|       | *************************************************************************************
   24|       | * \brief
   25|       | *    Allocates memory for a pps
   26|       | *
   27|       | * \return
   28|       | *    pointer to a pps
   29|       | *************************************************************************************
   30|       | */
   31|       |pic_parameter_set_rbsp_t *AllocPPS ()
   32|      1| {
   33|      1|   pic_parameter_set_rbsp_t *p;
   34|       |
   35|      1|   if ((p=calloc (sizeof (pic_parameter_set_rbsp_t), 1)) == NULL)
   36|      0|     no_mem_exit ("AllocPPS: PPS");
   37|      1|   if ((p->slice_group_id = calloc (SIZEslice_group_id, 1)) == NULL)
   38|      0|     no_mem_exit ("AllocPPS: slice_group_id");
   39|      1|   return p;
   40|      1| }
   41|       |
   42|       | 
   43|       |/*! 
   44|       | *************************************************************************************
   45|       | * \brief
   46|       | *    Allocates memory for am sps
   47|       | *
   48|       | * \return
   49|       | *    pointer to a sps
   50|       | *************************************************************************************
   51|       | */
   52|       |seq_parameter_set_rbsp_t *AllocSPS ()
   53|      1| {
   54|      1|   seq_parameter_set_rbsp_t *p;
   55|       |
   56|      1|   if ((p=calloc (sizeof (seq_parameter_set_rbsp_t), 1)) == NULL)
   57|      0|     no_mem_exit ("AllocSPS: SPS");
   58|      1|   return p;
   59|      1| }
   60|       |
   61|       | 
   62|       |/*! 
   63|       | *************************************************************************************
   64|       | * \brief
   65|       | *    Frees a pps
   66|       | *
   67|       | * \param pps
   68|       | *     pps to be freed
   69|       | *
   70|       | * \return
   71|       | *    none
   72|       | *************************************************************************************
   73|       | */
   74|       | 
   75|       | void FreePPS (pic_parameter_set_rbsp_t *pps)
   76|      0| {
   77|      0|   assert (pps != NULL);
   78|      0|   if (pps->slice_group_id != NULL) free (pps->slice_group_id);
   79|      0|   free (pps);
   80|      0| }
   81|       |
   82|       | 
   83|       | /*! 
   84|       | *************************************************************************************
   85|       | * \brief
   86|       | *    Frees a sps
   87|       | *
   88|       | * \param sps
   89|       | *     sps to be freed
   90|       | *
   91|       | * \return
   92|       | *    none
   93|       | *************************************************************************************
   94|       | */
   95|       | 
   96|       | void FreeSPS (seq_parameter_set_rbsp_t *sps)
   97|      1| {
   98|      1|   assert (sps != NULL);
   99|      1|   free (sps); 
  100|      1| }

/home/xzp/speccpu2006-v1.0.1/benchspec/CPU2006/464.h264ref/run/build_base_ql_riscv_llvm17.0000/parsetcommon.h:
    1|       |
    2|       |/*!
    3|       | **************************************************************************************
    4|       | * \file
    5|       | *    parsetcommon.h
    6|       | * \brief
    7|       | *    Picture and Sequence Parameter Sets, structures common to encoder and decoder
    8|       | *    This code reflects JVT version xxx
    9|       | *  \date 25 November 2002
   10|       | * \author
   11|       | *    Main contributors (see contributors.h for copyright, address and affiliation details) 
   12|       | *      - Stephan Wenger        <stewe@cs.tu-berlin.de>
   13|       | ***************************************************************************************
   14|       | */
   15|       |
   16|       |
   17|       |
   18|       |// In the JVT syntax, frequently flags are used that indicate the presence of
   19|       |// certain pieces of information in the NALU.  Here, these flags are also
   20|       |// present.  In the encoder, those bits indicate that the values signalled to
   21|       |// be present are meaningful and that this part of the syntax should be
   22|       |// written to the NALU.  In the decoder, the flag indicates that information
   23|       |// was received from the decoded NALU and should be used henceforth.
   24|       |// The structure names were chosen as indicated in the JVT syntax
   25|       |
   26|       |#ifndef _PARSETCOMMON_H_
   27|       |#define _PARSETCOMMON_H_
   28|       |
   29|       |#define MAXIMUMPARSETRBSPSIZE   1500
   30|       |#define MAXIMUMPARSETNALUSIZE   1500
   31|      1|#define SIZEslice_group_id      (sizeof (byte) * 60000)    // should be sufficient for HUGE pictures, need one int per MB in a picture
   32|       |
   33|       |#define MAXSPS  32
   34|       |#define MAXPPS  256
   35|       |
   36|       |#ifdef SPEC_CPU_AIX
   37|       |#undef FALSE
   38|       |#undef TRUE
   39|       |#endif
   40|       |
   41|       |//! Boolean Type
   42|       |typedef enum {
   43|       |  FALSE,
   44|       |  TRUE
   45|       |} Boolean;
   46|       |
   47|       |#define MAXIMUMVALUEOFcpb_cnt   32
   48|       |typedef struct
   49|       |{
   50|       |  unsigned  cpb_cnt;                                          // ue(v)
   51|       |  unsigned  bit_rate_scale;                                   // u(4)
   52|       |  unsigned  cpb_size_scale;                                   // u(4)
   53|       |    unsigned  bit_rate_value [MAXIMUMVALUEOFcpb_cnt];         // ue(v)
   54|       |    unsigned  cpb_size_value[MAXIMUMVALUEOFcpb_cnt];          // ue(v)
   55|       |    unsigned  vbr_cbr_flag[MAXIMUMVALUEOFcpb_cnt];            // u(1)
   56|       |  unsigned  initial_cpb_removal_delay_length_minus1;          // u(5)
   57|       |  unsigned  cpb_removal_delay_length_minus1;                  // u(5)
   58|       |  unsigned  dpb_output_delay_length_minus1;                   // u(5)
   59|       |  unsigned  time_offset_length;                               // u(5)
   60|       |} hrd_parameters_t;
   61|       |
   62|       |
   63|       |typedef struct
   64|       |{
   65|       |  Boolean      aspect_ratio_info_present_flag;                   // u(1)
   66|       |    unsigned  aspect_ratio_idc;                               // u(8)
   67|       |      unsigned  sar_width;                                    // u(16)
   68|       |      unsigned  sar_height;                                   // u(16)
   69|       |  Boolean      overscan_info_present_flag;                       // u(1)
   70|       |    Boolean      overscan_appropriate_flag;                      // u(1)
   71|       |  Boolean      video_signal_type_present_flag;                   // u(1)
   72|       |    unsigned  video_format;                                   // u(3)
   73|       |    Boolean      video_full_range_flag;                          // u(1)
   74|       |    Boolean      colour_description_present_flag;                // u(1)
   75|       |      unsigned  colour_primaries;                             // u(8)
   76|       |      unsigned  transfer_characteristics;                     // u(8)
   77|       |      unsigned  matrix_coefficients;                          // u(8)
   78|       |  Boolean      chroma_location_info_present_flag;                // u(1)
   79|       |    unsigned  chroma_location_frame;                          // ue(v)
   80|       |    unsigned  chroma_location_field;                          // ue(v)
   81|       |  Boolean      timing_info_present_flag;                         // u(1)
   82|       |    unsigned  num_units_in_tick;                              // u(32)
   83|       |    unsigned  time_scale;                                     // u(32)
   84|       |    Boolean      fixed_frame_rate_flag;                          // u(1)
   85|       |  Boolean      nal_hrd_parameters_present_flag;                  // u(1)
   86|       |    hrd_parameters_t nal_hrd_parameters;                      // hrd_paramters_t
   87|       |  Boolean      vcl_hrd_parameters_present_flag;                  // u(1)
   88|       |    hrd_parameters_t vcl_hrd_parameters;                      // hrd_paramters_t
   89|       |  // if ((nal_hrd_parameters_present_flag || (vcl_hrd_parameters_present_flag))
   90|       |    Boolean      low_delay_hrd_flag;                             // u(1)
   91|       |  Boolean      bitstream_restriction_flag;                       // u(1)
   92|       |    Boolean      motion_vectors_over_pic_boundaries_flag;        // u(1)
   93|       |    unsigned  max_bytes_per_pic_denom;                        // ue(v)
   94|       |    unsigned  max_bits_per_mb_denom;                          // ue(v)
   95|       |    unsigned  log2_max_mv_length_vertical;                    // ue(v)
   96|       |    unsigned  log2_max_mv_length_horizontal;                  // ue(v)
   97|       |    unsigned  max_dec_frame_reordering;                       // ue(v)
   98|       |    unsigned  max_dec_frame_buffering;                        // ue(v)
   99|       |} vui_seq_parameters_t;
  100|       |
  101|       |
  102|       |#define MAXnum_slice_groups_minus1  8
  103|       |typedef struct
  104|       |{
  105|       |  Boolean   Valid;                  // indicates the parameter set is valid
  106|       |  unsigned  pic_parameter_set_id;                             // ue(v)
  107|       |  unsigned  seq_parameter_set_id;                             // ue(v)
  108|       |  Boolean   entropy_coding_mode_flag;                         // u(1)
  109|       |
  110|       |  Boolean   transform_8x8_mode_flag;                          // u(1)
  111|       |  Boolean   pic_scaling_matrix_present_flag;                  // u(1)
  112|       |  int       pic_scaling_list_present_flag[8];                 // u(1)
  113|       |
  114|       |  // if( pic_order_cnt_type < 2 )  in the sequence parameter set
  115|       |  Boolean      pic_order_present_flag;                           // u(1)
  116|       |  unsigned  num_slice_groups_minus1;                          // ue(v)
  117|       |    unsigned  slice_group_map_type;                        // ue(v)
  118|       |    // if( slice_group_map_type = = 0 )
  119|       |      unsigned  run_length_minus1[MAXnum_slice_groups_minus1]; // ue(v)
  120|       |    // else if( slice_group_map_type = = 2 )
  121|       |      unsigned  top_left[MAXnum_slice_groups_minus1];         // ue(v)
  122|       |      unsigned  bottom_right[MAXnum_slice_groups_minus1];     // ue(v)
  123|       |    // else if( slice_group_map_type = = 3 || 4 || 5
  124|       |      Boolean   slice_group_change_direction_flag;            // u(1)
  125|       |      unsigned  slice_group_change_rate_minus1;               // ue(v)
  126|       |    // else if( slice_group_map_type = = 6 )
  127|       |      unsigned  pic_size_in_map_units_minus1;	                // ue(v)
  128|       |      byte      *slice_group_id;                              // complete MBAmap u(v)
  129|       |			
  130|       |  int       num_ref_idx_l0_active_minus1;                     // ue(v)
  131|       |  int       num_ref_idx_l1_active_minus1;                     // ue(v)
  132|       |  Boolean   weighted_pred_flag;                               // u(1)
  133|       |  unsigned  weighted_bipred_idc;                              // u(2)
  134|       |  int       pic_init_qp_minus26;                              // se(v)
  135|       |  int       pic_init_qs_minus26;                              // se(v)
  136|       |  int       chroma_qp_index_offset;                           // se(v)
  137|       |
  138|       |  int       cb_qp_index_offset;                               // se(v)
  139|       |  int       cr_qp_index_offset;                               // se(v)
  140|       |
  141|       |  Boolean   deblocking_filter_control_present_flag;           // u(1)
  142|       |  Boolean   constrained_intra_pred_flag;                      // u(1)
  143|       |  Boolean   redundant_pic_cnt_present_flag;                   // u(1)
  144|       |  Boolean   vui_pic_parameters_flag;                          // u(1)
  145|       |} pic_parameter_set_rbsp_t;
  146|       |
  147|       |
  148|       |#define MAXnum_ref_frames_in_pic_order_cnt_cycle  256
  149|       |typedef struct
  150|       |{
  151|       |  Boolean   Valid;                  // indicates the parameter set is valid
  152|       |
  153|       |  unsigned  profile_idc;                                      // u(8)
  154|       |  Boolean   constrained_set0_flag;                            // u(1)
  155|       |  Boolean   constrained_set1_flag;                            // u(1)
  156|       |  Boolean   constrained_set2_flag;                            // u(1)
  157|       |  Boolean   constrained_set3_flag;                            // u(1)
  158|       |  unsigned  level_idc;                                        // u(8)
  159|       |  unsigned  seq_parameter_set_id;                             // ue(v)
  160|       |  unsigned  chroma_format_idc;                                // ue(v)
  161|       |
  162|       |  Boolean   seq_scaling_matrix_present_flag;                  // u(1)
  163|       |  int       seq_scaling_list_present_flag[8];                 // u(1)
  164|       |
  165|       |  unsigned  bit_depth_luma_minus8;                            // ue(v)
  166|       |  unsigned  bit_depth_chroma_minus8;                          // ue(v)
  167|       |  unsigned  log2_max_frame_num_minus4;                        // ue(v)
  168|       |  unsigned pic_order_cnt_type;
  169|       |  // if( pic_order_cnt_type == 0 ) 
  170|       |  unsigned log2_max_pic_order_cnt_lsb_minus4;                 // ue(v)
  171|       |  // else if( pic_order_cnt_type == 1 )
  172|       |    Boolean delta_pic_order_always_zero_flag;               // u(1)
  173|       |    int     offset_for_non_ref_pic;                         // se(v)
  174|       |    int     offset_for_top_to_bottom_field;                 // se(v)
  175|       |    unsigned  num_ref_frames_in_pic_order_cnt_cycle;          // ue(v)
  176|       |    // for( i = 0; i < num_ref_frames_in_pic_order_cnt_cycle; i++ )
  177|       |      int   offset_for_ref_frame[MAXnum_ref_frames_in_pic_order_cnt_cycle];   // se(v)
  178|       |  unsigned  num_ref_frames;                                   // ue(v)
  179|       |  Boolean   gaps_in_frame_num_value_allowed_flag;             // u(1)
  180|       |  unsigned  pic_width_in_mbs_minus1;                          // ue(v)
  181|       |  unsigned  pic_height_in_map_units_minus1;                   // ue(v)
  182|       |  Boolean   frame_mbs_only_flag;                              // u(1)
  183|       |  // if( !frame_mbs_only_flag ) 
  184|       |    Boolean   mb_adaptive_frame_field_flag;                   // u(1)
  185|       |  Boolean   direct_8x8_inference_flag;                        // u(1)
  186|       |  Boolean   frame_cropping_flag;                              // u(1)
  187|       |    unsigned  frame_cropping_rect_left_offset;                // ue(v)
  188|       |    unsigned  frame_cropping_rect_right_offset;               // ue(v)
  189|       |    unsigned  frame_cropping_rect_top_offset;                 // ue(v)
  190|       |    unsigned  frame_cropping_rect_bottom_offset;              // ue(v)
  191|       |  Boolean   vui_parameters_present_flag;                      // u(1)
  192|       |    vui_seq_parameters_t vui_seq_parameters;                  // vui_seq_parameters_t
  193|       |} seq_parameter_set_rbsp_t;
  194|       |
  195|       |pic_parameter_set_rbsp_t *AllocPPS ();
  196|       |seq_parameter_set_rbsp_t *AllocSPS ();
  197|       |void FreePPS (pic_parameter_set_rbsp_t *pps);
  198|       |void FreeSPS (seq_parameter_set_rbsp_t *sps);
  199|       |
  200|       |#endif

/home/xzp/speccpu2006-v1.0.1/benchspec/CPU2006/464.h264ref/run/build_base_ql_riscv_llvm17.0000/q_matrix.c:
    1|       |
    2|       |/*!
    3|       | *************************************************************************************
    4|       | * \file q_matrix.c
    5|       | *
    6|       | * \brief
    7|       | *    read q_matrix parameters from input file: q_matrix.cfg
    8|       | *
    9|       | *************************************************************************************
   10|       | */
   11|       |#include <stdlib.h>
   12|       |#include <string.h>
   13|       |
   14|       |#include "global.h"
   15|       |
   16|       |extern char *GetConfigFileContent (char *Filename, int error_type);
   17|       |
   18|       |#define MAX_ITEMS_TO_PARSE  1000
   19|       |
   20|       |extern const int quant_coef[6][4][4];
   21|       |extern const int dequant_coef[6][4][4];
   22|       |
   23|       |extern const int quant_coef8[6][8][8];
   24|       |extern const int dequant_coef8[6][8][8];
   25|       |
   26|       |
   27|       |int matrix4x4_check[6] = {0, 0, 0, 0, 0, 0};
   28|       |int matrix8x8_check[2] = {0, 0};
   29|       |
   30|       |static const char MatrixType4x4[6][20] =
   31|       |{
   32|       |  "INTRA4X4_LUMA",
   33|       |  "INTRA4X4_CHROMAU",
   34|       |  "INTRA4X4_CHROMAV",
   35|       |  "INTER4X4_LUMA",
   36|       |  "INTER4X4_CHROMAU",
   37|       |  "INTER4X4_CHROMAV"
   38|       |};
   39|       |
   40|       |static const char MatrixType8x8[2][20] =
   41|       |{
   42|       |  "INTRA8X8_LUMA",
   43|       |  "INTER8X8_LUMA",
   44|       |};
   45|       |
   46|       |int LevelScale4x4Luma_Intra[6][4][4];
   47|       |int LevelScale4x4Chroma_Intra[2][6][4][4];
   48|       |
   49|       |int LevelScale4x4Luma_Inter[6][4][4];
   50|       |int LevelScale4x4Chroma_Inter[2][6][4][4];
   51|       |
   52|       |int LevelScale8x8Luma_Intra[6][8][8];
   53|       |int LevelScale8x8Luma_Inter[6][8][8];
   54|       |
   55|       |int InvLevelScale4x4Luma_Intra[6][4][4];
   56|       |int InvLevelScale4x4Chroma_Intra[2][6][4][4];
   57|       |
   58|       |int InvLevelScale4x4Luma_Inter[6][4][4];
   59|       |int InvLevelScale4x4Chroma_Inter[2][6][4][4];
   60|       |
   61|       |int InvLevelScale8x8Luma_Intra[6][8][8];
   62|       |int InvLevelScale8x8Luma_Inter[6][8][8];
   63|       |
   64|       |short ScalingList4x4input[6][16];
   65|       |short ScalingList8x8input[2][64];
   66|       |short ScalingList4x4[6][16];
   67|       |short ScalingList8x8[2][64];
   68|       |
   69|       |short UseDefaultScalingMatrix4x4Flag[6];
   70|       |short UseDefaultScalingMatrix8x8Flag[2];
   71|       |
   72|       |static const short Quant_intra_default[16] =
   73|       |{
   74|       | 6,13,20,28,
   75|       |13,20,28,32,
   76|       |20,28,32,37,
   77|       |28,32,37,42
   78|       |};
   79|       |
   80|       |static const short Quant_inter_default[16] =
   81|       |{
   82|       |10,14,20,24,
   83|       |14,20,24,27,
   84|       |20,24,27,30,
   85|       |24,27,30,34
   86|       |};
   87|       |
   88|       |static const short Quant8_intra_default[64] =
   89|       |{
   90|       | 6,10,13,16,18,23,25,27,
   91|       |10,11,16,18,23,25,27,29,
   92|       |13,16,18,23,25,27,29,31,
   93|       |16,18,23,25,27,29,31,33,
   94|       |18,23,25,27,29,31,33,36,
   95|       |23,25,27,29,31,33,36,38,
   96|       |25,27,29,31,33,36,38,40,
   97|       |27,29,31,33,36,38,40,42
   98|       |};
   99|       |
  100|       |static const short Quant8_inter_default[64] =
  101|       |{
  102|       | 9,13,15,17,19,21,22,24,
  103|       |13,13,17,19,21,22,24,25,
  104|       |15,17,19,21,22,24,25,27,
  105|       |17,19,21,22,24,25,27,28,
  106|       |19,21,22,24,25,27,28,30,
  107|       |21,22,24,25,27,28,30,32,
  108|       |22,24,25,27,28,30,32,33,
  109|       |24,25,27,28,30,32,33,35
  110|       |};
  111|       |
  112|       |
  113|       |/*!
  114|       | ***********************************************************************
  115|       | * \brief
  116|       | *    Check the parameter name.
  117|       | * \param s
  118|       | *    parameter name string
  119|       | * \param type
  120|       | *    4x4 or 8x8 matrix type
  121|       | * \return
  122|       | *    the index number if the string is a valid parameter name,         \n
  123|       | *    -1 for error
  124|       | ***********************************************************************
  125|       | */
  126|       |int CheckParameterName (char *s, int *type)
  127|      0|{
  128|      0|  int i = 0;
  129|       |
  130|      0|  *type = 0;
  131|      0|  while ((MatrixType4x4[i] != NULL) && (i<6))
  132|      0|  {
  133|      0|    if (0==strcmp (MatrixType4x4[i], s))
  134|      0|      return i;
  135|      0|    else
  136|      0|      i++;
  137|      0|  }
  138|       |
  139|      0|  i = 0;
  140|      0|  *type = 1;
  141|      0|  while ((MatrixType8x8[i] != NULL) && (i<2))
  142|      0|  {
  143|      0|    if (0==strcmp (MatrixType8x8[i], s))
  144|      0|      return i;
  145|      0|    else
  146|      0|      i++;
  147|      0|  }
  148|       |
  149|      0|  return -1;
  150|      0|};
  151|       |
  152|       |/*!
  153|       | ***********************************************************************
  154|       | * \brief
  155|       | *    Parse the Q matrix values read from cfg file.
  156|       | * \param buf
  157|       | *    buffer to be parsed
  158|       | * \param bufsize
  159|       | *    buffer size of buffer
  160|       | ***********************************************************************
  161|       | */
  162|       |void ParseMatrix (char *buf, int bufsize)
  163|      0|{
  164|      0|  char *items[MAX_ITEMS_TO_PARSE];
  165|      0|  int MapIdx;
  166|      0|  int item = 0;
  167|      0|  int InString = 0, InItem = 0;
  168|      0|  char *p = buf;
  169|      0|  char *bufend = &buf[bufsize];
  170|      0|  int IntContent;
  171|      0|  int i, j, range, type, cnt;
  172|      0|  short *ScalingList;
  173|       |
  174|      0|  while (p < bufend)
  175|      0|  {
  176|      0|    switch (*p)
  177|      0|    {
  178|      0|      case 13:
  179|      0|        p++;
  180|      0|        break;
  181|      0|      case '#':                 // Found comment
  182|      0|        *p = '\0';              // Replace '#' with '\0' in case of comment immediately following integer or string
  183|      0|        while (*p != '\n' && p < bufend)  // Skip till EOL or EOF, whichever comes first
  184|      0|          p++;
  185|      0|        InString = 0;
  186|      0|        InItem = 0;
  187|      0|        break;
  188|      0|      case '\n':
  189|      0|        InItem = 0;
  190|      0|        InString = 0;
  191|      0|        *p++='\0';
  192|      0|        break;
  193|      0|      case ' ':
  194|      0|      case '\t':              // Skip whitespace, leave state unchanged
  195|      0|        if (InString)
  196|      0|          p++;
  197|      0|        else
  198|      0|        {                     // Terminate non-strings once whitespace is found
  199|      0|          *p++ = '\0';
  200|      0|          InItem = 0;
  201|      0|        }
  202|      0|        break;
  203|       |
  204|      0|      case '"':               // Begin/End of String
  205|      0|        *p++ = '\0';
  206|      0|        if (!InString)
  207|      0|        {
  208|      0|          items[item++] = p;
  209|      0|          InItem = ~InItem;
  210|      0|        }
  211|      0|        else
  212|      0|          InItem = 0;
  213|      0|        InString = ~InString; // Toggle
  214|      0|        break;
  215|       |
  216|      0|      case ',':
  217|      0|        p++;
  218|      0|        InItem = 0;
  219|      0|        break;
  220|       |
  221|      0|      default:
  222|      0|        if (!InItem)
  223|      0|        {
  224|      0|          items[item++] = p;
  225|      0|          InItem = ~InItem;
  226|      0|        }
  227|      0|        p++;
  228|      0|    }
  229|      0|  }
  230|       |
  231|      0|  item--;
  232|       |
  233|      0|  for (i=0; i<item; i+=cnt)
  234|      0|  {
  235|      0|    cnt=0;
  236|      0|    if (0 > (MapIdx = CheckParameterName (items[i+cnt], &type)))
  237|      0|    {
  238|      0|      snprintf (errortext, ET_SIZE, " Parsing error in config file: Parameter Name '%s' not recognized.", items[i+cnt]);
  239|      0|      error (errortext, 300);
  240|      0|    }
  241|      0|    cnt++;
  242|      0|    if (strcmp ("=", items[i+cnt]))
  243|      0|    {
  244|      0|      snprintf (errortext, ET_SIZE, " Parsing error in config file: '=' expected as the second token in each item.");
  245|      0|      error (errortext, 300);
  246|      0|    }
  247|      0|    cnt++;
  248|       |
  249|      0|    if (!type) //4x4 Matrix
  250|      0|    {
  251|      0|      range = 16;
  252|      0|      ScalingList = ScalingList4x4input[MapIdx];
  253|      0|      matrix4x4_check[MapIdx] = 1; //to indicate matrix found in cfg file
  254|      0|    }
  255|      0|    else //8x8 matrix
  256|      0|    {
  257|      0|      range = 64;
  258|      0|      ScalingList = ScalingList8x8input[MapIdx];
  259|      0|      matrix8x8_check[MapIdx] = 1; //to indicate matrix found in cfg file
  260|      0|    }
  261|       |
  262|      0|    for(j=0; j<range; j++)
  263|      0|    {
  264|      0|      if (1 != sscanf (items[i+cnt+j], "%d", &IntContent))
  265|      0|      {
  266|      0|        snprintf (errortext, ET_SIZE, " Parsing error: Expected numerical value for Parameter of %s, found '%s'.", items[i], items[i+cnt+j]);
  267|      0|        error (errortext, 300);
  268|      0|      }
  269|       |
  270|      0|      ScalingList[j] = (short)IntContent; //save value in matrix
  271|      0|    }
  272|      0|    cnt+=j;
  273|      0|    printf (".");
  274|      0|  }
  275|      0|}
  276|       |
  277|       |/*!
  278|       | ***********************************************************************
  279|       | * \brief
  280|       | *    Check Q Matrix values. If invalid values found in matrix,
  281|       | *    whole matrix will be patch with default value 16.
  282|       | ***********************************************************************
  283|       | */
  284|       |void PatchMatrix(void)
  285|      0|{
  286|      0|  short *ScalingList;
  287|      0|  int i, cnt, fail;
  288|       |
  289|      0|  for(i=0; i<6; i++)
  290|      0|  {
  291|      0|    if(input->ScalingListPresentFlag[i])
  292|      0|    {
  293|      0|      ScalingList=ScalingList4x4input[i];
  294|      0|      if(matrix4x4_check[i])
  295|      0|      {
  296|      0|        fail=0;
  297|      0|        for(cnt=0; cnt<16; cnt++)
  298|      0|        {
  299|      0|          if(ScalingList[cnt]<0 || ScalingList[cnt]>255) // ScalingList[0]=0 to indicate use default matrix
  300|      0|          {
  301|      0|            fail=1;
  302|      0|            break;
  303|      0|          }
  304|      0|        }
  305|       |
  306|      0|        if(fail) //value of matrix exceed range
  307|      0|        {
  308|      0|          printf("\n%s value exceed range. (Value must be 1 to 255)\n", MatrixType4x4[i]);
  309|      0|          printf("Setting default values for this matrix.");
  310|      0|          if(i>2)
  311|      0|            memcpy(ScalingList, Quant_inter_default, sizeof(short)*16);
  312|      0|          else
  313|      0|            memcpy(ScalingList, Quant_intra_default, sizeof(short)*16);
  314|      0|        }
  315|      0|      }
  316|      0|      else //matrix not found, pad with default value
  317|      0|      {
  318|      0|        printf("\n%s matrix definition not found. Setting default values.", MatrixType4x4[i]);
  319|      0|        if(i>2)
  320|      0|          memcpy(ScalingList, Quant_inter_default, sizeof(short)*16);
  321|      0|        else
  322|      0|          memcpy(ScalingList, Quant_intra_default, sizeof(short)*16);
  323|      0|      }
  324|      0|    }
  325|       |
  326|      0|    if((i<2) && input->ScalingListPresentFlag[i+6])
  327|      0|    {
  328|      0|      ScalingList=ScalingList8x8input[i];
  329|      0|      if(matrix8x8_check[i])
  330|      0|      {
  331|      0|        fail=0;
  332|      0|        for(cnt=0; cnt<64; cnt++)
  333|      0|        {
  334|      0|          if(ScalingList[cnt]<0 || ScalingList[cnt]>255) // ScalingList[0]=0 to indicate use default matrix
  335|      0|          {
  336|      0|            fail=1;
  337|      0|            break;
  338|      0|          }
  339|      0|        }
  340|       |
  341|      0|        if(fail) //value of matrix exceed range
  342|      0|        {
  343|      0|          printf("\n%s value exceed range. (Value must be 1 to 255)\n", MatrixType8x8[i]);
  344|      0|          printf("Setting default values for this matrix.");
  345|      0|          if(i==7)
  346|      0|            memcpy(ScalingList, Quant8_inter_default, sizeof(short)*64);
  347|      0|          else
  348|      0|            memcpy(ScalingList, Quant8_intra_default, sizeof(short)*64);
  349|      0|        }
  350|      0|      }
  351|      0|      else //matrix not found, pad with default value
  352|      0|      {
  353|      0|        printf("\n%s matrix definition not found. Setting default values.", MatrixType8x8[i]);
  354|      0|        if(i==7)
  355|      0|          memcpy(ScalingList, Quant8_inter_default, sizeof(short)*64);
  356|      0|        else
  357|      0|          memcpy(ScalingList, Quant8_intra_default, sizeof(short)*64);
  358|      0|      }
  359|      0|    }
  360|      0|  }
  361|      0|}
  362|       |
  363|       |/*!
  364|       | ***********************************************************************
  365|       | * \brief
  366|       | *    Initialise Q matrix values.
  367|       | ***********************************************************************
  368|       | */
  369|       |void Init_QMatrix (void)
  370|      1|{
  371|      1|  char *content;
  372|       |
  373|      1|  if(input->ScalingMatrixPresentFlag)
  374|      0|  {
  375|      0|    printf ("Parsing QMatrix file %s ", input->QmatrixFile);
  376|      0|    content = GetConfigFileContent(input->QmatrixFile, 0);
  377|      0|    if(content!='\0')
  378|      0|      ParseMatrix(content, strlen (content));
  379|      0|    else
  380|      0|      printf("\nError: %s\nProceeding with default values for all matrices.", errortext);
  381|       |
  382|      0|    PatchMatrix();
  383|      0|    printf("\n");
  384|       |
  385|      0|    memset(UseDefaultScalingMatrix4x4Flag, 0, sizeof(short)*6);
  386|      0|    UseDefaultScalingMatrix8x8Flag[0]=UseDefaultScalingMatrix8x8Flag[1]=0;
  387|       |  
  388|      0|    free(content);
  389|      0|  }
  390|      1|}
  391|       |
  392|       |/*!
  393|       | ************************************************************************
  394|       | * \brief
  395|       | *    For calculating the quantisation values at frame level
  396|       | *
  397|       | * \par Input:
  398|       | *    none
  399|       | *
  400|       | * \par Output:
  401|       | *    none
  402|       | ************************************************************************
  403|       | */
  404|       |void CalculateQuantParam(void)
  405|    171|{
  406|    171|  int i, j, k, temp;
  407|    171|  int present[6];
  408|    171|  int no_q_matrix=FALSE;
  409|       |
  410|    171|  if(!active_sps->seq_scaling_matrix_present_flag && !active_pps->pic_scaling_matrix_present_flag) //set to no q-matrix
  411|    171|    no_q_matrix=TRUE;
  412|      0|  else
  413|      0|  {
  414|      0|    memset(present, 0, sizeof(int)*6);
  415|       |
  416|      0|    if(active_sps->seq_scaling_matrix_present_flag)
  417|      0|      for(i=0; i<6; i++)
  418|      0|        present[i] = active_sps->seq_scaling_list_present_flag[i];
  419|       |
  420|      0|    if(active_pps->pic_scaling_matrix_present_flag)
  421|      0|      for(i=0; i<6; i++)
  422|      0|      {
  423|      0|        if((i==0) || (i==3))
  424|      0|          present[i] |= active_pps->pic_scaling_list_present_flag[i];
  425|      0|        else
  426|      0|          present[i] = active_pps->pic_scaling_list_present_flag[i];
  427|      0|      }
  428|      0|  }
  429|       |
  430|    171|  if(no_q_matrix==TRUE)
  431|    171|  {
  432|  1.19k|    for(k=0; k<6; k++)
  433|  5.13k|      for(j=0; j<4; j++)
  434|  20.5k|        for(i=0; i<4; i++)
  435|  16.4k|        {
  436|  16.4k|          LevelScale4x4Luma_Intra[k][j][i]         = quant_coef[k][j][i];
  437|  16.4k|          InvLevelScale4x4Luma_Intra[k][j][i]      = dequant_coef[k][j][i]<<4;
  438|       |
  439|  16.4k|          LevelScale4x4Chroma_Intra[0][k][j][i]    = quant_coef[k][j][i];
  440|  16.4k|          InvLevelScale4x4Chroma_Intra[0][k][j][i] = dequant_coef[k][j][i]<<4;
  441|       |
  442|  16.4k|          LevelScale4x4Chroma_Intra[1][k][j][i]    = quant_coef[k][j][i];
  443|  16.4k|          InvLevelScale4x4Chroma_Intra[1][k][j][i] = dequant_coef[k][j][i]<<4;
  444|       |
  445|  16.4k|          LevelScale4x4Luma_Inter[k][j][i]         = quant_coef[k][j][i];
  446|  16.4k|          InvLevelScale4x4Luma_Inter[k][j][i]      = dequant_coef[k][j][i]<<4;
  447|       |
  448|  16.4k|          LevelScale4x4Chroma_Inter[0][k][j][i]    = quant_coef[k][j][i];
  449|  16.4k|          InvLevelScale4x4Chroma_Inter[0][k][j][i] = dequant_coef[k][j][i]<<4;
  450|       |
  451|  16.4k|          LevelScale4x4Chroma_Inter[1][k][j][i]    = quant_coef[k][j][i];
  452|  16.4k|          InvLevelScale4x4Chroma_Inter[1][k][j][i] = dequant_coef[k][j][i]<<4;
  453|  16.4k|        }
  454|    171|  }
  455|      0|  else
  456|      0|  {
  457|      0|    for(k=0; k<6; k++)
  458|      0|      for(j=0; j<4; j++)
  459|      0|        for(i=0; i<4; i++)
  460|      0|        {
  461|      0|          temp = (i<<2)+j;
  462|      0|          if((!present[0]) || UseDefaultScalingMatrix4x4Flag[0])
  463|      0|          {
  464|      0|            LevelScale4x4Luma_Intra[k][j][i]         = (quant_coef[k][j][i]<<4)/Quant_intra_default[temp];
  465|      0|            InvLevelScale4x4Luma_Intra[k][j][i]      = dequant_coef[k][j][i]*Quant_intra_default[temp];
  466|      0|          }
  467|      0|          else
  468|      0|          {
  469|      0|            LevelScale4x4Luma_Intra[k][j][i]         = (quant_coef[k][j][i]<<4)/ScalingList4x4[0][temp];
  470|      0|            InvLevelScale4x4Luma_Intra[k][j][i]      = dequant_coef[k][j][i]*ScalingList4x4[0][temp];
  471|      0|          }
  472|       |
  473|      0|          if(!present[1])
  474|      0|          {
  475|      0|            LevelScale4x4Chroma_Intra[0][k][j][i]    = LevelScale4x4Luma_Intra[k][j][i];
  476|      0|            InvLevelScale4x4Chroma_Intra[0][k][j][i] = InvLevelScale4x4Luma_Intra[k][j][i];
  477|      0|          }
  478|      0|          else
  479|      0|          {
  480|      0|            LevelScale4x4Chroma_Intra[0][k][j][i]    = (quant_coef[k][j][i]<<4)/(UseDefaultScalingMatrix4x4Flag[1] ? Quant_intra_default[temp]:ScalingList4x4[1][temp]);
  481|      0|            InvLevelScale4x4Chroma_Intra[0][k][j][i] = dequant_coef[k][j][i]*(UseDefaultScalingMatrix4x4Flag[1] ? Quant_intra_default[temp]:ScalingList4x4[1][temp]);
  482|      0|          }
  483|       |
  484|      0|          if(!present[2])
  485|      0|          {
  486|      0|            LevelScale4x4Chroma_Intra[1][k][j][i]    = LevelScale4x4Chroma_Intra[0][k][j][i];
  487|      0|            InvLevelScale4x4Chroma_Intra[1][k][j][i] = InvLevelScale4x4Chroma_Intra[0][k][j][i];
  488|      0|          }
  489|      0|          else
  490|      0|          {
  491|      0|            LevelScale4x4Chroma_Intra[1][k][j][i]    = (quant_coef[k][j][i]<<4)/(UseDefaultScalingMatrix4x4Flag[2] ? Quant_intra_default[temp]:ScalingList4x4[2][temp]);
  492|      0|            InvLevelScale4x4Chroma_Intra[1][k][j][i] = dequant_coef[k][j][i]*(UseDefaultScalingMatrix4x4Flag[2] ? Quant_intra_default[temp]:ScalingList4x4[2][temp]);
  493|      0|          }
  494|       |
  495|      0|          if((!present[3]) || UseDefaultScalingMatrix4x4Flag[3])
  496|      0|          {
  497|      0|            LevelScale4x4Luma_Inter[k][j][i]         = (quant_coef[k][j][i]<<4)/Quant_inter_default[temp];
  498|      0|            InvLevelScale4x4Luma_Inter[k][j][i]      = dequant_coef[k][j][i]*Quant_inter_default[temp];
  499|      0|          }
  500|      0|          else
  501|      0|          {
  502|      0|            LevelScale4x4Luma_Inter[k][j][i]         = (quant_coef[k][j][i]<<4)/ScalingList4x4[3][temp];
  503|      0|            InvLevelScale4x4Luma_Inter[k][j][i]      = dequant_coef[k][j][i]*ScalingList4x4[3][temp];
  504|      0|          }
  505|       |
  506|      0|          if(!present[4])
  507|      0|          {
  508|      0|            LevelScale4x4Chroma_Inter[0][k][j][i]    = LevelScale4x4Luma_Inter[k][j][i];
  509|      0|            InvLevelScale4x4Chroma_Inter[0][k][j][i] = InvLevelScale4x4Luma_Inter[k][j][i];
  510|      0|          }
  511|      0|          else
  512|      0|          {
  513|      0|            LevelScale4x4Chroma_Inter[0][k][j][i]    = (quant_coef[k][j][i]<<4)/(UseDefaultScalingMatrix4x4Flag[4] ? Quant_inter_default[temp]:ScalingList4x4[4][temp]);
  514|      0|            InvLevelScale4x4Chroma_Inter[0][k][j][i] = dequant_coef[k][j][i]*(UseDefaultScalingMatrix4x4Flag[4] ? Quant_inter_default[temp]:ScalingList4x4[4][temp]);
  515|      0|          }
  516|       |
  517|      0|          if(!present[5])
  518|      0|          {
  519|      0|            LevelScale4x4Chroma_Inter[1][k][j][i]    = LevelScale4x4Chroma_Inter[0][k][j][i];
  520|      0|            InvLevelScale4x4Chroma_Inter[1][k][j][i] = InvLevelScale4x4Chroma_Inter[0][k][j][i];
  521|      0|          }
  522|      0|          else
  523|      0|          {
  524|      0|            LevelScale4x4Chroma_Inter[1][k][j][i]    = (quant_coef[k][j][i]<<4)/(UseDefaultScalingMatrix4x4Flag[5] ? Quant_inter_default[temp]:ScalingList4x4[5][temp]);
  525|      0|            InvLevelScale4x4Chroma_Inter[1][k][j][i] = dequant_coef[k][j][i]*(UseDefaultScalingMatrix4x4Flag[5] ? Quant_inter_default[temp]:ScalingList4x4[5][temp]);
  526|      0|          }
  527|      0|        }
  528|      0|  }
  529|    171|}
  530|       |
  531|       |/*!
  532|       | ************************************************************************
  533|       | * \brief
  534|       | *    Calculate the quantisation and inverse quantisation parameters
  535|       | *
  536|       | ************************************************************************
  537|       | */
  538|       |void CalculateQuant8Param()
  539|      0|{
  540|      0|  int i, j, k, temp;
  541|      0|  int present[2];
  542|      0|  int no_q_matrix=FALSE;
  543|       |
  544|      0|  if(!active_sps->seq_scaling_matrix_present_flag && !active_pps->pic_scaling_matrix_present_flag) //set to default matrix
  545|      0|    no_q_matrix=TRUE;
  546|      0|  else
  547|      0|  {
  548|      0|    memset(present, 0, sizeof(int)*2);
  549|       |
  550|      0|    if(active_sps->seq_scaling_matrix_present_flag)
  551|      0|      for(i=0; i<2; i++)
  552|      0|        present[i] = active_sps->seq_scaling_list_present_flag[i+6];
  553|       |
  554|      0|    if(active_pps->pic_scaling_matrix_present_flag)
  555|      0|      for(i=0; i<2; i++)
  556|      0|        present[i] |= active_pps->pic_scaling_list_present_flag[i+6];
  557|      0|  }
  558|       |
  559|      0|  if(no_q_matrix==TRUE)
  560|      0|  {
  561|      0|    for(k=0; k<6; k++)
  562|      0|      for(j=0; j<8; j++)
  563|      0|        for(i=0; i<8; i++)
  564|      0|        {
  565|      0|          LevelScale8x8Luma_Intra[k][j][i]         = quant_coef8[k][j][i];
  566|      0|          InvLevelScale8x8Luma_Intra[k][j][i]      = dequant_coef8[k][j][i]<<4;
  567|       |
  568|      0|          LevelScale8x8Luma_Inter[k][j][i]         = quant_coef8[k][j][i];
  569|      0|          InvLevelScale8x8Luma_Inter[k][j][i]      = dequant_coef8[k][j][i]<<4;
  570|      0|        }
  571|      0|  }
  572|      0|  else
  573|      0|  {
  574|      0|    for(k=0; k<6; k++)
  575|      0|      for(j=0; j<8; j++)
  576|      0|        for(i=0; i<8; i++)
  577|      0|        {
  578|      0|          temp = (i<<3)+j;
  579|      0|          if((!present[0]) || UseDefaultScalingMatrix8x8Flag[0])
  580|      0|          {
  581|      0|            LevelScale8x8Luma_Intra[k][j][i]    = (quant_coef8[k][j][i]<<4)/Quant8_intra_default[temp];
  582|      0|            InvLevelScale8x8Luma_Intra[k][j][i] = dequant_coef8[k][j][i]*Quant8_intra_default[temp];
  583|      0|          }
  584|      0|          else
  585|      0|          {
  586|      0|            LevelScale8x8Luma_Intra[k][j][i]    = (quant_coef8[k][j][i]<<4)/ScalingList8x8[0][temp];
  587|      0|            InvLevelScale8x8Luma_Intra[k][j][i] = dequant_coef8[k][j][i]*ScalingList8x8[0][temp];
  588|      0|          }
  589|       |
  590|      0|          if((!present[1]) || UseDefaultScalingMatrix8x8Flag[1])
  591|      0|          {
  592|      0|            LevelScale8x8Luma_Inter[k][j][i]    = (quant_coef8[k][j][i]<<4)/Quant8_inter_default[temp];
  593|      0|            InvLevelScale8x8Luma_Inter[k][j][i] = dequant_coef8[k][j][i]*Quant8_inter_default[temp];
  594|      0|          }
  595|      0|          else
  596|      0|          {
  597|      0|            LevelScale8x8Luma_Inter[k][j][i]    = (quant_coef8[k][j][i]<<4)/ScalingList8x8[1][temp];
  598|      0|            InvLevelScale8x8Luma_Inter[k][j][i] = dequant_coef8[k][j][i]*ScalingList8x8[1][temp];
  599|      0|          }
  600|      0|        }
  601|      0|  }
  602|      0|}
  603|       |

/home/xzp/speccpu2006-v1.0.1/benchspec/CPU2006/464.h264ref/run/build_base_ql_riscv_llvm17.0000/q_offsets.c:
    1|       |
    2|       |/*!
    3|       | *************************************************************************************
    4|       | * \file q_offsets.c
    5|       | *
    6|       | * \brief
    7|       | *    read Quantization Offset matrix parameters from input file: q_OffsetMatrix.cfg
    8|       | *
    9|       | *************************************************************************************
   10|       | */
   11|       |#include <stdlib.h>
   12|       |#include <string.h>
   13|       |
   14|       |#include "global.h"
   15|       |
   16|       |extern char *GetConfigFileContent (char *Filename, int error_type);
   17|       |
   18|       |#define MAX_ITEMS_TO_PARSE  1000
   19|       |
   20|       |int offset4x4_check[6] = {0, 0, 0, 0, 0, 0};
   21|       |int offset8x8_check[2] = {0, 0};
   22|       |
   23|       |static const char OffsetType4x4[9][24] =
   24|       |{
   25|       |  "INTRA4X4_LUMA_INTRA",
   26|       |  "INTRA4X4_CHROMAU_INTRA",
   27|       |  "INTRA4X4_CHROMAV_INTRA",
   28|       |  "INTRA4X4_LUMA_INTER",
   29|       |  "INTRA4X4_CHROMAU_INTER",
   30|       |  "INTRA4X4_CHROMAV_INTER",
   31|       |  "INTER4X4_LUMA",
   32|       |  "INTER4X4_CHROMAU",
   33|       |  "INTER4X4_CHROMAV"
   34|       |};
   35|       |
   36|       |static const char OffsetType8x8[3][24] =
   37|       |{
   38|       |  "INTRA8X8_LUMA_INTRA",
   39|       |  "INTRA8X8_LUMA_INTER",
   40|       |  "INTER8X8_LUMA",
   41|       |};
   42|       |
   43|       |
   44|       |int LevelOffset4x4Luma_Intra[13][4][4];
   45|       |int LevelOffset4x4Chroma_Intra[2][13][4][4];
   46|       |
   47|       |int LevelOffset4x4Luma_Inter[13][4][4];
   48|       |int LevelOffset4x4Chroma_Inter[2][13][4][4];
   49|       |
   50|       |int LevelOffset8x8Luma_Intra[13][8][8];
   51|       |int LevelOffset8x8Luma_Inter[13][8][8];
   52|       |
   53|       |short OffsetList4x4input[9][16];
   54|       |short OffsetList8x8input[3][64];
   55|       |short OffsetList4x4[9][16];
   56|       |short OffsetList8x8[3][64];
   57|       |
   58|       |//short UseDefaultOffsetMatrix4x4Flag[6];
   59|       |//short UseDefaultOffsetMatrix8x8Flag[2];
   60|       |
   61|       |static const short Offset_intra_default_intra[16] =
   62|       |{
   63|       |  341,341,341,341,
   64|       |  341,341,341,341,
   65|       |  341,341,341,341,
   66|       |  341,341,341,341
   67|       |};
   68|       |
   69|       |static const short Offset_intra_default_inter[16] =
   70|       |{
   71|       |  171,171,171,171,
   72|       |  171,171,171,171,
   73|       |  171,171,171,171,
   74|       |  171,171,171,171,
   75|       |};
   76|       |
   77|       |static const short Offset_inter_default[16] =
   78|       |{
   79|       |  171,171,171,171,
   80|       |  171,171,171,171,
   81|       |  171,171,171,171,
   82|       |  171,171,171,171,
   83|       |};
   84|       |
   85|       |static const short Offset8_intra_default_intra[64] =
   86|       |{
   87|       |  341,341,341,341,341,341,341,341,
   88|       |  341,341,341,341,341,341,341,341,
   89|       |  341,341,341,341,341,341,341,341,
   90|       |  341,341,341,341,341,341,341,341,
   91|       |  341,341,341,341,341,341,341,341,
   92|       |  341,341,341,341,341,341,341,341,
   93|       |  341,341,341,341,341,341,341,341,
   94|       |  341,341,341,341,341,341,341,341
   95|       |};
   96|       |
   97|       |static const short Offset8_intra_default_inter[64] =
   98|       |{
   99|       |  171,171,171,171,171,171,171,171,
  100|       |  171,171,171,171,171,171,171,171,
  101|       |  171,171,171,171,171,171,171,171,
  102|       |  171,171,171,171,171,171,171,171,
  103|       |  171,171,171,171,171,171,171,171,
  104|       |  171,171,171,171,171,171,171,171,
  105|       |  171,171,171,171,171,171,171,171,
  106|       |  171,171,171,171,171,171,171,171
  107|       |};
  108|       |
  109|       |static const short Offset8_inter_default[64] =
  110|       |{
  111|       |  171,171,171,171,171,171,171,171,
  112|       |  171,171,171,171,171,171,171,171,
  113|       |  171,171,171,171,171,171,171,171,
  114|       |  171,171,171,171,171,171,171,171,
  115|       |  171,171,171,171,171,171,171,171,
  116|       |  171,171,171,171,171,171,171,171,
  117|       |  171,171,171,171,171,171,171,171,
  118|       |  171,171,171,171,171,171,171,171
  119|       |};
  120|       |
  121|       |
  122|       |/*!
  123|       | ***********************************************************************
  124|       | * \brief
  125|       | *    Check the parameter name.
  126|       | * \param s
  127|       | *    parameter name string
  128|       | * \param type
  129|       | *    4x4 or 8x8 offset matrix type
  130|       | * \return
  131|       | *    the index number if the string is a valid parameter name,         \n
  132|       | *    -1 for error
  133|       | ***********************************************************************
  134|       | */
  135|       |
  136|       |int CheckOffsetParameterName (char *s, int *type)
  137|      0|{
  138|      0|  int i = 0;
  139|       |
  140|      0|  *type = 0;
  141|      0|  while ((OffsetType4x4[i] != NULL) && (i<9))
  142|      0|  {
  143|      0|    if (0==strcmp (OffsetType4x4[i], s))
  144|      0|      return i;
  145|      0|    else
  146|      0|      i++;
  147|      0|  }
  148|       |
  149|      0|  i = 0;
  150|      0|  *type = 1;
  151|      0|  while ((OffsetType8x8[i] != NULL) && (i<3))
  152|      0|  {
  153|      0|    if (0==strcmp (OffsetType8x8[i], s))
  154|      0|      return i;
  155|      0|    else
  156|      0|      i++;
  157|      0|  }
  158|       |
  159|      0|  return -1;
  160|      0|};
  161|       |
  162|       |/*!
  163|       | ***********************************************************************
  164|       | * \brief
  165|       | *    Parse the Q Offset Matrix values read from cfg file.
  166|       | * \param buf
  167|       | *    buffer to be parsed
  168|       | * \param bufsize
  169|       | *    buffer size of buffer
  170|       | ***********************************************************************
  171|       | */
  172|       |void ParseQOffsetMatrix (char *buf, int bufsize)
  173|      0|{
  174|      0|  char *items[MAX_ITEMS_TO_PARSE];
  175|      0|  int MapIdx;
  176|      0|  int item = 0;
  177|      0|  int InString = 0, InItem = 0;
  178|      0|  char *p = buf;
  179|      0|  char *bufend = &buf[bufsize];
  180|      0|  int IntContent;
  181|      0|  int i, j, range, type, cnt;
  182|      0|  short *OffsetList;
  183|       |
  184|      0|  while (p < bufend)
  185|      0|  {
  186|      0|    switch (*p)
  187|      0|    {
  188|      0|      case 13:
  189|      0|        p++;
  190|      0|        break;
  191|      0|      case '#':                 // Found comment
  192|      0|        *p = '\0';              // Replace '#' with '\0' in case of comment immediately following integer or string
  193|      0|        while (*p != '\n' && p < bufend)  // Skip till EOL or EOF, whichever comes first
  194|      0|          p++;
  195|      0|        InString = 0;
  196|      0|        InItem = 0;
  197|      0|        break;
  198|      0|      case '\n':
  199|      0|        InItem = 0;
  200|      0|        InString = 0;
  201|      0|        *p++='\0';
  202|      0|        break;
  203|      0|      case ' ':
  204|      0|      case '\t':              // Skip whitespace, leave state unchanged
  205|      0|        if (InString)
  206|      0|          p++;
  207|      0|        else
  208|      0|        {                     // Terminate non-strings once whitespace is found
  209|      0|          *p++ = '\0';
  210|      0|          InItem = 0;
  211|      0|        }
  212|      0|        break;
  213|       |
  214|      0|      case '"':               // Begin/End of String
  215|      0|        *p++ = '\0';
  216|      0|        if (!InString)
  217|      0|        {
  218|      0|          items[item++] = p;
  219|      0|          InItem = ~InItem;
  220|      0|        }
  221|      0|        else
  222|      0|          InItem = 0;
  223|      0|        InString = ~InString; // Toggle
  224|      0|        break;
  225|       |
  226|      0|      case ',':
  227|      0|        p++;
  228|      0|        InItem = 0;
  229|      0|        break;
  230|       |
  231|      0|      default:
  232|      0|        if (!InItem)
  233|      0|        {
  234|      0|          items[item++] = p;
  235|      0|          InItem = ~InItem;
  236|      0|        }
  237|      0|        p++;
  238|      0|    }
  239|      0|  }
  240|       |
  241|      0|  item--;
  242|       |
  243|      0|  for (i=0; i<item; i+=cnt)
  244|      0|  {
  245|      0|    cnt=0;
  246|      0|    if (0 > (MapIdx = CheckOffsetParameterName (items[i+cnt], &type)))
  247|      0|    {
  248|      0|      snprintf (errortext, ET_SIZE, " Parsing error in config file: Parameter Name '%s' not recognized.", items[i+cnt]);
  249|      0|      error (errortext, 300);
  250|      0|    }
  251|      0|    cnt++;
  252|      0|    if (strcmp ("=", items[i+cnt]))
  253|      0|    {
  254|      0|      snprintf (errortext, ET_SIZE, " Parsing error in config file: '=' expected as the second token in each item.");
  255|      0|      error (errortext, 300);
  256|      0|    }
  257|      0|    cnt++;
  258|       |
  259|      0|    if (!type) //4x4 Matrix
  260|      0|    {
  261|      0|      range = 16;
  262|      0|      OffsetList = OffsetList4x4input[MapIdx];
  263|      0|      offset4x4_check[MapIdx] = 1; //to indicate matrix found in cfg file
  264|      0|    }
  265|      0|    else //8x8 matrix
  266|      0|    {
  267|      0|      range = 64;
  268|      0|      OffsetList = OffsetList8x8input[MapIdx];
  269|      0|      offset8x8_check[MapIdx] = 1; //to indicate matrix found in cfg file
  270|      0|    }
  271|       |
  272|      0|    for(j=0; j<range; j++)
  273|      0|    {
  274|      0|      if (1 != sscanf (items[i+cnt+j], "%d", &IntContent))
  275|      0|      {
  276|      0|        snprintf (errortext, ET_SIZE, " Parsing error: Expected numerical value for Parameter of %s, found '%s'.", items[i], items[i+cnt+j]);
  277|      0|        error (errortext, 300);
  278|      0|      }
  279|       |
  280|      0|      OffsetList[j] = (short) IntContent; //save value in matrix
  281|      0|    }
  282|      0|    cnt+=j;
  283|      0|    printf (".");
  284|      0|  }
  285|      0|}
  286|       |
  287|       |
  288|       |/*!
  289|       | ***********************************************************************
  290|       | * \brief
  291|       | *    Initialise Q offset matrix values.
  292|       | ***********************************************************************
  293|       | */
  294|       |void Init_QOffsetMatrix ()
  295|      1|{
  296|      1|  char *content;
  297|       |
  298|      1|  if(input->OffsetMatrixPresentFlag)
  299|      0|  {
  300|      0|    printf ("Parsing Quantization Offset Matrix file %s ", input->QOffsetMatrixFile);
  301|      0|    content = GetConfigFileContent(input->QOffsetMatrixFile, 0);
  302|      0|    if(content!='\0')
  303|      0|      ParseQOffsetMatrix(content, strlen (content));
  304|      0|    else
  305|      0|    {
  306|      0|      printf("\nError: %s\nProceeding with default values for all matrices.", errortext);
  307|      0|      input->OffsetMatrixPresentFlag = 0;
  308|      0|    }
  309|       |
  310|      0|    printf("\n");
  311|       |
  312|       |  
  313|      0|    free(content);
  314|      0|  }
  315|      1|}
  316|       |
  317|       |
  318|       |/*!
  319|       | ************************************************************************
  320|       | * \brief
  321|       | *    Calculation of the quantization offset params at the frame level
  322|       | *
  323|       | * \par Input:
  324|       | *    none
  325|       | *
  326|       | * \par Output:
  327|       | *    none
  328|       | ************************************************************************
  329|       | */
  330|       | void CalculateOffsetParam()
  331|    171| {
  332|    171|   int i, j, k, temp;
  333|    171|   int qp_per;
  334|       |   
  335|    171|   if(input->OffsetMatrixPresentFlag)
  336|      0|   {
  337|      0|     for(k=0; k<13; k++)
  338|      0|     {
  339|      0|       qp_per = Q_BITS + k - 10;
  340|      0|       for(j=0; j<4; j++)
  341|      0|       {
  342|      0|         for(i=0; i<4; i++)
  343|      0|         {
  344|      0|           temp = (i<<2)+j;
  345|      0|           if (img->type == I_SLICE)
  346|      0|           {
  347|      0|             LevelOffset4x4Luma_Intra[k][j][i]         = (int)OffsetList4x4input[0][temp]<<qp_per;
  348|      0|             LevelOffset4x4Chroma_Intra[0][k][j][i]    = (int)OffsetList4x4input[1][temp]<<qp_per;
  349|      0|             LevelOffset4x4Chroma_Intra[1][k][j][i]    = (int)OffsetList4x4input[2][temp]<<qp_per;
  350|      0|           }
  351|      0|           else
  352|      0|           {
  353|      0|             LevelOffset4x4Luma_Intra[k][j][i]         = (int)OffsetList4x4input[3][temp]<<qp_per;
  354|      0|             LevelOffset4x4Chroma_Intra[0][k][j][i]    = (int)OffsetList4x4input[4][temp]<<qp_per;
  355|      0|             LevelOffset4x4Chroma_Intra[1][k][j][i]    = (int)OffsetList4x4input[5][temp]<<qp_per;
  356|      0|           }
  357|       |           
  358|      0|           LevelOffset4x4Luma_Inter[k][j][i]         = (int)OffsetList4x4input[6][temp]<<qp_per;
  359|      0|           LevelOffset4x4Chroma_Inter[0][k][j][i]    = (int)OffsetList4x4input[7][temp]<<qp_per;
  360|      0|           LevelOffset4x4Chroma_Inter[1][k][j][i]    = (int)OffsetList4x4input[8][temp]<<qp_per;
  361|      0|         }
  362|      0|       }
  363|      0|     }
  364|      0|   }
  365|    171|   else
  366|    171|   {
  367|  2.39k|     for(k=0; k<13; k++)
  368|  2.22k|     {
  369|  2.22k|       qp_per = Q_BITS + k - 10;
  370|  11.1k|       for(j=0; j<4; j++)
  371|  8.89k|       {
  372|  44.4k|         for(i=0; i<4; i++)
  373|  35.5k|         {
  374|  35.5k|           temp = (i<<2)+j;
  375|  35.5k|           if (img->type == I_SLICE)
  376|  6.03k|           {
  377|  6.03k|             LevelOffset4x4Luma_Intra[k][j][i]         = (int)Offset_intra_default_intra[temp]<<qp_per;
  378|  6.03k|             LevelOffset4x4Chroma_Intra[0][k][j][i]    = (int)Offset_intra_default_intra[temp]<<qp_per;
  379|  6.03k|             LevelOffset4x4Chroma_Intra[1][k][j][i]    = (int)Offset_intra_default_intra[temp]<<qp_per;
  380|  6.03k|           }
  381|  29.5k|           else
  382|  29.5k|           {
  383|  29.5k|             LevelOffset4x4Luma_Intra[k][j][i]         = (int)Offset_intra_default_inter[temp]<<qp_per;
  384|  29.5k|             LevelOffset4x4Chroma_Intra[0][k][j][i]    = (int)Offset_intra_default_inter[temp]<<qp_per;
  385|  29.5k|             LevelOffset4x4Chroma_Intra[1][k][j][i]    = (int)Offset_intra_default_inter[temp]<<qp_per;
  386|  29.5k|           }
  387|  35.5k|           LevelOffset4x4Luma_Inter[k][j][i]         = (int)Offset_inter_default[temp]<<qp_per;
  388|  35.5k|           LevelOffset4x4Chroma_Inter[0][k][j][i]    = (int)Offset_inter_default[temp]<<qp_per;
  389|  35.5k|           LevelOffset4x4Chroma_Inter[1][k][j][i]    = (int)Offset_inter_default[temp]<<qp_per;
  390|  35.5k|         }
  391|  8.89k|       }
  392|  2.22k|     }
  393|    171|   }
  394|    171| }
  395|       | 
  396|       | /*!
  397|       | ************************************************************************
  398|       | * \brief
  399|       | *    Calculate the quantisation offset parameters
  400|       | *
  401|       | ************************************************************************
  402|       | */
  403|       |void CalculateOffset8Param()
  404|      0|{
  405|       |
  406|      0|  int i, j, k, temp;
  407|      0|   int q_bits;
  408|       |   
  409|      0|   if(input->OffsetMatrixPresentFlag)
  410|      0|   {
  411|      0|     for(k=0; k<13; k++)
  412|      0|     {
  413|      0|       q_bits = Q_BITS_8 + k - 10;
  414|      0|       for(j=0; j<8; j++)
  415|      0|       {
  416|      0|         for(i=0; i<8; i++)
  417|      0|         {           
  418|      0|           temp = (i<<3)+j;
  419|      0|           if (img->type == I_SLICE)
  420|      0|             LevelOffset8x8Luma_Intra[k][j][i] = (int)OffsetList8x8input[0][temp] << q_bits;
  421|      0|           else
  422|      0|             LevelOffset8x8Luma_Intra[k][j][i] = (int)OffsetList8x8input[1][temp] << q_bits;
  423|       |
  424|      0|           LevelOffset8x8Luma_Inter[k][j][i] = (int)OffsetList8x8input[2][temp] << q_bits;
  425|      0|         }
  426|      0|       }
  427|      0|     }
  428|      0|   }
  429|      0|   else
  430|      0|   {
  431|      0|     for(k=0; k<13; k++)
  432|      0|     {
  433|      0|       q_bits = Q_BITS_8 + k - 10;
  434|      0|       for(j=0; j<8; j++)
  435|      0|       {
  436|      0|         for(i=0; i<8; i++)
  437|      0|         {
  438|      0|           temp = (i<<3)+j;
  439|      0|           if (img->type == I_SLICE)
  440|      0|             LevelOffset8x8Luma_Intra[k][j][i] = (int)Offset8_intra_default_intra[temp] << q_bits;
  441|      0|           else
  442|      0|             LevelOffset8x8Luma_Intra[k][j][i] = (int)Offset8_intra_default_inter[temp] << q_bits;
  443|      0|           LevelOffset8x8Luma_Inter[k][j][i] = (int)Offset8_inter_default[temp] << q_bits;
  444|      0|         }
  445|      0|       }
  446|      0|     }
  447|      0|   }
  448|      0|}
  449|       |

/home/xzp/speccpu2006-v1.0.1/benchspec/CPU2006/464.h264ref/run/build_base_ql_riscv_llvm17.0000/ratectl.c:
    1|       |
    2|       |/*!
    3|       | ***************************************************************************
    4|       | * \file ratectl.c
    5|       | *
    6|       | * \brief
    7|       | *    Rate Control algorithm
    8|       | *
    9|       | * \author
   10|       | *    Main contributors (see contributors.h for copyright, address and affiliation details) 
   11|       | *     - Siwei Ma <swma@jdl.ac.cn>
   12|       | *     - Zhengguo LI<ezgli@lit.a-star.edu.sg>
   13|       | *
   14|       | * \date
   15|       | *   16 Jan. 2003
   16|       | **************************************************************************
   17|       | */
   18|       |
   19|       |#include <stdlib.h>
   20|       |#include <math.h>
   21|       |#include <assert.h>
   22|       |
   23|       |#include "global.h"
   24|       |#include "ratectl.h"
   25|       |
   26|       |#if defined(SPEC_CPU)
   27|       |double bit_rate; 
   28|       |double frame_rate;
   29|       |double GAMMAP;//LIZG, JVT019r1
   30|       |double BETAP;//LIZG, JVT019r1
   31|       |
   32|       |int RC_MAX_QUANT;//LIZG 28/10/2002
   33|       |int RC_MIN_QUANT;//LIZG 28/10/2002
   34|       |
   35|       |double BufferSize; //LIZG 25/10/2002
   36|       |double GOPTargetBufferLevel;
   37|       |double CurrentBufferFullness; //LIZG 25/10/2002
   38|       |double TargetBufferLevel;//LIZG 25/10/2002
   39|       |double PreviousBit_Rate;//LIZG  25/10/2002
   40|       |double AWp;
   41|       |double AWb;
   42|       |int MyInitialQp;
   43|       |int PAverageQp;
   44|       |
   45|       |/*LIZG JVT50V2 distortion prediction model*/
   46|       |/*coefficients of the prediction model*/
   47|       |double PreviousPictureMAD;
   48|       |double MADPictureC1;
   49|       |double MADPictureC2;
   50|       |double PMADPictureC1;
   51|       |double PMADPictureC2;
   52|       |/* LIZG JVT50V2 picture layer MAD */
   53|       |Boolean PictureRejected[21];
   54|       |double PPictureMAD[21];
   55|       |double PictureMAD[21];
   56|       |double ReferenceMAD[21];
   57|       |
   58|       |/*quadratic rate-distortion model*/
   59|       |Boolean   m_rgRejected[21];
   60|       |double  m_rgQp[21];
   61|       |double m_rgRp[21];
   62|       |double m_X1;
   63|       |double m_X2;
   64|       |int m_Qc;
   65|       |double m_Qstep;
   66|       |int m_Qp;
   67|       |int Pm_Qp;
   68|       |int PreAveMBHeader;
   69|       |int CurAveMBHeader;
   70|       |int PPreHeader;
   71|       |int PreviousQp1;
   72|       |int PreviousQp2;
   73|       |int NumberofBFrames;
   74|       |/*basic unit layer rate control*/
   75|       |int TotalFrameQP;
   76|       |int NumberofBasicUnit;
   77|       |int PAveHeaderBits1;
   78|       |int PAveHeaderBits2;
   79|       |int PAveHeaderBits3;
   80|       |int PAveFrameQP;
   81|       |int TotalNumberofBasicUnit;
   82|       |int CodedBasicUnit;
   83|       |double MINVALUE;
   84|       |double CurrentFrameMAD;
   85|       |double CurrentBUMAD;
   86|       |double TotalBUMAD;
   87|       |double PreviousFrameMAD;
   88|       |int m_Hp;
   89|       |int m_windowSize;
   90|       |int MADm_windowSize;
   91|       |int DDquant;
   92|       |int MBPerRow;
   93|       |double AverageMADPreviousFrame;
   94|       |int TotalBasicUnitBits;
   95|       |int QPLastPFrame;
   96|       |int QPLastGOP;
   97|       |//int MADn_windowSize;
   98|       |//int n_windowSize;
   99|       |
  100|       |double Pm_rgQp[20];
  101|       |double Pm_rgRp[20];
  102|       |double Pm_X1;
  103|       |double Pm_X2;
  104|       |int Pm_Hp;
  105|       |/* adaptive field/frame coding*/
  106|       |int FieldQPBuffer;
  107|       |int FrameQPBuffer;
  108|       |int FrameAveHeaderBits;
  109|       |int FieldAveHeaderBits;
  110|       |double *BUPFMAD;
  111|       |double *BUCFMAD;
  112|       |double *FCBUCFMAD;
  113|       |double *FCBUPFMAD;
  114|       |
  115|       |Boolean GOPOverdue;
  116|       |
  117|       |
  118|       |//comput macroblock activity for rate control
  119|       |int diffy[16][16];
  120|       |int diffyy[16][16];
  121|       |int diffy8[16][16];//for P8X8 mode 
  122|       |
  123|       |#endif /* SPEC_CPU */
  124|       |
  125|       |const double THETA=1.3636;
  126|       |const int Switch=0;
  127|       |
  128|       |int Iprev_bits=0;
  129|       |int Pprev_bits=0;
  130|       |
  131|       |
  132|       |/* rate control variables */
  133|       |int Xp, Xb;
  134|       |static int R,T_field;
  135|       |static int Np, Nb, bits_topfield;
  136|       |long T,T1;
  137|       |//HRD consideration
  138|       |long UpperBound1, UpperBound2, LowerBound;
  139|       |double InitialDelayOffset;
  140|       |const double OMEGA=0.9;
  141|       |
  142|       |double Wp,Wb; 
  143|       |int TotalPFrame;
  144|       |int DuantQp; 
  145|       |int PDuantQp;
  146|       |FILE *BitRate;
  147|       |double DeltaP;
  148|       |
  149|       |
  150|       |/*! 
  151|       | *************************************************************************************
  152|       | * \brief
  153|       | *    Dynamically allocate memory needed for rate control
  154|       | *
  155|       | *************************************************************************************
  156|       |*/
  157|       |void rc_alloc()
  158|      0|{
  159|      0|  img->MADofMB = (double*) calloc (img->FrameSizeInMbs, sizeof (double));
  160|      0|  if (NULL==img->MADofMB)
  161|      0|  {
  162|      0|    no_mem_exit("rc_alloc: img->MADofMB");
  163|      0|  }
  164|       |  
  165|      0|  BUPFMAD = (double*) calloc ((img->FrameSizeInMbs/input->basicunit), sizeof (double));
  166|      0|  if (NULL==BUPFMAD)
  167|      0|  {
  168|      0|    no_mem_exit("rc_alloc: img->BUPFMAD");
  169|      0|  }
  170|       |
  171|      0|  BUCFMAD = (double*) calloc ((img->FrameSizeInMbs/input->basicunit), sizeof (double));
  172|      0|  if (NULL==BUCFMAD)
  173|      0|  {
  174|      0|    no_mem_exit("rc_alloc: img->BUCFMAD");
  175|      0|  }
  176|       |
  177|      0|  FCBUCFMAD = (double*) calloc ((img->FrameSizeInMbs/input->basicunit), sizeof (double));
  178|      0|  if (NULL==FCBUCFMAD)
  179|      0|  {
  180|      0|    no_mem_exit("rc_alloc: img->FCBUCFMAD");
  181|      0|  }
  182|       |
  183|      0|  FCBUPFMAD = (double*) calloc ((img->FrameSizeInMbs/input->basicunit), sizeof (double));
  184|      0|  if (NULL==FCBUPFMAD)
  185|      0|  {
  186|      0|    no_mem_exit("rc_alloc: img->FCBUPFMAD");
  187|      0|  }
  188|       |
  189|      0|}
  190|       |
  191|       |/*! 
  192|       | *************************************************************************************
  193|       | * \brief
  194|       | *    Free memory needed for rate control
  195|       | *
  196|       | *************************************************************************************
  197|       |*/
  198|       |void rc_free()
  199|      0|{
  200|      0|  if (NULL!=img->MADofMB)
  201|      0|  {
  202|      0|    free (img->MADofMB);
  203|      0|    img->MADofMB = NULL;
  204|      0|  }
  205|      0|  if (NULL!=BUPFMAD)
  206|      0|  {
  207|      0|    free (BUPFMAD);
  208|      0|    BUPFMAD = NULL;
  209|      0|  }
  210|      0|  if (NULL!=BUCFMAD)
  211|      0|  {
  212|      0|    free (BUCFMAD);
  213|      0|    BUCFMAD = NULL;
  214|      0|  }
  215|      0|  if (NULL!=FCBUCFMAD)
  216|      0|  {
  217|      0|    free (FCBUCFMAD);
  218|      0|    FCBUCFMAD = NULL;
  219|      0|  }
  220|      0|  if (NULL!=FCBUPFMAD)
  221|      0|  {
  222|      0|    free (FCBUPFMAD);
  223|      0|    FCBUPFMAD = NULL;
  224|      0|  }
  225|      0|}
  226|       |
  227|       |
  228|       |/*! 
  229|       | *************************************************************************************
  230|       | * \brief
  231|       | *    Initialize rate control parameters
  232|       | *
  233|       | *************************************************************************************
  234|       |*/
  235|       |void rc_init_seq()
  236|      0|{
  237|      0|  double L1,L2,L3,bpp;
  238|      0|  int qp;
  239|      0|  int i;
  240|       |  
  241|      0|  Xp=0;
  242|      0|  Xb=0;
  243|       |   
  244|      0|  bit_rate=input->bit_rate;
  245|      0|  frame_rate = (img->framerate *(float)(input->successive_Bframe + 1)) / (float) (input->jumpd + 1);
  246|      0|  PreviousBit_Rate=bit_rate;
  247|       |   
  248|       |  /*compute the total number of MBs in a frame*/
  249|       |  
  250|      0|  img->Frame_Total_Number_MB=img->height*img->width/256;
  251|      0|  if(input->basicunit>img->Frame_Total_Number_MB)
  252|      0|    input->basicunit=img->Frame_Total_Number_MB;
  253|      0|  if(input->basicunit<img->Frame_Total_Number_MB)
  254|      0|    TotalNumberofBasicUnit=img->Frame_Total_Number_MB/input->basicunit;
  255|       |  
  256|      0|  MINVALUE=4.0;
  257|       |  /*initialize the parameters of fluid flow traffic model*/
  258|       |  
  259|      0|  BufferSize=bit_rate*2.56;
  260|      0|  CurrentBufferFullness=0;
  261|      0|  GOPTargetBufferLevel=CurrentBufferFullness;
  262|       |  /*HRD consideration*/
  263|      0|  InitialDelayOffset=BufferSize*0.8;
  264|       |  
  265|       |  /*initialize the previous window size*/
  266|      0|  m_windowSize=0;
  267|      0|  MADm_windowSize=0;
  268|      0|  img->NumberofCodedBFrame=0;
  269|      0|  img->NumberofCodedPFrame=0;
  270|      0|  img->NumberofGOP=0;
  271|       |  /*remaining # of bits in GOP */
  272|      0|  R = 0;
  273|       |  /*control parameter */
  274|      0|  if(input->successive_Bframe>0)
  275|      0|  {
  276|      0|    GAMMAP=0.25;
  277|      0|    BETAP=0.9;
  278|      0|  }
  279|      0|  else
  280|      0|  {
  281|      0|    GAMMAP=0.5;
  282|      0|    BETAP=0.5;
  283|      0|  }
  284|       |  
  285|       |  /*quadratic rate-distortion model*/
  286|      0|  PPreHeader=0;
  287|       |  
  288|      0|  Pm_X1=bit_rate*1.0;
  289|      0|  Pm_X2=0.0;
  290|       |  /* linear prediction model for P picture*/
  291|      0|  PMADPictureC1=1.0;
  292|      0|  PMADPictureC2=0.0;
  293|       |  
  294|      0|  for(i=0;i<20;i++)
  295|      0|  {
  296|      0|    Pm_rgQp[i]=0;
  297|      0|    Pm_rgRp[i]=0.0;
  298|      0|    PPictureMAD[i]=0.0;
  299|      0|  }
  300|      0|  PPictureMAD[20]=0.0;
  301|       |   
  302|       |  //Define the largest variation of quantization parameters
  303|      0|  PDuantQp=2;
  304|       |  
  305|       |  /*basic unit layer rate control*/
  306|      0|  PAveHeaderBits1=0;
  307|      0|  PAveHeaderBits3=0;  
  308|      0|  if(TotalNumberofBasicUnit>=9)
  309|      0|    DDquant=1;
  310|      0|  else
  311|      0|    DDquant=2;
  312|       |  
  313|      0|  MBPerRow=img->width/16;
  314|       |  
  315|       |  /*adaptive field/frame coding*/
  316|      0|  img->FieldControl=0;
  317|       |  
  318|      0|  RC_MAX_QUANT = 51;  // clipping
  319|      0|  RC_MIN_QUANT = 0;//clipping
  320|       |  
  321|       |  /*compute the initial QP*/
  322|      0|  bpp = 1.0*bit_rate /(frame_rate*img->width*img->height);
  323|      0|  if (img->width == 176) 
  324|      0|  {
  325|      0|    L1 = 0.1;
  326|      0|    L2 = 0.3;
  327|      0|    L3 = 0.6;
  328|      0|  }else if (img->width == 352)
  329|      0|  {
  330|      0|    L1 = 0.2;
  331|      0|    L2 = 0.6;
  332|      0|    L3 = 1.2;
  333|      0|  }else 
  334|      0|  {
  335|      0|    L1 = 0.6;
  336|      0|    L2 = 1.4;
  337|      0|    L3 = 2.4;
  338|      0|  }
  339|       |  
  340|      0|  if (input->SeinitialQP==0)
  341|      0|  {
  342|      0|    if(bpp<= L1)
  343|      0|      qp = 35;
  344|      0|    else
  345|      0|      if(bpp<=L2)
  346|      0|        qp = 25;
  347|      0|      else
  348|      0|        if(bpp<=L3)
  349|      0|          qp  = 20;
  350|      0|        else
  351|      0|          qp =10;
  352|      0|    input->SeinitialQP = qp;
  353|      0|  }
  354|      0|}
  355|       |
  356|       |/*! 
  357|       | *************************************************************************************
  358|       | * \brief
  359|       | *    Initialize one GOP
  360|       | *
  361|       | *************************************************************************************
  362|       |*/
  363|       |void rc_init_GOP(int np, int nb)
  364|      0|{
  365|      0|  Boolean Overum=FALSE;
  366|      0|  int OverBits;
  367|      0|  int OverDuantQp;
  368|      0|  int AllocatedBits;
  369|      0|  int GOPDquant;
  370|       |
  371|       |  /* check if the last GOP over uses its budget. If yes, the initial QP of the I frame in 
  372|       |     the coming  GOP will be increased.*/
  373|       |
  374|      0|  if(R<0)
  375|      0|    Overum=TRUE;
  376|      0|  OverBits=-R;
  377|       |
  378|       |  /*initialize the lower bound and the upper bound for the target bits of each frame, HRD consideration*/
  379|      0|  LowerBound=(long)(R+bit_rate/frame_rate);
  380|      0|  UpperBound1=(long)(R+InitialDelayOffset);
  381|       |
  382|       | /*compute the total number of bits for the current GOP*/ 
  383|      0|  AllocatedBits = (int) floor((1 + np + nb) * bit_rate / frame_rate + 0.5);
  384|      0|  R +=AllocatedBits;
  385|      0|  Np  = np;
  386|      0|  Nb  = nb;
  387|       |
  388|      0|  OverDuantQp=(int)(8*OverBits/AllocatedBits+0.5);
  389|      0|  GOPOverdue=FALSE;
  390|       |  
  391|       |  /*field coding*/
  392|      0|  img->IFLAG=1;
  393|       |
  394|       |  /*Compute InitialQp for each GOP*/
  395|      0|  TotalPFrame=np;
  396|      0|  img->NumberofGOP++;
  397|      0|  if(img->NumberofGOP==1)
  398|      0|  {
  399|      0|    MyInitialQp=input->SeinitialQP;
  400|      0|    PreviousQp2=MyInitialQp-1; //recent change -0;
  401|      0|    QPLastGOP=MyInitialQp;
  402|       |  
  403|      0|  }
  404|      0|  else
  405|      0|  {
  406|       |    /*adaptive field/frame coding*/
  407|      0|    if((input->PicInterlace==ADAPTIVE_CODING)\
  408|      0|      ||(input->MbInterlace))
  409|      0|    {
  410|      0|      if (img->FieldFrame == 1)
  411|      0|      {
  412|      0|        img->TotalQpforPPicture += FrameQPBuffer;
  413|      0|        QPLastPFrame = FrameQPBuffer;
  414|      0|      }
  415|      0|      else
  416|      0|      {
  417|      0|        img->TotalQpforPPicture += FieldQPBuffer;
  418|      0|        QPLastPFrame = FieldQPBuffer;
  419|      0|      }
  420|       |      
  421|      0|    }
  422|       |    /*compute the average QP of P frames in the previous GOP*/
  423|      0|    PAverageQp=(int)(1.0*img->TotalQpforPPicture/img->NumberofPPicture+0.5);
  424|       |
  425|      0|    GOPDquant=(int)(0.5+1.0*(np+nb+1)/15);
  426|      0|    if(GOPDquant>2)
  427|      0|        GOPDquant=2;
  428|       |
  429|      0|    PAverageQp-=GOPDquant;
  430|       |
  431|      0|    if (PAverageQp > (QPLastPFrame - 2))
  432|      0|      PAverageQp--;
  433|      0|    PAverageQp = MAX(QPLastGOP-2,  PAverageQp);
  434|      0|    PAverageQp = MIN(QPLastGOP+2, PAverageQp);
  435|      0|    PAverageQp = MIN(RC_MAX_QUANT, PAverageQp);
  436|      0|    PAverageQp = MAX(RC_MIN_QUANT, PAverageQp);
  437|       |  
  438|       |
  439|      0|    MyInitialQp=PAverageQp;
  440|      0|    QPLastGOP = MyInitialQp;
  441|      0|    Pm_Qp=PAverageQp;
  442|      0|    PAveFrameQP=PAverageQp;
  443|      0|    PreviousQp1=PreviousQp2;
  444|      0|    PreviousQp2=MyInitialQp-1;  
  445|      0|  }
  446|       |
  447|      0|  img->TotalQpforPPicture=0;
  448|      0|  img->NumberofPPicture=0;
  449|      0|  NumberofBFrames=0; 
  450|      0|}
  451|       |
  452|       |
  453|       |/*! 
  454|       | *************************************************************************************
  455|       | * \brief
  456|       | *    Initialize one picture
  457|       | *
  458|       | *************************************************************************************
  459|       |*/
  460|       |void rc_init_pict(int fieldpic,int topfield,int targetcomputation)
  461|      0|{
  462|      0|  int i;
  463|       |
  464|       |  /* compute the total number of basic units in a frame */
  465|      0|  if(input->MbInterlace)
  466|      0|    TotalNumberofBasicUnit=img->Frame_Total_Number_MB/img->BasicUnit;
  467|      0|  img->NumberofCodedMacroBlocks=0;
  468|       |
  469|       |  /* Normally, the bandwidth for the VBR case is estimated by 
  470|       |     a congestion control algorithm. A bandwidth curve can be predefined if we only want to 
  471|       |     test the proposed algorithm */
  472|      0|  if(input->channel_type==1)
  473|      0|  {
  474|      0|    if(img->NumberofCodedPFrame==58)
  475|      0|      bit_rate *=1.5;
  476|      0|    else if(img->NumberofCodedPFrame==59)
  477|      0|      PreviousBit_Rate=bit_rate;
  478|      0|  }
  479|       |
  480|       |  /* predefine a target buffer level for each frame */
  481|      0|  if((fieldpic||topfield)&&targetcomputation)
  482|      0|  {
  483|      0|    switch (img->type)
  484|      0|    {
  485|      0|      case P_SLICE:
  486|       |      /* Since the available bandwidth may vary at any time, the total number of 
  487|       |         bits is updated picture by picture*/
  488|      0|        if(PreviousBit_Rate!=bit_rate)
  489|      0|          R +=(int) floor((bit_rate-PreviousBit_Rate)*(Np+Nb)/frame_rate+0.5);
  490|       |              
  491|       |        /* predefine the  target buffer level for each picture.
  492|       |           frame layer rate control */
  493|      0|        if(img->BasicUnit==img->Frame_Total_Number_MB)
  494|      0|        {
  495|      0|          if(img->NumberofPPicture==1)
  496|      0|          {
  497|      0|            TargetBufferLevel=CurrentBufferFullness;
  498|      0|            DeltaP=(CurrentBufferFullness-GOPTargetBufferLevel)/(TotalPFrame-1);
  499|      0|            TargetBufferLevel -=DeltaP;
  500|      0|          }
  501|      0|          else if(img->NumberofPPicture>1)
  502|      0|            TargetBufferLevel -=DeltaP;
  503|      0|        }
  504|       |        /* basic unit layer rate control */
  505|      0|        else
  506|      0|        {
  507|      0|          if(img->NumberofCodedPFrame>0)
  508|      0|          {
  509|       |            /* adaptive frame/filed coding */
  510|      0|            if(((input->PicInterlace==ADAPTIVE_CODING)||(input->MbInterlace))\
  511|      0|              &&(img->FieldControl==1))
  512|      0|            {
  513|      0|              for(i=0;i<TotalNumberofBasicUnit;i++)
  514|      0|                FCBUPFMAD[i]=FCBUCFMAD[i];
  515|      0|            }
  516|      0|            else
  517|      0|            {
  518|      0|              for(i=0;i<TotalNumberofBasicUnit;i++)
  519|      0|                BUPFMAD[i]=BUCFMAD[i];
  520|      0|            }     
  521|      0|          }
  522|       |
  523|      0|          if(img->NumberofGOP==1)
  524|      0|          {
  525|      0|            if(img->NumberofPPicture==1)
  526|      0|            {
  527|      0|              TargetBufferLevel=CurrentBufferFullness;
  528|      0|              DeltaP=(CurrentBufferFullness-GOPTargetBufferLevel)/(TotalPFrame-1);
  529|      0|              TargetBufferLevel -=DeltaP;
  530|      0|            }
  531|      0|            else if(img->NumberofPPicture>1)
  532|      0|              TargetBufferLevel -=DeltaP;
  533|      0|          }
  534|      0|          else if(img->NumberofGOP>1)
  535|      0|          {
  536|      0|            if(img->NumberofPPicture==0)
  537|      0|            {
  538|      0|              TargetBufferLevel=CurrentBufferFullness;
  539|      0|              DeltaP=(CurrentBufferFullness-GOPTargetBufferLevel)/TotalPFrame;
  540|      0|              TargetBufferLevel -=DeltaP;
  541|      0|            }
  542|      0|            else if(img->NumberofPPicture>0)
  543|      0|              TargetBufferLevel -=DeltaP;
  544|      0|          }
  545|      0|        }
  546|       |
  547|      0|        if(img->NumberofCodedPFrame==1)
  548|      0|          AWp=Wp;
  549|      0|        if((img->NumberofCodedPFrame<8)&&(img->NumberofCodedPFrame>1))
  550|      0|            AWp=Wp*(img->NumberofCodedPFrame-1)/img->NumberofCodedPFrame+\
  551|      0|              AWp/img->NumberofCodedPFrame;
  552|      0|          else if(img->NumberofCodedPFrame>1)
  553|      0|            AWp=Wp/8+7*AWp/8;
  554|       |          
  555|       |        // compute the average complexity of B frames
  556|      0|        if(input->successive_Bframe>0)
  557|      0|        {
  558|       |          // compute the target buffer level
  559|      0|          TargetBufferLevel +=(AWp*(input->successive_Bframe+1)*bit_rate\
  560|      0|            /(frame_rate*(AWp+AWb*input->successive_Bframe))-bit_rate/frame_rate);
  561|      0|        }
  562|       |        
  563|      0|        break;
  564|       |
  565|      0|         case B_SLICE:
  566|       |         /* update the total number of bits if the bandwidth is changed*/
  567|      0|           if(PreviousBit_Rate!=bit_rate)
  568|      0|             R +=(int) floor((bit_rate-PreviousBit_Rate)*(Np+Nb)/frame_rate+0.5);
  569|      0|            if((img->NumberofCodedPFrame==1)&&(img->NumberofCodedBFrame==1))
  570|      0|          {
  571|      0|            AWp=Wp;
  572|      0|            AWb=Wb;
  573|      0|          }
  574|      0|          else if(img->NumberofCodedBFrame>1)
  575|      0|          {
  576|       |            //compute the average weight
  577|      0|            if(img->NumberofCodedBFrame<8)
  578|      0|              AWb=Wb*(img->NumberofCodedBFrame-1)/img->NumberofCodedBFrame+\
  579|      0|                AWb/img->NumberofCodedBFrame;
  580|      0|            else
  581|      0|              AWb=Wb/8+7*AWb/8;
  582|      0|          }
  583|       |
  584|      0|            break;
  585|      0|    }
  586|       |     /* Compute the target bit for each frame */
  587|      0|    if(img->type==P_SLICE)
  588|      0|    {
  589|       |      /* frame layer rate control */
  590|      0|      if(img->BasicUnit==img->Frame_Total_Number_MB)
  591|      0|      {
  592|      0|        if(img->NumberofCodedPFrame>0)
  593|      0|        {
  594|      0|          T = (long) floor(Wp*R/(Np*Wp+Nb*Wb) + 0.5);
  595|       |                
  596|      0|          T1 = (long) floor(bit_rate/frame_rate-GAMMAP*(CurrentBufferFullness-TargetBufferLevel)+0.5);
  597|      0|          T1=MAX(0,T1);
  598|      0|          T = (long)(floor(BETAP*T+(1.0-BETAP)*T1+0.5));
  599|      0|        }
  600|      0|       }
  601|       |      /* basic unit layer rate control */
  602|      0|      else
  603|      0|      {
  604|      0|        if((img->NumberofGOP==1)&&(img->NumberofCodedPFrame>0))
  605|      0|        {
  606|      0|          T = (int) floor(Wp*R/(Np*Wp+Nb*Wb) + 0.5);
  607|      0|          T1 = (int) floor(bit_rate/frame_rate-GAMMAP*(CurrentBufferFullness-TargetBufferLevel)+0.5);
  608|      0|          T1=MAX(0,T1);
  609|      0|          T = (int)(floor(BETAP*T+(1.0-BETAP)*T1+0.5));
  610|      0|        }
  611|      0|        else if(img->NumberofGOP>1)
  612|      0|        {
  613|      0|          T = (long) floor(Wp*R/(Np*Wp+Nb*Wb) + 0.5);
  614|      0|          T1 = (long) floor(bit_rate/frame_rate-GAMMAP*(CurrentBufferFullness-TargetBufferLevel)+0.5);
  615|      0|          T1 = MAX(0,T1);
  616|      0|          T = (long)(floor(BETAP*T+(1.0-BETAP)*T1+0.5));
  617|      0|        }
  618|      0|      }
  619|       |
  620|       |      /* reserve some bits for smoothing */
  621|       |
  622|      0|      T=(long)((1.0-0.0*input->successive_Bframe)*T);
  623|       |      /* HRD consideration */
  624|      0|      T = MAX(T, (long) LowerBound);
  625|      0|        T = MIN(T, (long) UpperBound2);
  626|       |
  627|      0|      if((topfield)||(fieldpic&&((input->PicInterlace==ADAPTIVE_CODING)\
  628|      0|        ||(input->MbInterlace))))
  629|      0|        T_field=T;
  630|      0|    }
  631|      0|  }
  632|       |
  633|      0|  if(fieldpic||topfield)
  634|      0|  {
  635|       |    /* frame layer rate control */
  636|      0|    img->NumberofHeaderBits=0;
  637|      0|    img->NumberofTextureBits=0;
  638|       |
  639|       |    /* basic unit layer rate control */
  640|      0|    if(img->BasicUnit<img->Frame_Total_Number_MB)
  641|      0|    {
  642|      0|      TotalFrameQP=0;
  643|      0|      img->NumberofBasicUnitHeaderBits=0;
  644|      0|      img->NumberofBasicUnitTextureBits=0;
  645|      0|      img->TotalMADBasicUnit=0;
  646|      0|      if(img->FieldControl==0)
  647|      0|        NumberofBasicUnit=TotalNumberofBasicUnit;
  648|      0|      else
  649|      0|        NumberofBasicUnit=TotalNumberofBasicUnit/2;
  650|      0|    }
  651|      0|  }
  652|       |    
  653|      0|  if((img->type==P_SLICE)&&(img->BasicUnit<img->Frame_Total_Number_MB)\
  654|      0|    &&(img->FieldControl==1))
  655|      0|  {
  656|       |  /* top filed at basic unit layer rate control */
  657|      0|    if(topfield)
  658|      0|    {
  659|      0|      bits_topfield=0;
  660|      0|      T=(long)(T_field*0.6);
  661|      0|    }
  662|       |  /* bottom filed at basic unit layer rate control */
  663|      0|    else
  664|      0|    {
  665|      0|      T=T_field-bits_topfield;
  666|      0|      img->NumberofBasicUnitHeaderBits=0;
  667|      0|      img->NumberofBasicUnitTextureBits=0;
  668|      0|      img->TotalMADBasicUnit=0;
  669|      0|      NumberofBasicUnit=TotalNumberofBasicUnit/2;
  670|      0|    }
  671|      0|  }
  672|      0|}
  673|       |
  674|       |
  675|       |/*! 
  676|       | *************************************************************************************
  677|       | * \brief
  678|       | *    calculate MAD for the current macroblock 
  679|       | *
  680|       | * \return
  681|       | *    calculated MAD
  682|       | *
  683|       | *************************************************************************************
  684|       |*/
  685|       |double calc_MAD()
  686|      0|{
  687|      0|  int k,l;
  688|      0|    int s = 0;
  689|      0|  double MAD;
  690|       |
  691|      0|  for (k = 0; k < 16; k++)
  692|      0|    for (l = 0; l < 16; l++)
  693|      0|      s+= abs(diffy[k][l]);
  694|       |  
  695|      0|  MAD=s*1.0/256;
  696|      0|  return MAD;
  697|      0|}
  698|       |
  699|       |
  700|       |/*! 
  701|       | *************************************************************************************
  702|       | * \brief
  703|       | *    update one picture after frame/field encoding
  704|       | *
  705|       | * \param nbits
  706|       | *    number of bits used for picture
  707|       | *
  708|       | *************************************************************************************
  709|       |*/
  710|       |void rc_update_pict(int nbits)
  711|      0|{
  712|      0|  R-= nbits; /* remaining # of bits in GOP */
  713|      0|  CurrentBufferFullness += nbits - bit_rate/frame_rate;
  714|       |
  715|       |  /*update the lower bound and the upper bound for the target bits of each frame, HRD consideration*/
  716|      0|  LowerBound  +=(long)(bit_rate/frame_rate-nbits);
  717|      0|  UpperBound1 +=(long)(bit_rate/frame_rate-nbits);
  718|      0|  UpperBound2 = (long)(OMEGA*UpperBound1);
  719|       |  
  720|      0|  return;
  721|      0|}
  722|       |
  723|       |
  724|       |/*! 
  725|       | *************************************************************************************
  726|       | * \brief
  727|       | *    update after frame encoding
  728|       | *
  729|       | * \param nbits
  730|       | *    number of bits used for frame
  731|       | *
  732|       | *************************************************************************************
  733|       |*/
  734|       |void rc_update_pict_frame(int nbits)
  735|      0|{
  736|       |
  737|       |  /* update the complexity weight of I, P, B frame */
  738|      0|  int Avem_Qc;
  739|      0|  int X=0;
  740|       |    
  741|       |  /* frame layer rate control */
  742|      0|  if(img->BasicUnit==img->Frame_Total_Number_MB)
  743|      0|    X = (int) floor(nbits*m_Qc+ 0.5);
  744|       |  /* basic unit layer rate control */
  745|      0|  else
  746|      0|  {
  747|      0|    if(img->type==P_SLICE)
  748|      0|    {
  749|      0|      if(((img->IFLAG==0)&&(img->FieldControl==1))\
  750|      0|        ||(img->FieldControl==0))
  751|      0|      {
  752|      0|        Avem_Qc=TotalFrameQP/TotalNumberofBasicUnit;
  753|      0|        X=(int)floor(nbits*Avem_Qc+0.5);
  754|      0|      }
  755|      0|    }
  756|      0|    else if(img->type==B_SLICE)
  757|      0|      X = (int) floor(nbits*m_Qc+ 0.5);
  758|      0|  }
  759|       |
  760|       |
  761|      0|  switch (img->type)
  762|      0|  {
  763|      0|  case P_SLICE:
  764|       |    /* field coding */
  765|      0|    if(((img->IFLAG==0)&&(img->FieldControl==1))\
  766|      0|      ||(img->FieldControl==0))
  767|      0|    {
  768|      0|      Xp = X;
  769|      0|      Np--;
  770|      0|      Wp=Xp;
  771|      0|      Pm_Hp=img->NumberofHeaderBits;
  772|      0|      img->NumberofCodedPFrame++;
  773|      0|      img->NumberofPPicture++;
  774|      0|    }
  775|      0|    else if((img->IFLAG!=0)&&(img->FieldControl==1))
  776|      0|      img->IFLAG=0;
  777|      0|    break;
  778|      0|  case B_SLICE:
  779|      0|    Xb = X;
  780|      0|    Nb--;
  781|      0|    Wb=Xb/THETA; 
  782|       |    
  783|      0|    img->NumberofCodedBFrame++;
  784|      0|    NumberofBFrames++;
  785|       |    
  786|      0|    break;
  787|      0|  }
  788|      0|}
  789|       |
  790|       |/*! 
  791|       | *************************************************************************************
  792|       | * \brief
  793|       | *    coded bits for top field
  794|       | *
  795|       | * \param nbits
  796|       | *    number of bits used for top field
  797|       | *
  798|       | *************************************************************************************
  799|       |*/
  800|       |void setbitscount(int nbits)
  801|      0|{
  802|      0|  bits_topfield = nbits;
  803|      0|}
  804|       |
  805|       |
  806|       |/*! 
  807|       | *************************************************************************************
  808|       | * \brief
  809|       | *    compute a  quantization parameter for each frame
  810|       | *
  811|       | *************************************************************************************
  812|       |*/
  813|       |int updateQuantizationParameter(int topfield)
  814|      0|{
  815|      0|  double dtmp;
  816|      0|  int m_Bits;
  817|      0|  int BFrameNumber;
  818|      0|  int StepSize;
  819|      0|  int PAverageQP;
  820|      0|  int SumofBasicUnit;
  821|      0|  int i;
  822|       |  
  823|       |  /* frame layer rate control */
  824|      0|  if(img->BasicUnit==img->Frame_Total_Number_MB)
  825|      0|  {
  826|       |    /* fixed quantization parameter is used to coded I frame, the first P frame and the first B frame
  827|       |    the quantization parameter is adjusted according the available channel bandwidth and 
  828|       |    the type of vide */  
  829|       |    /*top field*/
  830|      0|    if((topfield)||(img->FieldControl==0))
  831|      0|    {
  832|      0|      if(img->type==I_SLICE)
  833|      0|      {
  834|      0|        m_Qc=MyInitialQp;
  835|      0|        return m_Qc;
  836|      0|      }
  837|      0|      else if(img->type==B_SLICE)
  838|      0|      {
  839|      0|        if(input->successive_Bframe==1)
  840|      0|        {
  841|      0|            if((input->PicInterlace==ADAPTIVE_CODING)\
  842|      0|              ||(input->MbInterlace))
  843|      0|            {
  844|      0|              if(img->FieldControl==0)
  845|      0|              {                   
  846|       |                /*previous choice is frame coding*/
  847|      0|                if(img->FieldFrame==1)
  848|      0|                {
  849|      0|                  PreviousQp1=PreviousQp2;
  850|      0|                  PreviousQp2=FrameQPBuffer;
  851|      0|                }           
  852|       |                /*previous choice is field coding*/
  853|      0|                else
  854|      0|                {
  855|      0|                  PreviousQp1=PreviousQp2;
  856|      0|                  PreviousQp2=FieldQPBuffer;
  857|      0|                }
  858|      0|              }
  859|      0|            }
  860|       |
  861|      0|          if(PreviousQp1==PreviousQp2)
  862|      0|            m_Qc=PreviousQp1+2;
  863|      0|          else
  864|      0|            m_Qc=(PreviousQp1+PreviousQp2)/2+1;
  865|      0|          m_Qc = MIN(m_Qc, RC_MAX_QUANT); // clipping
  866|      0|          m_Qc = MAX(RC_MIN_QUANT, m_Qc);//clipping
  867|      0|        }
  868|      0|        else
  869|      0|        {
  870|      0|          BFrameNumber=(NumberofBFrames+1)%input->successive_Bframe;
  871|      0|          if(BFrameNumber==0)
  872|      0|            BFrameNumber=input->successive_Bframe;
  873|       |          
  874|       |          /*adaptive field/frame coding*/
  875|      0|          if(BFrameNumber==1)
  876|      0|          {
  877|      0|            if((input->PicInterlace==ADAPTIVE_CODING)\
  878|      0|              ||(input->MbInterlace))
  879|      0|            {
  880|      0|              if(img->FieldControl==0)
  881|      0|              {
  882|       |                /*previous choice is frame coding*/
  883|      0|                if(img->FieldFrame==1)
  884|      0|                {
  885|      0|                  PreviousQp1=PreviousQp2;
  886|      0|                  PreviousQp2=FrameQPBuffer;
  887|      0|                }
  888|       |                /*previous choice is field coding*/
  889|      0|                else
  890|      0|                {
  891|      0|                  PreviousQp1=PreviousQp2;
  892|      0|                  PreviousQp2=FieldQPBuffer;
  893|      0|                }
  894|      0|              }
  895|      0|            }
  896|      0|          }
  897|       |          
  898|      0|          if((PreviousQp2-PreviousQp1)<=(-2*input->successive_Bframe-3))
  899|      0|            StepSize=-3;
  900|      0|          else  if((PreviousQp2-PreviousQp1)==(-2*input->successive_Bframe-2))
  901|      0|            StepSize=-2;
  902|      0|          else if((PreviousQp2-PreviousQp1)==(-2*input->successive_Bframe-1))
  903|      0|            StepSize=-1;
  904|      0|          else if((PreviousQp2-PreviousQp1)==(-2*input->successive_Bframe))
  905|      0|            StepSize=0;
  906|      0|          else if((PreviousQp2-PreviousQp1)==(-2*input->successive_Bframe+1))
  907|      0|            StepSize=1;
  908|      0|          else
  909|      0|            StepSize=2;
  910|       |          
  911|      0|          m_Qc=PreviousQp1+StepSize;
  912|      0|          m_Qc +=MIN(2*(BFrameNumber-1),MAX(-2*(BFrameNumber-1), \
  913|      0|            (BFrameNumber-1)*(PreviousQp2-PreviousQp1)/(input->successive_Bframe-1)));
  914|      0|          m_Qc = MIN(m_Qc, RC_MAX_QUANT); // clipping
  915|      0|          m_Qc = MAX(RC_MIN_QUANT, m_Qc);//clipping
  916|      0|        }
  917|      0|        return m_Qc;
  918|      0|      }
  919|      0|      else if((img->type==P_SLICE)&&(img->NumberofPPicture==0))
  920|      0|      {
  921|      0|        m_Qc=MyInitialQp;
  922|       |        
  923|      0|        if(img->FieldControl==0)
  924|      0|        {
  925|      0|          if(active_sps->frame_mbs_only_flag)
  926|      0|          {
  927|      0|            img->TotalQpforPPicture +=m_Qc;
  928|      0|            PreviousQp1=PreviousQp2;
  929|      0|            PreviousQp2=m_Qc;
  930|      0|            Pm_Qp=m_Qc;
  931|      0|          }
  932|       |          /*adaptive field/frame coding*/
  933|      0|          else
  934|      0|            FrameQPBuffer=m_Qc;
  935|      0|        }
  936|       |        
  937|      0|        return m_Qc;  
  938|      0|      }
  939|      0|      else
  940|      0|      {
  941|       |        /*adaptive field/frame coding*/
  942|      0|        if(((input->PicInterlace==ADAPTIVE_CODING)\
  943|      0|          ||(input->MbInterlace))\
  944|      0|          &&(img->FieldControl==0))
  945|      0|        {
  946|       |          /*previous choice is frame coding*/
  947|      0|          if(img->FieldFrame==1)
  948|      0|          {
  949|      0|            img->TotalQpforPPicture +=FrameQPBuffer;
  950|      0|            Pm_Qp=FrameQPBuffer;
  951|      0|          }
  952|       |          /*previous choice is field coding*/
  953|      0|          else
  954|      0|          {
  955|      0|            img->TotalQpforPPicture +=FieldQPBuffer;
  956|      0|            Pm_Qp=FieldQPBuffer;
  957|      0|          }
  958|      0|        }
  959|       |        
  960|      0|        m_X1=Pm_X1;
  961|      0|        m_X2=Pm_X2;
  962|      0|        m_Hp=PPreHeader;
  963|      0|        m_Qp=Pm_Qp;
  964|      0|        DuantQp=PDuantQp;
  965|      0|        MADPictureC1=PMADPictureC1;
  966|      0|        MADPictureC2=PMADPictureC2;
  967|      0|        PreviousPictureMAD=PPictureMAD[0];
  968|       |        
  969|       |        /* predict the MAD of current picture*/
  970|      0|        CurrentFrameMAD=MADPictureC1*PreviousPictureMAD+MADPictureC2;
  971|       |        
  972|       |        /*compute the number of bits for the texture*/      
  973|       |        
  974|      0|        if(T<0)
  975|      0|        {
  976|      0|          m_Qc=m_Qp+DuantQp;
  977|      0|          m_Qc = MIN(m_Qc, RC_MAX_QUANT); // clipping
  978|      0|        }
  979|      0|        else
  980|      0|        {
  981|      0|          m_Bits =T-m_Hp;
  982|      0|          m_Bits = MAX(m_Bits, (int)(bit_rate/(MINVALUE*frame_rate)));
  983|      0|          dtmp = CurrentFrameMAD * m_X1 * CurrentFrameMAD * m_X1 \
  984|      0|            + 4 * m_X2 * CurrentFrameMAD * m_Bits;
  985|      0|          if ((m_X2 == 0.0) || (dtmp < 0) || ((sqrt (dtmp) - m_X1 * CurrentFrameMAD) <= 0.0)) // fall back 1st order mode
  986|      0|            m_Qstep = (float) (m_X1 * CurrentFrameMAD / (double) m_Bits);
  987|      0|          else // 2nd order mode
  988|      0|            m_Qstep = (float) ((2 * m_X2 * CurrentFrameMAD) / (sqrt (dtmp) - m_X1 * CurrentFrameMAD));
  989|       |          
  990|      0|          m_Qc=Qstep2QP(m_Qstep);
  991|       |          
  992|      0|          m_Qc = MIN(m_Qp+DuantQp,  m_Qc);  // control variation
  993|      0|          m_Qc = MIN(m_Qc, RC_MAX_QUANT); // clipping
  994|      0|          m_Qc = MAX(m_Qp-DuantQp, m_Qc); // control variation
  995|      0|          m_Qc = MAX(RC_MIN_QUANT, m_Qc);
  996|      0|        }
  997|       |        
  998|      0|        if(img->FieldControl==0)
  999|      0|        {
 1000|       |          /*frame coding*/
 1001|      0|          if(active_sps->frame_mbs_only_flag)
 1002|      0|          {
 1003|      0|            img->TotalQpforPPicture +=m_Qc;
 1004|      0|            PreviousQp1=PreviousQp2;
 1005|      0|            PreviousQp2=m_Qc;
 1006|      0|            Pm_Qp=m_Qc;
 1007|      0|          }
 1008|       |          /*adaptive field/frame coding*/
 1009|      0|          else
 1010|      0|            FrameQPBuffer=m_Qc;
 1011|      0|        }
 1012|       |        
 1013|      0|        return m_Qc;
 1014|      0|      }
 1015|      0|   }
 1016|       |   /*bottom field*/
 1017|      0|   else
 1018|      0|   {
 1019|      0|     if((img->type==P_SLICE)&&(img->IFLAG==0))
 1020|      0|     {
 1021|       |       /*field coding*/
 1022|      0|       if(input->PicInterlace==FIELD_CODING)
 1023|      0|       {
 1024|      0|         img->TotalQpforPPicture +=m_Qc;
 1025|      0|         PreviousQp1=PreviousQp2+1; 
 1026|      0|         PreviousQp2=m_Qc;//+0 Recent change 13/1/2003
 1027|      0|         Pm_Qp=m_Qc;
 1028|      0|       }
 1029|       |       /*adaptive field/frame coding*/
 1030|      0|       else
 1031|      0|         FieldQPBuffer=m_Qc;     
 1032|      0|     }
 1033|      0|     return m_Qc;
 1034|      0|   }
 1035|      0|  }
 1036|       |  /*basic unit layer rate control*/
 1037|      0|  else
 1038|      0|  {
 1039|       |    /*top filed of I frame*/
 1040|      0|    if(img->type==I_SLICE)
 1041|      0|    {
 1042|      0|      m_Qc=MyInitialQp;
 1043|      0|      return m_Qc;
 1044|      0|    }
 1045|       |    /*bottom field of I frame*/
 1046|      0|    else if((img->type==P_SLICE)&&(img->IFLAG==1)&&(img->FieldControl==1))
 1047|      0|    {
 1048|      0|      m_Qc=MyInitialQp;
 1049|      0|      return m_Qc;
 1050|      0|    }
 1051|      0|    else if(img->type==B_SLICE)
 1052|      0|    {
 1053|       |      /*top filed of B frame*/
 1054|      0|      if((topfield)||(img->FieldControl==0))
 1055|      0|      {
 1056|      0|        if(input->successive_Bframe==1)
 1057|      0|        {
 1058|       |         /*adaptive field/frame coding*/
 1059|      0|          if((input->PicInterlace==ADAPTIVE_CODING)\
 1060|      0|              ||(input->MbInterlace))
 1061|      0|            {
 1062|      0|              if(img->FieldControl==0)
 1063|      0|              {             
 1064|       |                /*previous choice is frame coding*/
 1065|      0|                if(img->FieldFrame==1)
 1066|      0|                {
 1067|      0|                  PreviousQp1=PreviousQp2;
 1068|      0|                  PreviousQp2=FrameQPBuffer;
 1069|      0|                }
 1070|       |                /*previous choice is field coding*/
 1071|      0|                else
 1072|      0|                {
 1073|      0|                  PreviousQp1=PreviousQp2;
 1074|      0|                  PreviousQp2=FieldQPBuffer;
 1075|      0|                }
 1076|      0|              }
 1077|      0|            }
 1078|       |
 1079|      0|          if(PreviousQp1==PreviousQp2)
 1080|      0|            m_Qc=PreviousQp1+2;
 1081|      0|          else
 1082|      0|            m_Qc=(PreviousQp1+PreviousQp2)/2+1;
 1083|      0|          m_Qc = MIN(m_Qc, RC_MAX_QUANT); // clipping
 1084|      0|          m_Qc = MAX(RC_MIN_QUANT, m_Qc);//clipping
 1085|      0|        }
 1086|      0|        else
 1087|      0|        {
 1088|      0|          BFrameNumber=(NumberofBFrames+1)%input->successive_Bframe;
 1089|      0|          if(BFrameNumber==0)
 1090|      0|            BFrameNumber=input->successive_Bframe;
 1091|       |          
 1092|       |          /*adaptive field/frame coding*/
 1093|      0|          if(BFrameNumber==1)
 1094|      0|          {
 1095|      0|            if((input->PicInterlace==ADAPTIVE_CODING)\
 1096|      0|              ||(input->MbInterlace))
 1097|      0|            {
 1098|      0|              if(img->FieldControl==0)
 1099|      0|              {
 1100|       |                /*previous choice is frame coding*/
 1101|      0|                if(img->FieldFrame==1)
 1102|      0|                {
 1103|      0|                  PreviousQp1=PreviousQp2;
 1104|      0|                  PreviousQp2=FrameQPBuffer;
 1105|      0|                }
 1106|       |                /*previous choice is field coding*/
 1107|      0|                else
 1108|      0|                {
 1109|      0|                  PreviousQp1=PreviousQp2;
 1110|      0|                  PreviousQp2=FieldQPBuffer;
 1111|      0|                }
 1112|      0|              } 
 1113|      0|            }
 1114|      0|          }
 1115|       |          
 1116|      0|          if((PreviousQp2-PreviousQp1)<=(-2*input->successive_Bframe-3))
 1117|      0|            StepSize=-3;
 1118|      0|          else  if((PreviousQp2-PreviousQp1)==(-2*input->successive_Bframe-2))
 1119|      0|            StepSize=-2;
 1120|      0|          else if((PreviousQp2-PreviousQp1)==(-2*input->successive_Bframe-1))
 1121|      0|            StepSize=-1;
 1122|      0|          else if((PreviousQp2-PreviousQp1)==(-2*input->successive_Bframe))
 1123|      0|            StepSize=0;//0
 1124|      0|          else if((PreviousQp2-PreviousQp1)==(-2*input->successive_Bframe+1))
 1125|      0|            StepSize=1;//1
 1126|      0|          else
 1127|      0|            StepSize=2;//2
 1128|      0|          m_Qc=PreviousQp1+StepSize;
 1129|      0|          m_Qc +=MIN(2*(BFrameNumber-1),MAX(-2*(BFrameNumber-1), \
 1130|      0|            (BFrameNumber-1)*(PreviousQp2-PreviousQp1)/(input->successive_Bframe-1)));
 1131|      0|          m_Qc = MIN(m_Qc, RC_MAX_QUANT); // clipping
 1132|      0|          m_Qc = MAX(RC_MIN_QUANT, m_Qc);//clipping
 1133|      0|        }
 1134|      0|        return m_Qc;
 1135|      0|      }
 1136|       |      /*bottom field of B frame*/
 1137|      0|      else
 1138|      0|        return m_Qc;
 1139|      0|    }
 1140|      0|    else if(img->type==P_SLICE)
 1141|      0|    {
 1142|      0|      if((img->NumberofGOP==1)&&(img->NumberofPPicture==0))
 1143|      0|      {
 1144|      0|        if((img->FieldControl==0)||((img->FieldControl==1)\
 1145|      0|          &&(img->IFLAG==0)))
 1146|      0|        {
 1147|       |          /*top field of the first P frame*/
 1148|      0|          m_Qc=MyInitialQp;
 1149|      0|          img->NumberofBasicUnitHeaderBits=0;
 1150|      0|          img->NumberofBasicUnitTextureBits=0;
 1151|      0|          NumberofBasicUnit--;
 1152|       |          /*bottom field of the first P frame*/
 1153|      0|          if((!topfield)&&(NumberofBasicUnit==0))
 1154|      0|          {
 1155|       |            /*frame coding or field coding*/
 1156|      0|            if((active_sps->frame_mbs_only_flag)||(input->PicInterlace==FIELD_CODING))
 1157|      0|            {
 1158|      0|              img->TotalQpforPPicture +=m_Qc;
 1159|      0|              PreviousQp1=PreviousQp2;
 1160|      0|              PreviousQp2=m_Qc;
 1161|      0|              PAveFrameQP=m_Qc;
 1162|      0|              PAveHeaderBits3=PAveHeaderBits2;
 1163|      0|            }
 1164|       |            /*adaptive frame/field coding*/
 1165|      0|            else if((input->PicInterlace==ADAPTIVE_CODING)\
 1166|      0|              ||(input->MbInterlace))
 1167|      0|            {
 1168|      0|              if(img->FieldControl==0)
 1169|      0|              {
 1170|      0|                FrameQPBuffer=m_Qc;
 1171|      0|                FrameAveHeaderBits=PAveHeaderBits2;
 1172|      0|              }
 1173|      0|              else
 1174|      0|              {
 1175|      0|                FieldQPBuffer=m_Qc;
 1176|      0|                FieldAveHeaderBits=PAveHeaderBits2;
 1177|      0|              }
 1178|      0|            }
 1179|      0|          }
 1180|      0|          Pm_Qp=m_Qc;
 1181|      0|          TotalFrameQP +=m_Qc;
 1182|      0|          return m_Qc;
 1183|      0|        }
 1184|      0|      }
 1185|      0|      else
 1186|      0|      {
 1187|      0|        m_X1=Pm_X1;
 1188|      0|        m_X2=Pm_X2;
 1189|      0|        m_Hp=PPreHeader;
 1190|      0|        m_Qp=Pm_Qp;
 1191|      0|        DuantQp=PDuantQp;
 1192|      0|        MADPictureC1=PMADPictureC1;
 1193|      0|        MADPictureC2=PMADPictureC2;
 1194|       |
 1195|      0|        if(img->FieldControl==0)
 1196|      0|          SumofBasicUnit=TotalNumberofBasicUnit;
 1197|      0|        else
 1198|      0|          SumofBasicUnit=TotalNumberofBasicUnit/2;
 1199|       |
 1200|       |        /*the average QP of the previous frame is used to coded the first basic unit of the current frame or field*/
 1201|      0|        if(NumberofBasicUnit==SumofBasicUnit)
 1202|      0|        {
 1203|       |
 1204|       |          /*adaptive field/frame coding*/
 1205|      0|          if(((input->PicInterlace==ADAPTIVE_CODING)\
 1206|      0|            ||(input->MbInterlace))\
 1207|      0|            &&(img->FieldControl==0))
 1208|      0|          {
 1209|       |            /*previous choice is frame coding*/
 1210|      0|            if(img->FieldFrame==1)
 1211|      0|            {
 1212|      0|              if(img->NumberofPPicture>0)
 1213|      0|                img->TotalQpforPPicture +=FrameQPBuffer;
 1214|      0|              PAveFrameQP=FrameQPBuffer;
 1215|      0|              PAveHeaderBits3=FrameAveHeaderBits;
 1216|      0|            }       
 1217|       |            /*previous choice is field coding*/
 1218|      0|            else
 1219|      0|            {
 1220|      0|              if(img->NumberofPPicture>0)
 1221|      0|                img->TotalQpforPPicture +=FieldQPBuffer;
 1222|      0|              PAveFrameQP=FieldQPBuffer;
 1223|      0|              PAveHeaderBits3=FieldAveHeaderBits;
 1224|      0|            }
 1225|      0|          }
 1226|       |
 1227|      0|          if(T<=0)
 1228|      0|          {
 1229|      0|            m_Qc=PAveFrameQP+2;
 1230|      0|            if(m_Qc>RC_MAX_QUANT)
 1231|      0|              m_Qc=RC_MAX_QUANT;
 1232|      0|            if(topfield||(img->FieldControl==0))
 1233|      0|              GOPOverdue=TRUE;
 1234|      0|          }
 1235|      0|          else
 1236|      0|          {
 1237|      0|            m_Qc=PAveFrameQP; 
 1238|      0|          }
 1239|      0|          TotalFrameQP +=m_Qc;
 1240|      0|          NumberofBasicUnit--;
 1241|      0|          Pm_Qp=PAveFrameQP;
 1242|      0|          return m_Qc;
 1243|      0|        }else
 1244|      0|        {
 1245|       |          /*compute the number of remaining bits*/
 1246|      0|          TotalBasicUnitBits=img->NumberofBasicUnitHeaderBits+img->NumberofBasicUnitTextureBits;
 1247|      0|          T -=TotalBasicUnitBits;
 1248|      0|          img->NumberofBasicUnitHeaderBits=0;
 1249|      0|          img->NumberofBasicUnitTextureBits=0;
 1250|      0|          if(T<0)
 1251|      0|          {
 1252|      0|            if(GOPOverdue==TRUE)
 1253|      0|              m_Qc=m_Qp+2;
 1254|      0|            else 
 1255|      0|              m_Qc=m_Qp+DDquant;//2 
 1256|      0|            m_Qc = MIN(m_Qc, RC_MAX_QUANT);  // clipping
 1257|      0|            if(input->basicunit>=MBPerRow)
 1258|      0|              m_Qc = MIN(m_Qc, PAveFrameQP+6); 
 1259|      0|            else
 1260|      0|              m_Qc = MIN(m_Qc, PAveFrameQP+3);
 1261|       |            
 1262|      0|            TotalFrameQP +=m_Qc;
 1263|      0|            NumberofBasicUnit--;
 1264|      0|            if(NumberofBasicUnit==0)
 1265|      0|            {
 1266|      0|              if((!topfield)||(img->FieldControl==0))
 1267|      0|              {
 1268|       |                /*frame coding or field coding*/
 1269|      0|                if((active_sps->frame_mbs_only_flag)||(input->PicInterlace==FIELD_CODING))
 1270|      0|                {
 1271|      0|                  PAverageQP=(int)(1.0*TotalFrameQP/TotalNumberofBasicUnit+0.5);
 1272|      0|                  if (img->NumberofPPicture == (input->intra_period - 2))
 1273|      0|                    QPLastPFrame = PAverageQP;
 1274|       |                  
 1275|      0|                  img->TotalQpforPPicture +=PAverageQP;
 1276|      0|                  if(GOPOverdue==TRUE)
 1277|      0|                  {
 1278|      0|                    PreviousQp1=PreviousQp2+1;
 1279|      0|                    PreviousQp2=PAverageQP;                   
 1280|      0|                  }
 1281|      0|                  else
 1282|      0|                  {
 1283|      0|                    if((img->NumberofPPicture==0)&&(img->NumberofGOP>1))
 1284|      0|                    {
 1285|      0|                      PreviousQp1=PreviousQp2;
 1286|      0|                      PreviousQp2=PAverageQP;
 1287|      0|                    }
 1288|      0|                    else if(img->NumberofPPicture>0)
 1289|      0|                    {
 1290|      0|                      PreviousQp1=PreviousQp2+1;
 1291|      0|                      PreviousQp2=PAverageQP;
 1292|      0|                    }
 1293|      0|                  }
 1294|      0|                  PAveFrameQP=PAverageQP;
 1295|      0|                  PAveHeaderBits3=PAveHeaderBits2;
 1296|      0|                }
 1297|       |                /*adaptive field/frame coding*/
 1298|      0|                else if((input->PicInterlace==ADAPTIVE_CODING)\
 1299|      0|                  ||(input->MbInterlace))
 1300|      0|                {
 1301|      0|                  if(img->FieldControl==0)
 1302|      0|                  {
 1303|      0|                    PAverageQP=(int)(1.0*TotalFrameQP/TotalNumberofBasicUnit+0.5);
 1304|      0|                    FrameQPBuffer=PAverageQP;
 1305|      0|                    FrameAveHeaderBits=PAveHeaderBits2;
 1306|      0|                  }
 1307|      0|                  else
 1308|      0|                  {
 1309|      0|                    PAverageQP=(int)(1.0*TotalFrameQP/TotalNumberofBasicUnit+0.5);
 1310|      0|                    FieldQPBuffer=PAverageQP;
 1311|      0|                    FieldAveHeaderBits=PAveHeaderBits2;
 1312|      0|                  }
 1313|      0|                }
 1314|      0|              }
 1315|      0|            }
 1316|      0|            if(GOPOverdue==TRUE)
 1317|      0|              Pm_Qp=PAveFrameQP;
 1318|      0|            else
 1319|      0|              Pm_Qp=m_Qc;
 1320|      0|            return m_Qc;
 1321|      0|          }
 1322|      0|          else
 1323|      0|          {
 1324|       |            /*predict the MAD of current picture*/
 1325|      0|            if(((input->PicInterlace==ADAPTIVE_CODING)||(input->MbInterlace))\
 1326|      0|              &&(img->FieldControl==1))
 1327|      0|            {
 1328|      0|              CurrentFrameMAD=MADPictureC1*FCBUPFMAD[TotalNumberofBasicUnit-NumberofBasicUnit]+MADPictureC2;
 1329|      0|              TotalBUMAD=0;
 1330|      0|              for(i=TotalNumberofBasicUnit-1; i>=(TotalNumberofBasicUnit-NumberofBasicUnit);i--)
 1331|      0|              {
 1332|      0|                CurrentBUMAD=MADPictureC1*FCBUPFMAD[i]+MADPictureC2;
 1333|      0|                TotalBUMAD +=CurrentBUMAD*CurrentBUMAD;
 1334|      0|              }
 1335|      0|            }
 1336|      0|            else
 1337|      0|            {
 1338|      0|              CurrentFrameMAD=MADPictureC1*BUPFMAD[TotalNumberofBasicUnit-NumberofBasicUnit]+MADPictureC2;
 1339|      0|              TotalBUMAD=0;
 1340|      0|              for(i=TotalNumberofBasicUnit-1; i>=(TotalNumberofBasicUnit-NumberofBasicUnit);i--)
 1341|      0|              {
 1342|      0|                CurrentBUMAD=MADPictureC1*BUPFMAD[i]+MADPictureC2;
 1343|      0|                TotalBUMAD +=CurrentBUMAD*CurrentBUMAD;
 1344|      0|              }
 1345|      0|            }
 1346|       |            
 1347|       |            /*compute the total number of bits for the current basic unit*/
 1348|      0|            m_Bits =(int)(T*CurrentFrameMAD*CurrentFrameMAD/TotalBUMAD);
 1349|       |            /*compute the number of texture bits*/
 1350|      0|            m_Bits -=PAveHeaderBits2;
 1351|       |            
 1352|      0|            m_Bits=MAX(m_Bits,(int)(bit_rate/(MINVALUE*frame_rate*TotalNumberofBasicUnit)));
 1353|       |            
 1354|      0|            dtmp = CurrentFrameMAD * m_X1 * CurrentFrameMAD * m_X1 \
 1355|      0|              + 4 * m_X2 * CurrentFrameMAD * m_Bits;
 1356|      0|            if ((m_X2 == 0.0) || (dtmp < 0) || ((sqrt (dtmp) - m_X1 * CurrentFrameMAD) <= 0.0))  // fall back 1st order mode
 1357|      0|              m_Qstep = (float)(m_X1 * CurrentFrameMAD / (double) m_Bits);
 1358|      0|            else // 2nd order mode
 1359|      0|              m_Qstep = (float) ((2 * m_X2 * CurrentFrameMAD) / (sqrt (dtmp) - m_X1 * CurrentFrameMAD));
 1360|       |            
 1361|      0|            m_Qc=Qstep2QP(m_Qstep);
 1362|      0|            m_Qc = MIN(m_Qp+DDquant,  m_Qc); // control variation
 1363|       |            
 1364|      0|            if(input->basicunit>=MBPerRow)
 1365|      0|              m_Qc = MIN(PAveFrameQP+6, m_Qc);
 1366|      0|            else
 1367|      0|              m_Qc = MIN(PAveFrameQP+3, m_Qc);
 1368|       |            
 1369|      0|            m_Qc = MIN(m_Qc, RC_MAX_QUANT);  // clipping
 1370|      0|            m_Qc = MAX(m_Qp-DDquant, m_Qc);  // control variation 
 1371|      0|            if(input->basicunit>=MBPerRow)
 1372|      0|              m_Qc = MAX(PAveFrameQP-6, m_Qc);
 1373|      0|            else
 1374|      0|              m_Qc = MAX(PAveFrameQP-3, m_Qc);
 1375|       |            
 1376|      0|            m_Qc = MAX(RC_MIN_QUANT, m_Qc);
 1377|      0|            TotalFrameQP +=m_Qc;
 1378|      0|            Pm_Qp=m_Qc;
 1379|      0|            NumberofBasicUnit--;
 1380|      0|            if((NumberofBasicUnit==0)&&(img->type==P_SLICE))
 1381|      0|            {
 1382|      0|              if((!topfield)||(img->FieldControl==0))
 1383|      0|              {
 1384|       |                /*frame coding or field coding*/
 1385|      0|                if((active_sps->frame_mbs_only_flag)||(input->PicInterlace==FIELD_CODING))
 1386|      0|                {
 1387|      0|                  PAverageQP=(int)(1.0*TotalFrameQP/TotalNumberofBasicUnit+0.5);
 1388|      0|                  if (img->NumberofPPicture == (input->intra_period - 2))
 1389|      0|                    QPLastPFrame = PAverageQP;
 1390|       |
 1391|      0|                  img->TotalQpforPPicture +=PAverageQP;
 1392|      0|                  PreviousQp1=PreviousQp2;
 1393|      0|                  PreviousQp2=PAverageQP; 
 1394|      0|                  PAveFrameQP=PAverageQP;
 1395|      0|                  PAveHeaderBits3=PAveHeaderBits2;
 1396|      0|                }
 1397|      0|                else if((input->PicInterlace==ADAPTIVE_CODING)\
 1398|      0|                  ||(input->MbInterlace))
 1399|      0|                {
 1400|      0|                  if(img->FieldControl==0)
 1401|      0|                  {
 1402|      0|                    PAverageQP=(int)(1.0*TotalFrameQP/TotalNumberofBasicUnit+0.5);
 1403|      0|                    FrameQPBuffer=PAverageQP;
 1404|      0|                    FrameAveHeaderBits=PAveHeaderBits2;
 1405|      0|                  }
 1406|      0|                  else
 1407|      0|                  {
 1408|      0|                    PAverageQP=(int)(1.0*TotalFrameQP/TotalNumberofBasicUnit+0.5);
 1409|      0|                    FieldQPBuffer=PAverageQP;
 1410|      0|                    FieldAveHeaderBits=PAveHeaderBits2;
 1411|      0|                  }
 1412|      0|                }
 1413|      0|              }
 1414|      0|            }
 1415|      0|            return m_Qc;
 1416|      0|          }
 1417|      0|        }
 1418|      0|      }
 1419|      0|    } 
 1420|      0|  }
 1421|      0|  return m_Qc;
 1422|      0|}
 1423|       |
 1424|       |
 1425|       |/*! 
 1426|       | *************************************************************************************
 1427|       | * \brief
 1428|       | *    update the parameters of quadratic R-D model
 1429|       | *
 1430|       | *************************************************************************************
 1431|       |*/
 1432|       |void updateRCModel ()
 1433|      0|{
 1434|       |
 1435|      0|  int n_windowSize;
 1436|      0|  int i;
 1437|      0|  double error[20], std = 0.0, threshold;
 1438|      0|  int m_Nc;
 1439|      0|  Boolean MADModelFlag = FALSE;
 1440|       |
 1441|      0|  if(img->type==P_SLICE)
 1442|      0|  {
 1443|       |    /*frame layer rate control*/
 1444|      0|    if(img->BasicUnit==img->Frame_Total_Number_MB)
 1445|      0|    {
 1446|      0|      CurrentFrameMAD=ComputeFrameMAD();
 1447|      0|      m_Nc=img->NumberofCodedPFrame;
 1448|      0|    }
 1449|       |    /*basic unit layer rate control*/
 1450|      0|    else
 1451|      0|    {
 1452|       |      /*compute the MAD of the current basic unit*/
 1453|      0|      if((input->MbInterlace)&&(img->FieldControl==0))
 1454|      0|        CurrentFrameMAD=img->TotalMADBasicUnit/img->BasicUnit/2;
 1455|      0|      else
 1456|      0|        CurrentFrameMAD=img->TotalMADBasicUnit/img->BasicUnit;
 1457|       |      
 1458|       |      
 1459|      0|      img->TotalMADBasicUnit=0;
 1460|       |              
 1461|       |      /* compute the average number of header bits*/
 1462|       |      
 1463|      0|      CodedBasicUnit=TotalNumberofBasicUnit-NumberofBasicUnit;
 1464|      0|      if(CodedBasicUnit>0)
 1465|      0|      {
 1466|      0|        PAveHeaderBits1=(int)(1.0*(PAveHeaderBits1*(CodedBasicUnit-1)+\
 1467|      0|          +img->NumberofBasicUnitHeaderBits)/CodedBasicUnit+0.5);
 1468|      0|        if(PAveHeaderBits3==0)
 1469|      0|          PAveHeaderBits2=PAveHeaderBits1;
 1470|      0|        else
 1471|      0|          PAveHeaderBits2=(int)(1.0*(PAveHeaderBits1*CodedBasicUnit+\
 1472|      0|          +PAveHeaderBits3*NumberofBasicUnit)/TotalNumberofBasicUnit+0.5);
 1473|      0|      }
 1474|       |      /*update the record of MADs for reference*/
 1475|      0|      if(((input->PicInterlace==ADAPTIVE_CODING)||(input->MbInterlace))\
 1476|      0|        &&(img->FieldControl==1))
 1477|      0|        FCBUCFMAD[TotalNumberofBasicUnit-1-NumberofBasicUnit]=CurrentFrameMAD;
 1478|      0|      else
 1479|      0|        BUCFMAD[TotalNumberofBasicUnit-1-NumberofBasicUnit]=CurrentFrameMAD;
 1480|       |      
 1481|      0|      if(NumberofBasicUnit!=0)
 1482|      0|        m_Nc=img->NumberofCodedPFrame*TotalNumberofBasicUnit+CodedBasicUnit;
 1483|      0|      else
 1484|      0|        m_Nc=(img->NumberofCodedPFrame-1)*TotalNumberofBasicUnit+CodedBasicUnit;
 1485|       |      
 1486|      0|    }
 1487|       |    
 1488|      0|    if(m_Nc>1)
 1489|      0|      MADModelFlag=TRUE;
 1490|       |    
 1491|      0|    PPreHeader=img->NumberofHeaderBits;
 1492|      0|    for (i = 19; i > 0; i--) 
 1493|      0|    {// update the history
 1494|      0|      Pm_rgQp[i] = Pm_rgQp[i - 1];
 1495|      0|      m_rgQp[i]=Pm_rgQp[i];
 1496|      0|      Pm_rgRp[i] = Pm_rgRp[i - 1];
 1497|      0|      m_rgRp[i]=Pm_rgRp[i];
 1498|      0|    }
 1499|      0|    Pm_rgQp[0] = QP2Qstep(m_Qc); //*1.0/CurrentFrameMAD;
 1500|       |    /*frame layer rate control*/
 1501|      0|    if(img->BasicUnit==img->Frame_Total_Number_MB)
 1502|      0|      Pm_rgRp[0] = img->NumberofTextureBits*1.0/CurrentFrameMAD;
 1503|       |    /*basic unit layer rate control*/
 1504|      0|    else
 1505|      0|      Pm_rgRp[0]=img->NumberofBasicUnitTextureBits*1.0/CurrentFrameMAD;
 1506|       |    
 1507|      0|    m_rgQp[0]=Pm_rgQp[0];
 1508|      0|    m_rgRp[0]=Pm_rgRp[0];
 1509|      0|    m_X1=Pm_X1;
 1510|      0|    m_X2=Pm_X2;
 1511|       |    
 1512|       |    
 1513|       |    /*compute the size of window*/
 1514|      0|    n_windowSize = (CurrentFrameMAD>PreviousFrameMAD)?(int)(PreviousFrameMAD/CurrentFrameMAD*20)\
 1515|      0|                   :(int)(CurrentFrameMAD/PreviousFrameMAD*20);
 1516|      0|    n_windowSize=MAX(n_windowSize, 1);
 1517|      0|    n_windowSize=MIN(n_windowSize,m_Nc);
 1518|      0|    n_windowSize=MIN(n_windowSize,m_windowSize+1);
 1519|      0|    n_windowSize=MIN(n_windowSize,20);
 1520|       |    
 1521|       |    /*update the previous window size*/
 1522|      0|    m_windowSize=n_windowSize;
 1523|       |    
 1524|      0|    for (i = 0; i < 20; i++) 
 1525|      0|    {
 1526|      0|      m_rgRejected[i] = FALSE;
 1527|      0|    }
 1528|       |    
 1529|       |    // initial RD model estimator
 1530|      0|    RCModelEstimator (n_windowSize);
 1531|       |    
 1532|      0|    n_windowSize = m_windowSize;
 1533|       |    // remove outlier 
 1534|       |    
 1535|      0|    for (i = 0; i < (int) n_windowSize; i++) 
 1536|      0|    {
 1537|      0|      error[i] = m_X1 / m_rgQp[i] + m_X2 / (m_rgQp[i] * m_rgQp[i]) - m_rgRp[i];
 1538|      0|      std += error[i] * error[i]; 
 1539|      0|    }
 1540|      0|    threshold = (n_windowSize == 2) ? 0 : sqrt (std / n_windowSize);
 1541|      0|    for (i = 0; i < (int) n_windowSize; i++) 
 1542|      0|    {
 1543|      0|      if (fabs(error[i]) > threshold)
 1544|      0|        m_rgRejected[i] = TRUE;
 1545|      0|    }
 1546|       |    // always include the last data point
 1547|      0|    m_rgRejected[0] = FALSE;
 1548|       |    
 1549|       |    // second RD model estimator
 1550|      0|    RCModelEstimator (n_windowSize);
 1551|       |    
 1552|      0|    if(MADModelFlag)
 1553|      0|      updateMADModel();
 1554|      0|    else if(img->type==P_SLICE)
 1555|      0|      PPictureMAD[0]=CurrentFrameMAD;
 1556|      0|  } 
 1557|      0|}
 1558|       |
 1559|       |/*! 
 1560|       | *************************************************************************************
 1561|       | * \brief
 1562|       | *    Model Estimator
 1563|       | *
 1564|       | *************************************************************************************
 1565|       |*/
 1566|       |void RCModelEstimator (int n_windowSize)
 1567|      0|{
 1568|      0|  int n_realSize = n_windowSize;
 1569|      0|  int i;
 1570|      0|  double oneSampleQ;
 1571|      0|  double a00 = 0.0, a01 = 0.0, a10 = 0.0, a11 = 0.0, b0 = 0.0, b1 = 0.0;
 1572|      0|  double MatrixValue;
 1573|      0|  Boolean estimateX2 = FALSE;
 1574|       |
 1575|      0|  for (i = 0; i < n_windowSize; i++) 
 1576|      0|  {// find the number of samples which are not rejected
 1577|      0|    if (m_rgRejected[i])
 1578|      0|      n_realSize--;
 1579|      0|  }
 1580|       |
 1581|       |  // default RD model estimation results
 1582|       |
 1583|      0|  m_X1 = m_X2 = 0.0;
 1584|       |
 1585|      0|  for (i = 0; i < n_windowSize; i++)  
 1586|      0|  {
 1587|      0|    if (!m_rgRejected[i])
 1588|      0|      oneSampleQ = m_rgQp[i];
 1589|      0|  }
 1590|      0|  for (i = 0; i < n_windowSize; i++)  
 1591|      0|  {// if all non-rejected Q are the same, take 1st order model
 1592|      0|    if ((m_rgQp[i] != oneSampleQ) && !m_rgRejected[i])
 1593|      0|      estimateX2 = TRUE;
 1594|      0|    if (!m_rgRejected[i])
 1595|      0|      m_X1 += (m_rgQp[i] * m_rgRp[i]) / n_realSize;
 1596|      0|  }
 1597|       |
 1598|       |  // take 2nd order model to estimate X1 and X2
 1599|      0|  if ((n_realSize >= 1) && estimateX2) 
 1600|      0|  {
 1601|      0|    for (i = 0; i < n_windowSize; i++) 
 1602|      0|    {
 1603|      0|      if (!m_rgRejected[i]) 
 1604|      0|      {
 1605|      0|        a00 = a00 + 1.0;
 1606|      0|        a01 += 1.0 / m_rgQp[i];
 1607|      0|        a10 = a01;
 1608|      0|        a11 += 1.0 / (m_rgQp[i] * m_rgQp[i]);
 1609|      0|        b0 += m_rgQp[i] * m_rgRp[i];
 1610|      0|        b1 += m_rgRp[i];
 1611|      0|      }
 1612|      0|    }
 1613|       |    // solve the equation of AX = B
 1614|      0|    MatrixValue=a00*a11-a01*a10;
 1615|      0|    if(fabs(MatrixValue)>0.000001)
 1616|      0|    {
 1617|      0|      m_X1=(b0*a11-b1*a01)/MatrixValue;
 1618|      0|      m_X2=(b1*a00-b0*a10)/MatrixValue;
 1619|      0|    }
 1620|      0|    else
 1621|      0|    {
 1622|      0|      m_X1=b0/a00;
 1623|      0|      m_X2=0.0;
 1624|      0|    }
 1625|       |    
 1626|      0|  }
 1627|      0|  if(img->type==P_SLICE)
 1628|      0|  {
 1629|      0|    Pm_X1=m_X1;
 1630|      0|    Pm_X2=m_X2;
 1631|      0|  }
 1632|      0|}
 1633|       |
 1634|       |
 1635|       |/*! 
 1636|       | *************************************************************************************
 1637|       | * \brief
 1638|       | *    Compute Frame MAD
 1639|       | *
 1640|       | *************************************************************************************
 1641|       |*/
 1642|       |double ComputeFrameMAD()
 1643|      0|{
 1644|      0|  double TotalMAD;
 1645|      0|  int i;
 1646|      0|  TotalMAD=0.0;
 1647|      0|  for(i=0;i<img->Frame_Total_Number_MB;i++)
 1648|      0|    TotalMAD +=img->MADofMB[i];
 1649|      0|  TotalMAD /=img->Frame_Total_Number_MB;
 1650|      0|  return TotalMAD;
 1651|      0|}
 1652|       |
 1653|       |
 1654|       |/*! 
 1655|       | *************************************************************************************
 1656|       | * \brief
 1657|       | *    update the parameters of linear prediction model
 1658|       | *
 1659|       | *************************************************************************************
 1660|       |*/
 1661|       |void updateMADModel ()
 1662|      0|{
 1663|       |  
 1664|      0|  int n_windowSize;
 1665|      0|  int i;
 1666|      0|  double error[20], std = 0.0, threshold;
 1667|      0|  int m_Nc;
 1668|       |  
 1669|      0|  if(img->NumberofCodedPFrame>0)
 1670|      0|  {
 1671|       |    //assert (img->type!=P_SLICE);
 1672|       |    
 1673|       |    /*frame layer rate control*/
 1674|      0|    if(img->BasicUnit==img->Frame_Total_Number_MB)
 1675|      0|      m_Nc=img->NumberofCodedPFrame;
 1676|       |    /*basic unit layer rate control*/
 1677|      0|    else
 1678|      0|      m_Nc=img->NumberofCodedPFrame*TotalNumberofBasicUnit+CodedBasicUnit;
 1679|       |    
 1680|      0|    for (i = 19; i > 0; i--) 
 1681|      0|    {// update the history
 1682|      0|      PPictureMAD[i] = PPictureMAD[i - 1];
 1683|      0|      PictureMAD[i]=PPictureMAD[i];
 1684|      0|      ReferenceMAD[i]= ReferenceMAD[i-1];
 1685|      0|    }
 1686|      0|    PPictureMAD[0] = CurrentFrameMAD;
 1687|      0|    PictureMAD[0]=PPictureMAD[0];
 1688|      0|    if(img->BasicUnit==img->Frame_Total_Number_MB)
 1689|      0|      ReferenceMAD[0]=PictureMAD[1];
 1690|      0|    else
 1691|      0|    {
 1692|      0|      if(((input->PicInterlace==ADAPTIVE_CODING)||(input->MbInterlace))\
 1693|      0|        &&(img->FieldControl==1))
 1694|      0|        ReferenceMAD[0]=FCBUPFMAD[TotalNumberofBasicUnit-1-NumberofBasicUnit];
 1695|      0|      else
 1696|      0|        ReferenceMAD[0]=BUPFMAD[TotalNumberofBasicUnit-1-NumberofBasicUnit];
 1697|      0|    }
 1698|      0|    MADPictureC1=PMADPictureC1;
 1699|      0|    MADPictureC2=PMADPictureC2;
 1700|       |    
 1701|       |    
 1702|       |    /*compute the size of window*/
 1703|       |    
 1704|      0|    n_windowSize = (CurrentFrameMAD>PreviousFrameMAD)?(int)(PreviousFrameMAD/CurrentFrameMAD*20)\
 1705|      0|      :(int)(CurrentFrameMAD/PreviousFrameMAD*20);
 1706|      0|    n_windowSize=MIN(n_windowSize,(m_Nc-1));
 1707|      0|    n_windowSize=MAX(n_windowSize, 1);
 1708|      0|    n_windowSize=MIN(n_windowSize,MADm_windowSize+1);
 1709|      0|    n_windowSize=MIN(20,n_windowSize);
 1710|       |    /*update the previous window size*/
 1711|      0|    MADm_windowSize=n_windowSize;
 1712|       |    
 1713|      0|    for (i = 0; i < 20; i++) 
 1714|      0|    {
 1715|      0|      PictureRejected[i] = FALSE;
 1716|      0|    }
 1717|       |    //update the MAD for the previous frame
 1718|      0|    if(img->type==P_SLICE)
 1719|      0|      PreviousFrameMAD=CurrentFrameMAD;
 1720|       |    
 1721|       |    // initial MAD model estimator
 1722|      0|    MADModelEstimator (n_windowSize);
 1723|       |    
 1724|       |    // remove outlier 
 1725|       |    
 1726|      0|    for (i = 0; i < (int) n_windowSize; i++) 
 1727|      0|    {
 1728|      0|      error[i] = MADPictureC1*ReferenceMAD[i]+MADPictureC2-PictureMAD[i];
 1729|      0|      std += error[i] * error[i]; 
 1730|      0|    }
 1731|      0|    threshold = (n_windowSize == 2) ? 0 : sqrt (std / n_windowSize);
 1732|      0|    for (i = 0; i < (int) n_windowSize; i++) 
 1733|      0|    {
 1734|      0|      if (fabs(error[i]) > threshold)
 1735|      0|        PictureRejected[i] = TRUE;
 1736|      0|    }
 1737|       |    // always include the last data point
 1738|      0|    PictureRejected[0] = FALSE;
 1739|       |    
 1740|       |    // second MAD model estimator
 1741|      0|    MADModelEstimator (n_windowSize);
 1742|      0|  }
 1743|      0|}
 1744|       |
 1745|       |
 1746|       |/*! 
 1747|       | *************************************************************************************
 1748|       | * \brief
 1749|       | *    MAD mode estimator
 1750|       | *
 1751|       | *************************************************************************************
 1752|       |*/
 1753|       |void MADModelEstimator (int n_windowSize)
 1754|      0|{
 1755|      0|  int n_realSize = n_windowSize;
 1756|      0|  int i;
 1757|      0|  double oneSampleQ;
 1758|      0|  double a00 = 0.0, a01 = 0.0, a10 = 0.0, a11 = 0.0, b0 = 0.0, b1 = 0.0;
 1759|      0|  double MatrixValue;
 1760|      0|  Boolean estimateX2 = FALSE;
 1761|       |  
 1762|      0|  for (i = 0; i < n_windowSize; i++) 
 1763|      0|  {// find the number of samples which are not rejected
 1764|      0|    if (PictureRejected[i])
 1765|      0|      n_realSize--;
 1766|      0|  }
 1767|       |  
 1768|       |  // default MAD model estimation results
 1769|       |  
 1770|      0|  MADPictureC1 = MADPictureC2 = 0.0;
 1771|       |  
 1772|      0|  for (i = 0; i < n_windowSize; i++)  
 1773|      0|  {
 1774|      0|    if (!PictureRejected[i])
 1775|      0|      oneSampleQ = PictureMAD[i];
 1776|      0|  }
 1777|       |
 1778|      0|  for (i = 0; i < n_windowSize; i++)  
 1779|      0|  {// if all non-rejected MAD are the same, take 1st order model
 1780|      0|    if ((PictureMAD[i] != oneSampleQ) && !PictureRejected[i])
 1781|      0|      estimateX2 = TRUE;
 1782|      0|    if (!PictureRejected[i])
 1783|      0|      MADPictureC1 += PictureMAD[i] / (ReferenceMAD[i]*n_realSize);
 1784|      0|  }
 1785|       |  
 1786|       |  // take 2nd order model to estimate X1 and X2
 1787|      0|  if ((n_realSize >= 1) && estimateX2) 
 1788|      0|  {
 1789|      0|    for (i = 0; i < n_windowSize; i++) 
 1790|      0|    {
 1791|      0|      if (!PictureRejected[i]) 
 1792|      0|      {
 1793|      0|        a00 = a00 + 1.0;
 1794|      0|        a01 += ReferenceMAD[i];
 1795|      0|        a10 = a01;
 1796|      0|        a11 += ReferenceMAD[i]*ReferenceMAD[i];
 1797|      0|        b0 += PictureMAD[i];
 1798|      0|        b1 += PictureMAD[i]*ReferenceMAD[i];
 1799|      0|      }
 1800|      0|    }
 1801|       |    // solve the equation of AX = B
 1802|      0|    MatrixValue=a00*a11-a01*a10;
 1803|      0|    if(fabs(MatrixValue)>0.000001)
 1804|      0|    {
 1805|      0|      MADPictureC2=(b0*a11-b1*a01)/MatrixValue;
 1806|      0|      MADPictureC1=(b1*a00-b0*a10)/MatrixValue;
 1807|      0|    }
 1808|      0|    else
 1809|      0|    {
 1810|      0|      MADPictureC1=b0/a01;
 1811|      0|      MADPictureC2=0.0;
 1812|      0|    }
 1813|       |    
 1814|      0|  }
 1815|      0|  if(img->type==P_SLICE)
 1816|      0|  {
 1817|      0|    PMADPictureC1=MADPictureC1;
 1818|      0|    PMADPictureC2=MADPictureC2;
 1819|      0|  }
 1820|      0|}
 1821|       |
 1822|       |
 1823|       |/*! 
 1824|       | *************************************************************************************
 1825|       | * \brief
 1826|       | *    map QP to Qstep
 1827|       | *
 1828|       | *************************************************************************************
 1829|       |*/
 1830|       |double QP2Qstep( int QP )
 1831|      0|{
 1832|      0|  int i; 
 1833|      0|  double Qstep;
 1834|      0|  static const double QP2QSTEP[6] = { 0.625, 0.6875, 0.8125, 0.875, 1.0, 1.125 };
 1835|       |  
 1836|      0|  Qstep = QP2QSTEP[QP % 6];
 1837|      0|  for( i=0; i<(QP/6); i++)
 1838|      0|    Qstep *= 2;
 1839|       |  
 1840|      0|  return Qstep;
 1841|      0|}
 1842|       |
 1843|       |
 1844|       |/*! 
 1845|       | *************************************************************************************
 1846|       | * \brief
 1847|       | *    map Qstep to QP
 1848|       | *
 1849|       | *************************************************************************************
 1850|       |*/
 1851|       |int Qstep2QP( double Qstep )
 1852|      0|{
 1853|      0|  int q_per = 0, q_rem = 0;
 1854|       |  
 1855|       |  //  assert( Qstep >= QP2Qstep(0) && Qstep <= QP2Qstep(51) );
 1856|      0|  if( Qstep < QP2Qstep(0))
 1857|      0|    return 0;
 1858|      0|  else if (Qstep > QP2Qstep(51) )
 1859|      0|    return 51;
 1860|       |  
 1861|      0|  while( Qstep > QP2Qstep(5) )
 1862|      0|  {
 1863|      0|    Qstep /= 2;
 1864|      0|    q_per += 1;
 1865|      0|  }
 1866|       |  
 1867|      0|  if (Qstep <= (0.625+0.6875)/2) 
 1868|      0|  {
 1869|      0|    Qstep = 0.625;
 1870|      0|    q_rem = 0;
 1871|      0|  }
 1872|      0|  else if (Qstep <= (0.6875+0.8125)/2)
 1873|      0|  {
 1874|      0|    Qstep = 0.6875;
 1875|      0|    q_rem = 1;
 1876|      0|  }
 1877|      0|  else if (Qstep <= (0.8125+0.875)/2)
 1878|      0|  {
 1879|      0|    Qstep = 0.8125;
 1880|      0|    q_rem = 2;
 1881|      0|  }
 1882|      0|  else if (Qstep <= (0.875+1.0)/2)
 1883|      0|  {
 1884|      0|    Qstep = 0.875;
 1885|      0|    q_rem = 3;
 1886|      0|  }
 1887|      0|  else if (Qstep <= (1.0+1.125)/2)
 1888|      0|  {
 1889|      0|    Qstep = 1.0;  
 1890|      0|    q_rem = 4;
 1891|      0|  }
 1892|      0|  else 
 1893|      0|  {
 1894|      0|    Qstep = 1.125;
 1895|      0|    q_rem = 5;
 1896|      0|  }
 1897|       |  
 1898|      0|  return (q_per * 6 + q_rem);
 1899|      0|}

/home/xzp/speccpu2006-v1.0.1/benchspec/CPU2006/464.h264ref/run/build_base_ql_riscv_llvm17.0000/ratectl.h:
    1|       |
    2|       |/*!
    3|       | ***************************************************************************
    4|       | * \file
    5|       | *    ratectl.h
    6|       | *
    7|       | * \author
    8|       | *    Zhengguo LI
    9|       | *
   10|       | * \date
   11|       | *    14 Jan 2003
   12|       | *
   13|       | * \brief
   14|       | *    Headerfile for rate control 
   15|       | **************************************************************************
   16|       | */
   17|       |
   18|       |#ifndef _RATE_CTL_H_
   19|       |#define _RATE_CTL_H_
   20|       |
   21|       |
   22|      0|#define MIN(a,b)  (((a)<(b)) ? (a) : (b))//LIZG 28/10/2002
   23|      0|#define MAX(a,b)  (((a)<(b)) ? (b) : (a))//LIZG 28/10/2002
   24|       |
   25|       |#if defined(SPEC_CPU)
   26|       |extern double bit_rate; 
   27|       |extern double frame_rate;
   28|       |extern double GAMMAP;//LIZG, JVT019r1
   29|       |extern double BETAP;//LIZG, JVT019r1
   30|       |
   31|       |extern int RC_MAX_QUANT;//LIZG 28/10/2002
   32|       |extern int RC_MIN_QUANT;//LIZG 28/10/2002
   33|       |
   34|       |extern double BufferSize; //LIZG 25/10/2002
   35|       |extern double GOPTargetBufferLevel;
   36|       |extern double CurrentBufferFullness; //LIZG 25/10/2002
   37|       |extern double TargetBufferLevel;//LIZG 25/10/2002
   38|       |extern double PreviousBit_Rate;//LIZG  25/10/2002
   39|       |extern double AWp;
   40|       |extern double AWb;
   41|       |extern int MyInitialQp;
   42|       |extern int PAverageQp;
   43|       |
   44|       |/*LIZG JVT50V2 distortion prediction model*/
   45|       |/*coefficients of the prediction model*/
   46|       |extern double PreviousPictureMAD;
   47|       |extern double MADPictureC1;
   48|       |extern double MADPictureC2;
   49|       |extern double PMADPictureC1;
   50|       |extern double PMADPictureC2;
   51|       |/* LIZG JVT50V2 picture layer MAD */
   52|       |extern Boolean PictureRejected[21];
   53|       |extern double PPictureMAD[21];
   54|       |extern double PictureMAD[21];
   55|       |extern double ReferenceMAD[21];
   56|       |
   57|       |/*quadratic rate-distortion model*/
   58|       |extern Boolean   m_rgRejected[21];
   59|       |extern double  m_rgQp[21];
   60|       |extern double m_rgRp[21];
   61|       |extern double m_X1;
   62|       |extern double m_X2;
   63|       |extern int m_Qc;
   64|       |extern double m_Qstep;
   65|       |extern int m_Qp;
   66|       |extern int Pm_Qp;
   67|       |extern int PreAveMBHeader;
   68|       |extern int CurAveMBHeader;
   69|       |extern int PPreHeader;
   70|       |extern int PreviousQp1;
   71|       |extern int PreviousQp2;
   72|       |extern int NumberofBFrames;
   73|       |/*basic unit layer rate control*/
   74|       |extern int TotalFrameQP;
   75|       |extern int NumberofBasicUnit;
   76|       |extern int PAveHeaderBits1;
   77|       |extern int PAveHeaderBits2;
   78|       |extern int PAveHeaderBits3;
   79|       |extern int PAveFrameQP;
   80|       |extern int TotalNumberofBasicUnit;
   81|       |extern int CodedBasicUnit;
   82|       |extern double MINVALUE;
   83|       |extern double CurrentFrameMAD;
   84|       |extern double CurrentBUMAD;
   85|       |extern double TotalBUMAD;
   86|       |extern double PreviousFrameMAD;
   87|       |extern int m_Hp;
   88|       |extern int m_windowSize;
   89|       |extern int MADm_windowSize;
   90|       |extern int DDquant;
   91|       |extern int MBPerRow;
   92|       |extern double AverageMADPreviousFrame;
   93|       |extern int TotalBasicUnitBits;
   94|       |extern int QPLastPFrame;
   95|       |extern int QPLastGOP;
   96|       |//int MADn_windowSize;
   97|       |//int n_windowSize;
   98|       |
   99|       |extern double Pm_rgQp[20];
  100|       |extern double Pm_rgRp[20];
  101|       |extern double Pm_X1;
  102|       |extern double Pm_X2;
  103|       |extern int Pm_Hp;
  104|       |/* adaptive field/frame coding*/
  105|       |extern int FieldQPBuffer;
  106|       |extern int FrameQPBuffer;
  107|       |extern int FrameAveHeaderBits;
  108|       |extern int FieldAveHeaderBits;
  109|       |extern double *BUPFMAD;
  110|       |extern double *BUCFMAD;
  111|       |extern double *FCBUCFMAD;
  112|       |extern double *FCBUPFMAD;
  113|       |
  114|       |extern Boolean GOPOverdue;
  115|       |
  116|       |
  117|       |//comput macroblock activity for rate control
  118|       |extern int diffy[16][16];
  119|       |extern int diffyy[16][16];
  120|       |extern int diffy8[16][16];//for P8X8 mode 
  121|       |
  122|       |#else /* SPEC_CPU */
  123|       |
  124|       |double bit_rate; 
  125|       |double frame_rate;
  126|       |double GAMMAP;//LIZG, JVT019r1
  127|       |double BETAP;//LIZG, JVT019r1
  128|       |
  129|       |int RC_MAX_QUANT;//LIZG 28/10/2002
  130|       |int RC_MIN_QUANT;//LIZG 28/10/2002
  131|       |
  132|       |double BufferSize; //LIZG 25/10/2002
  133|       |double GOPTargetBufferLevel;
  134|       |double CurrentBufferFullness; //LIZG 25/10/2002
  135|       |double TargetBufferLevel;//LIZG 25/10/2002
  136|       |double PreviousBit_Rate;//LIZG  25/10/2002
  137|       |double AWp;
  138|       |double AWb;
  139|       |int MyInitialQp;
  140|       |int PAverageQp;
  141|       |
  142|       |/*LIZG JVT50V2 distortion prediction model*/
  143|       |/*coefficients of the prediction model*/
  144|       |double PreviousPictureMAD;
  145|       |double MADPictureC1;
  146|       |double MADPictureC2;
  147|       |double PMADPictureC1;
  148|       |double PMADPictureC2;
  149|       |/* LIZG JVT50V2 picture layer MAD */
  150|       |Boolean PictureRejected[21];
  151|       |double PPictureMAD[21];
  152|       |double PictureMAD[21];
  153|       |double ReferenceMAD[21];
  154|       |
  155|       |/*quadratic rate-distortion model*/
  156|       |Boolean   m_rgRejected[21];
  157|       |double  m_rgQp[21];
  158|       |double m_rgRp[21];
  159|       |double m_X1;
  160|       |double m_X2;
  161|       |int m_Qc;
  162|       |double m_Qstep;
  163|       |int m_Qp;
  164|       |int Pm_Qp;
  165|       |int PreAveMBHeader;
  166|       |int CurAveMBHeader;
  167|       |int PPreHeader;
  168|       |int PreviousQp1;
  169|       |int PreviousQp2;
  170|       |int NumberofBFrames;
  171|       |/*basic unit layer rate control*/
  172|       |int TotalFrameQP;
  173|       |int NumberofBasicUnit;
  174|       |int PAveHeaderBits1;
  175|       |int PAveHeaderBits2;
  176|       |int PAveHeaderBits3;
  177|       |int PAveFrameQP;
  178|       |int TotalNumberofBasicUnit;
  179|       |int CodedBasicUnit;
  180|       |double MINVALUE;
  181|       |double CurrentFrameMAD;
  182|       |double CurrentBUMAD;
  183|       |double TotalBUMAD;
  184|       |double PreviousFrameMAD;
  185|       |int m_Hp;
  186|       |int m_windowSize;
  187|       |int MADm_windowSize;
  188|       |int DDquant;
  189|       |int MBPerRow;
  190|       |double AverageMADPreviousFrame;
  191|       |int TotalBasicUnitBits;
  192|       |int QPLastPFrame;
  193|       |int QPLastGOP;
  194|       |//int MADn_windowSize;
  195|       |//int n_windowSize;
  196|       |
  197|       |double Pm_rgQp[20];
  198|       |double Pm_rgRp[20];
  199|       |double Pm_X1;
  200|       |double Pm_X2;
  201|       |int Pm_Hp;
  202|       |/* adaptive field/frame coding*/
  203|       |int FieldQPBuffer;
  204|       |int FrameQPBuffer;
  205|       |int FrameAveHeaderBits;
  206|       |int FieldAveHeaderBits;
  207|       |double *BUPFMAD;
  208|       |double *BUCFMAD;
  209|       |double *FCBUCFMAD;
  210|       |double *FCBUPFMAD;
  211|       |
  212|       |Boolean GOPOverdue;
  213|       |
  214|       |
  215|       |//comput macroblock activity for rate control
  216|       |int diffy[16][16];
  217|       |int diffyy[16][16];
  218|       |int diffy8[16][16];//for P8X8 mode 
  219|       |
  220|       |#endif /* SPEC_CPU */
  221|       |
  222|       |extern int Iprev_bits;
  223|       |extern int Pprev_bits;
  224|       |
  225|       |void rc_alloc();
  226|       |void rc_free();
  227|       |
  228|       |void rc_init_seq();
  229|       |void rc_init_GOP(int np, int nb);
  230|       |void rc_update_pict_frame(int nbits);
  231|       |void rc_init_pict(int fieldpic,int topfield, int targetcomputation);
  232|       |void rc_update_pict(int nbits);
  233|       |void setbitscount(int nbits);
  234|       |
  235|       |int updateQuantizationParameter(int topfield);
  236|       |void updateRCModel ();
  237|       |void updateMADModel ();
  238|       |Boolean skipThisFrame ();
  239|       |void RCModelEstimator (int n_windowSize);
  240|       |void MADModelEstimator (int n_windowSize);
  241|       |double calc_MAD();
  242|       |double ComputeFrameMAD();
  243|       |int Qstep2QP( double Qstep );
  244|       |double QP2Qstep( int QP );
  245|       |
  246|       |#endif
  247|       |

/home/xzp/speccpu2006-v1.0.1/benchspec/CPU2006/464.h264ref/run/build_base_ql_riscv_llvm17.0000/rdopt.c:
    1|       |
    2|       |/*!
    3|       | ***************************************************************************
    4|       | * \file rdopt.c
    5|       | *
    6|       | * \brief
    7|       | *    Rate-Distortion optimized mode decision
    8|       | *
    9|       | * \author
   10|       | *    - Heiko Schwarz              <hschwarz@hhi.de>
   11|       | *    - Valeri George              <george@hhi.de>
   12|       | *    - Lowell Winger              <lwinger@lsil.com>
   13|       | *    - Alexis Michael Tourapis    <alexismt@ieee.org>
   14|       | * \date
   15|       | *    12. April 2001
   16|       | **************************************************************************
   17|       | */
   18|       |
   19|       |#include <stdlib.h>
   20|       |#include <math.h>
   21|       |#include <assert.h>
   22|       |#include <limits.h>
   23|       |
   24|       |#include "global.h"
   25|       |
   26|       |#include "rdopt_coding_state.h"
   27|       |#include "memalloc.h"
   28|       |#include "mb_access.h"
   29|       |#include "elements.h"
   30|       |#include "intrarefresh.h"
   31|       |#include "image.h"
   32|       |#include "transform8x8.h"
   33|       |#include "cabac.h"            // head file for rate control
   34|       |#include "vlc.h"
   35|       |#include "fast_me.h"
   36|       |#include "ratectl.h"            // head file for rate control
   37|       |
   38|       |#define KS_MV
   39|       |
   40|       |
   41|       |//Rate control
   42|       |
   43|       |int DELTA_QP,DELTA_QP2;
   44|       |#if !defined(SPEC_CPU)
   45|       |int QP,QP2;
   46|       |int diffy[16][16];
   47|       |#endif
   48|       |static int pred[16][16];
   49|       |
   50|       |extern       int  QP2QUANT  [40];
   51|       |
   52|       |//==== MODULE PARAMETERS ====
   53|       |int   best_mode;
   54|       |imgpel   rec_mbY[16][16], rec_mbU[16][16], rec_mbV[16][16], rec_mbY8x8[16][16];    // reconstruction values
   55|       |imgpel   mpr8x8[16][16];
   56|       |int   ****cofAC=NULL, ****cofAC8x8=NULL;        // [8x8block][4x4block][level/run][scan_pos]
   57|       |int   ***cofDC=NULL;                       // [yuv][level/run][scan_pos]
   58|       |int   **cofAC4x4=NULL, ****cofAC4x4intern=NULL; // [level/run][scan_pos]
   59|       |int   cbp, cbp8x8, cnt_nonz_8x8;
   60|       |int64 cbp_blk;
   61|       |int   cbp_blk8x8;
   62|       |short   frefframe[4][4], brefframe[4][4], b8mode[4], b8pdir[4];
   63|       |short   best8x8mode [4];                // [block]
   64|       |short   best8x8pdir  [MAXMODE][4];       // [mode][block]
   65|       |short   best8x8fwref [MAXMODE][4];       // [mode][block]
   66|       |short   best8x8bwref [MAXMODE][4];       // [mode][block]
   67|       |#if BI_PREDICTION
   68|       |int    bi_pred_me;
   69|       |#endif
   70|       |
   71|       |CSptr cs_mb=NULL, cs_b8=NULL, cs_cm=NULL, cs_imb=NULL, cs_ib8=NULL, cs_ib4=NULL, cs_pc=NULL;
   72|       |int   best_c_imode;
   73|       |int   best_i16offset;
   74|       |
   75|       |imgpel temp_imgY[16][16]; // to temp store the Y data for 8x8 transform
   76|       |imgpel temp_imgU[16][16];
   77|       |imgpel temp_imgV[16][16];
   78|       |int   best_transform_size[4];
   79|       |
   80|       |//mixed transform sizes definitions
   81|       |int   luma_transform_size_8x8_flag;
   82|       |int   NoMbPartLessThan8x8Flag;
   83|       |
   84|       |short part8x8pdir[4];
   85|       |short part8x8fwref[4];
   86|       |short part8x8bwref[4];
   87|       |
   88|       |short mv8x8[2][4][4][2];              //[LIST][block_x][block_y][MVx/MVy]
   89|       |short ref8x8[2][4][4];                //[LIST][block_x][block_y]
   90|       |
   91|       |short all_mv8x8[2][2][4][4][2];       //[8x8_data/temp_data][LIST][block_x][block_y][MVx/MVy]
   92|       |short pred_mv8x8[2][2][4][4][2];
   93|       |
   94|       |//ADD-VG-28062004
   95|       |int   ****cofAC_8x8ts = NULL;        // [8x8block][4x4block][level/run][scan_pos]
   96|       |imgpel   rec_mbY_8x8ts[16][16];
   97|       |imgpel   mpr_8x8ts[16][16];
   98|       |int64    cbp_blk8_8x8ts;
   99|       |int      cbp8_8x8ts;
  100|       |int      cost8_8x8ts;
  101|       |int      cnt_nonz8_8x8ts;
  102|       |int      part8x8mode[4];
  103|       |//ADD-VG-28062004-END
  104|       |
  105|       |
  106|       |void StoreMV8x8(int dir);
  107|       |void RestoreMV8x8(int dir);
  108|       |// end of mixed transform sizes definitions
  109|       |
  110|       |
  111|       |// Residue Color Transform
  112|       |int   cofAC4x4_chroma[2][2][18];
  113|       |int   rec_resG_8x8[16][16], resTrans_R_8x8[16][16], resTrans_B_8x8[16][16];
  114|       |int   rec_resG_8x8ts[16][16], resTrans_R_8x8ts[16][16], resTrans_B_8x8ts[16][16];
  115|       |int   mprRGB_8x8[3][16][16], mprRGB_8x8ts[3][16][16];
  116|       |int   b4_ipredmode[16], b4_intra_pred_modes[16];
  117|       |
  118|       |/*!
  119|       | ************************************************************************
  120|       | * \brief
  121|       | *    delete structure for RD-optimized mode decision
  122|       | ************************************************************************
  123|       | */
  124|       |void clear_rdopt ()
  125|      1|{
  126|      1|  free_mem_DCcoeff (cofDC);
  127|      1|  free_mem_ACcoeff (cofAC);
  128|      1|  free_mem_ACcoeff (cofAC8x8);
  129|      1|  free_mem_ACcoeff (cofAC4x4intern);
  130|       |
  131|      1|  if (input->AllowTransform8x8)
  132|      0|  {
  133|      0|    free_mem_ACcoeff (cofAC_8x8ts);
  134|      0|  }
  135|       |  
  136|       |  // structure for saving the coding state
  137|      1|  delete_coding_state (cs_mb);
  138|      1|  delete_coding_state (cs_b8);
  139|      1|  delete_coding_state (cs_cm);
  140|      1|  delete_coding_state (cs_imb);
  141|      1|  delete_coding_state (cs_ib8);
  142|      1|  delete_coding_state (cs_ib4);
  143|      1|  delete_coding_state (cs_pc);
  144|      1|}
  145|       |
  146|       |
  147|       |/*!
  148|       | ************************************************************************
  149|       | * \brief
  150|       | *    create structure for RD-optimized mode decision
  151|       | ************************************************************************
  152|       | */
  153|       |void init_rdopt ()
  154|      1|{
  155|      1|  rdopt = NULL;
  156|       |
  157|      1|  get_mem_DCcoeff (&cofDC);
  158|      1|  get_mem_ACcoeff (&cofAC);
  159|      1|  get_mem_ACcoeff (&cofAC8x8);
  160|      1|  get_mem_ACcoeff (&cofAC4x4intern);
  161|      1|  cofAC4x4 = cofAC4x4intern[0][0];
  162|       |
  163|      1|  if (input->AllowTransform8x8)
  164|      0|  {
  165|      0|    get_mem_ACcoeff (&cofAC_8x8ts);
  166|      0|  }
  167|       |  
  168|       |  // structure for saving the coding state
  169|      1|  cs_mb  = create_coding_state ();
  170|      1|  cs_b8  = create_coding_state ();
  171|      1|  cs_cm  = create_coding_state ();
  172|      1|  cs_imb = create_coding_state ();
  173|      1|  cs_ib8 = create_coding_state ();
  174|      1|  cs_ib4 = create_coding_state ();
  175|      1|  cs_pc  = create_coding_state ();
  176|      1|}
  177|       |
  178|       |
  179|       |
  180|       |/*!
  181|       | *************************************************************************************
  182|       | * \brief
  183|       | *    Updates the pixel map that shows, which reference frames are reliable for
  184|       | *    each MB-area of the picture.
  185|       | *
  186|       | * \note
  187|       | *    The new values of the pixel_map are taken from the temporary buffer refresh_map
  188|       | *
  189|       | *************************************************************************************
  190|       | */
  191|       |void UpdatePixelMap()
  192|      0|{
  193|      0|  int mx,my,y,x,i,j;
  194|      0|  if (img->type==I_SLICE)
  195|      0|  {
  196|      0|    for (y=0; y<img->height; y++)
  197|      0|    for (x=0; x<img->width; x++)
  198|      0|    {
  199|      0|      pixel_map[y][x]=1;
  200|      0|    }
  201|      0|  }
  202|      0|  else
  203|      0|  {
  204|      0|    for (my=0; my<img->height/8; my++)
  205|      0|    for (mx=0; mx<img->width/8;  mx++)
  206|      0|    {
  207|      0|      j = my*8 + 8;
  208|      0|      i = mx*8 + 8;
  209|      0|      if (refresh_map[my][mx])
  210|      0|      {
  211|      0|        for (y=my*8; y<j; y++)
  212|      0|        for (x=mx*8; x<i; x++)  pixel_map[y][x] = 1;
  213|      0|      }
  214|      0|      else
  215|      0|      {
  216|      0|        for (y=my*8; y<j; y++)
  217|      0|        for (x=mx*8; x<i; x++)  pixel_map[y][x] = min(pixel_map[y][x]+1, input->num_ref_frames+1);
  218|      0|      }
  219|      0|    }
  220|      0|  }
  221|      0|}
  222|       |
  223|       |/*!
  224|       | *************************************************************************************
  225|       | * \brief
  226|       | *    Checks if a given reference frame is reliable for the current
  227|       | *    macroblock, given the motion vectors that the motion search has
  228|       | *    returned.
  229|       | *
  230|       | * \return
  231|       | *    If the return value is 1, the reference frame is reliable. If it
  232|       | *    is 0, then it is not reliable.
  233|       | *
  234|       | * \note
  235|       | *    A specific area in each reference frame is assumed to be unreliable
  236|       | *    if the same area has been intra-refreshed in a subsequent frame.
  237|       | *    The information about intra-refreshed areas is kept in the pixel_map.
  238|       | *
  239|       | *************************************************************************************
  240|       | */
  241|       |int CheckReliabilityOfRef (int block, int list_idx, int ref, int mode)
  242|      0|{
  243|      0|  int y,x, block_y, block_x, dy, dx, y_pos, x_pos, yy, xx, pres_x, pres_y;
  244|      0|  int maxold_x  = img->width-1;
  245|      0|  int maxold_y  = img->height-1;
  246|      0|  int ref_frame = ref+1;
  247|       |
  248|      0|  int by0 = (mode>=4?2*(block/2):mode==2?2*block:0);
  249|      0|  int by1 = by0 + (mode>=4||mode==2?2:4);
  250|      0|  int bx0 = (mode>=4?2*(block%2):mode==3?2*block:0);
  251|      0|  int bx1 = bx0 + (mode>=4||mode==3?2:4);
  252|       |
  253|      0|  for (block_y=by0; block_y<by1; block_y++)
  254|      0|    for (block_x=bx0; block_x<bx1; block_x++)
  255|      0|    {
  256|      0|      y_pos  = img->all_mv[block_x][block_y][list_idx][ref][mode][1];
  257|      0|      y_pos += (img->block_y+block_y) * BLOCK_SIZE * 4;
  258|      0|      x_pos  = img->all_mv[block_x][block_y][list_idx][ref][mode][0];
  259|      0|      x_pos += (img->block_x+block_x) * BLOCK_SIZE * 4;
  260|       |
  261|       |      /* Here we specify which pixels of the reference frame influence
  262|       |         the reference values and check their reliability. This is
  263|       |         based on the function Get_Reference_Pixel */
  264|       |
  265|      0|      dy = y_pos & 3;
  266|      0|      dx = x_pos & 3;
  267|       |
  268|      0|      y_pos = (y_pos-dy)/4;
  269|      0|      x_pos = (x_pos-dx)/4;
  270|       |
  271|      0|      if (dy==0 && dx==0) //full-pel
  272|      0|      {
  273|      0|        for (y=0 ; y < BLOCK_SIZE ; y++)
  274|      0|          for (x=0 ; x < BLOCK_SIZE ; x++)
  275|      0|            if (pixel_map[max(0,min(maxold_y,y_pos+y))][max(0,min(maxold_x,x_pos+x))] < ref_frame)
  276|      0|              return 0;
  277|      0|      }
  278|      0|      else  /* other positions */
  279|      0|      {
  280|      0|        if (dy == 0)
  281|      0|        {
  282|      0|          for (y=0 ; y < BLOCK_SIZE ; y++)
  283|      0|            for (x=0 ; x < BLOCK_SIZE ; x++)
  284|      0|            {
  285|      0|              pres_y = max(0,min(maxold_y,y_pos+y));
  286|      0|              for(xx=-2;xx<4;xx++) {
  287|      0|                pres_x = max(0,min(maxold_x,x_pos+x+xx));
  288|      0|                if (pixel_map[pres_y][pres_x] < ref_frame)
  289|      0|                  return 0;
  290|      0|              }
  291|      0|            }
  292|      0|        }
  293|       |
  294|      0|        else if (dx == 0)
  295|      0|        {
  296|      0|          for (y=0 ; y < BLOCK_SIZE ; y++)
  297|      0|            for (x=0 ; x < BLOCK_SIZE ; x++)
  298|      0|            {
  299|      0|              pres_x = max(0,min(maxold_x,x_pos+x));
  300|      0|              for(yy=-2;yy<4;yy++) {
  301|      0|                pres_y = max(0,min(maxold_y,y_pos+yy+y));
  302|      0|                if (pixel_map[pres_y][pres_x] < ref_frame)
  303|      0|                  return 0;
  304|      0|              }
  305|      0|            }
  306|      0|        }
  307|      0|        else if (dx == 2)
  308|      0|        {
  309|      0|          for (y=0 ; y < BLOCK_SIZE ; y++)
  310|      0|            for (x=0 ; x < BLOCK_SIZE ; x++)
  311|      0|            {
  312|      0|              for(yy=-2;yy<4;yy++) {
  313|      0|                pres_y = max(0,min(maxold_y,y_pos+yy+y));
  314|      0|                for(xx=-2;xx<4;xx++) {
  315|      0|                  pres_x = max(0,min(maxold_x,x_pos+xx+x));
  316|      0|                  if (pixel_map[pres_y][pres_x] < ref_frame)
  317|      0|                    return 0;
  318|      0|                }
  319|      0|              }
  320|      0|            }
  321|      0|        }
  322|      0|        else if (dy == 2)
  323|      0|        {
  324|      0|          for (y=0 ; y < BLOCK_SIZE ; y++)
  325|      0|            for (x=0 ; x < BLOCK_SIZE ; x++)
  326|      0|            {
  327|      0|              for(xx=-2;xx<4;xx++) {
  328|      0|                pres_x = max(0,min(maxold_x,x_pos+xx+x));
  329|      0|                for(yy=-2;yy<4;yy++) {
  330|      0|                  pres_y = max(0,min(maxold_y,y_pos+yy+y));
  331|      0|                  if (pixel_map[pres_y][pres_x] < ref_frame)
  332|      0|                    return 0;
  333|      0|                }
  334|      0|              }
  335|      0|            }
  336|      0|        }
  337|      0|        else
  338|      0|        {
  339|      0|          for (y=0 ; y < BLOCK_SIZE ; y++)
  340|      0|            for (x=0 ; x < BLOCK_SIZE ; x++)
  341|      0|            {
  342|      0|              pres_y = dy == 1 ? y_pos+y : y_pos+y+1;
  343|      0|              pres_y = max(0,min(maxold_y,pres_y));
  344|       |
  345|      0|              for(xx=-2;xx<4;xx++) {
  346|      0|                pres_x = max(0,min(maxold_x,x_pos+xx+x));
  347|      0|                if (pixel_map[pres_y][pres_x] < ref_frame)
  348|      0|                  return 0;
  349|      0|              }
  350|       |
  351|      0|              pres_x = dx == 1 ? x_pos+x : x_pos+x+1;
  352|      0|              pres_x = max(0,min(maxold_x,pres_x));
  353|       |
  354|      0|              for(yy=-2;yy<4;yy++) {
  355|      0|                pres_y = max(0,min(maxold_y,y_pos+yy+y));
  356|      0|                if (pixel_map[pres_y][pres_x] < ref_frame)
  357|      0|                  return 0;
  358|      0|              }
  359|      0|            }
  360|      0|        }
  361|       |
  362|      0|      }
  363|      0|    }
  364|       |
  365|      0|  return 1;
  366|      0|}
  367|       |
  368|       |
  369|       |
  370|       |/*!
  371|       | *************************************************************************************
  372|       | * \brief
  373|       | *    R-D Cost for an 4x4 Intra block
  374|       | *************************************************************************************
  375|       | */
  376|       |double RDCost_for_4x4IntraBlocks (int*    nonzero,
  377|       |                           int     b8,
  378|       |                           int     b4,
  379|       |                           int    ipmode,
  380|       |                           double  lambda,
  381|       |                           double  min_rdcost,
  382|       |                           int mostProbableMode)
  383|  60.1M|{
  384|  60.1M|  double  rdcost;
  385|  60.1M|  int     dummy, x, y, rate;
  386|  60.1M|  int     distortion  = 0;
  387|  60.1M|  int     block_x     = 8*(b8%2)+4*(b4%2);
  388|  60.1M|  int     block_y     = 8*(b8/2)+4*(b4/2);
  389|  60.1M|  int     pic_pix_x   = img->pix_x+block_x;
  390|  60.1M|  int     pic_pix_y   = img->pix_y+block_y;
  391|  60.1M|  int     pic_opix_y  = img->opix_y+block_y;
  392|  60.1M|  imgpel  **imgY      = enc_picture->imgY;
  393|       |
  394|  60.1M|  Slice          *currSlice    =  img->currentSlice;
  395|  60.1M|  Macroblock     *currMB       = &img->mb_data[img->current_mb_nr];
  396|  60.1M|  SyntaxElement  *currSE       = &img->MB_SyntaxElements[currMB->currSEnr];
  397|  60.1M|  const int      *partMap      = assignSE2partition[input->partition_mode];
  398|  60.1M|  DataPartition  *dataPart;
  399|       |
  400|       |  //===== perform DCT, Q, IQ, IDCT, Reconstruction =====
  401|  60.1M|  dummy = 0;
  402|       |
  403|  60.1M|  *nonzero = dct_luma (block_x, block_y, &dummy, 1);
  404|       |
  405|       |  //===== get distortion (SSD) of 4x4 block =====
  406|  60.1M|  if(!img->residue_transform_flag)
  407|  60.1M|  {
  408|   300M|    for (y=0; y<4; y++)
  409|   240M|    {
  410|  1.20G|      for (x=pic_pix_x; x<pic_pix_x+4; x++)
  411|   961M|      {
  412|   961M|        distortion += img->quad [imgY_org[pic_opix_y+y][x] - imgY[pic_pix_y+y][x]];
  413|   961M|      }
  414|   240M|    }
  415|  60.1M|  }
  416|       |
  417|  60.1M|  store_coding_state (cs_cm);
  418|       |  //===== RATE for INTRA PREDICTION MODE  (SYMBOL MODE MUST BE SET TO UVLC) =====
  419|  60.1M|  currSE->value1 = (mostProbableMode == ipmode) ? -1 : ipmode < mostProbableMode ? ipmode : ipmode-1;
  420|       |
  421|       |  //--- set position and type ---
  422|  60.1M|  currSE->context = 4*b8 + b4;
  423|  60.1M|  currSE->type    = SE_INTRAPREDMODE;
  424|       |
  425|       |  //--- set function pointer ----
  426|  60.1M|  if (input->symbol_mode != UVLC)    
  427|  60.1M|  currSE->writing = writeIntraPredMode_CABAC;
  428|       |
  429|       |  //--- choose data partition ---
  430|  60.1M|  dataPart = &(currSlice->partArr[partMap[SE_INTRAPREDMODE]]);
  431|       |  //--- encode and update rate ---
  432|  60.1M|  if (input->symbol_mode == UVLC)    writeSyntaxElement_Intra4x4PredictionMode(currSE, dataPart);
  433|  60.1M|  else                               dataPart->writeSyntaxElement (currSE, dataPart);
  434|       |
  435|  60.1M|  rate = currSE->len;
  436|  60.1M|  currSE++;
  437|  60.1M|  currMB->currSEnr++;
  438|       |
  439|       |  //===== RATE for LUMINANCE COEFFICIENTS =====
  440|  60.1M|  if (input->symbol_mode == UVLC)
  441|      0|  {
  442|      0|    rate  += writeCoeff4x4_CAVLC (LUMA, b8, b4, 0);
  443|      0|  }
  444|  60.1M|  else
  445|  60.1M|  {
  446|  60.1M|    rate  += writeLumaCoeff4x4_CABAC (b8, b4, 1);
  447|  60.1M|  }
  448|  60.1M|  reset_coding_state (cs_cm);
  449|  60.1M|  rdcost = (double)distortion + lambda*(double)rate;
  450|       |
  451|  60.1M|  if(img->residue_transform_flag)
  452|      0|    return (double)rate;
  453|  60.1M|  else
  454|  60.1M|    return rdcost;
  455|  60.1M|}
  456|       |
  457|       |
  458|       |// Residue Color Transform
  459|       |int RDCost_for_4x4Blocks_Chroma (int     b8,
  460|       |                                 int     b4,
  461|       |                                 int  chroma)
  462|      0|{
  463|      0|  int     rate=0;
  464|       |
  465|      0|  Slice          *currSlice    =  img->currentSlice;
  466|      0|  Macroblock     *currMB       = &img->mb_data[img->current_mb_nr];
  467|      0|  SyntaxElement  *currSE       = &img->MB_SyntaxElements[currMB->currSEnr];
  468|      0|  const int      *partMap      = assignSE2partition[input->partition_mode];
  469|      0|  int uv;
  470|       |
  471|       |  //===== perform DCT, Q, IQ, IDCT, Reconstruction =====
  472|      0|  if(b8 > 7) 
  473|      0|    uv = 1;
  474|      0|  else 
  475|      0|    uv = 0;
  476|       |
  477|      0|  cbp_chroma_block_temp[uv][2*((b8-4*(uv+1))%2)+(b4%2)][2*((b8-4*(uv+1))/2)+(b4/2)] = dct_chroma4x4 (chroma, b8, b4);
  478|       |
  479|      0|  store_coding_state (cs_cm);
  480|       |  //===== RATE for LUMINANCE COEFFICIENTS =====
  481|      0|  if (input->symbol_mode == UVLC)
  482|      0|  {
  483|      0|    rate  = writeCoeff4x4_CAVLC (CHROMA_AC, b8, b4, ((2*(b8%2)+b4%2)<<4) | (2*(b8/2)+(b4/2)));
  484|      0|  }
  485|      0|  else
  486|      0|  {
  487|      0|    int * ACLevel, * ACRun;
  488|      0|    int level, run, k;
  489|      0|    DataPartition*  dataPart;
  490|      0|    int*            bitCount  = currMB->bitcounter;
  491|      0|    ACLevel = img->cofAC[b8][b4][0];
  492|      0|    ACRun   = img->cofAC[b8][b4][1];
  493|       |    
  494|      0|    level=1;
  495|       |    
  496|      0|    img->subblock_y = b4/2;
  497|      0|    img->subblock_x = b4%2;
  498|       |
  499|      0|    for (k=0; k < 17 && level != 0; k++)
  500|      0|    {
  501|      0|      level = currSE->value1 = ACLevel[k]; // level
  502|      0|      run   = currSE->value2 = ACRun  [k]; // run
  503|       |
  504|      0|      if (input->symbol_mode == UVLC)   currSE->mapping = levrun_linfo_inter;
  505|      0|      else                              currSE->writing = writeRunLevel_CABAC;
  506|       |
  507|      0|      currSE->context     = CHROMA_AC;
  508|      0|      currSE->type        = SE_CHR_AC_INTRA;
  509|       |
  510|      0|      img->is_intra_block =  IS_INTRA(currMB);
  511|      0|      img->is_v_block     = uv;
  512|       |
  513|       |      // choose the appropriate data partition
  514|      0|      dataPart = &(currSlice->partArr[partMap[currSE->type]]); 
  515|      0|      dataPart->writeSyntaxElement (currSE, dataPart);
  516|      0|      bitCount[BITS_COEFF_UV_MB] += currSE->len;
  517|      0|      rate                       += currSE->len;
  518|       |
  519|       |      // proceed to next SE
  520|      0|      currSE++;
  521|      0|      currMB->currSEnr++;
  522|      0|    }
  523|      0|  }
  524|      0|  reset_coding_state (cs_cm);
  525|       |
  526|      0|  return rate;
  527|      0|}
  528|       |
  529|       |
  530|       |/*!
  531|       | *************************************************************************************
  532|       | * \brief
  533|       | *    Mode Decision for an 4x4 Intra block
  534|       | *************************************************************************************
  535|       | */
  536|       |int Mode_Decision_for_4x4IntraBlocks (int  b8,  int  b4,  double  lambda,  int*  min_cost)
  537|  6.72M|{
  538|  6.72M|  int     ipmode, best_ipmode = 0, i, j, k, x, y, cost, dummy;
  539|  6.72M|  int     c_nz, nonzero = 0, rec4x4[4][4], diff[16];
  540|  6.72M|  double  rdcost;
  541|  6.72M|  int     block_x     = 8*(b8%2)+4*(b4%2);
  542|  6.72M|  int     block_y     = 8*(b8/2)+4*(b4/2);
  543|  6.72M|  int     pic_pix_x   = img->pix_x+block_x;
  544|  6.72M|  int     pic_pix_y   = img->pix_y+block_y;
  545|  6.72M|  int     pic_opix_x   = img->opix_x+block_x;
  546|  6.72M|  int     pic_opix_y   = img->opix_y+block_y;
  547|  6.72M|  int     pic_block_x = pic_pix_x/4;
  548|  6.72M|  int     pic_block_y = pic_pix_y/4;
  549|  6.72M|  double  min_rdcost  = 1e30;
  550|       |
  551|  6.72M|#if defined(SPEC_CPU)
  552|       |  /* SPEC_CPU: epsilon is required for systems where double can be
  553|       |     more than 64-bits (e.g. x87) */
  554|       |  /* Allow 1 ulp of error @ ~2000.0f */
  555|       |  /* hex value of epsilon = 0x3d50000000000000ull */
  556|  6.72M|  double epsilon = 2.27373675443232059478759765626E-13f;
  557|  6.72M|#endif
  558|       |
  559|  6.72M|  int left_available, up_available, all_available;
  560|       |
  561|  6.72M|  int     upMode;
  562|  6.72M|  int     leftMode;
  563|  6.72M|  int     mostProbableMode;
  564|       |
  565|  6.72M|  PixelPos left_block;
  566|  6.72M|  PixelPos top_block;
  567|       |
  568|       |#ifdef BEST_NZ_COEFF
  569|       |  int best_nz_coeff = 0;
  570|       |#endif
  571|       |
  572|       |  // Residue Color Transform
  573|  6.72M|  int residue_R, residue_G, residue_B;
  574|  6.72M|  int rate, distortion, temp;
  575|  6.72M|  int c_ipmode = img->mb_data[img->current_mb_nr].c_ipred_mode;
  576|  6.72M|  int rec4x4_c[2][4][4];
  577|       |  
  578|  6.72M|  getLuma4x4Neighbour(img->current_mb_nr, block_x/4, block_y/4, -1,  0, &left_block);
  579|  6.72M|  getLuma4x4Neighbour(img->current_mb_nr, block_x/4, block_y/4,  0, -1, &top_block);
  580|       |
  581|       |  // constrained intra pred
  582|  6.72M|  if (input->UseConstrainedIntraPred)
  583|      0|  {
  584|      0|    left_block.available = left_block.available ? img->intra_block[left_block.mb_addr] : 0;
  585|      0|    top_block.available  = top_block.available  ? img->intra_block[top_block.mb_addr]  : 0;
  586|      0|  }
  587|       |
  588|  6.72M|  upMode            = top_block.available ? img->ipredmode[top_block.pos_x ][top_block.pos_y ] : -1;
  589|  6.72M|  leftMode          = left_block.available ? img->ipredmode[left_block.pos_x][left_block.pos_y] : -1;
  590|       |
  591|  6.72M|  mostProbableMode  = (upMode < 0 || leftMode < 0) ? DC_PRED : upMode < leftMode ? upMode : leftMode;
  592|       |
  593|  6.72M|  *min_cost = INT_MAX;
  594|       |
  595|       |  //===== INTRA PREDICTION FOR 4x4 BLOCK =====
  596|  6.72M|  intrapred_luma (pic_pix_x, pic_pix_y, &left_available, &up_available, &all_available);
  597|       |
  598|       |  //===== LOOP OVER ALL 4x4 INTRA PREDICTION MODES =====
  599|  67.2M|  for (ipmode=0; ipmode<NO_INTRA_PMODE; ipmode++)
  600|  60.5M|  {
  601|  60.5M|    int available_mode =  (ipmode==DC_PRED) ||
  602|  60.5M|        ((ipmode==VERT_PRED||ipmode==VERT_LEFT_PRED||ipmode==DIAG_DOWN_LEFT_PRED) && up_available ) ||
  603|  60.5M|        ((ipmode==HOR_PRED||ipmode==HOR_UP_PRED) && left_available ) ||(all_available);
  604|       |
  605|  60.5M|    if (input->IntraDisableInterOnly==0 || img->type != I_SLICE)
  606|  60.5M|    {
  607|  60.5M|      if (input->Intra4x4ParDisable && (ipmode==VERT_PRED||ipmode==HOR_PRED))
  608|      0|        continue;
  609|       |      
  610|  60.5M|      if (input->Intra4x4DiagDisable && (ipmode==DIAG_DOWN_LEFT_PRED||ipmode==DIAG_DOWN_RIGHT_PRED))
  611|      0|        continue;
  612|       |      
  613|  60.5M|      if (input->Intra4x4DirDisable && ipmode>=VERT_RIGHT_PRED)
  614|      0|        continue;
  615|  60.5M|    }
  616|       | 
  617|  60.5M|    if( available_mode)
  618|  60.1M|    {
  619|  60.1M|      if (!input->rdopt)
  620|      0|      {
  621|      0|        for (k=j=0; j<4; j++)
  622|      0|          for (i=0; i<4; i++, k++)
  623|      0|          {
  624|      0|            diff[k] = imgY_org[pic_opix_y+j][pic_opix_x+i] - img->mprr[ipmode][j][i];
  625|      0|          }
  626|      0|        cost  = (ipmode == mostProbableMode) ? 0 : (int)floor(4 * lambda );
  627|      0|        cost += SATD (diff, input->hadamard);
  628|      0|        if (cost < *min_cost)
  629|      0|        {
  630|      0|          best_ipmode = ipmode;
  631|      0|          *min_cost   = cost;
  632|      0|        }
  633|      0|      }
  634|  60.1M|      else
  635|  60.1M|      {
  636|       |        // Residue Color Transform
  637|  60.1M|        if(!img->residue_transform_flag)
  638|  60.1M|        {
  639|       |          // get prediction and prediction error
  640|   300M|          for (j=0; j<4; j++)
  641|  1.20G|          for (i=0; i<4; i++)
  642|   961M|          {
  643|   961M|            img->mpr[block_x+i][block_y+j]  = img->mprr[ipmode][j][i];
  644|   961M|            img->m7[i][j]                   = imgY_org[pic_opix_y+j][pic_opix_x+i] - img->mprr[ipmode][j][i];
  645|   961M|          }
  646|       |
  647|       |          //===== store the coding state =====
  648|  60.1M|          store_coding_state (cs_cm);
  649|       |          // get and check rate-distortion cost
  650|  60.1M|#if defined(SPEC_CPU)
  651|  60.1M|          rdcost = RDCost_for_4x4IntraBlocks (&c_nz, b8, b4, ipmode, lambda, min_rdcost, mostProbableMode);
  652|  60.1M|          if ((fabs(rdcost - min_rdcost) > epsilon) && (rdcost < min_rdcost))
  653|       |#else
  654|       |          if ((rdcost = RDCost_for_4x4IntraBlocks (&c_nz, b8, b4, ipmode, lambda, min_rdcost, mostProbableMode)) < min_rdcost)
  655|       |#endif
  656|  17.0M|          {
  657|       |            //--- set coefficients ---
  658|  51.1M|            for (j=0; j<2; j++)
  659|   648M|            for (i=0; i<18;i++)  cofAC4x4[j][i]=img->cofAC[b8][b4][j][i];
  660|       |
  661|       |            //--- set reconstruction ---
  662|  85.3M|            for (y=0; y<4; y++)
  663|   341M|            for (x=0; x<4; x++)  rec4x4[y][x] = enc_picture->imgY[pic_pix_y+y][pic_pix_x+x];
  664|       |
  665|       |            //--- flag if dct-coefficients must be coded ---
  666|  17.0M|            nonzero = c_nz;
  667|       |
  668|       |            //--- set best mode update minimum cost ---
  669|  17.0M|            min_rdcost    = rdcost;
  670|  17.0M|            best_ipmode   = ipmode;
  671|       |#ifdef BEST_NZ_COEFF
  672|       |            best_nz_coeff = img->nz_coeff [img->current_mb_nr][block_x/4][block_y/4];
  673|       |#endif
  674|       |
  675|  17.0M|          }
  676|  60.1M|          reset_coding_state (cs_cm);
  677|  60.1M|        } 
  678|      0|        else 
  679|      0|        {
  680|      0|          for (j=0; j<4; j++)
  681|      0|            for (i=0; i<4; i++)
  682|      0|            {
  683|      0|              residue_B = imgUV_org[0][pic_opix_y+j][pic_opix_x+i] - img->mprr_c[0][c_ipmode][block_x+i][block_y+j];
  684|      0|              residue_G = imgY_org[pic_opix_y+j][pic_opix_x+i] - img->mprr[ipmode][j][i];
  685|      0|              residue_R = imgUV_org[1][pic_opix_y+j][pic_opix_x+i] - img->mprr_c[1][c_ipmode][block_x+i][block_y+j];
  686|       |              
  687|       |              /* Foward Residue Transform */
  688|      0|              resTrans_R[i][j] = residue_R-residue_B;
  689|      0|              temp = residue_B+(resTrans_R[i][j]>>1);
  690|      0|              resTrans_B[i][j] = residue_G-temp;
  691|      0|              resTrans_G[i][j] = temp+(resTrans_B[i][j]>>1);
  692|      0|            }
  693|       |            
  694|      0|          for (j=0; j<4; j++)
  695|      0|            for (i=0; i<4; i++)
  696|      0|            {
  697|      0|              img->m7[i][j]  = resTrans_G[i][j];
  698|      0|            }
  699|       |
  700|      0|          store_coding_state (cs_cm);
  701|      0|          rate = (int) RDCost_for_4x4IntraBlocks (&c_nz, b8, b4, ipmode, lambda, min_rdcost, mostProbableMode);
  702|      0|          reset_coding_state (cs_cm);
  703|       |
  704|      0|          for (j=0; j<4; j++)
  705|      0|            for (i=0; i<4; i++)
  706|      0|            {
  707|      0|              rec_resG[i][j] = img->m7[i][j];
  708|      0|              img->m7[i][j]  = resTrans_R[i][j];
  709|      0|            }
  710|      0|          store_coding_state (cs_cm);
  711|      0|          rate += RDCost_for_4x4Blocks_Chroma (b8+4, b4, 0);
  712|      0|          for (j=0; j<4; j++)
  713|      0|            for (i=0; i<4; i++)
  714|      0|            {
  715|      0|              rec_resR[i][j] = img->m7[i][j];
  716|      0|              img->m7[i][j]  = resTrans_B[i][j];
  717|      0|            }
  718|      0|          rate += RDCost_for_4x4Blocks_Chroma (b8+8, b4, 1);
  719|      0|          reset_coding_state (cs_cm);
  720|      0|          for (j=0; j<4; j++)
  721|      0|            for (i=0; i<4; i++)
  722|      0|            {
  723|      0|              rec_resB[i][j] = img->m7[i][j];
  724|      0|            }
  725|       |
  726|      0|          for (j=0; j<4; j++)
  727|      0|            for (i=0; i<4; i++)
  728|      0|            {
  729|       |              /* Inverse Residue Transform */
  730|      0|              temp      = rec_resG[i][j]-(rec_resB[i][j]>>1);
  731|      0|              residue_G = rec_resB[i][j]+temp;
  732|      0|              residue_B = temp - (rec_resR[i][j]>>1);
  733|      0|              residue_R = residue_B+rec_resR[i][j];
  734|      0|              enc_picture->imgUV[0][pic_pix_y+j][pic_pix_x+i] = min(img->max_imgpel_value_uv,max(0,residue_B+(int)img->mprr_c[0][c_ipmode][block_x+i][block_y+j]));
  735|      0|              enc_picture->imgY[pic_pix_y+j][pic_pix_x+i]     = min(img->max_imgpel_value,max(0,residue_G+(int)img->mprr[ipmode][j][i]));
  736|      0|              enc_picture->imgUV[1][pic_pix_y+j][pic_pix_x+i] = min(img->max_imgpel_value_uv,max(0,residue_R+(int)img->mprr_c[1][c_ipmode][block_x+i][block_y+j]));
  737|      0|            }
  738|       |
  739|       |          //===== get distortion (SSD) of 4x4 block =====
  740|      0|          distortion = 0;
  741|      0|          for (y=0; y<4; y++)
  742|      0|            for (x=pic_pix_x; x<pic_pix_x+4; x++)
  743|      0|            {
  744|      0|              distortion += (imgY_org[pic_pix_y+y][x] - enc_picture->imgY[pic_pix_y+y][x])*(imgY_org[pic_pix_y+y][x] - enc_picture->imgY[pic_pix_y+y][x]);
  745|      0|              distortion += (imgUV_org[0][pic_pix_y+y][x] - enc_picture->imgUV[0][pic_pix_y+y][x])*(imgUV_org[0][pic_pix_y+y][x] - enc_picture->imgUV[0][pic_pix_y+y][x]);
  746|      0|              distortion += (imgUV_org[1][pic_pix_y+y][x] - enc_picture->imgUV[1][pic_pix_y+y][x])*(imgUV_org[1][pic_pix_y+y][x] - enc_picture->imgUV[1][pic_pix_y+y][x]);
  747|      0|            }
  748|      0|          rdcost = (double)distortion + lambda*(double)rate;
  749|       |
  750|      0|          if (rdcost < min_rdcost)
  751|      0|          {
  752|       |            //--- set coefficients ---
  753|      0|            for (j=0; j<2; j++)
  754|      0|              for (i=0; i<18;i++)  cofAC4x4[j][i]=img->cofAC[b8][b4][j][i];
  755|       |
  756|      0|            for (j=0; j<2; j++)
  757|      0|              for (i=0; i<18;i++)  cofAC4x4_chroma[0][j][i]=img->cofAC[b8+4][b4][j][i];
  758|      0|            for (j=0; j<2; j++)
  759|      0|              for (i=0; i<18;i++)  cofAC4x4_chroma[1][j][i]=img->cofAC[b8+8][b4][j][i];
  760|       |
  761|      0|            for (i=0; i<2; i++)
  762|      0|            { //uv
  763|      0|              dc_level[i][2*(b8%2)+(b4%2)][2*(b8/2)+(b4/2)] = dc_level_temp[i][2*(b8%2)+(b4%2)][2*(b8/2)+(b4/2)];
  764|      0|              cbp_chroma_block[i][2*(b8%2)+(b4%2)][2*(b8/2)+(b4/2)] = cbp_chroma_block_temp[i][2*(b8%2)+(b4%2)][2*(b8/2)+(b4/2)];
  765|       |              //--- set reconstruction ---
  766|      0|              for (y=0; y<4; y++)
  767|      0|                for (x=0; x<4; x++)  rec4x4_c[i][y][x] = enc_picture->imgUV[i][pic_pix_y+y][pic_pix_x+x];
  768|      0|            }
  769|       |
  770|       |            //--- set reconstruction ---
  771|      0|            for (y=0; y<4; y++)
  772|      0|              for (x=0; x<4; x++)  rec4x4[y][x] = enc_picture->imgY[pic_pix_y+y][pic_pix_x+x];
  773|       |
  774|       |            //--- flag if dct-coefficients must be coded ---
  775|      0|            nonzero = c_nz;
  776|       |
  777|       |            //--- set best mode update minimum cost ---
  778|      0|            min_rdcost  = rdcost;
  779|      0|            best_ipmode = ipmode;
  780|       |#ifdef BEST_NZ_COEFF
  781|       |            best_nz_coeff = img->nz_coeff [img->current_mb_nr][block_x/4][block_y/4];
  782|       |#endif
  783|      0|          }
  784|      0|        }
  785|  60.1M|      }
  786|  60.1M|    }
  787|  60.5M|  }
  788|       |
  789|       |#ifdef BEST_NZ_COEFF
  790|       |  img->nz_coeff [img->current_mb_nr][block_x/4][block_y/4] = best_nz_coeff;
  791|       |#endif
  792|       |  //===== set intra mode prediction =====
  793|  6.72M|  img->ipredmode[pic_block_x][pic_block_y] = best_ipmode;
  794|  6.72M|  img->mb_data[img->current_mb_nr].intra_pred_modes[4*b8+b4] = mostProbableMode == best_ipmode ? -1 : best_ipmode < mostProbableMode ? best_ipmode : best_ipmode-1;
  795|       |
  796|  6.72M|  if (!input->rdopt)
  797|      0|  {
  798|       |    // Residue Color Transform
  799|      0|    if(!img->residue_transform_flag)
  800|      0|    {
  801|       |      // get prediction and prediction error
  802|      0|      for (j=0; j<4; j++)
  803|      0|        for (i=0; i<4; i++)
  804|      0|        {
  805|      0|          img->mpr[block_x+i][block_y+j]  = img->mprr[best_ipmode][j][i];
  806|      0|          img->m7[i][j]                   = imgY_org[pic_opix_y+j][pic_opix_x+i] - img->mprr[best_ipmode][j][i];
  807|      0|        }
  808|      0|      nonzero = dct_luma (block_x, block_y, &dummy, 1);
  809|      0|    } else 
  810|      0|    {
  811|      0|      for (j=0; j<4; j++)
  812|      0|        for (i=0; i<4; i++)
  813|      0|        {
  814|      0|          residue_B = imgUV_org[0][pic_opix_y+j][pic_opix_x+i] - img->mprr_c[0][c_ipmode][block_x+i][block_y+j];
  815|      0|          residue_G = imgY_org[pic_opix_y+j][pic_opix_x+i] - img->mprr[best_ipmode][j][i];
  816|      0|          residue_R = imgUV_org[1][pic_opix_y+j][pic_opix_x+i] - img->mprr_c[1][c_ipmode][block_x+i][block_y+j];
  817|       |          
  818|       |          /* Forward Residue Transform */
  819|      0|          resTrans_R[i][j] = residue_R-residue_B;
  820|      0|          temp = residue_B+(resTrans_R[i][j]>>1);
  821|      0|          resTrans_B[i][j] = residue_G-temp;
  822|      0|          resTrans_G[i][j] = temp+(resTrans_B[i][j]>>1);
  823|      0|        }
  824|       |
  825|      0|      for (j=0; j<4; j++)
  826|      0|        for (i=0; i<4; i++)
  827|      0|        {
  828|      0|          img->m7[i][j]  = resTrans_G[i][j];
  829|      0|        }
  830|      0|      nonzero = dct_luma (block_x, block_y, &dummy, 1);
  831|      0|      for (j=0; j<4; j++)
  832|      0|        for (i=0; i<4; i++)
  833|      0|        {
  834|      0|          rec_resG[i][j] = img->m7[i][j];
  835|      0|          img->m7[i][j]  = resTrans_R[i][j];
  836|      0|        }
  837|      0|      cbp_chroma_block[0][2*(b8%2)+(b4%2)][2*(b8/2)+(b4/2)] = dct_chroma4x4 (0, b8+4, b4);
  838|      0|      dc_level[0][2*(b8%2)+(b4%2)][2*(b8/2)+(b4/2)] = dc_level_temp[0][2*(b8%2)+(b4%2)][2*(b8/2)+(b4/2)];
  839|      0|      for (j=0; j<4; j++)
  840|      0|        for (i=0; i<4; i++)
  841|      0|        {
  842|      0|          rec_resR[i][j] = img->m7[i][j];
  843|      0|          img->m7[i][j]  = resTrans_B[i][j];
  844|      0|        }
  845|      0|      cbp_chroma_block[1][2*(b8%2)+(b4%2)][2*(b8/2)+(b4/2)] = dct_chroma4x4 (1, b8+8, b4);
  846|      0|      dc_level[1][2*(b8%2)+(b4%2)][2*(b8/2)+(b4/2)] = dc_level_temp[1][2*(b8%2)+(b4%2)][2*(b8/2)+(b4/2)];
  847|      0|      for (j=0; j<4; j++)
  848|      0|        for (i=0; i<4; i++)
  849|      0|        {
  850|      0|          rec_resB[i][j] = img->m7[i][j];
  851|      0|        }
  852|      0|      for (j=0; j<4; j++)
  853|      0|        for (i=0; i<4; i++)
  854|      0|        {
  855|       |          /* Inverse Residue Transform */
  856|      0|          temp      = rec_resG[i][j]-(rec_resB[i][j]>>1);
  857|      0|          residue_G = rec_resB[i][j]+temp;
  858|      0|          residue_B = temp - (rec_resR[i][j]>>1);
  859|      0|          residue_R = residue_B+rec_resR[i][j];
  860|      0|          enc_picture->imgUV[0][pic_pix_y+j][pic_pix_x+i] = min(img->max_imgpel_value_uv,max(0,residue_B+(int)img->mprr_c[0][c_ipmode][block_x+i][block_y+j]));
  861|      0|          enc_picture->imgY[pic_pix_y+j][pic_pix_x+i]     = min(img->max_imgpel_value,max(0,residue_G+(int)img->mprr[best_ipmode][j][i]));
  862|      0|          enc_picture->imgUV[1][pic_pix_y+j][pic_pix_x+i] = min(img->max_imgpel_value_uv,max(0,residue_R+(int)img->mprr_c[1][c_ipmode][block_x+i][block_y+j]));
  863|      0|        }
  864|      0|    }
  865|      0|  }
  866|  6.72M|  else
  867|  6.72M|  {
  868|       |    //===== restore coefficients =====
  869|  20.1M|    for (j=0; j<2; j++)
  870|   255M|      for (i=0; i<18;i++)  img->cofAC[b8][b4][j][i]=cofAC4x4[j][i];
  871|       |
  872|       |    // Residue Color Transform
  873|  6.72M|    if(img->residue_transform_flag)
  874|      0|    {
  875|      0|      for (j=0; j<2; j++)
  876|      0|        for (i=0; i<18;i++)  img->cofAC[b8+4][b4][j][i]=cofAC4x4_chroma[0][j][i];
  877|      0|      for (j=0; j<2; j++)
  878|      0|        for (i=0; i<18;i++)  img->cofAC[b8+8][b4][j][i]=cofAC4x4_chroma[1][j][i];
  879|      0|    }
  880|       |
  881|       |    //===== restore reconstruction and prediction (needed if single coeffs are removed) =====
  882|  33.6M|    for (y=0; y<4; y++)
  883|   134M|      for (x=0; x<4; x++)
  884|   107M|      {
  885|   107M|        enc_picture->imgY[pic_pix_y+y][pic_pix_x+x] = rec4x4[y][x];
  886|   107M|        img->mpr[block_x+x][block_y+y] = img->mprr[best_ipmode][y][x];
  887|   107M|      }
  888|       |
  889|       |    // Residue Color Transform
  890|  6.72M|    if(img->residue_transform_flag)
  891|      0|    {
  892|      0|      for (i=0; i<2; i++)
  893|      0|      { //uv
  894|       |        //--- set reconstruction ---
  895|      0|        for (y=0; y<4; y++)
  896|      0|          for (x=0; x<4; x++) enc_picture->imgUV[i][pic_pix_y+y][pic_pix_x+x] = rec4x4_c[i][y][x] ;
  897|      0|      }
  898|      0|    }
  899|       |
  900|  6.72M|  }
  901|       |
  902|  6.72M|  return nonzero;
  903|  6.72M|}
  904|       |
  905|       |
  906|       |/*!
  907|       | *************************************************************************************
  908|       | * \brief
  909|       | *    Mode Decision for an 8x8 Intra block
  910|       | *************************************************************************************
  911|       | */
  912|       |int Mode_Decision_for_8x8IntraBlocks(int b8,double lambda,int *cost)
  913|  1.68M|{
  914|  1.68M|  int  nonzero=0, b4;
  915|  1.68M|  int  cost4x4;
  916|       |
  917|  1.68M|  *cost = (int)floor(6.0 * lambda + 0.4999);
  918|       |
  919|  8.40M|  for (b4=0; b4<4; b4++)
  920|  6.72M|  {
  921|  6.72M|    if (Mode_Decision_for_4x4IntraBlocks (b8, b4, lambda, &cost4x4))
  922|   767k|    {
  923|   767k|      nonzero        = 1;
  924|   767k|    }
  925|  6.72M|    *cost += cost4x4;
  926|  6.72M|  }
  927|       |
  928|  1.68M|  return nonzero;
  929|  1.68M|}
  930|       |
  931|       |/*!
  932|       | *************************************************************************************
  933|       | * \brief
  934|       | *    4x4 Intra mode decision for an macroblock
  935|       | *************************************************************************************
  936|       | */
  937|       |int Mode_Decision_for_Intra4x4Macroblock (double lambda,  int* cost)
  938|       |
  939|   420k|{
  940|   420k|  int  cbp=0, b8, cost8x8;
  941|       |
  942|  2.10M|  for (*cost=0, b8=0; b8<4; b8++)
  943|  1.68M|  {
  944|  1.68M|    if (Mode_Decision_for_8x8IntraBlocks (b8, lambda, &cost8x8))
  945|   521k|    {
  946|   521k|      cbp |= (1<<b8);
  947|   521k|    }
  948|  1.68M|    *cost += cost8x8;
  949|  1.68M|  }
  950|       |
  951|   420k|  return cbp;
  952|   420k|}
  953|       |
  954|       |
  955|       |/*!
  956|       | *************************************************************************************
  957|       | * \brief
  958|       | *    R-D Cost for an 8x8 Partition
  959|       | *************************************************************************************
  960|       | */
  961|       |double RDCost_for_8x8blocks (int*    cnt_nonz,   // --> number of nonzero coefficients
  962|       |                             int64*  cbp_blk,    // --> cbp blk
  963|       |                             double  lambda,     // <-- lagrange multiplier
  964|       |                             int     block,      // <-- 8x8 block number
  965|       |                             int     mode,       // <-- partitioning mode
  966|       |                             short   pdir,       // <-- prediction direction
  967|       |                             short   ref,        // <-- reference frame
  968|       |                             short   bwd_ref)    // <-- abp type
  969|  1.67M|{
  970|  1.67M|  int  i, j, k;
  971|  1.67M|  int  rate=0;
  972|  1.67M|  int64 distortion=0;
  973|  1.67M|  int  dummy, mrate;
  974|  1.67M|  int  fw_mode, bw_mode;
  975|  1.67M|  int  cbp     = 0;
  976|  1.67M|  int  pax     = 8*(block%2);
  977|  1.67M|  int  pay     = 8*(block/2);
  978|  1.67M|  int  i0      = pax/4;
  979|  1.67M|  int  j0      = pay/4;
  980|  1.67M|  int  bframe  = (img->type==B_SLICE);
  981|  1.67M|  int  direct  = (bframe && mode==0);
  982|  1.67M|  int  b8value = B8Mode2Value (mode, pdir);
  983|       |
  984|  1.67M|  Macroblock    *currMB    = &img->mb_data[img->current_mb_nr];
  985|  1.67M|  SyntaxElement *currSE    = &img->MB_SyntaxElements[currMB->currSEnr];
  986|  1.67M|  Slice         *currSlice = img->currentSlice;
  987|  1.67M|  DataPartition *dataPart;
  988|  1.67M|  const int     *partMap   = assignSE2partition[input->partition_mode];
  989|       |
  990|  1.67M|  EncodingEnvironmentPtr eep_dp;
  991|       |
  992|       |  // Residue Color Transform
  993|  1.67M|  int residue_R, residue_G, residue_B, temp, b4;
  994|  1.67M|  int b4_x, b4_y;
  995|       |
  996|       |  //=====
  997|       |  //=====  GET COEFFICIENTS, RECONSTRUCTIONS, CBP
  998|       |  //=====
  999|  1.67M|#if BI_PREDICTION
 1000|  1.67M|  currMB->bi_pred_me=0;
 1001|  1.67M|#endif
 1002|       |
 1003|  1.67M|  if (direct)
 1004|   217k|  {
 1005|   217k|    if (direct_pdir[img->block_x+i0][img->block_y+j0]<0) // mode not allowed
 1006|      0|    {
 1007|      0|      return (1e20);
 1008|      0|    }
 1009|   217k|    else
 1010|   217k|    {
 1011|   217k|      *cnt_nonz = LumaResidualCoding8x8 (&cbp, cbp_blk, block, direct_pdir[img->block_x+i0][img->block_y+j0], 0, 0, (short)max(0,direct_ref_idx[LIST_0][img->block_x+i0][img->block_y+j0]), direct_ref_idx[LIST_1][img->block_x+i0][img->block_y+j0]);
 1012|   217k|    }
 1013|   217k|  }
 1014|  1.45M|  else
 1015|  1.45M|  {
 1016|  1.45M|    fw_mode   = (pdir==0||pdir==2 ? mode : 0);
 1017|  1.45M|    bw_mode   = (pdir==1||pdir==2 ? mode : 0);
 1018|  1.45M|    *cnt_nonz = LumaResidualCoding8x8 (&cbp, cbp_blk, block, pdir, fw_mode, bw_mode, ref, bwd_ref);
 1019|  1.45M|  }
 1020|       |
 1021|       |  // Residue Color Transform
 1022|  1.67M|  if(img->residue_transform_flag)
 1023|      0|  {
 1024|      0|    for(b4 = 0; b4 < 4; b4++)
 1025|      0|    {
 1026|      0|      b4_x = pax+(b4%2)*4;
 1027|      0|      b4_y = pay+(b4/2)*4;
 1028|      0|      for (j=0; j<4; j++)
 1029|      0|      for (i=0; i<4; i++)
 1030|      0|      {
 1031|      0|        img->m7[i][j]  = resTrans_R[i+b4_x][j+b4_y];
 1032|      0|      }
 1033|      0|      rate += RDCost_for_4x4Blocks_Chroma (block+4, b4, 0);
 1034|      0|      for (j=0; j<4; j++)
 1035|      0|      for (i=0; i<4; i++)
 1036|      0|      {
 1037|      0|        rec_resR[i+b4_x][j+b4_y] = img->m7[i][j];
 1038|      0|        img->m7[i][j]  = resTrans_B[i+b4_x][j+b4_y];
 1039|      0|      }
 1040|      0|      rate += RDCost_for_4x4Blocks_Chroma (block+8, b4, 1);
 1041|      0|      for (j=0; j<4; j++)
 1042|      0|      for (i=0; i<4; i++)
 1043|      0|      {
 1044|      0|        rec_resB[i+b4_x][j+b4_y] = img->m7[i][j];
 1045|      0|      }
 1046|      0|    }
 1047|       |
 1048|       |    /* Inverse Residue Transform */
 1049|      0|    for (j=pay; j<pay+8; j++)
 1050|      0|    for (i=pax; i<pax+8; i++)
 1051|      0|    {
 1052|       |      /* YCoCg-R */
 1053|      0|      temp      = rec_resG[i][j]-(rec_resB[i][j]>>1);
 1054|      0|      residue_G = rec_resB[i][j]+temp;
 1055|      0|      residue_B = temp - (rec_resR[i][j]>>1);
 1056|      0|      residue_R = residue_B+rec_resR[i][j];
 1057|       |
 1058|      0|      enc_picture->imgUV[0][img->pix_y+j][img->pix_x+i] = min(img->max_imgpel_value_uv,max(0,residue_B+mprRGB[1][i][j]));
 1059|      0|      enc_picture->imgY[img->pix_y+j][img->pix_x+i]     = min(img->max_imgpel_value,max(0,residue_G+mprRGB[0][i][j]));
 1060|      0|      enc_picture->imgUV[1][img->pix_y+j][img->pix_x+i] = min(img->max_imgpel_value_uv,max(0,residue_R+mprRGB[2][i][j]));
 1061|      0|    }
 1062|      0|  }
 1063|       |
 1064|       |  //===== get residue =====
 1065|  1.67M|  if (input->rdopt==2 && img->type!=B_SLICE)
 1066|      0|  {
 1067|       |    // We need the reconstructed prediction residue for the simulated decoders.
 1068|      0|    compute_residue_b8block (block, -1);
 1069|      0|  }
 1070|       |
 1071|       |  //=====
 1072|       |  //=====   GET DISTORTION
 1073|       |  //=====
 1074|  1.67M|  if (input->rdopt==2 && img->type!=B_SLICE)
 1075|      0|  {
 1076|      0|    for (k=0; k<input->NoOfDecoders ;k++)
 1077|      0|    {
 1078|      0|      decode_one_b8block (k, P8x8, block, mode, ref);
 1079|      0|      for (j=img->opix_y+pay; j<img->opix_y+pay+8; j++)
 1080|      0|      for (i=img->opix_x+pax; i<img->opix_x+pax+8; i++)
 1081|      0|      {
 1082|      0|        distortion += img->quad[imgY_org[j][i] - decs->decY[k][j][i]];
 1083|      0|      }
 1084|      0|    }
 1085|      0|    distortion /= input->NoOfDecoders;
 1086|      0|  }
 1087|  1.67M|  else
 1088|  1.67M|  {
 1089|  15.0M|    for (j=pay; j<pay+8; j++)
 1090|   120M|    for (i=img->pix_x+pax; i<img->pix_x+pax+8; i++)
 1091|   106M|    {
 1092|   106M|      distortion += img->quad [imgY_org[img->opix_y+j][i] - enc_picture->imgY[img->pix_y+j][i]];
 1093|       |      // Residue Color Transform
 1094|   106M|      if(img->residue_transform_flag)
 1095|      0|      {
 1096|      0|        distortion += img->quad [imgUV_org[0][img->opix_y+j][i] - enc_picture->imgUV[0][img->pix_y+j][i]];
 1097|      0|        distortion += img->quad [imgUV_org[1][img->opix_y+j][i] - enc_picture->imgUV[1][img->pix_y+j][i]];
 1098|      0|      }
 1099|   106M|    }
 1100|  1.67M|  }
 1101|       |
 1102|       |  //=====
 1103|       |  //=====   GET RATE
 1104|       |  //=====
 1105|       |  //----- block 8x8 mode -----
 1106|  1.67M|  if (input->symbol_mode == UVLC)
 1107|      0|  {
 1108|      0|    ue_linfo (b8value, dummy, &mrate, &dummy);
 1109|      0|    rate += mrate;
 1110|      0|  }
 1111|  1.67M|  else
 1112|  1.67M|  {
 1113|  1.67M|    currSE->value1  = b8value;
 1114|  1.67M|    currSE->writing = writeB8_typeInfo_CABAC;
 1115|  1.67M|    currSE->type    = SE_MBTYPE;
 1116|  1.67M|    dataPart = &(currSlice->partArr[partMap[currSE->type]]);
 1117|  1.67M|    dataPart->writeSyntaxElement (currSE, dataPart);
 1118|  1.67M|    rate += currSE->len;
 1119|  1.67M|    currSE++;
 1120|  1.67M|    currMB->currSEnr++;
 1121|  1.67M|  }
 1122|       |
 1123|       |  //----- motion information -----
 1124|  1.67M|  if (!direct)
 1125|  1.45M|  {
 1126|  1.45M|    if ((img->num_ref_idx_l0_active > 1 ) && (pdir==0 || pdir==2))
 1127|   946k|      rate  += writeReferenceFrame (mode, i0, j0, 1, ref);
 1128|  1.45M|    if(img->num_ref_idx_l1_active > 1 && img->type== B_SLICE)
 1129|      0|    {
 1130|      0|      if (pdir==1 || pdir==2)
 1131|      0|      {
 1132|      0|        rate  += writeReferenceFrame (mode, i0, j0, 0, bwd_ref);
 1133|      0|      }
 1134|      0|    }
 1135|       |
 1136|  1.45M|    if (pdir==0 || pdir==2)
 1137|   956k|    {
 1138|   956k|      rate  += writeMotionVector8x8 (i0, j0, i0+2, j0+2, ref,LIST_0, mode);
 1139|   956k|    }
 1140|  1.45M|    if (pdir==1 || pdir==2)
 1141|   503k|    {
 1142|   503k|      rate  += writeMotionVector8x8 (i0, j0, i0+2, j0+2, bwd_ref, LIST_1, mode);
 1143|   503k|    }
 1144|  1.45M|  }
 1145|       |
 1146|       |  //----- coded block pattern (for CABAC only) -----
 1147|  1.67M|  if (input->symbol_mode == CABAC)
 1148|  1.67M|  {
 1149|  1.67M|    dataPart = &(currSlice->partArr[partMap[SE_CBP_INTER]]);
 1150|  1.67M|    eep_dp   = &(dataPart->ee_cabac);
 1151|  1.67M|    mrate    = arienco_bits_written (eep_dp);
 1152|  1.67M|    writeCBP_BIT_CABAC (block, ((*cnt_nonz>0)?1:0), cbp8x8, currMB, 1, eep_dp);
 1153|  1.67M|    mrate    = arienco_bits_written (eep_dp) - mrate;
 1154|  1.67M|    rate    += mrate;
 1155|  1.67M|  }
 1156|       |
 1157|       |  //----- luminance coefficients -----
 1158|  1.67M|  if (*cnt_nonz)
 1159|  44.4k|  {
 1160|  44.4k|    rate += writeLumaCoeff8x8 (block, mode, currMB->luma_transform_size_8x8_flag);
 1161|  44.4k|  }
 1162|       |
 1163|  1.67M|  return (double)distortion + lambda * (double)rate;
 1164|  1.67M|}
 1165|       |
 1166|       |
 1167|       |/*!
 1168|       | *************************************************************************************
 1169|       | * \brief
 1170|       | *    Gets mode offset for intra16x16 mode
 1171|       | *************************************************************************************
 1172|       | */
 1173|       |int I16Offset (int cbp, int i16mode)
 1174|   420k|{
 1175|   420k|  return (cbp&15?13:1) + i16mode + ((cbp&0x30)>>2);
 1176|   420k|}
 1177|       |
 1178|       |
 1179|       |/*!
 1180|       | *************************************************************************************
 1181|       | * \brief
 1182|       | *    Sets modes and reference frames for an macroblock
 1183|       | *************************************************************************************
 1184|       | */
 1185|       |void SetModesAndRefframeForBlocks (int mode)
 1186|  4.50M|{
 1187|  4.50M|  int i,j,k,l;
 1188|  4.50M|  Macroblock *currMB = &img->mb_data[img->current_mb_nr];
 1189|  4.50M|  int  bframe  = (img->type==B_SLICE);
 1190|       |
 1191|  4.50M|  int list_offset   = ((img->MbaffFrameFlag)&&(currMB->mb_field))? img->current_mb_nr%2 ? 4 : 2 : 0;
 1192|       |
 1193|       |  //--- macroblock type ---
 1194|  4.50M|  currMB->mb_type = mode;
 1195|       |
 1196|  4.50M|#if BI_PREDICTION
 1197|  4.50M|  if (mode == 1)
 1198|   966k|    currMB->bi_pred_me=img->bi_pred_me[mode];  
 1199|  3.54M|  else
 1200|  3.54M|    currMB->bi_pred_me = 0;
 1201|  4.50M|#endif
 1202|       |
 1203|       |  //--- block 8x8 mode and prediction direction ---
 1204|  4.50M|  switch (mode)
 1205|  4.50M|  {
 1206|   541k|  case 0:
 1207|  2.70M|    for(i=0;i<4;i++)
 1208|  2.16M|    {
 1209|  2.16M|      currMB->b8mode[i] = 0;
 1210|  2.16M|      currMB->b8pdir[i] = (bframe?direct_pdir[img->block_x+(i%2)*2][img->block_y+(i/2)*2]:0);
 1211|  2.16M|    }
 1212|   541k|    break;
 1213|   966k|  case 1:
 1214|  1.40M|  case 2:
 1215|  1.84M|  case 3:
 1216|  9.22M|    for(i=0;i<4;i++)
 1217|  7.38M|    {
 1218|  7.38M|      currMB->b8mode[i] = mode;
 1219|  7.38M|      currMB->b8pdir[i] = best8x8pdir[mode][i];
 1220|  7.38M|    }
 1221|  1.84M|    break;
 1222|   439k|  case P8x8:
 1223|  2.19M|    for(i=0;i<4;i++)
 1224|  1.75M|    {
 1225|  1.75M|      currMB->b8mode[i]   = best8x8mode[i];
 1226|  1.75M|      currMB->b8pdir[i]   = best8x8pdir[mode][i];
 1227|  1.75M|    }
 1228|   439k|    break;
 1229|   840k|  case I4MB:
 1230|  4.20M|    for(i=0;i<4;i++)
 1231|  3.36M|    {
 1232|  3.36M|      currMB->b8mode[i] = IBLOCK;
 1233|  3.36M|      currMB->b8pdir[i] = -1;
 1234|  3.36M|    }
 1235|   840k|    break;
 1236|   840k|  case I16MB:
 1237|  4.20M|    for(i=0;i<4;i++)
 1238|  3.36M|    {
 1239|  3.36M|      currMB->b8mode[i] =  0;
 1240|  3.36M|      currMB->b8pdir[i] = -1;
 1241|  3.36M|    }
 1242|   840k|    break;
 1243|      0|  case I8MB:
 1244|      0|    for(i=0;i<4;i++)
 1245|      0|    {
 1246|      0|      currMB->b8mode[i] = I8MB;
 1247|      0|      currMB->b8pdir[i] = -1;
 1248|      0|    }
 1249|       |    //switch to 8x8 transform
 1250|      0|    currMB->luma_transform_size_8x8_flag = 1;
 1251|      0|    break;
 1252|      0|  default:
 1253|      0|    printf ("Unsupported mode in SetModesAndRefframeForBlocks!\n");
 1254|      0|    exit (1);
 1255|  4.50M|  }
 1256|       |
 1257|  54.1M|#define IS_FW ((best8x8pdir[mode][k]==0 || best8x8pdir[mode][k]==2) && (mode!=P8x8 || best8x8mode[k]!=0 || !bframe))
 1258|  21.4M|#define IS_BW ((best8x8pdir[mode][k]==1 || best8x8pdir[mode][k]==2) && (mode!=P8x8 || best8x8mode[k]!=0))
 1259|       |  //--- reference frame arrays ---
 1260|  4.50M|  if (mode==0 || mode==I4MB || mode==I16MB || mode==I8MB)
 1261|  2.22M|  {
 1262|  2.22M|    if (bframe)
 1263|  1.20M|    {
 1264|  6.00M|      for (j=0;j<4;j++)
 1265|  24.0M|        for (i=0;i<4;i++)
 1266|  19.2M|        {
 1267|  19.2M|          if(!mode)
 1268|  5.83M|          {     //direct mode
 1269|  5.83M|            enc_picture->ref_idx[LIST_0][img->block_x+i][img->block_y+j] = direct_ref_idx[LIST_0][img->block_x+i][img->block_y+j];
 1270|  5.83M|            enc_picture->ref_idx[LIST_1][img->block_x+i][img->block_y+j] = direct_ref_idx[LIST_1][img->block_x+i][img->block_y+j];
 1271|  5.83M|          }
 1272|  13.3M|          else
 1273|  13.3M|          {   //intra
 1274|  13.3M|            enc_picture->ref_idx[LIST_0][img->block_x+i][img->block_y+j] = -1;
 1275|  13.3M|            enc_picture->ref_idx[LIST_1][img->block_x+i][img->block_y+j] = -1;
 1276|       |
 1277|  13.3M|          }
 1278|  19.2M|        }
 1279|  1.20M|    }
 1280|  1.02M|    else
 1281|  1.02M|    {
 1282|  5.10M|      for (j=0;j<4;j++)
 1283|  20.4M|        for (i=0;i<4;i++)
 1284|  16.3M|        {
 1285|  16.3M|          enc_picture->ref_idx[LIST_0][img->block_x+i][img->block_y+j] = (mode==0?0:-1);
 1286|  16.3M|        }
 1287|  1.02M|    }
 1288|  2.22M|  }
 1289|  2.28M|  else
 1290|  2.28M|  {
 1291|  2.28M|    if (bframe)
 1292|  1.57M|    {
 1293|  7.89M|      for (j=0;j<4;j++)
 1294|  31.5M|        for (i=0;i<4;i++)
 1295|  25.2M|        {
 1296|  25.2M|          k = 2*(j/2)+(i/2);
 1297|  25.2M|          l = 2*(j%2)+(i%2);
 1298|       |
 1299|  25.2M|          if(mode == P8x8 && best8x8mode[k]==0)
 1300|  3.83M|          {
 1301|  3.83M|            enc_picture->ref_idx[LIST_0][img->block_x+i][img->block_y+j] = direct_ref_idx[LIST_0][img->block_x+i][img->block_y+j];
 1302|  3.83M|            enc_picture->ref_idx[LIST_1][img->block_x+i][img->block_y+j] = direct_ref_idx[LIST_1][img->block_x+i][img->block_y+j];
 1303|  3.83M|          }
 1304|  21.4M|          else
 1305|  21.4M|          {
 1306|  21.4M|#if BI_PREDICTION
 1307|  21.4M|            if (mode ==1 && currMB->bi_pred_me && IS_FW && IS_BW)
 1308|      0|            {
 1309|      0|              enc_picture->ref_idx[LIST_0][img->block_x+i][img->block_y+j] = 0;
 1310|      0|              enc_picture->ref_idx[LIST_1][img->block_x+i][img->block_y+j] = 0;
 1311|      0|            }
 1312|  21.4M|            else
 1313|  21.4M|#endif
 1314|  21.4M|            {
 1315|  21.4M|              enc_picture->ref_idx[LIST_0][img->block_x+i][img->block_y+j] = (IS_FW ? best8x8fwref[mode][k] : -1);
 1316|  21.4M|              enc_picture->ref_idx[LIST_1][img->block_x+i][img->block_y+j] = (IS_BW ? best8x8bwref[mode][k] : -1);
 1317|  21.4M|            }
 1318|  21.4M|          }
 1319|  25.2M|        }
 1320|  1.57M|    }
 1321|   706k|    else
 1322|   706k|    {
 1323|  3.53M|      for (j=0;j<4;j++)
 1324|  14.1M|        for (i=0;i<4;i++)
 1325|  11.2M|        {
 1326|  11.2M|          k = 2*(j/2)+(i/2);
 1327|  11.2M|          l = 2*(j%2)+(i%2);
 1328|  11.2M|          enc_picture->ref_idx[LIST_0][img->block_x+i][img->block_y+j] = (IS_FW ? best8x8fwref[mode][k] : -1);
 1329|  11.2M|        }
 1330|   706k|    }
 1331|  2.28M|  }
 1332|       |
 1333|  22.5M|  for (j=0;j<4;j++)
 1334|  18.0M|  {
 1335|  90.1M|    for (i=0;i<4;i++)
 1336|  72.1M|    {
 1337|  72.1M|      enc_picture->ref_pic_id [LIST_0][img->block_x+i][img->block_y+j] =
 1338|  72.1M|        (enc_picture->ref_idx[LIST_0][img->block_x+i][img->block_y+j]>=0 ?
 1339|  34.4M|         enc_picture->ref_pic_num[LIST_0 + list_offset][enc_picture->ref_idx[LIST_0][img->block_x+i][img->block_y+j]]:
 1340|  72.1M|         -1);
 1341|  72.1M|    }
 1342|  18.0M|  }
 1343|  4.50M|  if (bframe)
 1344|  2.77M|  {
 1345|  13.8M|    for (j=0;j<4;j++)
 1346|  11.1M|    {
 1347|  55.5M|      for (i=0;i<4;i++)
 1348|  44.4M|      {
 1349|  44.4M|        enc_picture->ref_pic_id [LIST_1][img->block_x+i][img->block_y+j] =
 1350|  44.4M|          (enc_picture->ref_idx[LIST_1][img->block_x+i][img->block_y+j]>=0 ?
 1351|  20.1M|           enc_picture->ref_pic_num[LIST_1 + list_offset][enc_picture->ref_idx[LIST_1][img->block_x+i][img->block_y+j]]:
 1352|  44.4M|           -1);
 1353|  44.4M|      }
 1354|       |
 1355|  11.1M|    }
 1356|  2.77M|  }
 1357|       |
 1358|       |
 1359|  4.50M|#undef IS_FW
 1360|  4.50M|#undef IS_BW
 1361|  4.50M|}
 1362|       |
 1363|       |
 1364|       |/*!
 1365|       | *************************************************************************************
 1366|       | * \brief
 1367|       | *    Intra 16x16 mode decision
 1368|       | *************************************************************************************
 1369|       | */
 1370|       |void
 1371|       |Intra16x16_Mode_Decision (Macroblock* currMB, int* i16mode)
 1372|   420k|{
 1373|       |  // Residue Color Transform
 1374|   420k|  int residue_R, residue_G, residue_B;
 1375|   420k|  int c_ipmode = img->mb_data[img->current_mb_nr].c_ipred_mode;
 1376|   420k|  int i, j, temp;
 1377|   420k|  int pic_pix_x   = img->pix_x;
 1378|   420k|  int pic_pix_y   = img->pix_y;
 1379|   420k|  pel_t   **imgY_orig  = imgY_org;
 1380|   420k|  pel_t   ***imgUV_orig  = imgUV_org;
 1381|   420k|  int cr_cbp;
 1382|       |
 1383|   420k|  intrapred_luma_16x16 ();   /* make intra pred for all 4 new modes */
 1384|       |
 1385|   420k|  if(!img->residue_transform_flag)
 1386|   420k|    find_sad_16x16 (i16mode);   /* get best new intra mode */
 1387|       |
 1388|       |  // Residue Color Transform
 1389|   420k|  if(img->residue_transform_flag)
 1390|      0|  {
 1391|      0|    for (j=0; j<16; j++)
 1392|      0|      for (i=0; i<16; i++)
 1393|      0|      {
 1394|      0|        residue_B = imgUV_orig[0][pic_pix_y+j][pic_pix_x+i] - img->mprr_c[0][c_ipmode][i][j];
 1395|      0|        residue_G = imgY_orig[pic_pix_y+j][pic_pix_x+i] - img->mprr_2[*i16mode][j][i];
 1396|      0|        residue_R = imgUV_orig[1][pic_pix_y+j][pic_pix_x+i] - img->mprr_c[1][c_ipmode][i][j];
 1397|       |        
 1398|       |        /* Forward Residue Transform */
 1399|      0|        resTrans_R[i][j] = residue_R-residue_B;
 1400|      0|        temp = residue_B+(resTrans_R[i][j]>>1);
 1401|      0|        resTrans_B[i][j] = residue_G-temp;
 1402|      0|        resTrans_G[i][j] = temp+(resTrans_B[i][j]>>1);
 1403|       |        
 1404|      0|        img->m7[i][j]  = resTrans_G[i][j];
 1405|      0|      }
 1406|      0|  }
 1407|       |
 1408|   420k|  currMB->cbp = dct_luma_16x16 (*i16mode);
 1409|       |
 1410|       |  // Residue Color Transform
 1411|   420k|  if(img->residue_transform_flag)
 1412|      0|  {
 1413|      0|    for (j=0; j<16; j++)
 1414|      0|      for (i=0; i<16; i++)
 1415|      0|      {
 1416|      0|        rec_resG[i][j] = img->m7[i][j];
 1417|      0|        img->m7[i][j]  = resTrans_R[i][j];
 1418|      0|      }
 1419|       |
 1420|      0|    cr_cbp = dct_chroma(0, 0);
 1421|       |
 1422|      0|    for (j=0; j<16; j++)
 1423|      0|      for (i=0; i<16; i++)
 1424|      0|      {
 1425|      0|        rec_resR[i][j] = img->m7[i][j];
 1426|      0|        img->m7[i][j]  = resTrans_B[i][j];
 1427|      0|      }
 1428|       |      
 1429|      0|    cr_cbp = dct_chroma(1, cr_cbp);
 1430|       |
 1431|      0|    for (j=0; j<16; j++)
 1432|      0|      for (i=0; i<16; i++)
 1433|      0|      {
 1434|      0|        rec_resB[i][j] = img->m7[i][j];
 1435|      0|      }
 1436|       |
 1437|      0|    currMB->cbp += (cr_cbp<<4);
 1438|       |
 1439|       |    /* Inverse Residue Transform */
 1440|      0|    for (j=0; j<16; j++)
 1441|      0|      for (i=0; i<16; i++)
 1442|      0|      {
 1443|      0|        temp      = rec_resG[i][j]-(rec_resB[i][j]>>1);
 1444|      0|        residue_G = rec_resB[i][j]+temp;
 1445|      0|        residue_B = temp - (rec_resR[i][j]>>1);
 1446|      0|        residue_R = residue_B+rec_resR[i][j];
 1447|       |        
 1448|      0|        enc_picture->imgUV[0][pic_pix_y+j][pic_pix_x+i] = min(img->max_imgpel_value_uv,max(0,residue_B+(int)img->mprr_c[0][c_ipmode][i][j]));
 1449|      0|        enc_picture->imgY[pic_pix_y+j][pic_pix_x+i]     = min(img->max_imgpel_value,max(0,residue_G+(int)img->mprr_2[*i16mode][j][i]));
 1450|      0|        enc_picture->imgUV[1][pic_pix_y+j][pic_pix_x+i] = min(img->max_imgpel_value_uv,max(0,residue_R+(int)img->mprr_c[1][c_ipmode][i][j]));
 1451|      0|      }
 1452|      0|  }
 1453|   420k|}
 1454|       |
 1455|       |
 1456|       |
 1457|       |/*!
 1458|       | *************************************************************************************
 1459|       | * \brief
 1460|       | *    Sets Coefficients and reconstruction for an 8x8 block
 1461|       | *************************************************************************************
 1462|       | */
 1463|       |void SetCoeffAndReconstruction8x8 (Macroblock* currMB)
 1464|  90.8k|{
 1465|  90.8k|  int block, k, j, i;
 1466|       |
 1467|       |
 1468|       |  //============= MIXED TRANSFORM SIZES FOR 8x8 PARTITION ==============
 1469|       |  //--------------------------------------------------------------------
 1470|  90.8k|  int l;
 1471|  90.8k|  int bframe = img->type==B_SLICE;
 1472|  90.8k|  int list_offset   = ((img->MbaffFrameFlag)&&(currMB->mb_field))? img->current_mb_nr%2 ? 4 : 2 : 0;
 1473|       |
 1474|  90.8k|  if (currMB->luma_transform_size_8x8_flag)
 1475|      0|  {
 1476|      0|    assert(input->AllowTransform8x8);
 1477|       |
 1478|       |    //============= set mode and ref. frames ==============
 1479|      0|    for(i=0;i<4;i++)
 1480|      0|    {
 1481|      0|      currMB->b8mode[i]   = part8x8mode[i];
 1482|      0|      currMB->b8pdir[i]   = part8x8pdir[i];
 1483|      0|    }
 1484|       |
 1485|      0|    if (bframe)
 1486|      0|    {
 1487|      0|      for (j=0;j<4;j++)
 1488|      0|        for (i=0;i<4;i++)
 1489|      0|        {
 1490|      0|          k = 2*(j/2)+(i/2);
 1491|      0|          l = 2*(j%2)+(i%2);
 1492|      0|          enc_picture->ref_idx[LIST_0][img->block_x+i][img->block_y+j] = part8x8fwref[k];
 1493|      0|          enc_picture->ref_idx[LIST_1][img->block_x+i][img->block_y+j] = part8x8bwref[k];
 1494|      0|        }
 1495|      0|    }
 1496|      0|    else
 1497|      0|    {
 1498|      0|      for (j=0;j<4;j++)
 1499|      0|        for (i=0;i<4;i++)
 1500|      0|        {
 1501|      0|          k = 2*(j/2)+(i/2);
 1502|      0|          l = 2*(j%2)+(i%2);
 1503|      0|          enc_picture->ref_idx[LIST_0][img->block_x+i][img->block_y+j] = part8x8fwref[k];
 1504|      0|        }
 1505|      0|    }
 1506|       |
 1507|      0|    for (j=0;j<4;j++)
 1508|      0|    {
 1509|      0|      for (i=0;i<4;i++)
 1510|      0|      {
 1511|      0|        enc_picture->ref_pic_id [LIST_0][img->block_x+i][img->block_y+j] =
 1512|      0|          (enc_picture->ref_idx[LIST_0][img->block_x+i][img->block_y+j]>=0 ?
 1513|      0|          enc_picture->ref_pic_num[LIST_0 + list_offset][enc_picture->ref_idx[LIST_0][img->block_x+i][img->block_y+j]]:
 1514|      0|        -1);
 1515|      0|      }
 1516|      0|    }
 1517|      0|    if (bframe)
 1518|      0|    {
 1519|      0|      for (j=0;j<4;j++)
 1520|      0|      {
 1521|      0|        for (i=0;i<4;i++)
 1522|      0|        {
 1523|      0|          enc_picture->ref_pic_id [LIST_1][img->block_x+i][img->block_y+j] =
 1524|      0|            (enc_picture->ref_idx[LIST_1][img->block_x+i][img->block_y+j]>=0 ?
 1525|      0|            enc_picture->ref_pic_num[LIST_1 + list_offset][enc_picture->ref_idx[LIST_1][img->block_x+i][img->block_y+j]]:
 1526|      0|          -1);
 1527|      0|        }
 1528|       |
 1529|      0|      }
 1530|      0|    }
 1531|       |
 1532|       |    //====== set the mv's for 8x8 partition with transform size 8x8 ======
 1533|       |    //save the mv data for 4x4 transform
 1534|      0|    StoreMV8x8(1);
 1535|       |    //set new mv data for 8x8 transform
 1536|      0|    RestoreMV8x8(0);
 1537|       |
 1538|       |    //============= get pre-calculated data ==============
 1539|       |    //restore coefficients from 8x8 transform
 1540|      0|    for (block=0; block<4; block++)
 1541|      0|    for (k=0; k<4; k++)
 1542|      0|    for (j=0; j<2; j++)
 1543|      0|    for (i=0; i<65; i++)
 1544|      0|      img->cofAC[block][k][j][i] = cofAC_8x8ts[block][k][j][i];
 1545|       |    
 1546|       |    //restore reconstruction 
 1547|      0|    if (cnt_nonz8_8x8ts <= _LUMA_8x8_COEFF_COST_ && 
 1548|      0|        ((img->qp + img->bitdepth_luma_qp_scale)!=0 || img->lossless_qpprime_flag==0))
 1549|      0|    {
 1550|      0|      currMB->cbp     = 0;
 1551|      0|      currMB->cbp_blk = 0;
 1552|      0|      for (j=0; j<16; j++)
 1553|      0|        for (i=0; i<16; i++)
 1554|       |          // Residue Color Transform
 1555|      0|          if(!img->residue_transform_flag)
 1556|      0|            enc_picture->imgY[img->pix_y+j][img->pix_x+i] = mpr_8x8ts[j][i];
 1557|      0|          else
 1558|      0|            rec_resG[i][j] = 0;
 1559|      0|    }
 1560|      0|    else
 1561|      0|    {
 1562|      0|      currMB->cbp     = cbp8_8x8ts;
 1563|      0|      currMB->cbp_blk = cbp_blk8_8x8ts;
 1564|      0|      for (j=0; j<16; j++)
 1565|      0|        for (i=0; i<16; i++)
 1566|       |          // Residue Color Transform
 1567|      0|          if(!img->residue_transform_flag)
 1568|      0|            enc_picture->imgY[img->pix_y+j][img->pix_x+i] = rec_mbY_8x8ts[j][i];
 1569|      0|          else
 1570|      0|            rec_resG[i][j] =  rec_resG_8x8ts[i][j];
 1571|      0|    }
 1572|       |
 1573|       |    // Residue Color Transform
 1574|      0|    for (j=0; j<16; j++)
 1575|      0|    for (i=0; i<16; i++)
 1576|      0|    {
 1577|      0|      mprRGB[0][i][j] = mprRGB_8x8ts[0][i][j];
 1578|      0|      mprRGB[1][i][j] = mprRGB_8x8ts[1][i][j];
 1579|      0|      mprRGB[2][i][j] = mprRGB_8x8ts[2][i][j];
 1580|      0|      resTrans_R[i][j] = resTrans_R_8x8ts[i][j];
 1581|      0|      resTrans_B[i][j] = resTrans_B_8x8ts[i][j];
 1582|      0|    }
 1583|      0|  }
 1584|  90.8k|  else
 1585|  90.8k|  {
 1586|       |    //============= get pre-calculated data ==============
 1587|       |    //---------------------------------------------------
 1588|       |    //--- restore coefficients ---
 1589|   636k|    for (block=0; block<4+img->num_blk8x8_uv; block++)
 1590|  2.72M|    for (k=0; k<4; k++)
 1591|  6.54M|    for (j=0; j<2; j++)
 1592|   287M|    for (i=0; i<65; i++)
 1593|   283M|      img->cofAC[block][k][j][i] = cofAC8x8[block][k][j][i];
 1594|       |
 1595|  90.8k|    if (cnt_nonz_8x8<=5 && img->type!=SP_SLICE &&
 1596|  90.8k|        ((img->qp + img->bitdepth_luma_qp_scale)!=0 || img->lossless_qpprime_flag==0))
 1597|  87.6k|    {
 1598|  87.6k|      currMB->cbp     = 0;
 1599|  87.6k|      currMB->cbp_blk = 0;
 1600|  1.48M|      for (j=0; j<16; j++)
 1601|  23.8M|      for (i=0; i<16; i++)
 1602|       |        // Residue Color Transform
 1603|  22.4M|        if(!img->residue_transform_flag)
 1604|  22.4M|          enc_picture->imgY[img->pix_y+j][img->pix_x+i] = mpr8x8[j][i];
 1605|      0|        else
 1606|      0|          rec_resG[i][j] = 0;
 1607|  87.6k|    }
 1608|  3.23k|    else
 1609|  3.23k|    {
 1610|  3.23k|      currMB->cbp     = cbp8x8;
 1611|  3.23k|      currMB->cbp_blk = cbp_blk8x8;
 1612|  55.0k|      for (j=0; j<16; j++)
 1613|   880k|      for (i=0; i<16; i++)
 1614|       |        // Residue Color Transform
 1615|   828k|        if(!img->residue_transform_flag)
 1616|   828k|          enc_picture->imgY[img->pix_y+j][img->pix_x+i] = rec_mbY8x8[j][i];
 1617|      0|        else
 1618|      0|          rec_resG[i][j] =  rec_resG_8x8[i][j];
 1619|  3.23k|    }
 1620|       |
 1621|       |    // Residue Color Transform
 1622|  1.54M|    for (j=0; j<16; j++)
 1623|  24.7M|    for (i=0; i<16; i++)
 1624|  23.2M|    {
 1625|  23.2M|      mprRGB[0][i][j] = mprRGB_8x8[0][i][j];
 1626|  23.2M|      mprRGB[1][i][j] = mprRGB_8x8[1][i][j];
 1627|  23.2M|      mprRGB[2][i][j] = mprRGB_8x8[2][i][j];
 1628|  23.2M|      resTrans_R[i][j] = resTrans_R_8x8[i][j];
 1629|  23.2M|      resTrans_B[i][j] = resTrans_B_8x8[i][j];
 1630|  23.2M|    }
 1631|  90.8k|  }
 1632|  90.8k|}
 1633|       |
 1634|       |
 1635|       |/*!
 1636|       | *************************************************************************************
 1637|       | * \brief
 1638|       | *    Sets motion vectors for an macroblock
 1639|       | *************************************************************************************
 1640|       | */
 1641|       |void SetMotionVectorsMB (Macroblock* currMB, int bframe)
 1642|   109k|{
 1643|   109k|  int i, j, k, l, m, mode8, pdir8, ref, by, bx, bxr;
 1644|   109k|  short ******all_mv  = img->all_mv;
 1645|   109k|  short ******pred_mv = img->pred_mv;
 1646|   109k|  int  bw_ref;
 1647|       |
 1648|       |#ifdef PMVFAST  
 1649|       |  int mvblocktype = input->InterSearch8x8? 4 : 1;
 1650|       |#endif
 1651|       |
 1652|   547k|  for (j=0; j<4; j++)
 1653|  2.18M|    for (i=0; i<4; i++)
 1654|  1.75M|    {
 1655|  1.75M|      mode8 = currMB->b8mode[k=2*(j/2)+(i/2)];
 1656|  1.75M|      l     = 2*(j%2)+(i%2);
 1657|  1.75M|      by    = img->block_y+j;
 1658|  1.75M|      bxr   = img->block_x+i;
 1659|  1.75M|      bx    = img->block_x+i+4;
 1660|       |      
 1661|  1.75M|      pdir8 = currMB->b8pdir[k];
 1662|  1.75M|      ref    = enc_picture->ref_idx[LIST_0][bxr][by];
 1663|  1.75M|      bw_ref = enc_picture->ref_idx[LIST_1][bxr][by];
 1664|       |      
 1665|  1.75M|#if BI_PREDICTION
 1666|  1.75M|      if (currMB->bi_pred_me && (pdir8 == 2) && currMB->mb_type==1)
 1667|      0|      {
 1668|      0|        all_mv  = currMB->bi_pred_me == 1 ? img->bipred_mv1 : img->bipred_mv2;
 1669|      0|        ref = 0;
 1670|      0|        bw_ref = 0;
 1671|      0|      }
 1672|  1.75M|#endif
 1673|       |      
 1674|  1.75M|      if (!bframe)
 1675|   880k|      {
 1676|   880k|        if (pdir8>=0) //(mode8!=IBLOCK)&&(mode8!=I16MB))  // && ref != -1)
 1677|   457k|        {
 1678|   457k|          enc_picture->mv[LIST_0][bxr][by][0] = all_mv [i][j][LIST_0][ ref][mode8][0];
 1679|   457k|          enc_picture->mv[LIST_0][bxr][by][1] = all_mv [i][j][LIST_0][ ref][mode8][1];
 1680|   457k|        }
 1681|   423k|        else
 1682|   423k|        {
 1683|   423k|          enc_picture->mv[LIST_0][bxr][by][0] = 0;
 1684|   423k|          enc_picture->mv[LIST_0][bxr][by][1] = 0;
 1685|   423k|        }
 1686|   880k|      }
 1687|   870k|      else
 1688|   870k|      {
 1689|   870k|        if (pdir8==-1) // intra
 1690|  5.48k|        {
 1691|  5.48k|          enc_picture->mv[LIST_0][bxr][by][0] = 0;
 1692|  5.48k|          enc_picture->mv[LIST_0][bxr][by][1] = 0;
 1693|  5.48k|          enc_picture->mv[LIST_1][bxr][by][0] = 0;
 1694|  5.48k|          enc_picture->mv[LIST_1][bxr][by][1] = 0;
 1695|  5.48k|        }
 1696|   864k|        else if (pdir8==0) // forward
 1697|   287k|        {
 1698|   287k|          enc_picture->mv[LIST_0][bxr][by][0] = all_mv [i][j][LIST_0][ ref][mode8][0];
 1699|   287k|          enc_picture->mv[LIST_0][bxr][by][1] = all_mv [i][j][LIST_0][ ref][mode8][1];
 1700|   287k|          enc_picture->mv[LIST_1][bxr][by][0] = 0;
 1701|   287k|          enc_picture->mv[LIST_1][bxr][by][1] = 0;
 1702|   287k|        }
 1703|   577k|        else if (pdir8==1) // backward
 1704|   223k|        {
 1705|   223k|          enc_picture->mv[LIST_0][bxr][by][0] = 0;
 1706|   223k|          enc_picture->mv[LIST_0][bxr][by][1] = 0;
 1707|       |
 1708|   223k|          enc_picture->mv[LIST_1][bxr][by][0] = all_mv[i][j][LIST_1][bw_ref][mode8][0];
 1709|   223k|          enc_picture->mv[LIST_1][bxr][by][1] = all_mv[i][j][LIST_1][bw_ref][mode8][1];
 1710|   223k|        }
 1711|   354k|        else if (pdir8==2) // bidir
 1712|   354k|        {
 1713|   354k|          enc_picture->mv[LIST_0][bxr][by][0] = all_mv [i][j][LIST_0][ ref][mode8][0];
 1714|   354k|          enc_picture->mv[LIST_0][bxr][by][1] = all_mv [i][j][LIST_0][ ref][mode8][1];
 1715|       |
 1716|       |
 1717|   354k|          enc_picture->mv[LIST_1][bxr][by][0] = all_mv[i][j][LIST_1][bw_ref][mode8][0];
 1718|   354k|          enc_picture->mv[LIST_1][bxr][by][1] = all_mv[i][j][LIST_1][bw_ref][mode8][1];
 1719|   354k|        }
 1720|      0|        else
 1721|      0|        {
 1722|      0|          error("invalid direction mode", 255);
 1723|      0|        }
 1724|   870k|      }
 1725|  1.75M|  }
 1726|       |
 1727|       |  // copy all the motion vectors into rdopt structure
 1728|       |  // Can simplify this by copying the MV's of the best mode (TBD)
 1729|   109k|  if(img->MbaffFrameFlag)
 1730|      0|  {
 1731|      0|    for(i=0;i<4;i++)
 1732|      0|    {
 1733|      0|      for(j=0;j<4;j++)
 1734|      0|      {
 1735|      0|        for (k=0;k<2;k++)
 1736|      0|        {
 1737|      0|          for(l=0;l<img->max_num_references;l++)
 1738|      0|          {
 1739|      0|            for(m=0;m<9;m++)
 1740|      0|            {
 1741|      0|              rdopt->all_mv [i][j][k][l][m][0]  = all_mv [i][j][k][l][m][0];
 1742|      0|              rdopt->pred_mv[i][j][k][l][m][0]  = pred_mv[i][j][k][l][m][0];
 1743|       |
 1744|      0|              rdopt->all_mv [i][j][k][l][m][1]  = all_mv [i][j][k][l][m][1];
 1745|      0|              rdopt->pred_mv[i][j][k][l][m][1]  = pred_mv[i][j][k][l][m][1];
 1746|      0|            }
 1747|      0|          }
 1748|      0|        }
 1749|      0|      }
 1750|      0|    }
 1751|      0|  }
 1752|   109k|}
 1753|       |
 1754|       |
 1755|       |
 1756|       |/*!
 1757|       | *************************************************************************************
 1758|       | * \brief
 1759|       | *    R-D Cost for a macroblock
 1760|       | *************************************************************************************
 1761|       | */
 1762|       |int RDCost_for_macroblocks (double   lambda,       // <-- lagrange multiplier
 1763|       |                            int      mode,         // <-- modus (0-COPY/DIRECT, 1-16x16, 2-16x8, 3-8x16, 4-8x8(+), 5-Intra4x4, 6-Intra16x16)
 1764|       |                            double*  min_rdcost,   // <-> minimum rate-distortion cost
 1765|       |                            int i16mode )
 1766|  1.50M|{
 1767|  1.50M|  int         i, j, k; //, k, ****ip4;
 1768|  1.50M|  int         rate=0;
 1769|  1.50M|  int64       distortion=0;
 1770|  1.50M|  double      rdcost;
 1771|  1.50M|  Macroblock  *currMB   = &img->mb_data[img->current_mb_nr];
 1772|  1.50M|  Macroblock  *prevMB   = img->current_mb_nr ? &img->mb_data[img->current_mb_nr-1] : NULL;
 1773|  1.50M|  int         bframe    = (img->type==B_SLICE);
 1774|  1.50M|  int         tmp_cc;
 1775|  1.50M|  int         use_of_cc =  (img->type!=I_SLICE &&  input->symbol_mode!=CABAC);
 1776|  1.50M|  int         cc_rate, dummy;
 1777|  1.50M|  int         cr_cbp=0, uv;
 1778|       |
 1779|       |  //=====
 1780|       |  //=====  SET REFERENCE FRAMES AND BLOCK MODES
 1781|       |  //=====
 1782|  1.50M|  SetModesAndRefframeForBlocks (mode);
 1783|       |
 1784|       |  //=====
 1785|       |  //=====  GET COEFFICIENTS, RECONSTRUCTIONS, CBP
 1786|       |  //=====
 1787|  1.50M|  if (bframe && mode==0)
 1788|   155k|  {
 1789|   155k|    int block_x=img->pix_x>>2;
 1790|   155k|    int block_y=img->pix_y>>2;
 1791|   779k|    for (i=0;i<4;i++)
 1792|  3.11M|      for (j=0;j<4;j++)
 1793|  2.49M|        if (direct_pdir[block_x+i][block_y+j]<0)
 1794|      0|          return 0;
 1795|   155k|  }
 1796|       |
 1797|  1.50M|  if (mode<P8x8)
 1798|   573k|  {
 1799|   573k|    LumaResidualCoding ();
 1800|   573k|    if(mode==0 && currMB->cbp==0 && currMB->luma_transform_size_8x8_flag==1) //for B_skip, luma_transform_size_8x8_flag=0 only
 1801|      0|      return 0;
 1802|   573k|  }
 1803|   931k|  else if (mode==P8x8)
 1804|  90.8k|  {
 1805|  90.8k|    SetCoeffAndReconstruction8x8 (currMB);
 1806|  90.8k|  }
 1807|   840k|  else if (mode==I4MB)
 1808|   420k|  {
 1809|   420k|    currMB->cbp = Mode_Decision_for_Intra4x4Macroblock (lambda, &dummy);
 1810|       |
 1811|       |    // Residue Color Transform
 1812|   420k|    if(img->residue_transform_flag)
 1813|      0|    {
 1814|      0|      for(i=0; i<2; i++)
 1815|      0|      for(j=0; j<4; j++)
 1816|      0|      for(k=0; k<4; k++)
 1817|      0|        if(cbp_chroma_block[i][j][k])
 1818|      0|          cr_cbp = 2;
 1819|       |
 1820|      0|      for(uv=0; uv<2; uv++)
 1821|      0|        cr_cbp = dct_chroma_DC(uv, cr_cbp);
 1822|       |
 1823|      0|      currMB->cbp += (cr_cbp<<4);
 1824|      0|    }
 1825|   420k|  }
 1826|   420k|  else if (mode==I16MB)
 1827|   420k|  {
 1828|   420k|    Intra16x16_Mode_Decision  (currMB, &i16mode);
 1829|   420k|  }
 1830|      0|  else if(mode==I8MB){
 1831|      0|    currMB->cbp = Mode_Decision_for_new_Intra8x8Macroblock(lambda, &dummy);
 1832|       |
 1833|       |    // Residue Color Transform
 1834|      0|    if(img->residue_transform_flag)
 1835|      0|    {
 1836|      0|      for(i=0; i<2; i++)
 1837|      0|      for(j=0; j<4; j++)
 1838|      0|      for(k=0; k<4; k++)
 1839|      0|        if(cbp_chroma_block[i][j][k])
 1840|      0|          cr_cbp = 2;
 1841|       |
 1842|      0|      for(uv=0; uv<2; uv++)
 1843|      0|        cr_cbp = dct_chroma_DC(uv, cr_cbp);
 1844|       |
 1845|      0|      currMB->cbp += (cr_cbp<<4);
 1846|      0|    }
 1847|      0|  }
 1848|       |
 1849|  1.50M|  if (input->rdopt==2 && img->type!=B_SLICE)
 1850|      0|  {
 1851|       |    // We need the reconstructed prediction residue for the simulated decoders.
 1852|      0|    compute_residue_mb (mode==I16MB?i16mode:-1);
 1853|      0|  }
 1854|       |
 1855|       |  //Rate control
 1856|  1.50M|  if (mode == I16MB)
 1857|   420k|  {
 1858|  7.14M|    for(i=0; i<16; i++)
 1859|   114M|    for(j=0; j<16; j++)
 1860|   107M|      pred[j][i] = img->mprr_2[i16mode][j][i];
 1861|   420k|  }else
 1862|  1.08M|  {
 1863|  18.4M|    for(i=0; i<16; i++)
 1864|   295M|    for(j=0; j<16; j++)
 1865|   277M|      pred[j][i] = img->mpr[i][j];
 1866|  1.08M|  }
 1867|       |
 1868|  1.50M|  img->i16offset = 0;
 1869|  1.50M|  dummy = 0;
 1870|  1.50M|  if ((!(img->residue_transform_flag && (mode==I4MB || mode==I16MB || mode==I8MB))) && img->yuv_format!=YUV400)
 1871|  1.50M|    ChromaResidualCoding (&dummy);
 1872|  1.50M|  if (mode==I16MB)     img->i16offset = I16Offset  (currMB->cbp, i16mode);
 1873|       |
 1874|       |  //=====
 1875|       |  //=====   GET DISTORTION
 1876|       |  //=====
 1877|       |  // LUMA
 1878|  1.50M|  if (input->rdopt==2 && img->type!=B_SLICE)
 1879|      0|  {
 1880|      0|    for (k=0; k<input->NoOfDecoders ;k++)
 1881|      0|    {
 1882|      0|      decode_one_mb (k, currMB);
 1883|      0|      for (j=0; j<MB_BLOCK_SIZE; j++)
 1884|      0|      for (i=img->opix_x; i<img->opix_x+MB_BLOCK_SIZE; i++)
 1885|      0|      {
 1886|      0|        distortion += img->quad [imgY_org[img->opix_y+j][i] - decs->decY[k][img->opix_y+j][i]];
 1887|      0|      }
 1888|      0|    }
 1889|      0|    distortion /= input->NoOfDecoders;
 1890|      0|  }
 1891|  1.50M|  else
 1892|  1.50M|  {
 1893|  25.5M|    for (j=0; j<16; j++)
 1894|   409M|    for (i=img->opix_x; i<img->opix_x+16; i++)
 1895|   385M|    {
 1896|   385M|      distortion += img->quad [imgY_org[j+img->opix_y][i] - enc_picture->imgY[img->pix_y+j][i]];
 1897|   385M|    }
 1898|  1.50M|  }
 1899|       |
 1900|  1.50M|  if (img->yuv_format != YUV400)
 1901|  1.50M|  {
 1902|       |    // CHROMA
 1903|  13.5M|    for (j=0; j<img->mb_cr_size_y; j++)
 1904|   108M|    for (i=img->opix_c_x; i<img->opix_c_x+img->mb_cr_size_x; i++)
 1905|  96.3M|    {
 1906|  96.3M|      distortion += img->quad [imgUV_org[0][j+img->opix_c_y][i] - enc_picture->imgUV[0][img->pix_c_y+j][i]];
 1907|  96.3M|      distortion += img->quad [imgUV_org[1][j+img->opix_c_y][i] - enc_picture->imgUV[1][img->pix_c_y+j][i]];
 1908|  96.3M|    }
 1909|  1.50M|  }
 1910|       |
 1911|       |
 1912|       |  //=====   S T O R E   C O D I N G   S T A T E   =====
 1913|       |  //---------------------------------------------------
 1914|  1.50M|  store_coding_state (cs_cm);
 1915|       |
 1916|       |  //=====
 1917|       |  //=====   GET RATE
 1918|       |  //=====
 1919|       |  //----- macroblock header -----
 1920|  1.50M|  if (use_of_cc)
 1921|      0|  {
 1922|      0|    if (currMB->mb_type!=0 || (bframe && currMB->cbp!=0))
 1923|      0|    {
 1924|       |      // cod counter and macroblock mode are written ==> do not consider code counter
 1925|      0|      tmp_cc = img->cod_counter;
 1926|      0|      rate   = writeMBLayer (1);
 1927|      0|      ue_linfo (tmp_cc, dummy, &cc_rate, &dummy);
 1928|      0|      rate  -= cc_rate;
 1929|      0|      img->cod_counter = tmp_cc;
 1930|      0|    }
 1931|      0|    else
 1932|      0|    {
 1933|       |      // cod counter is just increased  ==> get additional rate
 1934|      0|      ue_linfo (img->cod_counter+1, dummy, &rate,    &dummy);
 1935|      0|      ue_linfo (img->cod_counter,   dummy, &cc_rate, &dummy);
 1936|      0|      rate -= cc_rate;
 1937|      0|    }
 1938|      0|  }
 1939|  1.50M|  else
 1940|  1.50M|  {
 1941|  1.50M|    rate = writeMBLayer (1);
 1942|  1.50M|  }
 1943|       |
 1944|       |  //=====   R E S T O R E   C O D I N G   S T A T E   =====
 1945|       |  //-------------------------------------------------------
 1946|  1.50M|  reset_coding_state (cs_cm);
 1947|       |
 1948|  1.50M|  rdcost = (double)distortion + lambda * max(0.5,(double)rate);
 1949|       |
 1950|  1.50M|#if defined(SPEC_CPU)
 1951|  1.50M|   if (((rdcost - *min_rdcost) >= -1e-12) ||
 1952|       |#else
 1953|       |  if (rdcost >= *min_rdcost ||
 1954|       |#endif
 1955|  1.50M|      ((img->qp + img->bitdepth_luma_qp_scale)==0 && img->lossless_qpprime_flag==1 && distortion!=0))
 1956|  1.31M|  {
 1957|  1.31M|    return 0;
 1958|  1.31M|  }
 1959|       |
 1960|       |
 1961|   191k|  if ((img->MbaffFrameFlag) && (mode ? 0: ((img->type == B_SLICE) ? !currMB->cbp:1)))  // AFF and current is skip
 1962|      0|  {
 1963|      0|    if (img->current_mb_nr%2) //bottom
 1964|      0|    {
 1965|      0|      if (prevMB->mb_type ? 0:((img->type == B_SLICE) ? !prevMB->cbp:1)) //top is skip
 1966|      0|      {
 1967|      0|        if (!(field_flag_inference() == currMB->mb_field)) //skip only allowed when correct inference
 1968|      0|          return 0;
 1969|      0|      }
 1970|      0|    }
 1971|      0|  }
 1972|       |
 1973|       |  //=====   U P D A T E   M I N I M U M   C O S T   =====
 1974|       |  //-----------------------------------------------------
 1975|   191k|  *min_rdcost = rdcost;
 1976|   191k|  return 1;
 1977|   191k|}
 1978|       |
 1979|       |
 1980|       |
 1981|       |
 1982|       |
 1983|       |/*!
 1984|       | *************************************************************************************
 1985|       | * \brief
 1986|       | *    Store macroblock parameters
 1987|       | *************************************************************************************
 1988|       | */
 1989|       |void store_macroblock_parameters (int mode)
 1990|   191k|{
 1991|   191k|  int  i, j, k, ****i4p, ***i3p;
 1992|   191k|  Macroblock *currMB  = &img->mb_data[img->current_mb_nr];
 1993|   191k|  int        bframe   = (img->type==B_SLICE);
 1994|       |
 1995|       |  //--- store best mode ---
 1996|   191k|  best_mode = mode;
 1997|   191k|  best_c_imode = currMB->c_ipred_mode;
 1998|   191k|  best_i16offset = img->i16offset;
 1999|   191k|#if BI_PREDICTION
 2000|       |  // If condition is not really necessary.
 2001|   191k|  if (mode == 1)
 2002|  29.0k|    bi_pred_me=currMB->bi_pred_me;  
 2003|   162k|  else
 2004|   162k|    bi_pred_me=0;
 2005|   191k|#endif
 2006|       |
 2007|   956k|  for (i=0; i<4; i++)
 2008|   765k|  {
 2009|   765k|    b8mode[i]   = currMB->b8mode[i];
 2010|   765k|    b8pdir[i]   = currMB->b8pdir[i];
 2011|   765k|  }
 2012|       |  // Residue Color Transform
 2013|   956k|  for (k=0, j=img->block_y; j<img->block_y+4; j++)
 2014|  3.82M|  for (i=img->block_x; i<img->block_x+4; i++, k++)
 2015|  3.06M|  {
 2016|  3.06M|    b4_ipredmode[k] = img->ipredmode[i][j];
 2017|  3.06M|    b4_intra_pred_modes[k] = currMB->intra_pred_modes[k];
 2018|  3.06M|  }
 2019|   956k|  for(i = k = 0; i < 4; i++)
 2020|  3.82M|  for(j = 0; j < 4; j++,k++)
 2021|  3.06M|  {
 2022|  3.06M|    b8_ipredmode8x8[i][j] = img->ipredmode8x8[img->block_x+i][img->block_y+j];
 2023|       |    //only every fourth value relevant
 2024|  3.06M|    b8_intra_pred_modes8x8[k] = currMB->intra_pred_modes8x8[k];
 2025|  3.06M|  }
 2026|       |
 2027|       |  //--- reconstructed blocks ----
 2028|  3.25M|  for (j=0; j<16; j++)
 2029|  52.0M|  for (i=0; i<16; i++)
 2030|  48.9M|  {
 2031|  48.9M|    rec_mbY[j][i] = enc_picture->imgY[img->pix_y+j][img->pix_x+i];
 2032|  48.9M|  }
 2033|       |
 2034|   191k|  if (img->yuv_format != YUV400)
 2035|   191k|  {
 2036|  1.72M|    for (j=0; j<img->mb_cr_size_y; j++)
 2037|  13.7M|    for (i=0; i<img->mb_cr_size_x; i++)
 2038|  12.2M|    {
 2039|  12.2M|      rec_mbU[j][i] = enc_picture->imgUV[0][img->pix_c_y+j][img->pix_c_x+i];
 2040|  12.2M|      rec_mbV[j][i] = enc_picture->imgUV[1][img->pix_c_y+j][img->pix_c_x+i];
 2041|  12.2M|    }
 2042|   191k|  }
 2043|       |
 2044|       |
 2045|       |  //--- store results of decoders ---
 2046|   191k|  if (input->rdopt==2 && img->type!=B_SLICE)
 2047|      0|  {
 2048|      0|    for (k=0; k<input->NoOfDecoders; k++)
 2049|      0|    {
 2050|      0|      for (j=img->pix_y; j<img->pix_y+16; j++)
 2051|      0|      for (i=img->pix_x; i<img->pix_x+16; i++)
 2052|      0|      {
 2053|       |        // Keep the decoded values of each MB for updating the ref frames
 2054|      0|        decs->decY_best[k][j][i] = decs->decY[k][j][i];
 2055|      0|      }
 2056|      0|    }
 2057|      0|  }
 2058|       |
 2059|       |  //--- coeff, cbp, kac ---
 2060|   191k|  if (mode || bframe)
 2061|   154k|  {
 2062|   154k|    i4p=cofAC; cofAC=img->cofAC; img->cofAC=i4p;
 2063|   154k|    i3p=cofDC; cofDC=img->cofDC; img->cofDC=i3p;
 2064|   154k|    cbp     = currMB->cbp;
 2065|   154k|    cbp_blk = currMB->cbp_blk;
 2066|   154k|  }
 2067|  36.4k|  else
 2068|  36.4k|  {
 2069|  36.4k|    cbp_blk = cbp = 0;
 2070|  36.4k|  }
 2071|       |
 2072|       |  //--- store transform size ---
 2073|   191k|  luma_transform_size_8x8_flag = currMB->luma_transform_size_8x8_flag;
 2074|       |//  NoMbPartLessThan8x8Flag  = currMB->NoMbPartLessThan8x8Flag;   //DEL-VG-29072004
 2075|       |
 2076|       |
 2077|   956k|  for (j=0; j<4; j++)
 2078|  3.82M|  for (i=0; i<4; i++)
 2079|  3.06M|  {
 2080|  3.06M|    frefframe[j][i] = enc_picture->ref_idx[LIST_0][img->block_x+i][img->block_y+j];
 2081|       |
 2082|  3.06M|    if (bframe)
 2083|  1.16M|    {
 2084|  1.16M|      brefframe[j][i] = enc_picture->ref_idx[LIST_1][img->block_x+i][img->block_y+j];
 2085|  1.16M|    }
 2086|  3.06M|  }
 2087|       |
 2088|   191k|}
 2089|       |
 2090|       |
 2091|       |/*!
 2092|       | *************************************************************************************
 2093|       | * \brief
 2094|       | *    Set stored macroblock parameters
 2095|       | *************************************************************************************
 2096|       | */
 2097|       |void set_stored_macroblock_parameters ()
 2098|   109k|{
 2099|   109k|  int  i, j, k, ****i4p, ***i3p,l;
 2100|   109k|  Macroblock  *currMB  = &img->mb_data[img->current_mb_nr];
 2101|   109k|  int         mode     = best_mode;
 2102|   109k|  int         bframe   = (img->type==B_SLICE);
 2103|   109k|  int         **ipredmodes = img->ipredmode;
 2104|       |
 2105|   109k|  imgpel        **imgY  = enc_picture->imgY;
 2106|   109k|  imgpel       ***imgUV = enc_picture->imgUV;
 2107|       |
 2108|   109k|  int        list_offset   = ((img->MbaffFrameFlag)&&(currMB->mb_field))? img->current_mb_nr%2 ? 4 : 2 : 0;
 2109|       |
 2110|       |  //===== reconstruction values =====
 2111|  1.86M|  for (j=0; j<16; j++)
 2112|  29.7M|  for (i=0; i<16; i++)
 2113|  28.0M|  {
 2114|  28.0M|    imgY[img->pix_y+j][img->pix_x+i] = rec_mbY[j][i];
 2115|       |
 2116|  28.0M|    if(img->MbaffFrameFlag)
 2117|      0|      rdopt->rec_mbY[j][i]       = rec_mbY[j][i];
 2118|  28.0M|  }
 2119|       |
 2120|   109k|  if (img->yuv_format != YUV400)
 2121|   109k|  {
 2122|   984k|    for (j=0; j<img->mb_cr_size_y; j++)
 2123|  7.87M|      for (i=0; i<img->mb_cr_size_x; i++)
 2124|  7.00M|      {
 2125|  7.00M|        imgUV[0][img->pix_c_y+j][img->pix_c_x+i] = rec_mbU[j][i];
 2126|  7.00M|        imgUV[1][img->pix_c_y+j][img->pix_c_x+i] = rec_mbV[j][i];
 2127|       |        
 2128|  7.00M|        if(img->MbaffFrameFlag)
 2129|      0|        {
 2130|      0|          rdopt->rec_mbU[j][i]           = rec_mbU[j][i];
 2131|      0|          rdopt->rec_mbV[j][i]           = rec_mbV[j][i];
 2132|      0|        }
 2133|  7.00M|      }
 2134|   109k|  }
 2135|       |
 2136|       |  //===== coefficients and cbp =====
 2137|   109k|  i4p=cofAC; cofAC=img->cofAC; img->cofAC=i4p;
 2138|   109k|  i3p=cofDC; cofDC=img->cofDC; img->cofDC=i3p;
 2139|   109k|  currMB->cbp      = cbp;
 2140|   109k|  currMB->cbp_blk = cbp_blk;
 2141|       |  //==== macroblock type ====
 2142|   109k|  currMB->mb_type = mode;
 2143|       |
 2144|   109k|  if(img->MbaffFrameFlag)
 2145|      0|  {
 2146|      0|    rdopt->mode = mode;
 2147|      0|    rdopt->i16offset = img->i16offset;
 2148|      0|    rdopt->cbp = cbp;
 2149|      0|    rdopt->cbp_blk = cbp_blk;
 2150|      0|    rdopt->mb_type  = mode;
 2151|       |
 2152|      0|    rdopt->prev_qp=currMB->prev_qp;
 2153|      0|    rdopt->prev_delta_qp=currMB->prev_delta_qp;
 2154|      0|    rdopt->qp=currMB->qp;
 2155|       |
 2156|      0|    for(i=0;i<4+img->num_blk8x8_uv;i++)
 2157|      0|      for(j=0;j<4;j++)
 2158|      0|        for(k=0;k<2;k++)
 2159|      0|          for(l=0;l<65;l++)
 2160|      0|            rdopt->cofAC[i][j][k][l] = img->cofAC[i][j][k][l];
 2161|       |
 2162|      0|    for(i=0;i<3;i++)
 2163|      0|        for(k=0;k<2;k++)
 2164|      0|          for(l=0;l<18;l++)
 2165|      0|            rdopt->cofDC[i][k][l] = img->cofDC[i][k][l];
 2166|      0|  }
 2167|       |
 2168|       |
 2169|   547k|  for (i=0; i<4; i++)
 2170|   437k|  {
 2171|   437k|    currMB->b8mode[i]   = b8mode[i];
 2172|   437k|    currMB->b8pdir[i]   = b8pdir[i];
 2173|   437k|    if(img->MbaffFrameFlag)
 2174|      0|    {
 2175|      0|      rdopt->b8mode[i]  = b8mode[i];
 2176|      0|      rdopt->b8pdir[i]  = b8pdir[i];
 2177|      0|    }
 2178|   437k|  }
 2179|       |
 2180|   109k|#if BI_PREDICTION
 2181|       |  // Again if condition seems not necessary, Just a precaution
 2182|   109k|  if (currMB->mb_type == 1)
 2183|  14.2k|    currMB->bi_pred_me=bi_pred_me;  
 2184|  95.1k|  else
 2185|  95.1k|    currMB->bi_pred_me=0;  
 2186|   109k|#endif
 2187|       |
 2188|       |  //if P8x8 mode and transform size 4x4 choosen, restore motion vector data for this transform size 
 2189|   109k|  if (mode == P8x8 && !luma_transform_size_8x8_flag && input->AllowTransform8x8)
 2190|      0|    RestoreMV8x8(1);
 2191|       |  
 2192|       |  //==== transform size flag ====
 2193|   109k|  if (((currMB->cbp & 15) == 0) && !(IS_OLDINTRA(currMB) || currMB->mb_type == I8MB))
 2194|  99.9k|    currMB->luma_transform_size_8x8_flag = 0;
 2195|  9.47k|  else
 2196|  9.47k|    currMB->luma_transform_size_8x8_flag = luma_transform_size_8x8_flag;
 2197|       |
 2198|   109k|  rdopt->luma_transform_size_8x8_flag  = currMB->luma_transform_size_8x8_flag;
 2199|       |
 2200|       |
 2201|   109k|  if (input->rdopt==2 && img->type!=B_SLICE)
 2202|      0|  {
 2203|       |    //! save the MB Mode of every macroblock
 2204|      0|    decs->dec_mb_mode[img->mb_x][img->mb_y] = mode;
 2205|      0|  }
 2206|       |
 2207|       |  //==== reference frames =====
 2208|   547k|  for (j=0; j<4; j++)
 2209|  2.18M|  for (i=0; i<4; i++)
 2210|  1.75M|  {
 2211|       |    // backward prediction or intra
 2212|  1.75M|    if ((currMB->b8pdir[i/2+(j/2)*2] == 1) || IS_INTRA(currMB))
 2213|   652k|    {
 2214|   652k|      enc_picture->ref_idx[LIST_0][img->block_x+i][img->block_y+j] = -1;
 2215|   652k|      enc_picture->ref_pic_id [LIST_0][img->block_x+i][img->block_y+j] = -1;
 2216|       |
 2217|   652k|      enc_picture->mv[LIST_0][img->block_x+i][img->block_y+j][0] =0;
 2218|   652k|      enc_picture->mv[LIST_0][img->block_x+i][img->block_y+j][1] = 0;
 2219|   652k|      if(img->MbaffFrameFlag)
 2220|      0|        rdopt->refar[LIST_0][j][i] = -1;
 2221|   652k|    }
 2222|  1.09M|    else
 2223|  1.09M|    {
 2224|  1.09M|#if BI_PREDICTION
 2225|  1.09M|      if (currMB->bi_pred_me && (currMB->b8pdir[i/2+(j/2)*2] == 2) && currMB->mb_type==1)
 2226|      0|      {
 2227|      0|        short   ******bipred_mv = currMB->bi_pred_me == 1 ? img->bipred_mv1 : img->bipred_mv2;
 2228|       |
 2229|      0|        enc_picture->ref_idx[LIST_0][img->block_x+i][img->block_y+j] = 0; 
 2230|      0|        enc_picture->ref_pic_id [LIST_0][img->block_x+i][img->block_y+j] = enc_picture->ref_pic_num[LIST_0 + list_offset][0];
 2231|      0|        enc_picture->mv[LIST_0][img->block_x+i][img->block_y+j][0] = bipred_mv[i][j][LIST_0][0][currMB->b8mode[i/2+(j/2)*2]][0];
 2232|      0|        enc_picture->mv[LIST_0][img->block_x+i][img->block_y+j][1] = bipred_mv[i][j][LIST_0][0][currMB->b8mode[i/2+(j/2)*2]][1];        
 2233|      0|        if(img->MbaffFrameFlag)
 2234|      0|          rdopt->refar[LIST_0][j][i] = 0;        
 2235|      0|      }
 2236|  1.09M|      else
 2237|  1.09M|#endif
 2238|  1.09M|      {
 2239|  1.09M|        enc_picture->ref_idx[LIST_0][img->block_x+i][img->block_y+j] = frefframe[j][i];
 2240|  1.09M|        enc_picture->ref_pic_id [LIST_0][img->block_x+i][img->block_y+j] = enc_picture->ref_pic_num[LIST_0 + list_offset][enc_picture->ref_idx[LIST_0][img->block_x+i][img->block_y+j]];
 2241|  1.09M|        enc_picture->mv[LIST_0][img->block_x+i][img->block_y+j][0] = img->all_mv[i][j][LIST_0][frefframe[j][i]][currMB->b8mode[i/2+(j/2)*2]][0];
 2242|  1.09M|        enc_picture->mv[LIST_0][img->block_x+i][img->block_y+j][1] = img->all_mv[i][j][LIST_0][frefframe[j][i]][currMB->b8mode[i/2+(j/2)*2]][1];
 2243|  1.09M|        if(img->MbaffFrameFlag)
 2244|      0|          rdopt->refar[LIST_0][j][i] = frefframe[j][i];
 2245|  1.09M|      }
 2246|  1.09M|    }
 2247|       |
 2248|       |    // forward prediction or intra
 2249|  1.75M|    if ((currMB->b8pdir[i/2+(j/2)*2] == 0) || IS_INTRA(currMB))
 2250|  1.17M|    {
 2251|  1.17M|      enc_picture->ref_idx[LIST_1][img->block_x+i][img->block_y+j] = -1;
 2252|  1.17M|      enc_picture->ref_pic_id [LIST_1][img->block_x+i][img->block_y+j] = -1;
 2253|  1.17M|      enc_picture->mv[LIST_1][img->block_x+i][img->block_y+j][0] =0;
 2254|  1.17M|      enc_picture->mv[LIST_1][img->block_x+i][img->block_y+j][1] = 0;
 2255|  1.17M|      if(img->MbaffFrameFlag)
 2256|      0|        rdopt->refar[LIST_1][j][i] = -1;
 2257|  1.17M|    }
 2258|  1.75M|  }
 2259|       |
 2260|   109k|  if (bframe)
 2261|  54.4k|  {
 2262|   272k|    for (j=0; j<4; j++)
 2263|  1.08M|      for (i=0; i<4; i++)
 2264|   870k|      {
 2265|       |
 2266|       |        // forward
 2267|   870k|        if (IS_INTRA(currMB)||(currMB->b8pdir[i/2+(j/2)*2] == 0))
 2268|   293k|        {
 2269|   293k|          enc_picture->ref_idx[LIST_1][img->block_x+i][img->block_y+j] = -1;
 2270|   293k|          enc_picture->ref_pic_id [LIST_1][img->block_x+i][img->block_y+j] = -1;
 2271|   293k|          enc_picture->mv[LIST_1][img->block_x+i][img->block_y+j][0] = 0;
 2272|   293k|          enc_picture->mv[LIST_1][img->block_x+i][img->block_y+j][1] = 0;
 2273|   293k|          if(img->MbaffFrameFlag)
 2274|      0|            rdopt->refar[LIST_1][j][i] = -1;
 2275|   293k|        }
 2276|   577k|        else
 2277|   577k|        {
 2278|   577k|#if BI_PREDICTION
 2279|   577k|          if (currMB->bi_pred_me && (currMB->b8pdir[i/2+(j/2)*2] == 2) && currMB->mb_type==1)
 2280|      0|          {
 2281|      0|            short   ******bipred_mv = currMB->bi_pred_me == 1 ? img->bipred_mv1 : img->bipred_mv2;
 2282|       |
 2283|      0|            enc_picture->ref_idx[LIST_1][img->block_x+i][img->block_y+j] = 0; 
 2284|      0|            enc_picture->ref_pic_id [LIST_1][img->block_x+i][img->block_y+j] = enc_picture->ref_pic_num[LIST_1 + list_offset][0];
 2285|      0|            enc_picture->mv[LIST_1][img->block_x+i][img->block_y+j][0] = bipred_mv[i][j][LIST_1][0][currMB->b8mode[i/2+(j/2)*2]][0];
 2286|      0|            enc_picture->mv[LIST_1][img->block_x+i][img->block_y+j][1] = bipred_mv[i][j][LIST_1][0][currMB->b8mode[i/2+(j/2)*2]][1];        
 2287|      0|          if(img->MbaffFrameFlag)
 2288|      0|            rdopt->refar[LIST_1][j][i] = 0;        
 2289|       |            //printf("mvl0 %d %d\n",enc_picture->mv[LIST_1][img->block_x+i][img->block_y+j][0],enc_picture->mv[LIST_1][img->block_x+i][img->block_y+j][1]);
 2290|      0|          }
 2291|   577k|          else
 2292|   577k|#endif
 2293|   577k|          {
 2294|   577k|            enc_picture->ref_idx[LIST_1][img->block_x+i][img->block_y+j] = brefframe[j][i];
 2295|   577k|            enc_picture->ref_pic_id [LIST_1][img->block_x+i][img->block_y+j] = enc_picture->ref_pic_num[LIST_1 + list_offset][enc_picture->ref_idx[LIST_1][img->block_x+i][img->block_y+j]];
 2296|   577k|            enc_picture->mv[LIST_1][img->block_x+i][img->block_y+j][0] = img->all_mv[i][j][LIST_1][brefframe[j][i]][currMB->b8mode[i/2+(j/2)*2]][0];
 2297|   577k|            enc_picture->mv[LIST_1][img->block_x+i][img->block_y+j][1] = img->all_mv[i][j][LIST_1][brefframe[j][i]][currMB->b8mode[i/2+(j/2)*2]][1];
 2298|   577k|            if(img->MbaffFrameFlag)
 2299|      0|              rdopt->refar[LIST_1][j][i] = brefframe[j][i];
 2300|   577k|          }
 2301|   577k|        }
 2302|   870k|      }
 2303|  54.4k|  }
 2304|       |
 2305|       |  //==== intra prediction modes ====
 2306|   109k|  currMB->c_ipred_mode = best_c_imode;
 2307|   109k|  img->i16offset = best_i16offset;
 2308|       |
 2309|   109k|  if(currMB->mb_type == I8MB)
 2310|      0|  {
 2311|      0|    for(i = k = 0; i < 4; i++)
 2312|      0|      for(j = 0; j < 4; j++,k++)
 2313|      0|      {
 2314|      0|        img->ipredmode[img->block_x+i][img->block_y+j] = img->ipredmode8x8[img->block_x+i][img->block_y+j];
 2315|       |        //only every fourth value is relevant
 2316|      0|        currMB->intra_pred_modes[k] = currMB->intra_pred_modes8x8[k];
 2317|      0|      }
 2318|      0|  }
 2319|   109k|  else if (mode!=I4MB && mode!=I8MB)
 2320|   104k|  {
 2321|   521k|    for (k=0, j=img->block_y; j<img->block_y+4; j++)
 2322|  2.08M|      for (   i=img->block_x; i<img->block_x+4; i++, k++)
 2323|  1.66M|      {
 2324|  1.66M|        ipredmodes           [i][j] = DC_PRED;
 2325|  1.66M|        currMB->intra_pred_modes[k] = DC_PRED;
 2326|  1.66M|      }
 2327|   104k|  }
 2328|       |  // Residue Color Transform
 2329|  5.10k|  else if (mode == I4MB)
 2330|  5.10k|  {
 2331|  25.5k|    for (k=0, j=img->block_y; j<img->block_y+4; j++)
 2332|   102k|      for (i=img->block_x; i<img->block_x+4; i++, k++)
 2333|  81.6k|      {
 2334|  81.6k|        ipredmodes[i][j] = b4_ipredmode[k];
 2335|  81.6k|        currMB->intra_pred_modes[k] = b4_intra_pred_modes[k];
 2336|  81.6k|      }
 2337|  5.10k|  }
 2338|       |
 2339|   109k|  if(currMB->mb_type == I8MB)
 2340|      0|  {
 2341|      0|    for(i = k = 0; i < 4; i++)
 2342|      0|      for(j = 0; j < 4; j++,k++)
 2343|      0|      {
 2344|       |        //img->ipredmode[img->block_x+i][img->block_y+j] = img->ipredmode8x8[img->block_x+i][img->block_y+j];
 2345|       |        //only every fourth value relevant
 2346|       |        //currMB->intra_pred_modes[k] = currMB->intra_pred_modes8x8[k];
 2347|      0|        img->ipredmode[img->block_x+i][img->block_y+j] = b8_ipredmode8x8[i][j];
 2348|      0|        currMB->intra_pred_modes[k] = b8_intra_pred_modes8x8[k];
 2349|      0|      }
 2350|      0|  }
 2351|       |
 2352|       |
 2353|   109k|  if(img->MbaffFrameFlag)
 2354|      0|  {
 2355|      0|    for (k=0, j=img->block_y; j<img->block_y+4; j++)
 2356|      0|      for (   i=img->block_x; i<img->block_x+4; i++, k++)
 2357|      0|      {
 2358|      0|        rdopt->ipredmode[i][j]     = ipredmodes[i][j];
 2359|      0|        rdopt->intra_pred_modes[k] = currMB->intra_pred_modes[k];
 2360|      0|      }
 2361|      0|    rdopt->c_ipred_mode = currMB->c_ipred_mode;
 2362|      0|    rdopt->i16offset = img->i16offset;  // DH
 2363|      0|  }
 2364|       |
 2365|       |  //==== motion vectors =====
 2366|   109k|  SetMotionVectorsMB (currMB, bframe);
 2367|   109k|}
 2368|       |
 2369|       |
 2370|       |
 2371|       |/*!
 2372|       | *************************************************************************************
 2373|       | * \brief
 2374|       | *    Set reference frames and motion vectors
 2375|       | *************************************************************************************
 2376|       | */
 2377|       |void SetRefAndMotionVectors (int block, int mode, int pdir, int fwref, int bwref)
 2378|   545k|{
 2379|   545k|  int     i, j=0;
 2380|   545k|  int     bslice  = (img->type==B_SLICE);
 2381|   545k|  int     pmode   = (mode==1||mode==2||mode==3?mode:4);
 2382|   545k|  int     j0      = ((block/2)<<1);
 2383|   545k|  int     i0      = ((block%2)<<1);
 2384|   545k|  int     j1      = j0 + (input->part_size[pmode][1]);
 2385|   545k|  int     i1      = i0 + (input->part_size[pmode][0]);
 2386|       |
 2387|   545k|  int list_offset   = ((img->MbaffFrameFlag)&&(img->mb_data[img->current_mb_nr].mb_field))? img->current_mb_nr%2 ? 4 : 2 : 0;
 2388|   545k|  Macroblock  *currMB  = &img->mb_data[img->current_mb_nr];
 2389|       |
 2390|   545k|  if (pdir<0)
 2391|      0|  {
 2392|      0|    for (j=j0; j<j1; j++)
 2393|      0|    for (i=i0; i<i1; i++)
 2394|      0|    {
 2395|      0|      enc_picture->mv[LIST_0][img->block_x+i][img->block_y+j][0] = 0;
 2396|      0|      enc_picture->mv[LIST_0][img->block_x+i][img->block_y+j][1] = 0;
 2397|      0|      enc_picture->mv[LIST_1][img->block_x+i][img->block_y+j][0] = 0;
 2398|      0|      enc_picture->mv[LIST_1][img->block_x+i][img->block_y+j][1] = 0;
 2399|      0|      enc_picture->ref_idx[LIST_0][img->block_x+i][img->block_y+j] = -1;
 2400|      0|      enc_picture->ref_idx[LIST_1][img->block_x+i][img->block_y+j] = -1;
 2401|      0|      enc_picture->ref_pic_id[LIST_0][img->block_x+i][img->block_y+j] = -1;
 2402|      0|      enc_picture->ref_pic_id[LIST_1][img->block_x+i][img->block_y+j] = -1;
 2403|      0|    }
 2404|      0|    return;
 2405|      0|  }
 2406|       |
 2407|   545k|  if (!bslice)
 2408|   218k|  {
 2409|   729k|    for (j=j0; j<j1; j++)
 2410|  1.67M|    for (i=i0; i<i1; i++)
 2411|  1.16M|    {
 2412|  1.16M|      enc_picture->mv[LIST_0][img->block_x+i][img->block_y+j][0] = img->all_mv[i][j][LIST_0][fwref][mode][0];
 2413|  1.16M|      enc_picture->mv[LIST_0][img->block_x+i][img->block_y+j][1] = img->all_mv[i][j][LIST_0][fwref][mode][1];
 2414|  1.16M|      enc_picture->ref_idx[LIST_0][img->block_x+i][img->block_y+j] = fwref;
 2415|  1.16M|      enc_picture->ref_pic_id[LIST_0][img->block_x+i][img->block_y+j] = enc_picture->ref_pic_num[LIST_0+list_offset][enc_picture->ref_idx[LIST_0][img->block_x+i][img->block_y+j]];
 2416|  1.16M|    }
 2417|   218k|  }
 2418|   326k|  else
 2419|   326k|  {
 2420|  1.08M|    for (j=j0; j<j1; j++)
 2421|  2.50M|      for (i=i0; i<i1; i++)
 2422|  1.74M|      {
 2423|  1.74M|        if (mode==0)
 2424|   792k|        {
 2425|   792k|          pdir  =direct_pdir[img->block_x+i][img->block_y+j];
 2426|   792k|          fwref =direct_ref_idx[LIST_0][img->block_x+i][img->block_y+j];
 2427|   792k|          bwref =direct_ref_idx[LIST_1][img->block_x+i][img->block_y+j];
 2428|   792k|        }
 2429|       |
 2430|  1.74M|        if ((pdir==0 || pdir==2))
 2431|  1.07M|        {
 2432|  1.07M|#if BI_PREDICTION
 2433|  1.07M|          if (currMB->bi_pred_me && (pdir == 2) && mode == 1)
 2434|      0|          {
 2435|      0|            short   ******bipred_mv = currMB->bi_pred_me == 1 ? img->bipred_mv1 : img->bipred_mv2;
 2436|       |
 2437|      0|              enc_picture->mv[LIST_0][img->block_x+i][img->block_y+j][0] = bipred_mv[i][j][LIST_0][0][mode][0];
 2438|      0|              enc_picture->mv[LIST_0][img->block_x+i][img->block_y+j][1] = bipred_mv[i][j][LIST_0][0][mode][1];
 2439|      0|              enc_picture->ref_idx[LIST_0][img->block_x+i][img->block_y+j] = 0;            
 2440|      0|              enc_picture->ref_pic_id[LIST_0][img->block_x+i][img->block_y+j] = enc_picture->ref_pic_num[LIST_0+list_offset][0];
 2441|      0|          }
 2442|  1.07M|          else
 2443|  1.07M|#endif
 2444|  1.07M|          {
 2445|  1.07M|            enc_picture->mv[LIST_0][img->block_x+i][img->block_y+j][0] = img->all_mv[i][j][LIST_0][fwref][mode][0];
 2446|  1.07M|            enc_picture->mv[LIST_0][img->block_x+i][img->block_y+j][1] = img->all_mv[i][j][LIST_0][fwref][mode][1];
 2447|  1.07M|            enc_picture->ref_idx[LIST_0][img->block_x+i][img->block_y+j] = fwref;
 2448|  1.07M|            enc_picture->ref_pic_id[LIST_0][img->block_x+i][img->block_y+j] = enc_picture->ref_pic_num[LIST_0+list_offset][enc_picture->ref_idx[LIST_0][img->block_x+i][img->block_y+j]];
 2449|  1.07M|          }
 2450|  1.07M|        }
 2451|   660k|        else
 2452|   660k|        {
 2453|   660k|          enc_picture->mv[LIST_0][img->block_x+i][img->block_y+j][0] = 0;
 2454|   660k|          enc_picture->mv[LIST_0][img->block_x+i][img->block_y+j][1] = 0;
 2455|   660k|          enc_picture->ref_idx[LIST_0][img->block_x+i][img->block_y+j] = -1;
 2456|   660k|          enc_picture->ref_pic_id[LIST_0][img->block_x+i][img->block_y+j] = -1;
 2457|   660k|        }
 2458|       |
 2459|  1.74M|        if ((pdir==1 || pdir==2))
 2460|  1.07M|        {
 2461|  1.07M|#if BI_PREDICTION
 2462|  1.07M|          if (currMB->bi_pred_me && (pdir == 2) && mode == 1)
 2463|      0|          {
 2464|      0|            short   ******bipred_mv = currMB->bi_pred_me == 1 ? img->bipred_mv1 : img->bipred_mv2;
 2465|       |            
 2466|      0|            enc_picture->mv[LIST_1][img->block_x+i][img->block_y+j][0] = bipred_mv[i][j][LIST_1][0][mode][0];
 2467|      0|            enc_picture->mv[LIST_1][img->block_x+i][img->block_y+j][1] = bipred_mv[i][j][LIST_1][0][mode][1];
 2468|      0|            enc_picture->ref_idx[LIST_1][img->block_x+i][img->block_y+j] = 0;            
 2469|      0|            enc_picture->ref_pic_id[LIST_1][img->block_x+i][img->block_y+j] = enc_picture->ref_pic_num[LIST_1+list_offset][0];
 2470|      0|          }
 2471|  1.07M|          else
 2472|  1.07M|#endif
 2473|  1.07M|          {
 2474|  1.07M|            enc_picture->mv[LIST_1][img->block_x+i][img->block_y+j][0] = img->all_mv[i][j][LIST_1][bwref][mode][0];
 2475|  1.07M|            enc_picture->mv[LIST_1][img->block_x+i][img->block_y+j][1] = img->all_mv[i][j][LIST_1][bwref][mode][1];
 2476|  1.07M|            enc_picture->ref_idx[LIST_1][img->block_x+i][img->block_y+j] = bwref;
 2477|  1.07M|            enc_picture->ref_pic_id[LIST_1][img->block_x+i][img->block_y+j] = enc_picture->ref_pic_num[LIST_1+list_offset][enc_picture->ref_idx[LIST_1][img->block_x+i][img->block_y+j]];
 2478|  1.07M|          }
 2479|  1.07M|        }
 2480|   665k|        else
 2481|   665k|        {
 2482|   665k|          enc_picture->mv[LIST_1][img->block_x+i][img->block_y+j][0] = 0;
 2483|   665k|          enc_picture->mv[LIST_1][img->block_x+i][img->block_y+j][1] = 0;
 2484|   665k|          enc_picture->ref_idx[LIST_1][img->block_x+i][img->block_y+j] = -1;
 2485|   665k|          enc_picture->ref_pic_id[LIST_1][img->block_x+i][img->block_y+j] = -1;
 2486|   665k|        }
 2487|  1.74M|      }
 2488|   326k|  }
 2489|   545k|}
 2490|       |
 2491|       |/*!
 2492|       | *************************************************************************************
 2493|       | * \brief
 2494|       | *    skip macroblock field inference
 2495|       | * \return
 2496|       | *    inferred field flag
 2497|       | *************************************************************************************
 2498|       | */
 2499|       |int field_flag_inference()
 2500|      0|{
 2501|      0|  int mb_field;
 2502|      0|  Macroblock *currMB = &img->mb_data[img->current_mb_nr];
 2503|       |
 2504|      0|  if (currMB->mbAvailA)
 2505|      0|  {
 2506|      0|    mb_field = img->mb_data[currMB->mbAddrA].mb_field;
 2507|      0|  }
 2508|      0|  else
 2509|      0|  {
 2510|       |    // check top macroblock pair
 2511|      0|    if (currMB->mbAvailB)
 2512|      0|    {
 2513|      0|      mb_field = img->mb_data[currMB->mbAddrB].mb_field;
 2514|      0|    }
 2515|      0|    else
 2516|      0|      mb_field = 0;
 2517|      0|  }
 2518|       |
 2519|      0|  return mb_field;
 2520|      0|}
 2521|       |
 2522|       |/*!
 2523|       | *************************************************************************************
 2524|       | * \brief
 2525|       | *    Store motion vectors for 8x8 partition
 2526|       | *************************************************************************************
 2527|       | */
 2528|       |
 2529|       |void StoreMVBlock8x8(int dir, int block8x8, int mode, int ref, int bw_ref, int pdir8, int bframe)
 2530|      0|{
 2531|      0|  int i, j, i0, j0, ii, jj;
 2532|      0|  short ******all_mv  = img->all_mv;
 2533|      0|  short ******pred_mv = img->pred_mv;
 2534|       |
 2535|       |
 2536|      0|  i0 = (block8x8%2)<<1;
 2537|      0|  j0 = (block8x8/2)<<1;
 2538|      0|  ii = i0+2;
 2539|      0|  jj = j0+2;
 2540|       |
 2541|      0|  if (!bframe)
 2542|      0|  {
 2543|      0|    if (pdir8>=0) //(mode8!=IBLOCK)&&(mode8!=I16MB))  // && ref != -1)
 2544|      0|    {
 2545|      0|      for (j=j0; j<jj; j++)
 2546|      0|        for (i=i0; i<ii; i++)
 2547|      0|        {
 2548|      0|          all_mv8x8[dir][LIST_0][i][j][0] = all_mv[i][j][LIST_0][ref][4][0];
 2549|      0|          all_mv8x8[dir][LIST_0][i][j][1] = all_mv[i][j][LIST_0][ref][4][1];
 2550|      0|          pred_mv8x8[dir][LIST_0][i][j][0] = pred_mv[i][j][LIST_0][ref][4][0];
 2551|      0|          pred_mv8x8[dir][LIST_0][i][j][1] = pred_mv[i][j][LIST_0][ref][4][1];
 2552|      0|        }
 2553|      0|    }
 2554|      0|  }
 2555|      0|  else
 2556|      0|  {
 2557|      0|    if (pdir8==0) // forward
 2558|      0|    {
 2559|      0|      for (j=j0; j<jj; j++)
 2560|      0|        for (i=i0; i<ii; i++)
 2561|      0|        {
 2562|      0|          all_mv8x8[dir][LIST_0][i][j][0] = all_mv[i][j][LIST_0][ref][mode][0];
 2563|      0|          all_mv8x8[dir][LIST_0][i][j][1] = all_mv[i][j][LIST_0][ref][mode][1];
 2564|      0|          pred_mv8x8[dir][LIST_0][i][j][0] = pred_mv[i][j][LIST_0][ref][mode][0];
 2565|      0|          pred_mv8x8[dir][LIST_0][i][j][1] = pred_mv[i][j][LIST_0][ref][mode][1];
 2566|      0|        }
 2567|      0|    }
 2568|      0|    else if (pdir8==1) // backward
 2569|      0|    {
 2570|      0|      for (j=j0; j<jj; j++)
 2571|      0|        for (i=i0; i<ii; i++)
 2572|      0|        {
 2573|      0|          all_mv8x8[dir][LIST_1][i][j][0] = all_mv[i][j][LIST_1][bw_ref][mode][0];
 2574|      0|          all_mv8x8[dir][LIST_1][i][j][1] = all_mv[i][j][LIST_1][bw_ref][mode][1];
 2575|      0|          pred_mv8x8[dir][LIST_1][i][j][0] = pred_mv[i][j][LIST_1][bw_ref][mode][0];
 2576|      0|          pred_mv8x8[dir][LIST_1][i][j][1] = pred_mv[i][j][LIST_1][bw_ref][mode][1];
 2577|      0|        }
 2578|      0|    }
 2579|      0|    else if (pdir8==2) // bidir
 2580|      0|    {
 2581|      0|      for (j=j0; j<jj; j++)
 2582|      0|        for (i=i0; i<ii; i++)
 2583|      0|        {
 2584|      0|          all_mv8x8[dir][LIST_0][i][j][0] = all_mv[i][j][LIST_0][ref][mode][0];
 2585|      0|          all_mv8x8[dir][LIST_0][i][j][1] = all_mv[i][j][LIST_0][ref][mode][1];
 2586|      0|          pred_mv8x8[dir][LIST_0][i][j][0] = pred_mv[i][j][LIST_0][ref][mode][0];
 2587|      0|          pred_mv8x8[dir][LIST_0][i][j][1] = pred_mv[i][j][LIST_0][ref][mode][1];
 2588|       |
 2589|      0|          all_mv8x8[dir][LIST_1][i][j][0] = all_mv[i][j][LIST_1][bw_ref][mode][0];
 2590|      0|          all_mv8x8[dir][LIST_1][i][j][1] = all_mv[i][j][LIST_1][bw_ref][mode][1];
 2591|      0|          pred_mv8x8[dir][LIST_1][i][j][0] = pred_mv[i][j][LIST_1][bw_ref][mode][0];
 2592|      0|          pred_mv8x8[dir][LIST_1][i][j][1] = pred_mv[i][j][LIST_1][bw_ref][mode][1];
 2593|      0|        }
 2594|      0|    }
 2595|      0|    else
 2596|      0|    {
 2597|      0|      error("invalid direction mode", 255);
 2598|      0|    }
 2599|      0|  }
 2600|      0|}
 2601|       |
 2602|       |
 2603|       |
 2604|       |/*!
 2605|       | *************************************************************************************
 2606|       | * \brief
 2607|       | *    Store motion vectors of 8x8 partitions of one macroblock
 2608|       | *************************************************************************************
 2609|       | */
 2610|       |void StoreMV8x8(int dir)
 2611|      0|{
 2612|      0|  int block8x8;
 2613|       |
 2614|      0|  int bframe = (img->type == B_SLICE);
 2615|       |
 2616|      0|  for (block8x8=0; block8x8<4; block8x8++)
 2617|      0|    StoreMVBlock8x8(dir, block8x8, part8x8mode[block8x8],
 2618|      0|                              part8x8fwref[block8x8], part8x8bwref[block8x8], part8x8pdir[block8x8], bframe);
 2619|      0|}
 2620|       |
 2621|       |/*!
 2622|       |*************************************************************************************
 2623|       |* \brief
 2624|       |*    Restore motion vectors for 8x8 partition
 2625|       |*************************************************************************************
 2626|       |*/
 2627|       |void RestoreMVBlock8x8(int dir, int block8x8, int mode, int ref, int bw_ref, int pdir8, int bframe)
 2628|      0|{
 2629|      0|  int i, j, i0, j0, ii, jj;
 2630|      0|  short ******all_mv  = img->all_mv;
 2631|      0|  short ******pred_mv = img->pred_mv;
 2632|       |
 2633|      0|  i0 = (block8x8%2)<<1;
 2634|      0|  j0 = (block8x8/2)<<1;
 2635|      0|  ii = i0+2;
 2636|      0|  jj = j0+2;
 2637|       |
 2638|      0|  if (!bframe)
 2639|      0|  {
 2640|      0|    if (pdir8>=0) //(mode8!=IBLOCK)&&(mode8!=I16MB))  // && ref != -1)
 2641|      0|    {
 2642|      0|      for (j=j0; j<jj; j++)
 2643|      0|        for (i=i0; i<ii; i++)
 2644|      0|        {
 2645|      0|          all_mv[i][j][LIST_0][ref][4][0]  = all_mv8x8[dir][LIST_0][i][j][0] ;
 2646|      0|          all_mv[i][j][LIST_0][ref][4][1]  = all_mv8x8[dir][LIST_0][i][j][1] ;
 2647|      0|          pred_mv[i][j][LIST_0][ref][4][0] = pred_mv8x8[dir][LIST_0][i][j][0];
 2648|      0|          pred_mv[i][j][LIST_0][ref][4][1] = pred_mv8x8[dir][LIST_0][i][j][1];
 2649|      0|        }
 2650|      0|    }
 2651|      0|  }
 2652|      0|  else
 2653|      0|  {
 2654|      0|    if (pdir8==0) // forward
 2655|      0|    {
 2656|      0|      for (j=j0; j<jj; j++)
 2657|      0|        for (i=i0; i<ii; i++)
 2658|      0|        {
 2659|      0|          all_mv[i][j][LIST_0][ref][mode][0]  = all_mv8x8[dir][LIST_0][i][j][0] ;
 2660|      0|          all_mv[i][j][LIST_0][ref][mode][1]  = all_mv8x8[dir][LIST_0][i][j][1] ;
 2661|      0|          pred_mv[i][j][LIST_0][ref][mode][0] = pred_mv8x8[dir][LIST_0][i][j][0];
 2662|      0|          pred_mv[i][j][LIST_0][ref][mode][1] = pred_mv8x8[dir][LIST_0][i][j][1];
 2663|      0|        }
 2664|      0|    }
 2665|      0|    else if (pdir8==1) // backward
 2666|      0|    {
 2667|      0|      for (j=j0; j<jj; j++)
 2668|      0|        for (i=i0; i<ii; i++)
 2669|      0|        {
 2670|      0|          all_mv[i][j][LIST_1][bw_ref][mode][0]  = all_mv8x8[dir][LIST_1][i][j][0] ;
 2671|      0|          all_mv[i][j][LIST_1][bw_ref][mode][1]  = all_mv8x8[dir][LIST_1][i][j][1] ;
 2672|      0|          pred_mv[i][j][LIST_1][bw_ref][mode][0] = pred_mv8x8[dir][LIST_1][i][j][0];
 2673|      0|          pred_mv[i][j][LIST_1][bw_ref][mode][1] = pred_mv8x8[dir][LIST_1][i][j][1];
 2674|      0|        }
 2675|      0|    }
 2676|      0|    else if (pdir8==2) // bidir
 2677|      0|    {
 2678|      0|      for (j=j0; j<jj; j++)
 2679|      0|        for (i=i0; i<ii; i++)
 2680|      0|        {
 2681|      0|          all_mv[i][j][LIST_0][ref][mode][0]  = all_mv8x8[dir][LIST_0][i][j][0] ;
 2682|      0|          all_mv[i][j][LIST_0][ref][mode][1]  = all_mv8x8[dir][LIST_0][i][j][1] ;
 2683|      0|          pred_mv[i][j][LIST_0][ref][mode][0] = pred_mv8x8[dir][LIST_0][i][j][0];
 2684|      0|          pred_mv[i][j][LIST_0][ref][mode][1] = pred_mv8x8[dir][LIST_0][i][j][1];
 2685|       |
 2686|      0|          all_mv[i][j][LIST_1][bw_ref][mode][0]  = all_mv8x8[dir][LIST_1][i][j][0] ;
 2687|      0|          all_mv[i][j][LIST_1][bw_ref][mode][1]  = all_mv8x8[dir][LIST_1][i][j][1] ;
 2688|      0|          pred_mv[i][j][LIST_1][bw_ref][mode][0] = pred_mv8x8[dir][LIST_1][i][j][0];
 2689|      0|          pred_mv[i][j][LIST_1][bw_ref][mode][1] = pred_mv8x8[dir][LIST_1][i][j][1];
 2690|      0|        }
 2691|      0|    }
 2692|      0|    else
 2693|      0|    {
 2694|      0|      error("invalid direction mode", 255);
 2695|      0|    }
 2696|      0|  }
 2697|      0|}
 2698|       |
 2699|       |
 2700|       |
 2701|       |/*!
 2702|       | *************************************************************************************
 2703|       | * \brief
 2704|       | *    Restore motion vectors of 8x8 partitions of one macroblock
 2705|       | *************************************************************************************
 2706|       | */
 2707|       |void RestoreMV8x8(int dir)
 2708|      0|{
 2709|      0|  int block8x8;
 2710|       |
 2711|      0|  int bframe = (img->type == B_SLICE);
 2712|       |
 2713|      0|  for (block8x8=0; block8x8<4; block8x8++)
 2714|      0|    RestoreMVBlock8x8(dir, block8x8, part8x8mode[block8x8],
 2715|      0|                                part8x8fwref[block8x8], part8x8bwref[block8x8], part8x8pdir[block8x8], bframe);
 2716|      0|}
 2717|       |
 2718|       |
 2719|       |/*!
 2720|       | *************************************************************************************
 2721|       | * \brief
 2722|       | *    Store predictors for 8x8 partition
 2723|       | *************************************************************************************
 2724|       | */
 2725|       |
 2726|       |void StoreNewMotionVectorsBlock8x8(int dir, int block8x8, int mode, int fw_ref, int bw_ref, int pdir8, int bframe)
 2727|      0|{
 2728|      0|  int i, j, i0, j0, ii, jj;
 2729|      0|  short ******all_mv  = img->all_mv;
 2730|      0|  short ******pred_mv = img->pred_mv;
 2731|       |
 2732|       |
 2733|      0|  i0 = (block8x8%2)<<1;
 2734|      0|  j0 = (block8x8/2)<<1;
 2735|      0|  ii = i0+2;
 2736|      0|  jj = j0+2;
 2737|       |
 2738|      0|  if (pdir8<0)
 2739|      0|  {
 2740|      0|    for (j=j0; j<jj; j++)
 2741|      0|      for (i=i0; i<ii; i++)
 2742|      0|      {
 2743|      0|        all_mv8x8[dir][LIST_0][i][j][0] = 0;
 2744|      0|        all_mv8x8[dir][LIST_0][i][j][1] = 0;
 2745|      0|        all_mv8x8[dir][LIST_1][i][j][0] = 0;
 2746|      0|        all_mv8x8[dir][LIST_1][i][j][1] = 0;
 2747|      0|      }
 2748|      0|      return;
 2749|      0|  }
 2750|       |
 2751|      0|  if (!bframe)
 2752|      0|  {
 2753|      0|    for (j=j0; j<jj; j++)
 2754|      0|      for (i=i0; i<ii; i++)
 2755|      0|      {
 2756|      0|        all_mv8x8[dir][LIST_0][i][j][0] = all_mv[i][j][LIST_0][fw_ref][4][0];
 2757|      0|        all_mv8x8[dir][LIST_0][i][j][1] = all_mv[i][j][LIST_0][fw_ref][4][1];
 2758|      0|        pred_mv8x8[dir][LIST_0][i][j][0] = pred_mv[i][j][LIST_0][fw_ref][4][0];
 2759|      0|        pred_mv8x8[dir][LIST_0][i][j][1] = pred_mv[i][j][LIST_0][fw_ref][4][1];
 2760|      0|      }
 2761|      0|  }
 2762|      0|  else
 2763|      0|  {
 2764|      0|    if ((pdir8==0 || pdir8==2))
 2765|      0|    {
 2766|      0|      for (j=j0; j<jj; j++)
 2767|      0|        for (i=i0; i<ii; i++)
 2768|      0|        {
 2769|      0|          all_mv8x8[dir][LIST_0][i][j][0] = all_mv[i][j][LIST_0][fw_ref][mode][0];
 2770|      0|          all_mv8x8[dir][LIST_0][i][j][1] = all_mv[i][j][LIST_0][fw_ref][mode][1];
 2771|      0|          pred_mv8x8[dir][LIST_0][i][j][0] = pred_mv[i][j][LIST_0][fw_ref][mode][0];
 2772|      0|          pred_mv8x8[dir][LIST_0][i][j][1] = pred_mv[i][j][LIST_0][fw_ref][mode][1];
 2773|      0|        }
 2774|      0|    }
 2775|      0|    else
 2776|      0|    {
 2777|      0|      for (j=j0; j<jj; j++)
 2778|      0|        for (i=i0; i<ii; i++)
 2779|      0|        {
 2780|      0|          all_mv8x8[dir][LIST_0][i][j][0] = 0;
 2781|      0|          all_mv8x8[dir][LIST_0][i][j][1] = 0;
 2782|      0|        }
 2783|      0|    }
 2784|       |
 2785|      0|    if ((pdir8==1 || pdir8==2))
 2786|      0|    {
 2787|      0|      for (j=j0; j<jj; j++)
 2788|      0|        for (i=i0; i<ii; i++)
 2789|      0|        {
 2790|      0|          all_mv8x8[dir][LIST_1][i][j][0] = all_mv[i][j][LIST_1][bw_ref][mode][0];
 2791|      0|          all_mv8x8[dir][LIST_1][i][j][1] = all_mv[i][j][LIST_1][bw_ref][mode][1];
 2792|      0|          pred_mv8x8[dir][LIST_1][i][j][0] = pred_mv[i][j][LIST_1][bw_ref][mode][0];
 2793|      0|          pred_mv8x8[dir][LIST_1][i][j][1] = pred_mv[i][j][LIST_1][bw_ref][mode][1];
 2794|      0|        }
 2795|      0|    }
 2796|      0|    else
 2797|      0|    {
 2798|      0|      for (j=j0; j<jj; j++)
 2799|      0|        for (i=i0; i<ii; i++)
 2800|      0|        {
 2801|      0|          all_mv8x8[dir][LIST_1][i][j][0] = 0;
 2802|      0|          all_mv8x8[dir][LIST_1][i][j][1] = 0;
 2803|      0|        }
 2804|      0|    }
 2805|      0|  }
 2806|      0|}
 2807|       |
 2808|       |/*!
 2809|       | ************************************************************************
 2810|       | * \brief
 2811|       | *    Makes the decision if 8x8 tranform will be used (for RD-off)
 2812|       | ************************************************************************
 2813|       | */
 2814|       |int GetBestTransformP8x8()
 2815|      0|{
 2816|      0|  int    block_y, block_x, pic_pix_y, pic_pix_x, i, j, k;
 2817|      0|  int    mb_y, mb_x, block8x8;
 2818|      0|  int    cost8x8=0, cost4x4=0;
 2819|      0|  int    diff4x4[64], *diff_ptr;
 2820|      0|  int    diff8x8[64];
 2821|       |
 2822|      0|  if(input->AllowTransform8x8==2) //always allow 8x8 transform
 2823|      0|    return 1;
 2824|       |  
 2825|      0|  for (block8x8=0; block8x8<4; block8x8++)
 2826|      0|  {
 2827|      0|    mb_y = (block8x8 / 2) << 3;
 2828|      0|    mb_x = (block8x8 % 2) << 3;
 2829|       |    //===== loop over 4x4 blocks =====
 2830|      0|    k=0;
 2831|      0|    for (block_y=mb_y; block_y<mb_y+8; block_y+=4)
 2832|      0|    {
 2833|      0|      pic_pix_y = img->opix_y + block_y;
 2834|       |      
 2835|       |      //get cost for transform size 4x4
 2836|      0|      for (block_x=mb_x; block_x<mb_x+8; block_x+=4)
 2837|      0|      {
 2838|      0|        pic_pix_x = img->opix_x + block_x;
 2839|       |
 2840|       |        //===== get displaced frame difference ======
 2841|      0|        diff_ptr=&diff4x4[k];
 2842|      0|        for (j=0; j<4; j++)
 2843|      0|        for (i=0; i<4; i++, k++)
 2844|      0|        {
 2845|       |          //4x4 transform size
 2846|      0|          diff4x4[k] = imgY_org[pic_pix_y+j][pic_pix_x+i] - mpr8x8[j+block_y][i+block_x];
 2847|       |          //8x8 transform size
 2848|      0|          diff8x8[k] = imgY_org[pic_pix_y+j][pic_pix_x+i] - mpr_8x8ts[j+block_y][i+block_x];
 2849|      0|        }
 2850|       |
 2851|      0|        cost4x4 += SATD (diff_ptr, input->hadamard);
 2852|      0|      }
 2853|      0|    }
 2854|       |
 2855|      0|    cost8x8 += SATD8X8 (diff8x8, input->hadamard);
 2856|      0|  }
 2857|       |
 2858|      0|  if(cost8x8<cost4x4)
 2859|      0|    return 1;
 2860|      0|  else
 2861|      0|    return 0;
 2862|      0|}
 2863|       |
 2864|       |/*!
 2865|       | *************************************************************************************
 2866|       | * \brief
 2867|       | *    Mode Decision for a macroblock
 2868|       | *************************************************************************************
 2869|       | */
 2870|       | void encode_one_macroblock ()
 2871|   109k| {
 2872|   109k|   static const int  b8_mode_table[6]  = {0, 4, 5, 6, 7};         // DO NOT CHANGE ORDER !!!
 2873|   109k|   static const int  mb_mode_table[8]  = {0, 1, 2, 3, P8x8, I16MB, I4MB, I8MB}; // DO NOT CHANGE ORDER !!!
 2874|       |   // Residue Color Transform
 2875|   109k|   static const int  mb_mode_table_RCT[11]  = {0, 1, 2, 3, P8x8, I16MB, I16MB, I16MB, I16MB, I4MB, I8MB};
 2876|   109k|   int max_index;
 2877|       |
 2878|   109k|   int         valid[MAXMODE];
 2879|   109k|   int         rerun, block, index, mode, i0, i1, j0, j1, i, j, k, ctr16x16, dummy;
 2880|   109k|   short       pdir, best_pdir, ref;
 2881|   109k|   double      qp, lambda_mode, lambda_motion, min_rdcost, rdcost = 0, max_rdcost=1e30;
 2882|   109k|   int         lambda_motion_factor;
 2883|   109k|   int         fw_mcost, bw_mcost, bid_mcost, mcost, max_mcost=INT_MAX;
 2884|   109k|   int         cnt_nonz = 0, best_cnt_nonz = 0 ;
 2885|   109k|   short       best_fw_ref = 0;
 2886|   109k|   int64       curr_cbp_blk;
 2887|   109k|   int         cost=0;
 2888|   109k|   int         min_cost = max_mcost, min_cost8x8, cost8x8, cost_direct=0, have_direct=0, i16mode;
 2889|   109k|   int         intra1 = 0;
 2890|   109k|   int         temp_cpb = 0;
 2891|   109k|   int         best_transform_flag = 0;
 2892|   109k|   int         direct4x4_tmp, direct8x8_tmp, cost8x8_direct=0;
 2893|       |
 2894|   109k|   int         intra       = (((img->type==P_SLICE||img->type==SP_SLICE) && img->mb_y==img->mb_y_upd && img->mb_y_upd!=img->mb_y_intra) || img->type==I_SLICE);
 2895|   109k|   int         spframe     = (img->type==SP_SLICE);
 2896|   109k|   int         siframe     = (img->type==SI_SLICE);
 2897|   109k|   int         bframe      = (img->type==B_SLICE);
 2898|   109k|   int         runs        = (input->RestrictRef==1 && input->rdopt==2 && (img->type==P_SLICE || img->type==SP_SLICE || (img->type==B_SLICE && img->nal_reference_idc>0)) ? 2 : 1);
 2899|       |
 2900|   109k|   int         checkref    = (input->rdopt && input->RestrictRef && (img->type==P_SLICE || img->type==SP_SLICE));
 2901|   109k|   Macroblock* currMB      = &img->mb_data[img->current_mb_nr];
 2902|   109k|   Macroblock* prevMB      = img->current_mb_nr ? &img->mb_data[img->current_mb_nr-1]:NULL ;
 2903|       |
 2904|   109k|   int     **ipredmodes = img->ipredmode;
 2905|   109k|   short   best_bw_ref = -1;
 2906|   109k|   short   ******allmvs = img->all_mv;
 2907|   109k|   int     ****i4p;  //for non-RD-opt. mode
 2908|       |   
 2909|   109k|#if BI_PREDICTION
 2910|   109k|   int bpd_mcost_l0,bpd_mcost_l1;
 2911|   109k|#endif
 2912|       |
 2913|       |
 2914|   109k|   int  l,list_offset;
 2915|       |
 2916|       |#ifdef BEST_NZ_COEFF
 2917|       |   int best_nz_coeff[2][2];
 2918|       |#endif
 2919|       |
 2920|   109k|   int curr_mb_field = ((img->MbaffFrameFlag)&&(currMB->mb_field));
 2921|       |
 2922|   109k|   int tmp_8x8_flag, tmp_no_mbpart;
 2923|       |   
 2924|       |   // Residue Color Transform
 2925|   109k|   int residue_R, residue_G, residue_B, temp;
 2926|   109k|   int cr_cbp = 0;
 2927|       |
 2928|       |   // find out the correct list offsets
 2929|   109k|   if (curr_mb_field)
 2930|      0|   {
 2931|      0|     if(img->current_mb_nr%2)
 2932|      0|       list_offset = 4; // bottom field mb
 2933|      0|     else
 2934|      0|       list_offset = 2; // top field mb
 2935|      0|   }
 2936|   109k|   else
 2937|   109k|   {
 2938|   109k|     list_offset = 0;  // no mb aff or frame mb
 2939|   109k|   }
 2940|       |
 2941|   109k|   if(input->FMEnable)
 2942|      0|     decide_intrabk_SAD();
 2943|       |
 2944|   109k|   intra |= RandomIntra (img->current_mb_nr);    // Forced Pseudo-Random Intra
 2945|       |
 2946|       |   //===== SET VALID MODES =====
 2947|       |
 2948|   109k|   valid[I8MB]   = input->AllowTransform8x8;
 2949|   109k|   valid[I4MB]   = (input->AllowTransform8x8==2) ? 0:1;
 2950|   109k|   valid[I16MB]  = 1;
 2951|       |
 2952|   109k|   valid[0]      = (!intra );
 2953|   109k|   valid[1]      = (!intra && input->InterSearch16x16);
 2954|   109k|   valid[2]      = (!intra && input->InterSearch16x8);
 2955|   109k|   valid[3]      = (!intra && input->InterSearch8x16);
 2956|   109k|   valid[4]      = (!intra && input->InterSearch8x8);
 2957|   109k|   valid[5]      = (!intra && input->InterSearch8x4);
 2958|   109k|   valid[6]      = (!intra && input->InterSearch4x8);
 2959|   109k|   valid[7]      = (!intra && input->InterSearch4x4);
 2960|   109k|   if (input->AllowTransform8x8==2) valid[5] = valid[6] = valid[7] = 0;  // tchen 6-10-04
 2961|   109k|   valid[P8x8]   = (valid[4] || valid[5] || valid[6] || valid[7]);
 2962|   109k|   valid[12]     = (siframe);
 2963|       |
 2964|   109k|   if (!img->MbaffFrameFlag)
 2965|   109k|   {
 2966|   328k|     for (l=0+list_offset;l<(2+list_offset);l++)
 2967|   218k|     {
 2968|   718k|       for(k = 0; k < listXsize[l]; k++)
 2969|   499k|       {
 2970|   499k|         listX[l][k]->chroma_vector_adjustment= 0;
 2971|   499k|         if(img->structure == TOP_FIELD && img->structure != listX[l][k]->structure)
 2972|      0|           listX[l][k]->chroma_vector_adjustment = -2;
 2973|   499k|         if(img->structure == BOTTOM_FIELD && img->structure != listX[l][k]->structure)
 2974|      0|           listX[l][k]->chroma_vector_adjustment = 2;
 2975|   499k|       }
 2976|   218k|     }
 2977|   109k|   }
 2978|      0|   else
 2979|      0|   {
 2980|      0|     if (curr_mb_field)
 2981|      0|     {
 2982|      0|       for (l=0+list_offset;l<(2+list_offset);l++)
 2983|      0|       {
 2984|      0|         for(k = 0; k < listXsize[l]; k++)
 2985|      0|         {
 2986|      0|           listX[l][k]->chroma_vector_adjustment= 0;
 2987|      0|           if(img->current_mb_nr % 2 == 0 && listX[l][k]->structure == BOTTOM_FIELD)
 2988|      0|             listX[l][k]->chroma_vector_adjustment = -2;
 2989|      0|           if(img->current_mb_nr % 2 == 1 && listX[l][k]->structure == TOP_FIELD)
 2990|      0|             listX[l][k]->chroma_vector_adjustment = 2;
 2991|      0|         }
 2992|      0|       }
 2993|      0|     }
 2994|      0|     else
 2995|      0|     {
 2996|      0|       for (l=0+list_offset;l<(2+list_offset);l++)
 2997|      0|       {
 2998|      0|         for(k = 0; k < listXsize[l]; k++)
 2999|      0|         {
 3000|      0|           listX[l][k]->chroma_vector_adjustment= 0;
 3001|      0|         }
 3002|      0|       }
 3003|      0|     }
 3004|       |
 3005|      0|   }
 3006|       |
 3007|       |   //===== SET LAGRANGE PARAMETERS =====
 3008|       |
 3009|   109k|   if (input->rdopt)
 3010|   109k|   {
 3011|   109k|     qp = (double)img->qp - SHIFT_QP;
 3012|       |
 3013|   109k|     if (input->UseExplicitLambdaParams)
 3014|      0|     {
 3015|      0|       if (img->type==B_SLICE && img->nal_reference_idc)
 3016|      0|         lambda_mode   = input->LambdaWeight[5] * pow (2, img->bitdepth_lambda_scale + qp/3.0) ;       
 3017|      0|       else
 3018|      0|         lambda_mode   = input->LambdaWeight[img->type] * pow (2, img->bitdepth_lambda_scale + qp/3.0) ;       
 3019|      0|     }
 3020|   109k|     else
 3021|   109k|     {
 3022|   109k|       double lambda_scale = (img->type == B_SLICE && img->nal_reference_idc == 0 ? 1.0: 1.0 - 0.05 * (double) input->jumpd);
 3023|       |
 3024|   109k|       if (input->successive_Bframe>0)
 3025|   109k|         lambda_mode   = 0.68 * pow (2, img->bitdepth_lambda_scale + qp/3.0) * (bframe ? max(2.00,min(4.00,(qp / 6.0))):spframe?max(1.4,min(3.0,(qp / 12.0))):1.0);
 3026|      0|       else
 3027|      0|         lambda_mode   = 0.85 * pow (2, img->bitdepth_lambda_scale + qp/3.0) * (bframe ? 4.0:spframe?max(1.4,min(3.0,(qp / 12.0))):1.0);
 3028|       |       
 3029|   109k|       if (input->PyramidCoding == 2)
 3030|      0|       {
 3031|      0|         if (img->type==B_SLICE && img->nal_reference_idc)
 3032|      0|           lambda_mode *= (1.0 - min(0.4,0.20 * (double) gop_structure[img->b_frame_to_code-1].pyramid_layer)) ;
 3033|      0|       }
 3034|   109k|       else
 3035|   109k|       {
 3036|   109k|         if (img->type==B_SLICE && img->nal_reference_idc)
 3037|      0|           lambda_mode *= 0.80;
 3038|   109k|       }
 3039|       |       
 3040|   109k|       lambda_mode *=lambda_scale;
 3041|       |
 3042|   109k|     }
 3043|   109k|   if (input->hadamardqpel)
 3044|      0|   {
 3045|      0|     lambda_mode *= 0.95;
 3046|      0|   }
 3047|       |     
 3048|   109k|     lambda_motion = sqrt (lambda_mode);
 3049|   109k|   }
 3050|      0|   else
 3051|      0|   {
 3052|      0|     lambda_mode = lambda_motion = QP2QUANT[max(0,img->qp-SHIFT_QP)];
 3053|      0|   }
 3054|       |
 3055|   109k|   lambda_motion_factor = LAMBDA_FACTOR (lambda_motion);
 3056|       |
 3057|   109k|#if BI_PREDICTION
 3058|  1.75M|   for (mode=0; mode<MAXMODE; mode++)
 3059|  1.64M|   {
 3060|  1.64M|     img->bi_pred_me[mode]=0;
 3061|  1.64M|   }
 3062|   109k|#endif
 3063|       |
 3064|       |
 3065|   218k|   for (rerun=0; rerun<runs; rerun++)
 3066|   109k|   {
 3067|   109k|     if (runs==2)
 3068|      0|     {
 3069|      0|       if (rerun==0)   input->rdopt=1;
 3070|      0|       else            input->rdopt=2;
 3071|      0|     }
 3072|       |
 3073|       |     // reset chroma intra predictor to default
 3074|   109k|     currMB->c_ipred_mode = DC_PRED_8;
 3075|       |
 3076|   109k|     if (!intra)
 3077|  90.8k|     {
 3078|       |       //===== set direct motion vectors =====
 3079|  90.8k|       if (bframe)
 3080|  54.4k|       {
 3081|  54.4k|         Get_Direct_Motion_Vectors ();
 3082|  54.4k|       }
 3083|       |
 3084|       |       //===== MOTION ESTIMATION FOR 16x16, 16x8, 8x16 BLOCKS =====
 3085|   363k|       for (min_cost=INT_MAX, best_mode=1, mode=1; mode<4; mode++)
 3086|   272k|       {
 3087|   272k|#if BI_PREDICTION
 3088|   272k|         bi_pred_me = 0;
 3089|   272k|         img->bi_pred_me[mode]=0;
 3090|   272k|#endif
 3091|       |
 3092|   272k|         if (valid[mode])
 3093|   272k|         {
 3094|   727k|           for (cost=0, block=0; block<(mode==1?1:2); block++)
 3095|   454k|           {
 3096|   454k|             PartitionMotionSearch (mode, block, lambda_motion);
 3097|       |
 3098|       |             //--- set 4x4 block indizes (for getting MV) ---
 3099|   454k|             j = (block==1 && mode==2 ? 2 : 0);
 3100|   454k|             i = (block==1 && mode==3 ? 2 : 0);
 3101|       |
 3102|       |             //--- get cost and reference frame for forward prediction ---
 3103|  2.68M|             for (fw_mcost=max_mcost, ref=0; ref<listXsize[LIST_0+list_offset]; ref++)
 3104|  2.22M|             {
 3105|  2.22M|               if (!checkref || ref==0 || CheckReliabilityOfRef (block, LIST_0, ref, mode))
 3106|  2.22M|               {
 3107|  2.22M|                 mcost  = (input->rdopt ? REF_COST (lambda_motion_factor, ref, LIST_0 + list_offset) : (int)(2*lambda_motion*min(ref,1)));
 3108|       |
 3109|  2.22M|                 mcost += motion_cost[mode][LIST_0][ref][block];
 3110|  2.22M|                 if (mcost < fw_mcost)
 3111|   572k|                 {
 3112|   572k|                   fw_mcost    = mcost;
 3113|   572k|                   best_fw_ref = ref;
 3114|   572k|                 }
 3115|  2.22M|               }
 3116|  2.22M|             }
 3117|       |
 3118|   454k|             if (bframe)
 3119|   272k|             {
 3120|       |               //--- get cost for bidirectional prediction ---
 3121|   544k|               for (bw_mcost=max_mcost, ref=0; ref<listXsize[LIST_1 + list_offset]; ref++)
 3122|   272k|               {
 3123|   272k|                 mcost  = (input->rdopt ? REF_COST (lambda_motion_factor, ref, LIST_1 + list_offset) : (int)(2*lambda_motion*min(ref,1)));
 3124|   272k|                 mcost += motion_cost[mode][LIST_1][ref][block];
 3125|   272k|                 if (mcost < bw_mcost)
 3126|   272k|                 {
 3127|   272k|                   bw_mcost    = mcost;
 3128|   272k|                   best_bw_ref = ref;
 3129|   272k|                 }
 3130|   272k|               }
 3131|       |
 3132|       |               // search bidirectional between best forward and ref_idx=0 backward
 3133|   272k|               bid_mcost  = (input->rdopt ? (REF_COST (lambda_motion_factor, best_fw_ref,LIST_0+list_offset)+REF_COST (lambda_motion_factor, 0,LIST_1+list_offset)) : (int)(2*lambda_motion*min(best_fw_ref,1)));
 3134|   272k|               bid_mcost += BIDPartitionCost (mode, block, best_fw_ref, 0, lambda_motion_factor);
 3135|       |
 3136|   272k|#if BI_PREDICTION 
 3137|   272k|              if (mode == 1 && img->type==B_SLICE && input->BiPredMotionEstimation )
 3138|      0|              {                
 3139|       |                // search bidirectional between ref_idx=0 forward and ref_idx=0 backward
 3140|      0|                bpd_mcost_l0  = (input->rdopt ? (REF_COST (lambda_motion_factor, 0,LIST_0+list_offset)+REF_COST (lambda_motion_factor, 0,LIST_1+list_offset)) : (int)(2*lambda_motion*min(0,1)));
 3141|      0|                bpd_mcost_l0 += BPredPartitionCost(mode, block, 0, 0, lambda_motion_factor,0);
 3142|      0|                bpd_mcost_l1  = (input->rdopt ? (REF_COST (lambda_motion_factor, 0,LIST_0+list_offset)+REF_COST (lambda_motion_factor, 0,LIST_1+list_offset)) : (int)(2*lambda_motion*min(0,1)));
 3143|      0|                bpd_mcost_l1 += BPredPartitionCost(mode, block, 0, 0, lambda_motion_factor,1);                
 3144|      0|              }
 3145|   272k|              else
 3146|   272k|              {
 3147|   272k|                bpd_mcost_l0  = INT_MAX;
 3148|   272k|                bpd_mcost_l1  = INT_MAX;
 3149|   272k|              }
 3150|       |              
 3151|   272k|#endif
 3152|       |
 3153|   272k|#if BI_PREDICTION 
 3154|   272k|              if (input->BiPredMotionEstimation && mode==1)
 3155|      0|              {
 3156|       |                //--- get prediction direction ----
 3157|      0|                if (fw_mcost<=bw_mcost && fw_mcost<=bid_mcost && fw_mcost<bpd_mcost_l0 && fw_mcost<bpd_mcost_l1)
 3158|      0|                {
 3159|      0|                  best_pdir = 0;
 3160|      0|                  best_bw_ref = 0;
 3161|      0|                  cost += fw_mcost;
 3162|      0|                }
 3163|      0|                else if (bw_mcost<=fw_mcost && bw_mcost<=bid_mcost && bw_mcost<bpd_mcost_l0 && bw_mcost<bpd_mcost_l1)
 3164|      0|                {
 3165|      0|                  best_pdir = 1;
 3166|      0|                  cost += bw_mcost;
 3167|      0|                  best_fw_ref = 0;
 3168|      0|                }
 3169|      0|                else if (bid_mcost<=fw_mcost && bid_mcost<=bw_mcost && bid_mcost<bpd_mcost_l0 && bid_mcost<bpd_mcost_l1)
 3170|      0|                {
 3171|      0|                  best_pdir = 2;
 3172|      0|                  cost += bid_mcost;
 3173|      0|                  bi_pred_me = 0;
 3174|      0|                  img->bi_pred_me[mode]=0;
 3175|      0|                  best_bw_ref = 0;  
 3176|      0|                }
 3177|      0|                else if (bpd_mcost_l0<=fw_mcost && bpd_mcost_l0<=bw_mcost && bpd_mcost_l0<=bid_mcost&& bpd_mcost_l0<=bpd_mcost_l1)
 3178|      0|                {
 3179|      0|                  best_pdir = 2;
 3180|      0|                  best_bw_ref = 0;
 3181|      0|                  best_fw_ref = 0;
 3182|      0|                  cost += bpd_mcost_l0;                  
 3183|      0|                  bi_pred_me = 1;
 3184|      0|                  img->bi_pred_me[mode]=1;
 3185|      0|                }
 3186|      0|                else
 3187|      0|                {
 3188|      0|                  best_bw_ref = 0;
 3189|      0|                  best_fw_ref = 0;
 3190|      0|                  best_pdir = 2;
 3191|      0|                  cost += bpd_mcost_l1;                                  
 3192|      0|                  bi_pred_me = 2;
 3193|      0|                  img->bi_pred_me[mode]=2;
 3194|      0|                }               
 3195|      0|              }
 3196|   272k|              else
 3197|   272k|#endif
 3198|   272k|              {
 3199|       |                //--- get prediction direction ----
 3200|   272k|               if (fw_mcost<=bw_mcost && fw_mcost<=bid_mcost)
 3201|   124k|               {
 3202|   124k|                 best_pdir = 0;
 3203|   124k|                 best_bw_ref = 0;
 3204|   124k|                 cost += fw_mcost;
 3205|   124k|               }
 3206|   147k|               else if (bw_mcost<=fw_mcost && bw_mcost<=bid_mcost)
 3207|   142k|               {
 3208|   142k|                 best_pdir = 1;
 3209|   142k|                 cost += bw_mcost;
 3210|   142k|                 best_fw_ref = 0;
 3211|   142k|               }
 3212|  4.46k|               else
 3213|  4.46k|               {
 3214|  4.46k|                 best_pdir = 2;
 3215|  4.46k|                 cost += bid_mcost;
 3216|  4.46k|                 best_bw_ref = 0;
 3217|  4.46k|               }
 3218|   272k|              }                          
 3219|   272k|             }
 3220|   182k|             else // if (bframe)
 3221|   182k|             {
 3222|   182k|               best_pdir  = 0;
 3223|   182k|               cost      += fw_mcost;
 3224|   182k|             }
 3225|       |
 3226|   454k|             if (mode==1)
 3227|  90.8k|             {
 3228|  90.8k|               if (best_pdir==1)
 3229|  27.4k|               {
 3230|   137k|                 for (j=0; j<4; j++)
 3231|   109k|                 {
 3232|   549k|                   for (i=0; i<4; i++)
 3233|   439k|                   {
 3234|   439k|                     enc_picture->ref_idx[LIST_0][img->block_x+(block&1)*2+i][img->block_y+(block&2)+j] = -1;
 3235|   439k|                     enc_picture->ref_pic_id [LIST_0][img->block_x+(block&1)*2+i][img->block_y+(block&2)+j] = -1;
 3236|   439k|                     enc_picture->mv[LIST_0][img->block_x+(block&1)*2+i][img->block_y+(block&2)+j][0] = 0;
 3237|   439k|                     enc_picture->mv[LIST_0][img->block_x+(block&1)*2+i][img->block_y+(block&2)+j][1] = 0;
 3238|   439k|                   }
 3239|   109k|                 }
 3240|  27.4k|               }
 3241|  63.3k|               else
 3242|  63.3k|               {
 3243|   316k|                 for (j=0; j<4; j++)
 3244|   253k|                 {
 3245|  1.26M|                   for (i=0; i<4; i++)
 3246|  1.01M|                   {
 3247|  1.01M|#if BI_PREDICTION
 3248|  1.01M|                     if (img->bi_pred_me[mode])
 3249|      0|                     {
 3250|      0|                       short   ******bipred_mv = img->bi_pred_me[mode] == 1 ? img->bipred_mv1 : img->bipred_mv2;
 3251|       |                       
 3252|      0|                       enc_picture->ref_idx[LIST_0][img->block_x+(block&1)*2+i][img->block_y+(block&2)+j] = 0;
 3253|      0|                       enc_picture->ref_pic_id [LIST_0][img->block_x+(block&1)*2+i][img->block_y+(block&2)+j] = enc_picture->ref_pic_num[LIST_0 + list_offset][0];  
 3254|      0|                       enc_picture->mv[LIST_0][img->block_x+(block&1)*2+i][img->block_y+(block&2)+j][0] = bipred_mv[i][j][LIST_0][0][mode][0];
 3255|      0|                       enc_picture->mv[LIST_0][img->block_x+(block&1)*2+i][img->block_y+(block&2)+j][1] = bipred_mv[i][j][LIST_0][0][mode][1];
 3256|      0|                     }
 3257|  1.01M|#endif
 3258|  1.01M|                     else 
 3259|  1.01M|                     {
 3260|  1.01M|                       enc_picture->ref_idx[LIST_0][img->block_x+(block&1)*2+i][img->block_y+(block&2)+j] = best_fw_ref;
 3261|  1.01M|                       enc_picture->ref_pic_id [LIST_0][img->block_x+(block&1)*2+i][img->block_y+(block&2)+j] = enc_picture->ref_pic_num[LIST_0 + list_offset][enc_picture->ref_idx[LIST_0][img->block_x+(block&1)*2+i][img->block_y+(block&2)+j]];  
 3262|  1.01M|                       enc_picture->mv[LIST_0][img->block_x+(block&1)*2+i][img->block_y+(block&2)+j][0] = img->all_mv[i][j][LIST_0][best_fw_ref][mode][0];
 3263|  1.01M|                       enc_picture->mv[LIST_0][img->block_x+(block&1)*2+i][img->block_y+(block&2)+j][1] = img->all_mv[i][j][LIST_0][best_fw_ref][mode][1];
 3264|  1.01M|                     }
 3265|       |                     
 3266|  1.01M|                   }
 3267|   253k|                 }
 3268|  63.3k|               }
 3269|       |               
 3270|  90.8k|               if (bframe)
 3271|  54.4k|               {
 3272|  54.4k|                 if (best_pdir==0)
 3273|  25.7k|                 {
 3274|   128k|                   for (j=0; j<4; j++)
 3275|   103k|                   {
 3276|   515k|                     for (i=0; i<4; i++)
 3277|   412k|                     {
 3278|   412k|                       enc_picture->ref_idx[LIST_1][img->block_x+(block&1)*2+i][img->block_y+(block&2)+j] = -1;
 3279|   412k|                       enc_picture->ref_pic_id [LIST_1][img->block_x+(block&1)*2+i][img->block_y+(block&2)+j] = -1;
 3280|   412k|                       enc_picture->mv[LIST_1][img->block_x+(block&1)*2+i][img->block_y+(block&2)+j][0] = 0;
 3281|   412k|                       enc_picture->mv[LIST_1][img->block_x+(block&1)*2+i][img->block_y+(block&2)+j][1] = 0;
 3282|   412k|                     }
 3283|   103k|                   }
 3284|  25.7k|                 }
 3285|  28.6k|                 else
 3286|  28.6k|                 {
 3287|   143k|                   for (j=0; j<4; j++)
 3288|   114k|                   {
 3289|   573k|                     for (i=0; i<4; i++)
 3290|   458k|                     {                     
 3291|   458k|#if BI_PREDICTION
 3292|   458k|                       if (img->bi_pred_me[mode])
 3293|      0|                       {
 3294|      0|                         short   ******bipred_mv = img->bi_pred_me[mode] == 1 ? img->bipred_mv1 : img->bipred_mv2;
 3295|       |                         
 3296|      0|                         enc_picture->ref_idx[LIST_1][img->block_x+(block&1)*2+i][img->block_y+(block&2)+j] = 0;
 3297|      0|                         enc_picture->ref_pic_id [LIST_1][img->block_x+(block&1)*2+i][img->block_y+(block&2)+j] = enc_picture->ref_pic_num[LIST_1 + list_offset][0];
 3298|      0|                         enc_picture->mv[LIST_1][img->block_x+(block&1)*2+i][img->block_y+(block&2)+j][0] = bipred_mv[i][j][LIST_1][0][mode][0];
 3299|      0|                         enc_picture->mv[LIST_1][img->block_x+(block&1)*2+i][img->block_y+(block&2)+j][1] = bipred_mv[i][j][LIST_1][0][mode][1];
 3300|      0|                       }
 3301|   458k|                       else 
 3302|   458k|#endif
 3303|   458k|                       {
 3304|   458k|                         enc_picture->ref_idx[LIST_1][img->block_x+(block&1)*2+i][img->block_y+(block&2)+j] = best_bw_ref;
 3305|   458k|                         enc_picture->ref_pic_id [LIST_1][img->block_x+(block&1)*2+i][img->block_y+(block&2)+j] = enc_picture->ref_pic_num[LIST_1 + list_offset][enc_picture->ref_idx[LIST_1][img->block_x+(block&1)*2+i][img->block_y+(block&2)+j]];
 3306|   458k|                         if(best_bw_ref>=0)
 3307|   458k|                         {
 3308|   458k|                           enc_picture->mv[LIST_1][img->block_x+(block&1)*2+i][img->block_y+(block&2)+j][0] = img->all_mv[i][j][LIST_1][best_bw_ref][mode][0];
 3309|   458k|                           enc_picture->mv[LIST_1][img->block_x+(block&1)*2+i][img->block_y+(block&2)+j][1] = img->all_mv[i][j][LIST_1][best_bw_ref][mode][1];
 3310|   458k|                         }
 3311|   458k|                       }
 3312|       |                       
 3313|   458k|                     }
 3314|   114k|                   }
 3315|  28.6k|                 }
 3316|  54.4k|               }
 3317|  90.8k|             }
 3318|   363k|             else if (mode==2)
 3319|   181k|             {
 3320|   181k|               int blocky_plus_block2 = img->block_y+block*2;
 3321|   545k|               for (j=0; j<2; j++)
 3322|   363k|               {
 3323|  1.81M|                 for (i=0; i<4; i++)
 3324|  1.45M|                 {
 3325|  1.45M|                   if (best_pdir==1)
 3326|   463k|                   {
 3327|   463k|                    enc_picture->ref_idx[LIST_0][img->block_x+i][blocky_plus_block2+j] = -1;
 3328|   463k|                    enc_picture->ref_pic_id [LIST_0][img->block_x+i][blocky_plus_block2+j] = -1;
 3329|   463k|                    enc_picture->mv[LIST_0][img->block_x+i][blocky_plus_block2+j][0] = 0;
 3330|   463k|                    enc_picture->mv[LIST_0][img->block_x+i][blocky_plus_block2+j][1] = 0;
 3331|   463k|                   }
 3332|   990k|                   else
 3333|   990k|                   {                     
 3334|   990k|                     enc_picture->ref_idx[LIST_0][img->block_x+i][blocky_plus_block2+j] = best_fw_ref;
 3335|   990k|                     enc_picture->ref_pic_id [LIST_0][img->block_x+i][blocky_plus_block2+j] = enc_picture->ref_pic_num[LIST_0 + list_offset][enc_picture->ref_idx[LIST_0][img->block_x+i][blocky_plus_block2+j]];
 3336|   990k|                     enc_picture->mv[LIST_0][img->block_x+i][blocky_plus_block2+j][0] = img->all_mv[i][j+block*2][LIST_0][best_fw_ref][mode][0];
 3337|   990k|                     enc_picture->mv[LIST_0][img->block_x+i][blocky_plus_block2+j][1] = img->all_mv[i][j+block*2][LIST_0][best_fw_ref][mode][1];                    
 3338|   990k|                   }
 3339|       |
 3340|  1.45M|                   if (bframe)
 3341|   870k|                   {
 3342|   870k|                     if (best_pdir==0)
 3343|   393k|                     {
 3344|   393k|                       enc_picture->ref_idx[LIST_1][img->block_x+i][blocky_plus_block2+j] = -1;
 3345|   393k|                       enc_picture->ref_pic_id [LIST_1][img->block_x+i][blocky_plus_block2+j] = -1;
 3346|   393k|                       enc_picture->mv[LIST_1][img->block_x+i][blocky_plus_block2+j][0] = 0;
 3347|   393k|                       enc_picture->mv[LIST_1][img->block_x+i][blocky_plus_block2+j][1] = 0;
 3348|   393k|                     }
 3349|   476k|                     else
 3350|   476k|                     {
 3351|   476k|                       enc_picture->ref_idx[LIST_1][img->block_x+i][blocky_plus_block2+j] = best_bw_ref;
 3352|   476k|                       enc_picture->ref_pic_id [LIST_1][img->block_x+i][blocky_plus_block2+j] = enc_picture->ref_pic_num[LIST_1 + list_offset][enc_picture->ref_idx[LIST_1][img->block_x+i][blocky_plus_block2+j]];
 3353|   476k|                       if(best_bw_ref>=0)
 3354|   476k|                       {
 3355|       |#ifndef KS_MV
 3356|       |                         enc_picture->mv[LIST_1][img->block_x+i][blocky_plus_block2+j][0] = img->all_mv[i][j][LIST_1][best_bw_ref][mode][0];
 3357|       |                         enc_picture->mv[LIST_1][img->block_x+i][blocky_plus_block2+j][1] = img->all_mv[i][j][LIST_1][best_bw_ref][mode][1];
 3358|       |#else
 3359|   476k|                         enc_picture->mv[LIST_1][img->block_x+i][blocky_plus_block2+j][0] = img->all_mv[i][block*2+j][LIST_1][best_bw_ref][mode][0];
 3360|   476k|                         enc_picture->mv[LIST_1][img->block_x+i][blocky_plus_block2+j][1] = img->all_mv[i][block*2+j][LIST_1][best_bw_ref][mode][1];
 3361|   476k|#endif                         
 3362|   476k|                       }                       
 3363|   476k|                     }
 3364|   870k|                   }
 3365|  1.45M|                 }
 3366|   363k|               }
 3367|   181k|             }
 3368|   181k|             else
 3369|   181k|             {
 3370|   181k|               int blockx_plus_block2 = img->block_x+block*2;
 3371|   908k|               for (j=0; j<4; j++)
 3372|   727k|               {
 3373|  2.18M|                 for (i=0; i<2; i++)
 3374|  1.45M|                 {
 3375|  1.45M|                   if (best_pdir==1)
 3376|   460k|                   {
 3377|   460k|                     enc_picture->ref_idx[LIST_0][blockx_plus_block2+i][img->block_y+j] = -1;
 3378|   460k|                     enc_picture->ref_pic_id [LIST_0][blockx_plus_block2+i][img->block_y+j] = -1;
 3379|   460k|                     enc_picture->mv[LIST_0][blockx_plus_block2+i][img->block_y+j][0] = 0;
 3380|   460k|                     enc_picture->mv[LIST_0][blockx_plus_block2+i][img->block_y+j][1] = 0;
 3381|   460k|                   }
 3382|   993k|                   else
 3383|   993k|                   {
 3384|   993k|                     enc_picture->ref_idx[LIST_0][blockx_plus_block2+i][img->block_y+j] = best_fw_ref;
 3385|   993k|                     enc_picture->ref_pic_id [LIST_0][blockx_plus_block2+i][img->block_y+j] = enc_picture->ref_pic_num[LIST_0 + list_offset][enc_picture->ref_idx[LIST_0][blockx_plus_block2+i][img->block_y+j]];
 3386|       |#ifndef KS_MV
 3387|       |                     enc_picture->mv[LIST_0][blockx_plus_block2+i][img->block_y+j][0] = img->all_mv[i][j][LIST_0][best_fw_ref][mode][0];
 3388|       |                     enc_picture->mv[LIST_0][blockx_plus_block2+i][img->block_y+j][1] = img->all_mv[i][j][LIST_0][best_fw_ref][mode][1];
 3389|       |#else
 3390|   993k|                     enc_picture->mv[LIST_0][blockx_plus_block2+i][img->block_y+j][0] = img->all_mv[block*2+i][j][LIST_0][best_fw_ref][mode][0];
 3391|   993k|                     enc_picture->mv[LIST_0][blockx_plus_block2+i][img->block_y+j][1] = img->all_mv[block*2+i][j][LIST_0][best_fw_ref][mode][1];
 3392|   993k|#endif
 3393|   993k|                   }
 3394|       |
 3395|  1.45M|                   if (bframe)
 3396|   870k|                   {
 3397|   870k|                     if (best_pdir==0)
 3398|   396k|                     {
 3399|   396k|                       enc_picture->ref_idx[LIST_1][blockx_plus_block2+i][img->block_y+j] = -1;
 3400|   396k|                       enc_picture->ref_pic_id [LIST_1][blockx_plus_block2+i][img->block_y+j] = -1;
 3401|   396k|                       enc_picture->mv[LIST_1][blockx_plus_block2+i][img->block_y+j][0] = 0;
 3402|   396k|                       enc_picture->mv[LIST_1][blockx_plus_block2+i][img->block_y+j][1] = 0;
 3403|   396k|                     }
 3404|   473k|                     else
 3405|   473k|                     {
 3406|   473k|                       enc_picture->ref_idx[LIST_1][blockx_plus_block2+i][img->block_y+j] = best_bw_ref;
 3407|   473k|                       enc_picture->ref_pic_id [LIST_1][blockx_plus_block2+i][img->block_y+j] = enc_picture->ref_pic_num[LIST_1 + list_offset][enc_picture->ref_idx[LIST_1][blockx_plus_block2+i][img->block_y+j]];
 3408|   473k|                       if(best_bw_ref>=0)
 3409|   473k|                       {
 3410|       |#ifndef KS_MV
 3411|       |                         enc_picture->mv[LIST_1][blockx_plus_block2+i][img->block_y+j][0] = img->all_mv[i][j][LIST_1][best_bw_ref][mode][0];
 3412|       |                         enc_picture->mv[LIST_1][blockx_plus_block2+i][img->block_y+j][1] = img->all_mv[i][j][LIST_1][best_bw_ref][mode][1];
 3413|       |#else
 3414|   473k|                         enc_picture->mv[LIST_1][blockx_plus_block2+i][img->block_y+j][0] = img->all_mv[block*2+i][j][LIST_1][best_bw_ref][mode][0];
 3415|   473k|                         enc_picture->mv[LIST_1][blockx_plus_block2+i][img->block_y+j][1] = img->all_mv[block*2+i][j][LIST_1][best_bw_ref][mode][1];
 3416|   473k|#endif
 3417|   473k|                       }
 3418|   473k|                     }
 3419|   870k|                   }
 3420|  1.45M|                 }
 3421|   727k|               }
 3422|   181k|             }
 3423|       |
 3424|       |             //----- set reference frame and direction parameters -----
 3425|   454k|             if (mode==3)
 3426|   181k|             {
 3427|   181k|               best8x8fwref [3][block  ] = best8x8fwref [3][  block+2] = best_fw_ref;
 3428|   181k|               best8x8pdir  [3][block  ] = best8x8pdir  [3][  block+2] = best_pdir;
 3429|   181k|               best8x8bwref [3][block  ] = best8x8bwref [3][  block+2] = best_bw_ref;
 3430|   181k|             }
 3431|   272k|             else if (mode==2)
 3432|   181k|             {
 3433|   181k|               best8x8fwref [2][2*block] = best8x8fwref [2][2*block+1] = best_fw_ref;
 3434|   181k|               best8x8pdir  [2][2*block] = best8x8pdir  [2][2*block+1] = best_pdir;
 3435|   181k|               best8x8bwref [2][2*block] = best8x8bwref [2][2*block+1] = best_bw_ref;
 3436|   181k|             }
 3437|  90.8k|             else
 3438|  90.8k|             {
 3439|  90.8k|               best8x8fwref [1][0] = best8x8fwref [1][1] = best8x8fwref [1][2] = best8x8fwref [1][3] = best_fw_ref;
 3440|  90.8k|               best8x8pdir  [1][0] = best8x8pdir  [1][1] = best8x8pdir  [1][2] = best8x8pdir  [1][3] = best_pdir;
 3441|  90.8k|               best8x8bwref [1][0] = best8x8bwref [1][1] = best8x8bwref [1][2] = best8x8bwref [1][3] = best_bw_ref;
 3442|  90.8k|             }
 3443|       |
 3444|       |             //--- set reference frames and motion vectors ---
 3445|   454k|             if (mode>1 && block==0)
 3446|   181k|               SetRefAndMotionVectors (block, mode, best_pdir, best_fw_ref, best_bw_ref);
 3447|       |
 3448|   454k|          } // for (block=0; block<(mode==1?1:2); block++)
 3449|       |
 3450|   272k|          if(!input->rdopt)
 3451|      0|          {
 3452|      0|            currMB->luma_transform_size_8x8_flag = 0;
 3453|      0|            if (input->AllowTransform8x8) //for inter rd-off, set 8x8 to do 8x8 transform
 3454|      0|            {
 3455|      0|              SetModesAndRefframeForBlocks(mode);
 3456|      0|              currMB->luma_transform_size_8x8_flag = TransformDecision(-1, &cost);
 3457|      0|            }
 3458|      0|          }
 3459|       |
 3460|   272k|          if (cost < min_cost)
 3461|   110k|          {
 3462|   110k|            best_mode = mode;
 3463|   110k|            min_cost  = cost;
 3464|   110k|            best_transform_flag = currMB->luma_transform_size_8x8_flag;
 3465|   110k|          }
 3466|   272k|        } // if (valid[mode])
 3467|   272k|      } // for (mode=1; mode<4; mode++)
 3468|       |
 3469|  90.8k|      if (valid[P8x8])
 3470|  90.8k|      {
 3471|  90.8k|        cost8x8 = 0;
 3472|  90.8k|        cost8_8x8ts = INT_MAX;
 3473|       |
 3474|       |        //===== store coding state of macroblock =====
 3475|  90.8k|        store_coding_state (cs_mb);
 3476|       |
 3477|  90.8k|        currMB->all_blk_8x8 = -1;
 3478|       |
 3479|  90.8k|        if (input->AllowTransform8x8)
 3480|      0|        {
 3481|       |          //===========================================================
 3482|       |          // Check 8x8 partition with transform size 8x8 
 3483|       |          //===========================================================
 3484|       |          //=====  LOOP OVER 8x8 SUB-PARTITIONS  (Motion Estimation & Mode Decision) =====
 3485|      0|          for (cost_direct=cbp8x8=cbp_blk8x8=cnt_nonz_8x8=0, block=0; block<4; block++)
 3486|      0|          {
 3487|       |            //--- set coordinates ---
 3488|      0|            j0 = ((block/2)<<3);    j1 = (j0>>2);
 3489|      0|            i0 = ((block%2)<<3);    i1 = (i0>>2);
 3490|       |
 3491|       |#ifdef BEST_NZ_COEFF
 3492|       |            {
 3493|       |              int x, y;
 3494|       |              for(y = 0; y <= 1; y++)
 3495|       |                for(x = 0; x <= 1; x++)
 3496|       |                  best_nz_coeff[x][y]= img->nz_coeff[img->current_mb_nr][i1 + x][j1 + y] = 0;
 3497|       |            }
 3498|       |#endif
 3499|      0|            currMB->luma_transform_size_8x8_flag = 1; //switch to transform size 8x8
 3500|       |
 3501|       |            //=====  LOOP OVER POSSIBLE CODING MODES FOR 8x8 SUB-PARTITION  =====
 3502|      0|            for (min_cost8x8=INT_MAX,min_rdcost=1e30, index=(bframe?0:1); index<2; index++)
 3503|      0|            {
 3504|      0|              mode = b8_mode_table[index]; 
 3505|      0|              if ((valid[mode] && mode != 0) || (mode == 0 && active_sps->direct_8x8_inference_flag))
 3506|      0|              {
 3507|      0|                curr_cbp_blk = 0;
 3508|       |                
 3509|      0|                if (mode==0)
 3510|      0|                {
 3511|       |                  //--- Direct Mode ---
 3512|      0|                  if (!input->rdopt)
 3513|      0|                  {
 3514|       |                    // T.Nishi(MEI ACC) 04-28-2004
 3515|      0|                    direct4x4_tmp=0; direct8x8_tmp=0;
 3516|      0|                    direct4x4_tmp = Get_Direct_Cost8x8 ( block, &direct8x8_tmp);
 3517|      0|                    if ((direct4x4_tmp==INT_MAX)||(cost_direct==INT_MAX))
 3518|      0|                    {
 3519|      0|                      cost_direct = (INT_MAX);
 3520|      0|                      cost8x8_direct = (INT_MAX);
 3521|      0|                    }
 3522|      0|                    else
 3523|      0|                    {
 3524|      0|                      cost_direct += direct4x4_tmp;
 3525|      0|                      cost8x8_direct += direct8x8_tmp;
 3526|      0|                    }
 3527|       |
 3528|      0|                    switch(input->AllowTransform8x8)
 3529|      0|                    {
 3530|      0|                    case 1: // Mixture of 8x8 & 4x4 transform
 3531|      0|                      if((direct8x8_tmp < direct4x4_tmp) ||
 3532|      0|                        !(valid[5] && valid[6] && valid[7]))
 3533|      0|                        cost = direct8x8_tmp;
 3534|      0|                      else
 3535|      0|                        cost = direct4x4_tmp;
 3536|      0|                      break;
 3537|      0|                    case 2: // 8x8 Transform only
 3538|      0|                      cost = direct8x8_tmp;
 3539|      0|                      break;
 3540|      0|                    default: // 4x4 Transform only
 3541|      0|                      cost = direct4x4_tmp;
 3542|      0|                      break;
 3543|      0|                    }
 3544|       |                    // T.Nishi(MEI ACC) 04-28-2004 end
 3545|       |
 3546|      0|                    if (input->AllowTransform8x8==2) cost = min_cost8x8 + 1;  // tchen 6-10-04: disable direct_8x8 mode that allows 4x4 dct only
 3547|       |
 3548|      0|                    have_direct ++;
 3549|      0|                  }
 3550|       |
 3551|      0|                  best_fw_ref = direct_ref_idx[LIST_0][img->block_x+(block&1)*2][img->block_y+(block&2)];
 3552|      0|                  best_bw_ref = direct_ref_idx[LIST_1][img->block_x+(block&1)*2][img->block_y+(block&2)];
 3553|      0|                  best_pdir   = direct_pdir[img->block_x+(block&1)*2][img->block_y+(block&2)];
 3554|      0|                } // if (mode==0)
 3555|      0|                else
 3556|      0|                {
 3557|       |
 3558|       |                  //======= motion estimation for all reference frames ========
 3559|       |                  //-----------------------------------------------------------
 3560|      0|                  PartitionMotionSearch (mode, block, lambda_motion);
 3561|       |
 3562|       |                  //--- get cost and reference frame for forward prediction ---
 3563|      0|                  for (fw_mcost=max_mcost, ref=0; ref<listXsize[LIST_0+list_offset]; ref++)
 3564|      0|                  {
 3565|      0|                    if (!checkref || ref==0 || CheckReliabilityOfRef (block, LIST_0, ref, mode))
 3566|      0|                    {
 3567|      0|                      mcost  = (input->rdopt ? REF_COST(lambda_motion_factor,ref,LIST_0+list_offset) : (int)(2*lambda_motion*min(ref,1)));
 3568|       |
 3569|      0|                      mcost += motion_cost[mode][LIST_0][ref][block];
 3570|      0|                      if (mcost < fw_mcost)
 3571|      0|                      {
 3572|      0|                        fw_mcost    = mcost;
 3573|      0|                        best_fw_ref = ref;
 3574|      0|                      }
 3575|      0|                    }
 3576|      0|                  }
 3577|       |
 3578|       |                  //store forward reference index for every block
 3579|      0|                  for (j=0; j<2; j++)
 3580|      0|                    for (i=0; i<2; i++)
 3581|      0|                    {
 3582|      0|                      enc_picture->ref_idx[LIST_0][img->block_x+(block&1)*2+i][img->block_y+(block&2)+j] = best_fw_ref;
 3583|      0|                      enc_picture->ref_pic_id [LIST_0][img->block_x+(block&1)*2+i][img->block_y+(block&2)+j] = enc_picture->ref_pic_num[LIST_0 + list_offset][enc_picture->ref_idx[LIST_0][img->block_x+(block&1)*2+i][img->block_y+(block&2)+j]];
 3584|      0|                    }
 3585|       |
 3586|      0|                    if (bframe)
 3587|      0|                    {
 3588|      0|                      for (bw_mcost=max_mcost, ref=0; ref<listXsize[LIST_1+list_offset]; ref++)
 3589|      0|                      {
 3590|      0|                        mcost  = (input->rdopt ? REF_COST(lambda_motion_factor,ref,LIST_1+list_offset) : (int)(2*lambda_motion*min(ref,1)));
 3591|       |                        
 3592|      0|                        mcost += motion_cost[mode][LIST_1][ref][block];
 3593|      0|                        if (mcost < bw_mcost)
 3594|      0|                        {
 3595|      0|                          bw_mcost    = mcost;
 3596|      0|                          best_bw_ref = ref;
 3597|      0|                        }
 3598|      0|                      }
 3599|       |
 3600|       |                      // bidirectional uses best forward and zero backward reference
 3601|      0|                      bid_mcost  = (input->rdopt ? (REF_COST (lambda_motion_factor, best_fw_ref, LIST_0 + list_offset)+REF_COST (lambda_motion_factor, 0, LIST_1 + list_offset)) : (int)(2*lambda_motion*min(best_fw_ref,1)));
 3602|      0|                      bid_mcost += BIDPartitionCost (mode, block, best_fw_ref, 0, lambda_motion_factor );
 3603|       |
 3604|       |                      //--- get prediction direction ----
 3605|      0|                      if      (fw_mcost<=bw_mcost && fw_mcost<=bid_mcost)
 3606|      0|                      {
 3607|      0|                        best_pdir = 0;
 3608|      0|                        cost = fw_mcost;
 3609|      0|                        best_bw_ref = -1;
 3610|      0|                      }
 3611|      0|                      else if (bw_mcost<=fw_mcost && bw_mcost<=bid_mcost)
 3612|      0|                      {
 3613|      0|                        best_pdir = 1;
 3614|      0|                        cost = bw_mcost;
 3615|      0|                        best_fw_ref = -1;
 3616|      0|                      }
 3617|      0|                      else
 3618|      0|                      {
 3619|      0|                        best_pdir = 2;
 3620|      0|                        cost = bid_mcost;
 3621|      0|                        best_bw_ref = 0;
 3622|      0|                      }
 3623|       |                      //store backward reference index for every block
 3624|      0|                      for (j=0; j<2; j++)
 3625|      0|                        for (i=0; i<2; i++)
 3626|      0|                        {
 3627|      0|                          enc_picture->ref_idx[LIST_0][img->block_x+(block&1)*2+i][img->block_y+(block&2)+j] = best_fw_ref;
 3628|      0|                          enc_picture->ref_idx[LIST_1][img->block_x+(block&1)*2+i][img->block_y+(block&2)+j] = best_bw_ref;
 3629|       |                          //enc_picture->ref_pic_id [LIST_1][img->block_x+(block&1)*2+i][img->block_y+(block&2)+j] = enc_picture->ref_pic_num[LIST_1 + list_offset][enc_picture->ref_idx[LIST_1][img->block_x+(block&1)*2+i][img->block_y+(block&2)+j]];
 3630|      0|                        }
 3631|      0|                    } // if (bframe)
 3632|      0|                    else
 3633|      0|                    {
 3634|      0|                      best_pdir = 0;
 3635|      0|                      cost      = fw_mcost;
 3636|      0|                    }
 3637|      0|                } // if (mode!=0)
 3638|       |
 3639|       |                //--- store coding state before coding with current mode ---
 3640|      0|                store_coding_state (cs_cm);
 3641|       |                
 3642|      0|                if (input->rdopt)
 3643|      0|                {
 3644|       |                  //--- get and check rate-distortion cost ---
 3645|      0|                  rdcost = RDCost_for_8x8blocks (&cnt_nonz, &curr_cbp_blk, lambda_mode,
 3646|      0|                    block, mode, best_pdir, best_fw_ref, best_bw_ref);
 3647|      0|                }
 3648|      0|                else
 3649|      0|                {
 3650|      0|                  if (cost!=INT_MAX)
 3651|      0|                    cost += (REF_COST (lambda_motion_factor, B8Mode2Value (mode, best_pdir), list_offset + (best_pdir<1?0:1)) - 1);
 3652|      0|                }
 3653|       |                
 3654|       |                
 3655|       |                //--- set variables if best mode has changed ---
 3656|      0|                if (( input->rdopt && rdcost < min_rdcost) ||
 3657|      0|                  (!input->rdopt && cost < min_cost8x8  )   )
 3658|      0|                {
 3659|      0|                  min_cost8x8          = cost;
 3660|      0|                  min_rdcost           = rdcost;
 3661|      0|                  part8x8mode  [block] = mode;
 3662|      0|                  part8x8pdir  [block] = best_pdir;
 3663|      0|                  part8x8fwref [block] = best_fw_ref;
 3664|      0|                  part8x8bwref [block] = best_bw_ref;
 3665|       |
 3666|       |#ifdef BEST_NZ_COEFF
 3667|       |                  {
 3668|       |                    int x, y;
 3669|       |                    for(y = 0; y <= 1; y++)
 3670|       |                      for(x = 0; x <= 1; x++)
 3671|       |                        best_nz_coeff[x][y]= cnt_nonz ? img->nz_coeff[img->current_mb_nr][i1 + x][j1 + y] : 0;
 3672|       |                  }
 3673|       |#endif
 3674|       |
 3675|       |                                    
 3676|       |                  //--- store number of nonzero coefficients ---
 3677|      0|                  best_cnt_nonz  = cnt_nonz;
 3678|       |                  
 3679|      0|                  if (input->rdopt)
 3680|      0|                  {
 3681|       |                    //--- store block cbp ---
 3682|      0|                    cbp_blk8x8    &= (~(0x33 << (((block>>1)<<3)+((block%2)<<1)))); // delete bits for block
 3683|      0|                    cbp_blk8x8    |= curr_cbp_blk;
 3684|       |                    
 3685|       |                    //--- store coefficients ---
 3686|      0|                    for (k=0; k< 4; k++)
 3687|      0|                      for (j=0; j< 2; j++)
 3688|      0|                        for (i=0; i<65; i++)  cofAC_8x8ts[block][k][j][i] = img->cofAC[block][k][j][i]; // 18->65 for ABT
 3689|       |                        
 3690|       |                    //--- store reconstruction & prediction ---
 3691|      0|                    for (j=j0; j<j0+8; j++)
 3692|      0|                      for (i=i0; i<i0+8; i++)
 3693|      0|                      {
 3694|       |                        // Residue Color Transform
 3695|      0|                        if(!img->residue_transform_flag)
 3696|      0|                        {
 3697|      0|                          rec_mbY_8x8ts[j][i] = enc_picture->imgY[img->pix_y+j][img->pix_x+i];
 3698|      0|                          mpr_8x8ts   [j][i] = img->mpr[i][j];
 3699|      0|                        } 
 3700|      0|                        else 
 3701|      0|                        {
 3702|      0|                          rec_resG_8x8ts[i][j] = rec_resG[i][j];
 3703|      0|                          resTrans_R_8x8ts[i][j] = resTrans_R[i][j];
 3704|      0|                          resTrans_B_8x8ts[i][j] = resTrans_B[i][j];
 3705|      0|                          mprRGB_8x8ts[0][i][j] = mprRGB[0][i][j];
 3706|      0|                          mprRGB_8x8ts[1][i][j] = mprRGB[1][i][j];
 3707|      0|                          mprRGB_8x8ts[2][i][j] = mprRGB[2][i][j];
 3708|      0|                        }
 3709|      0|                      }
 3710|      0|                  }
 3711|       |
 3712|       |                  //--- store coding state ---
 3713|      0|                  store_coding_state (cs_b8);
 3714|      0|                } // if (rdcost <= min_rdcost)
 3715|       |
 3716|       |                //--- re-set coding state as it was before coding with current mode was performed ---
 3717|      0|                reset_coding_state (cs_cm);
 3718|      0|              } // if ((valid[mode] && mode != 0) || (mode == 0 && active_sps->direct_8x8_inference_flag))
 3719|      0|            } // for (min_rdcost=1e30, index=(bframe?0:1); index<6; index++)
 3720|       |
 3721|       |#ifdef BEST_NZ_COEFF
 3722|       |            {
 3723|       |              int x, y;
 3724|       |              for(y = 0; y <= 1; y++)
 3725|       |                for(x = 0; x <= 1; x++)
 3726|       |                  img->nz_coeff[img->current_mb_nr][i1 + x][j1 + y]
 3727|       |                  = best_nz_coeff[x][y];
 3728|       |            }
 3729|       |#endif
 3730|       |
 3731|      0|            if (!input->rdopt)
 3732|      0|            {
 3733|      0|              cost8x8 += min_cost8x8;
 3734|       |
 3735|      0|              mode = part8x8mode[block];
 3736|      0|              pdir = part8x8pdir[block];
 3737|       |
 3738|      0|              curr_cbp_blk  = 0;
 3739|      0|              best_cnt_nonz = LumaResidualCoding8x8 (&dummy, &curr_cbp_blk, block, pdir,
 3740|      0|                                                    (pdir==0||pdir==2?mode:0),
 3741|      0|                                                    (pdir==1||pdir==2?mode:0),
 3742|      0|                                                    part8x8fwref[block],
 3743|      0|                                                    part8x8bwref[block]);
 3744|      0|              cbp_blk8x8   &= (~(0x33 << (((block>>1)<<3)+((block%2)<<1)))); // delete bits for block
 3745|      0|              cbp_blk8x8   |= curr_cbp_blk;
 3746|       |
 3747|       |              //--- store coefficients ---
 3748|      0|              for (k=0; k< 4; k++)
 3749|      0|                for (j=0; j< 2; j++)
 3750|      0|                  for (i=0; i<65; i++)  cofAC_8x8ts[block][k][j][i] = img->cofAC[block][k][j][i]; // 18->65 for ABT
 3751|       |
 3752|       |              //--- store reconstruction and prediction ---
 3753|      0|              for (j=j0; j<j0+8; j++)
 3754|      0|                for (i=i0; i<i0+8; i++)
 3755|      0|                {
 3756|       |                  // Residue Color Transform
 3757|      0|                  if(!img->residue_transform_flag)
 3758|      0|                  {
 3759|      0|                    rec_mbY_8x8ts[j][i] = enc_picture->imgY[img->pix_y+j][img->pix_x+i];
 3760|      0|                    mpr_8x8ts    [j][i] = img->mpr[i][j];
 3761|      0|                  } 
 3762|      0|                  else 
 3763|      0|                  {
 3764|      0|                    rec_resG_8x8ts[i][j] = rec_resG[i][j];
 3765|      0|                    resTrans_R_8x8ts[i][j] = resTrans_R[i][j];
 3766|      0|                    resTrans_B_8x8ts[i][j] = resTrans_B[i][j];
 3767|      0|                    mprRGB_8x8ts[0][i][j] = mprRGB[0][i][j];
 3768|      0|                    mprRGB_8x8ts[1][i][j] = mprRGB[1][i][j];
 3769|      0|                    mprRGB_8x8ts[2][i][j] = mprRGB[2][i][j];
 3770|      0|                  }
 3771|      0|                }
 3772|      0|            }
 3773|       |
 3774|       |            //----- set cbp and count of nonzero coefficients ---
 3775|      0|            if (best_cnt_nonz)
 3776|      0|            {
 3777|      0|              cbp8x8        |= (1<<block);
 3778|      0|              cnt_nonz_8x8   += best_cnt_nonz;
 3779|      0|            }
 3780|       |
 3781|       |            //======= save motion data for 8x8 partition for transform size 8x8 ========
 3782|      0|            StoreNewMotionVectorsBlock8x8(0, block, part8x8mode[block], part8x8fwref[block], part8x8bwref[block], part8x8pdir[block], bframe);
 3783|       |
 3784|       |            //set motion data for using as predictor data for next run
 3785|      0|            SetRefAndMotionVectors (block, part8x8mode[block], part8x8pdir[block], part8x8fwref[block], part8x8bwref[block]);
 3786|       |
 3787|       |            //===== set the coding state after current block =====
 3788|      0|            if (block < 3)
 3789|      0|              reset_coding_state (cs_b8);
 3790|       |
 3791|      0|          } // for (cbp8x8=cbp_blk8x8=cnt_nonz_8x8=0, block=0; block<4; block++)
 3792|       |
 3793|      0|          cbp8_8x8ts      = cbp8x8;
 3794|      0|          cbp_blk8_8x8ts  = cbp_blk8x8;
 3795|      0|          cnt_nonz8_8x8ts = cnt_nonz_8x8;
 3796|      0|          cost8_8x8ts     = cost8x8;                //for disabled rd-opt
 3797|      0|          currMB->luma_transform_size_8x8_flag = 0; //switch to 4x4 transform size
 3798|      0|        }// if (input->AllowTransform8x8)
 3799|       |
 3800|  90.8k|        cost8x8 = INT_MAX;
 3801|       |
 3802|  90.8k|        if (input->AllowTransform8x8 != 2)  
 3803|  90.8k|        {
 3804|  90.8k|          cost8x8 = 0;
 3805|       |
 3806|       |          //=================================================================
 3807|       |          // Check 8x8, 8x4, 4x8 and 4x4 partitions with transform size 4x4
 3808|       |          //=================================================================
 3809|       |          //=====  LOOP OVER 8x8 SUB-PARTITIONS  (Motion Estimation & Mode Decision) =====
 3810|   454k|          for (cost_direct=cbp8x8=cbp_blk8x8=cnt_nonz_8x8=0, block=0; block<4; block++)
 3811|   363k|          {
 3812|       |            //--- set coordinates ---
 3813|   363k|            j0 = ((block/2)<<3);    j1 = (j0>>2);
 3814|   363k|            i0 = ((block%2)<<3);    i1 = (i0>>2);
 3815|       |            
 3816|       |#ifdef BEST_NZ_COEFF
 3817|       |            {
 3818|       |              int x, y;
 3819|       |              for(y = 0; y <= 1; y++)
 3820|       |                for(x = 0; x <= 1; x++)
 3821|       |                  best_nz_coeff[x][y] = img->nz_coeff[img->current_mb_nr][i1 + x][j1 + y] = 0;
 3822|       |            }
 3823|       |#endif
 3824|       |            //=====  LOOP OVER POSSIBLE CODING MODES FOR 8x8 SUB-PARTITION  =====
 3825|  2.03M|            for (min_cost8x8=INT_MAX, min_rdcost=1e30, index=(bframe?0:1); index<5; index++)
 3826|  1.67M|            {
 3827|  1.67M|              if (valid[mode=b8_mode_table[index]])
 3828|  1.67M|              {
 3829|  1.67M|                curr_cbp_blk = 0;
 3830|       |                
 3831|  1.67M|                if (mode==0)
 3832|   217k|                {
 3833|       |                  //--- Direct Mode ---
 3834|   217k|                  if (!input->rdopt)
 3835|      0|                  {
 3836|      0|                    cost = Get_Direct_Cost8x8 ( block,  &direct8x8_tmp);
 3837|      0|                    if((cost==INT_MAX)||(cost_direct==INT_MAX))
 3838|      0|                    {
 3839|      0|                      cost_direct = INT_MAX;
 3840|      0|                    }
 3841|      0|                    else
 3842|      0|                    {
 3843|      0|                      cost_direct += cost;
 3844|      0|                    }
 3845|      0|                    have_direct ++;
 3846|      0|                  }
 3847|   217k|                  best_fw_ref = direct_ref_idx[LIST_0][img->block_x+(block&1)*2][img->block_y+(block&2)];
 3848|   217k|                  best_bw_ref = direct_ref_idx[LIST_1][img->block_x+(block&1)*2][img->block_y+(block&2)];
 3849|   217k|                  best_pdir   = direct_pdir[img->block_x+(block&1)*2][img->block_y+(block&2)];
 3850|   217k|                } // if (mode==0)
 3851|  1.45M|                else
 3852|  1.45M|                {
 3853|       |                  //--- motion estimation for all reference frames ---
 3854|  1.45M|                  PartitionMotionSearch (mode, block, lambda_motion);
 3855|       |                  
 3856|       |                  //--- get cost and reference frame for forward prediction ---
 3857|  8.58M|                  for (fw_mcost=max_mcost, ref=0; ref<listXsize[LIST_0+list_offset]; ref++)
 3858|  7.12M|                  {
 3859|  7.12M|                    if (!checkref || ref==0 || CheckReliabilityOfRef (block, LIST_0, ref, mode))
 3860|  7.12M|                    {
 3861|  7.12M|                      mcost  = (input->rdopt ? REF_COST(lambda_motion_factor,ref,LIST_0+list_offset) : (int)(2*lambda_motion*min(ref,1)));
 3862|       |                      
 3863|  7.12M|                      mcost += motion_cost[mode][LIST_0][ref][block];
 3864|  7.12M|                      if (mcost < fw_mcost)
 3865|  1.80M|                      {
 3866|  1.80M|                        fw_mcost    = mcost;
 3867|  1.80M|                        best_fw_ref = ref;
 3868|  1.80M|                      }
 3869|  7.12M|                    }
 3870|  7.12M|                  }
 3871|       |                  
 3872|       |                  //store forward reference index for every block
 3873|  4.36M|                  for (j=0; j<2; j++)
 3874|  8.72M|                    for (i=0; i<2; i++)
 3875|  5.81M|                    {
 3876|  5.81M|                      enc_picture->ref_idx[LIST_0][img->block_x+(block&1)*2+i][img->block_y+(block&2)+j] = best_fw_ref;
 3877|  5.81M|                      enc_picture->ref_pic_id [LIST_0][img->block_x+(block&1)*2+i][img->block_y+(block&2)+j] = enc_picture->ref_pic_num[LIST_0 + list_offset][enc_picture->ref_idx[LIST_0][img->block_x+(block&1)*2+i][img->block_y+(block&2)+j]];
 3878|  5.81M|                    }
 3879|       |                    
 3880|  1.45M|                    if (bframe)
 3881|   870k|                    {
 3882|  1.74M|                      for (bw_mcost=max_mcost, ref=0; ref<listXsize[LIST_1+list_offset]; ref++)
 3883|   870k|                      {
 3884|   870k|                        mcost  = (input->rdopt ? REF_COST(lambda_motion_factor,ref,LIST_1+list_offset) : (int)(2*lambda_motion*min(ref,1)));
 3885|       |                        
 3886|   870k|                        mcost += motion_cost[mode][LIST_1][ref][block];
 3887|   870k|                        if (mcost < bw_mcost)
 3888|   870k|                        {
 3889|   870k|                          bw_mcost    = mcost;
 3890|   870k|                          best_bw_ref = ref;
 3891|   870k|                        }
 3892|   870k|                      }
 3893|       |                      
 3894|       |                      // bidirectional uses best forward and zero backward reference
 3895|   870k|                      bid_mcost  = (input->rdopt ? (REF_COST (lambda_motion_factor, best_fw_ref, LIST_0 + list_offset)+REF_COST (lambda_motion_factor, 0, LIST_1 + list_offset)) : (int)(2*lambda_motion*min(best_fw_ref,1)));
 3896|   870k|                      bid_mcost += BIDPartitionCost (mode, block, best_fw_ref, 0, lambda_motion_factor );
 3897|       |                      
 3898|       |                      //--- get prediction direction ----
 3899|   870k|                      if      (fw_mcost<=bw_mcost && fw_mcost<=bid_mcost)
 3900|   367k|                      {
 3901|   367k|                        best_pdir = 0;
 3902|   367k|                        cost = fw_mcost;
 3903|   367k|                        best_bw_ref = -1;
 3904|   367k|                      }
 3905|   503k|                      else if (bw_mcost<=fw_mcost && bw_mcost<=bid_mcost)
 3906|   497k|                      {
 3907|   497k|                        best_pdir = 1;
 3908|   497k|                        cost = bw_mcost;
 3909|   497k|                        best_fw_ref = -1;
 3910|   497k|                      }
 3911|  5.80k|                      else
 3912|  5.80k|                      {
 3913|  5.80k|                        best_pdir = 2;
 3914|  5.80k|                        cost = bid_mcost;
 3915|  5.80k|                        best_bw_ref = 0;
 3916|  5.80k|                      }
 3917|       |                      //store backward reference index for every block
 3918|  2.61M|                      for (j=0; j<2; j++)
 3919|  5.22M|                        for (i=0; i<2; i++)
 3920|  3.48M|                        {
 3921|  3.48M|                          enc_picture->ref_idx[LIST_0][img->block_x+(block&1)*2+i][img->block_y+(block&2)+j] = best_fw_ref;
 3922|  3.48M|                          enc_picture->ref_idx[LIST_1][img->block_x+(block&1)*2+i][img->block_y+(block&2)+j] = best_bw_ref;
 3923|  3.48M|                        }
 3924|   870k|                    } // if (bframe)
 3925|   583k|                    else
 3926|   583k|                    {
 3927|   583k|                      best_pdir = 0;
 3928|   583k|                      cost      = fw_mcost;
 3929|   583k|                    }
 3930|  1.45M|                } // if (mode!=0)
 3931|       |                
 3932|       |                //--- store coding state before coding with current mode ---
 3933|  1.67M|                store_coding_state (cs_cm);
 3934|       |                
 3935|  1.67M|                if (input->rdopt)
 3936|  1.67M|                {
 3937|       |                  //--- get and check rate-distortion cost ---
 3938|  1.67M|                  rdcost = RDCost_for_8x8blocks (&cnt_nonz, &curr_cbp_blk, lambda_mode,
 3939|  1.67M|                    block, mode, best_pdir, best_fw_ref, best_bw_ref);
 3940|  1.67M|                }
 3941|      0|                else
 3942|      0|                {
 3943|      0|                  if (cost!=INT_MAX)
 3944|      0|                  cost += (REF_COST (lambda_motion_factor, B8Mode2Value (mode, best_pdir), list_offset + (best_pdir<1?0:1)) - 1);
 3945|      0|                }
 3946|       |                
 3947|       |                //--- set variables if best mode has changed ---
 3948|  1.67M|                if (( input->rdopt && rdcost < min_rdcost) ||
 3949|  1.67M|                  (!input->rdopt && cost   < min_cost8x8  )   )
 3950|   400k|                {
 3951|   400k|                  min_cost8x8                  = cost;
 3952|   400k|                  min_rdcost                   = rdcost;
 3953|   400k|                  best8x8mode          [block] = mode;
 3954|   400k|                  best8x8pdir    [P8x8][block] = best_pdir;
 3955|   400k|                  best8x8fwref   [P8x8][block] = best_fw_ref;
 3956|   400k|                  best8x8bwref   [P8x8][block] = best_bw_ref;
 3957|       |                  
 3958|       |                  
 3959|       |#ifdef BEST_NZ_COEFF
 3960|       |                  {
 3961|       |                    int x, y;
 3962|       |                    for(y = 0; y <= 1; y++)
 3963|       |                      for(x = 0; x <= 1; x++)
 3964|       |                        best_nz_coeff[x][y]= cnt_nonz ? img->nz_coeff[img->current_mb_nr][i1 + x][j1 + y] : 0;
 3965|       |                  }
 3966|       |#endif
 3967|       |                  
 3968|       |                  //--- store number of nonzero coefficients ---
 3969|   400k|                  best_cnt_nonz  = cnt_nonz;
 3970|       |                  
 3971|   400k|                  if (input->rdopt)
 3972|   400k|                  {
 3973|       |                    //--- store block cbp ---
 3974|   400k|                    cbp_blk8x8    &= (~(0x33 << (((block>>1)<<3)+((block%2)<<1)))); // delete bits for block
 3975|   400k|                    cbp_blk8x8    |= curr_cbp_blk;
 3976|       |                    
 3977|       |                    //--- store coefficients ---
 3978|  2.00M|                    for (k=0; k< 4; k++)
 3979|  4.80M|                      for (j=0; j< 2; j++)
 3980|   211M|                        for (i=0; i<65; i++)  cofAC8x8[block][k][j][i] = img->cofAC[block][k][j][i]; // 18->65 for ABT
 3981|       |                        
 3982|       |                    //--- store reconstruction and prediction ---
 3983|  3.60M|                    for (j=j0; j<j0+8; j++)
 3984|  28.8M|                      for (i=i0; i<i0+8; i++)
 3985|  25.6M|                      {
 3986|  25.6M|                        rec_mbY8x8[j][i] = enc_picture->imgY[img->pix_y+j][img->pix_x+i];
 3987|  25.6M|                        mpr8x8    [j][i] = img->mpr[i][j];
 3988|  25.6M|                      }
 3989|   400k|                  }
 3990|       |                  // Residue Color Transform
 3991|   400k|                  if(img->residue_transform_flag)
 3992|      0|                  {
 3993|      0|                    for (j=j0; j<j0+8; j++)
 3994|      0|                      for (i=i0; i<i0+8; i++)
 3995|      0|                      {
 3996|      0|                        rec_resG_8x8[i][j] = rec_resG[i][j];
 3997|      0|                        resTrans_R_8x8[i][j] = resTrans_R[i][j];
 3998|      0|                        resTrans_B_8x8[i][j] = resTrans_B[i][j];
 3999|      0|                        mprRGB_8x8[0][i][j] = mprRGB[0][i][j];
 4000|      0|                        mprRGB_8x8[1][i][j] = mprRGB[1][i][j];
 4001|      0|                        mprRGB_8x8[2][i][j] = mprRGB[2][i][j];
 4002|      0|                      }
 4003|      0|                  }
 4004|       |
 4005|       |                  //--- store coding state ---
 4006|   400k|                  store_coding_state (cs_b8);
 4007|   400k|                } // if (rdcost <= min_rdcost)
 4008|       |                
 4009|       |                //--- re-set coding state as it was before coding with current mode was performed ---
 4010|  1.67M|                reset_coding_state (cs_cm);
 4011|  1.67M|              } // if (valid[mode=b8_mode_table[index]])
 4012|  1.67M|            } // for (min_rdcost=1e30, index=(bframe?0:1); index<6; index++)
 4013|       |
 4014|       |#ifdef BEST_NZ_COEFF
 4015|       |            {
 4016|       |              int x, y;
 4017|       |              for(y = 0; y <= 1; y++)
 4018|       |                for(x = 0; x <= 1; x++)
 4019|       |                  img->nz_coeff[img->current_mb_nr][i1 + x][j1 + y]
 4020|       |                  = best_nz_coeff[x][y];
 4021|       |            }
 4022|       |#endif
 4023|       |            
 4024|   363k|            cost8x8 += min_cost8x8;
 4025|       |            
 4026|   363k|            if (!input->rdopt)
 4027|      0|            {
 4028|      0|              mode = best8x8mode[block];
 4029|      0|              pdir = best8x8pdir[P8x8][block];
 4030|       |              
 4031|      0|              curr_cbp_blk  = 0;
 4032|      0|              best_cnt_nonz = LumaResidualCoding8x8 (&dummy, &curr_cbp_blk, block, pdir,
 4033|      0|                                                      (pdir==0||pdir==2?mode:0),
 4034|      0|                                                      (pdir==1||pdir==2?mode:0),
 4035|      0|                                                      best8x8fwref[P8x8][block],
 4036|      0|                                                      best8x8bwref[P8x8][block]);
 4037|       |
 4038|      0|              cbp_blk8x8   &= (~(0x33 << (((block>>1)<<3)+((block%2)<<1)))); // delete bits for block
 4039|      0|              cbp_blk8x8   |= curr_cbp_blk;
 4040|       |
 4041|       |              //--- store coefficients ---
 4042|      0|              for (k=0; k< 4; k++)
 4043|      0|                for (j=0; j< 2; j++)
 4044|      0|                  for (i=0; i<65; i++)  cofAC8x8[block][k][j][i] = img->cofAC[block][k][j][i]; // 18->65 for ABT
 4045|       |
 4046|       |                  //--- store reconstruction and prediction ---
 4047|      0|                  for (j=j0; j<j0+8; j++)
 4048|      0|                    for (i=i0; i<i0+8; i++)
 4049|      0|                    {
 4050|      0|                      rec_mbY8x8[j][i] = enc_picture->imgY[img->pix_y+j][img->pix_x+i];
 4051|      0|                      mpr8x8    [j][i] = img->mpr[i][j];
 4052|      0|                    }
 4053|       |                  // Residue Color Transform
 4054|      0|                  if(img->residue_transform_flag)
 4055|      0|                  {
 4056|      0|                    for (j=j0; j<j0+8; j++)
 4057|      0|                      for (i=i0; i<i0+8; i++)
 4058|      0|                      {
 4059|      0|                        rec_resG_8x8[i][j] = rec_resG[i][j];
 4060|      0|                        resTrans_R_8x8[i][j] = resTrans_R[i][j];
 4061|      0|                        resTrans_B_8x8[i][j] = resTrans_B[i][j];
 4062|      0|                        mprRGB_8x8[0][i][j] = mprRGB[0][i][j];
 4063|      0|                        mprRGB_8x8[1][i][j] = mprRGB[1][i][j];
 4064|      0|                        mprRGB_8x8[2][i][j] = mprRGB[2][i][j];
 4065|      0|                      }
 4066|      0|                  }
 4067|      0|            }
 4068|       |            
 4069|       |            //----- set cbp and count of nonzero coefficients ---
 4070|   363k|            if (best_cnt_nonz)
 4071|  5.91k|            {
 4072|  5.91k|              cbp8x8        |= (1<<block);
 4073|  5.91k|              cnt_nonz_8x8  += best_cnt_nonz;
 4074|  5.91k|            }
 4075|       |            
 4076|   363k|            mode=best8x8mode[block];
 4077|       |            //===== reset intra prediction modes (needed for prediction, must be stored after 8x8 mode dec.) =====
 4078|   363k|            j0 = img->block_y+2*(block/2);
 4079|   363k|            i0 = img->block_x+2*(block%2);
 4080|  1.09M|            for (j=j0; j<j0+2; j++)
 4081|  2.18M|              for (i=i0; i<i0+2; i++) 
 4082|  1.45M|                ipredmodes[i][j]         = DC_PRED;
 4083|       |              
 4084|   363k|            i0 = 4*block;
 4085|  1.81M|            for (i=i0; i<i0+4; i++)    currMB->intra_pred_modes[i]  = DC_PRED;
 4086|       |            
 4087|   363k|            if (block<3)
 4088|   272k|            {
 4089|       |              //===== re-set reconstructed block =====
 4090|   272k|              j0   = 8*(block/2);
 4091|   272k|              i0   = 8*(block%2);
 4092|  2.45M|              for (j=j0; j<j0+8; j++)
 4093|  19.6M|                for (i=i0; i<i0+8; i++)  
 4094|  17.4M|                  enc_picture->imgY[img->pix_y+j][img->pix_x+i] = rec_mbY8x8[j][i];
 4095|   272k|            } // if (block<3)
 4096|       |              
 4097|       |              //===== set motion vectors and reference frames (prediction) =====
 4098|   363k|              SetRefAndMotionVectors (block, mode, best8x8pdir[P8x8][block], best8x8fwref[P8x8][block], best8x8bwref[P8x8][block]);
 4099|       |
 4100|       |              //===== set the coding state after current block =====
 4101|   363k|              reset_coding_state (cs_b8);
 4102|       |
 4103|   363k|          } // for (cbp8x8=cbp_blk8x8=cnt_nonz_8x8=0, block=0; block<4; block++)
 4104|  90.8k|        } // if (input->AllowTransform8x8 != 2)
 4105|       |
 4106|       |
 4107|       |        //--- re-set coding state (as it was before 8x8 block coding) ---
 4108|  90.8k|        reset_coding_state (cs_mb);
 4109|  1.54M|        for (i=0; i<16; i++)
 4110|  24.7M|          for(j=0; j<16; j++)
 4111|  23.2M|            diffy[j][i] = imgY_org[img->opix_y+j][img->opix_x+i]-img->mpr[i][j];
 4112|       |
 4113|       |        //check cost for P8x8 for non-rdopt mode
 4114|  90.8k|        if (!input->rdopt && (cost8x8 < min_cost || cost8_8x8ts < min_cost))
 4115|      0|        {
 4116|      0|          best_mode = P8x8;
 4117|      0|          if (input->AllowTransform8x8)
 4118|      0|          {
 4119|      0|            if (cost8_8x8ts < cost8x8)
 4120|      0|            {
 4121|      0|              min_cost = cost8_8x8ts;
 4122|      0|              currMB->luma_transform_size_8x8_flag=1;
 4123|      0|            }
 4124|      0|            else if(cost8x8 < cost8_8x8ts)
 4125|      0|            {
 4126|      0|              min_cost = cost8x8;
 4127|      0|              currMB->luma_transform_size_8x8_flag=0;
 4128|      0|            }
 4129|      0|            else
 4130|      0|            {
 4131|      0|              min_cost = cost8_8x8ts;
 4132|      0|              currMB->luma_transform_size_8x8_flag=1;
 4133|      0|              if (GetBestTransformP8x8() == 0)
 4134|      0|              {
 4135|      0|                min_cost = cost8x8;
 4136|      0|                currMB->luma_transform_size_8x8_flag=0;
 4137|      0|              }
 4138|      0|            }
 4139|      0|          }
 4140|      0|          else
 4141|      0|          {
 4142|      0|            min_cost = cost8x8;
 4143|      0|            currMB->luma_transform_size_8x8_flag=0;
 4144|      0|          }
 4145|      0|        }// if (!input->rdopt && (cost8x8 < min_cost || cost8_8x8ts < min_cost))
 4146|  90.8k|      }
 4147|      0|      else // if (valid[P8x8])
 4148|      0|      {
 4149|      0|        cost8x8 = INT_MAX;
 4150|      0|      }
 4151|       |
 4152|       |      // Find a motion vector for the Skip mode
 4153|  90.8k|      if((img->type == P_SLICE)||(img->type == SP_SLICE))
 4154|  36.4k|        FindSkipModeMotionVector ();
 4155|  90.8k|    }
 4156|  18.5k|    else // if (img->type!=I_SLICE)
 4157|  18.5k|    {
 4158|  18.5k|      min_cost = INT_MAX;
 4159|  18.5k|    }
 4160|       |
 4161|       |    //========= C H O O S E   B E S T   M A C R O B L O C K   M O D E =========
 4162|       |    //-------------------------------------------------------------------------
 4163|       |
 4164|   109k|    if (input->rdopt)
 4165|   109k|    {
 4166|   109k|      int mb_available_up;
 4167|   109k|      int mb_available_left;
 4168|   109k|      int mb_available_up_left;
 4169|       |
 4170|   109k|      min_rdcost = max_rdcost;
 4171|       |
 4172|   109k|      if (img->yuv_format != YUV400)
 4173|   109k|      {
 4174|       |        // precompute all new chroma intra prediction modes
 4175|   109k|        IntraChromaPrediction(&mb_available_up, &mb_available_left, &mb_available_up_left);
 4176|   547k|        for (currMB->c_ipred_mode=DC_PRED_8; currMB->c_ipred_mode<=PLANE_8; currMB->c_ipred_mode++)
 4177|   437k|        {
 4178|       |
 4179|       |          // bypass if c_ipred_mode is not allowed
 4180|   437k|          if ((input->ChromaIntraDisable == 1 && currMB->c_ipred_mode!=DC_PRED_8) ||
 4181|   437k|            (currMB->c_ipred_mode==VERT_PRED_8 && !mb_available_up) ||
 4182|   437k|              (currMB->c_ipred_mode==HOR_PRED_8 && !mb_available_left) ||
 4183|   437k|              (currMB->c_ipred_mode==PLANE_8 && (!mb_available_left || !mb_available_up || !mb_available_up_left)))
 4184|  17.6k|            continue;
 4185|       |
 4186|       |          // Residue Color Transform
 4187|   420k|          if(img->residue_transform_flag)
 4188|      0|            max_index = 11;
 4189|   420k|          else
 4190|   420k|            max_index = 8;
 4191|       |
 4192|   420k|#if BI_PREDICTION
 4193|   420k|          if (input->BiPredMotionEstimation)
 4194|      0|          img->bi_pred_me[1] =0;  
 4195|   420k|#endif
 4196|       |
 4197|       |          //===== GET BEST MACROBLOCK MODE =====
 4198|  4.19M|          for (ctr16x16=0, index=0; index<max_index; index++)
 4199|  3.77M|          {
 4200|  3.77M|            mode = mb_mode_table[index];
 4201|       |            // Residue Color Transform
 4202|  3.77M|            if(img->residue_transform_flag)
 4203|      0|            {
 4204|      0|              mode = mb_mode_table_RCT[index];
 4205|      0|              if( mode == I16MB) i16mode = index -5;
 4206|       |              // bypass if i16mode is not allowed
 4207|      0|              if (mode == I16MB &&
 4208|      0|                ((i16mode==VERT_PRED_16 && !mb_available_up) ||
 4209|      0|                (i16mode==HOR_PRED_16 && !mb_available_left) ||
 4210|      0|                (i16mode==PLANE_16 && (!mb_available_left || !mb_available_up || !mb_available_up_left))))
 4211|      0|                continue;
 4212|      0|            }
 4213|  3.77M|            else
 4214|  3.77M|            {
 4215|  3.77M|              mode = mb_mode_table[index];
 4216|  3.77M|              i16mode = 0; 
 4217|  3.77M|            }
 4218|       |
 4219|       |            //--- for INTER16x16 check all prediction directions ---
 4220|  3.77M|            if (mode==1 && img->type==B_SLICE)
 4221|   626k|            {
 4222|   626k|              best8x8pdir[1][0] = best8x8pdir[1][1] = best8x8pdir[1][2] = best8x8pdir[1][3] = ctr16x16;
 4223|   626k|#if BI_PREDICTION            
 4224|   626k|              if ((input->BiPredMotionEstimation) && (img->type==B_SLICE))
 4225|      0|              {
 4226|      0|                if (ctr16x16 == 2 && img->bi_pred_me[mode] < 2 && mode == 1 ) 
 4227|      0|                {
 4228|      0|                  ctr16x16--;
 4229|      0|                }                
 4230|      0|              }
 4231|   626k|#endif
 4232|   626k|              if (ctr16x16 < 2) index--;
 4233|   626k|              ctr16x16++;
 4234|   626k|            }
 4235|       |
 4236|  3.77M|            img->NoResidueDirect = 0;
 4237|       |
 4238|  3.77M|            if (input->SkipIntraInInterSlices && img->type != I_SLICE)
 4239|      0|            {
 4240|      0|              if (mode >= I16MB && best_mode == 0 && currMB->cbp == 0)
 4241|      0|              {
 4242|      0|                valid[mode] = 0;
 4243|      0|              }
 4244|      0|            }
 4245|       |
 4246|  3.77M|            if (valid[mode])
 4247|  3.00M|            {
 4248|       |              //--- transform size ---
 4249|  3.00M|              currMB->luma_transform_size_8x8_flag = 0; //4x4 transform defined
 4250|  3.00M|              if (input->AllowTransform8x8==2)
 4251|      0|              {
 4252|      0|                if (mode >= 1 && mode <= 3)
 4253|      0|                  currMB->luma_transform_size_8x8_flag = 1;
 4254|      0|                else if (mode == 0 && bframe && active_sps->direct_8x8_inference_flag)
 4255|      0|                  currMB->luma_transform_size_8x8_flag = 1;
 4256|      0|                else if ((mode == P8x8) && (valid[4]))
 4257|      0|                  currMB->luma_transform_size_8x8_flag = 1; //run mode 4 with 8x8 transform
 4258|      0|              }
 4259|       |
 4260|       |              // bypass if c_ipred_mode not used
 4261|  3.00M|              SetModesAndRefframeForBlocks (mode);
 4262|  3.00M|              if (currMB->c_ipred_mode == DC_PRED_8 || (IS_INTRA(currMB) ))
 4263|  1.40M|              {
 4264|  1.40M|                while(1)
 4265|  1.40M|                {
 4266|  1.40M|                  if (RDCost_for_macroblocks (lambda_mode, mode, &min_rdcost, i16mode))
 4267|   186k|                  {
 4268|       |                    //Rate control
 4269|   186k|                    if(mode == P8x8)
 4270|  2.25k|                    {
 4271|  38.4k|                      for (i=0; i<16; i++)
 4272|   614k|                        for(j=0; j<16; j++)
 4273|   578k|                          diffy[j][i] = imgY_org[img->opix_y+j][img->opix_x+i] - mpr8x8[j][i];
 4274|  2.25k|                    }else
 4275|   184k|                    {
 4276|  3.12M|                      for (i=0; i<16; i++)
 4277|  50.0M|                        for(j=0; j<16; j++)
 4278|  47.1M|                          diffy[j][i] = imgY_org[img->opix_y+j][img->opix_x+i] - pred[j][i];
 4279|   184k|                    }
 4280|       |
 4281|   186k|                    store_macroblock_parameters (mode);
 4282|   186k|                  }
 4283|       |
 4284|  1.40M|                  if (input->AllowTransform8x8==1)
 4285|      0|                  {
 4286|       |                    //=========== try mb_types 1,2,3 with 8x8 transform ===========
 4287|      0|                    if ((mode >= 1 && mode <= 3) && currMB->luma_transform_size_8x8_flag == 0)
 4288|      0|                    {
 4289|       |                      //try with 8x8 transform size
 4290|      0|                      currMB->luma_transform_size_8x8_flag = 1;
 4291|      0|                      continue;
 4292|      0|                    }
 4293|       |                    //=========== try DIRECT-MODE with 8x8 transform ===========
 4294|      0|                    else if (mode == 0 && bframe && active_sps->direct_8x8_inference_flag && currMB->luma_transform_size_8x8_flag == 0)
 4295|      0|                    {
 4296|       |                      //try with 8x8 transform size
 4297|      0|                      currMB->luma_transform_size_8x8_flag = 1;
 4298|      0|                      continue;
 4299|      0|                    }
 4300|       |                    //=========== try mb_type P8x8 for mode 4 with 4x4/8x8 transform ===========
 4301|      0|                    else if ((mode == P8x8) && (valid[4]) && (currMB->luma_transform_size_8x8_flag == 0))
 4302|      0|                    {
 4303|      0|                      currMB->luma_transform_size_8x8_flag = 1; //check 8x8 partition for transform size 8x8
 4304|      0|                      continue;
 4305|      0|                    }
 4306|      0|                    else
 4307|      0|                    {
 4308|      0|                      currMB->luma_transform_size_8x8_flag = 0;
 4309|      0|                      break;
 4310|      0|                    }
 4311|      0|                  }
 4312|  1.40M|                  else
 4313|  1.40M|                    break;
 4314|  1.40M|                }
 4315|  1.40M|              } // if (currMB->c_ipred_mode == DC_PRED_8 ||(IS_INTRA(currMB) ))
 4316|       |
 4317|  3.00M|              if (valid[0] && bframe && mode == 0 && currMB->cbp && (currMB->cbp&15) != 15 && !input->nobskip)
 4318|   101k|              {
 4319|   101k|                img->NoResidueDirect = 1;
 4320|   101k|                if (RDCost_for_macroblocks (lambda_mode, mode, &min_rdcost, i16mode))
 4321|  5.03k|                {
 4322|       |                  //Rate control
 4323|  85.6k|                  for (i=0; i<16; i++)
 4324|  1.37M|                    for(j=0; j<16; j++)
 4325|  1.28M|                      diffy[j][i] = imgY_org[img->opix_y+j][img->opix_x+i] - pred[j][i];
 4326|  5.03k|                    store_macroblock_parameters (mode);
 4327|  5.03k|                }
 4328|   101k|              }
 4329|  3.00M|            } // if valid[mode]
 4330|  3.77M|#if BI_PREDICTION            
 4331|  3.77M|            if ((input->BiPredMotionEstimation) && (img->type==B_SLICE))
 4332|      0|            {
 4333|      0|              if (ctr16x16 == 2 && img->bi_pred_me[mode] < 2 && mode == 1 && best8x8pdir[1][0] == 2) 
 4334|      0|              {
 4335|      0|                img->bi_pred_me[mode] = img->bi_pred_me[mode] + 1;
 4336|      0|              }
 4337|      0|            }
 4338|       |            
 4339|  3.77M|#endif
 4340|       |
 4341|  3.77M|          }// for (ctr16x16=0, index=0; index<8; index++)
 4342|   420k|        }// for (currMB->c_ipred_mode=DC_PRED_8; currMB->c_ipred_mode<=PLANE_8; currMB->c_ipred_mode++)
 4343|   109k|      }//if (img->yuv_format != YUV400)
 4344|      0|      else
 4345|      0|      {
 4346|      0|#if BI_PREDICTION            
 4347|      0|        if (input->BiPredMotionEstimation)
 4348|      0|          img->bi_pred_me[1] =0;  
 4349|      0|#endif
 4350|       |        //============= YUV400 ===============
 4351|       |        //===== GET BEST MACROBLOCK MODE =====
 4352|      0|        for (ctr16x16=0, index=0; index<8; index++)
 4353|      0|        {
 4354|      0|          mode = mb_mode_table[index];
 4355|       |
 4356|       |          //--- for INTER16x16 check all prediction directions ---
 4357|      0|          if (mode==1 && img->type==B_SLICE)
 4358|      0|          {
 4359|      0|            best8x8pdir[1][0] = best8x8pdir[1][1] = best8x8pdir[1][2] = best8x8pdir[1][3] = ctr16x16;
 4360|      0|#if BI_PREDICTION            
 4361|      0|            if ((input->BiPredMotionEstimation) && (img->type==B_SLICE))
 4362|      0|            {
 4363|      0|              if (ctr16x16 == 2 && img->bi_pred_me[mode] < 2 && mode == 1 ) 
 4364|      0|              {
 4365|      0|                ctr16x16--;
 4366|      0|              }
 4367|       |              
 4368|      0|            }
 4369|      0|#endif
 4370|       |            
 4371|      0|            if (ctr16x16 < 2) index--;
 4372|      0|            ctr16x16++;
 4373|      0|         }
 4374|       |
 4375|      0|          img->NoResidueDirect = 0;
 4376|       |
 4377|      0|          if (valid[mode])
 4378|      0|          {
 4379|       |            //--- transform size ---
 4380|      0|            currMB->luma_transform_size_8x8_flag = 0; //4x4 transform defined
 4381|      0|            if (input->AllowTransform8x8==2)
 4382|      0|            {
 4383|      0|              if (mode >= 1 && mode <= 3)
 4384|      0|                currMB->luma_transform_size_8x8_flag = 1;
 4385|      0|              else if (mode == 0 && bframe && active_sps->direct_8x8_inference_flag)
 4386|      0|                currMB->luma_transform_size_8x8_flag = 1;
 4387|      0|              else if ((mode == P8x8) && (valid[4]))
 4388|      0|                currMB->luma_transform_size_8x8_flag = 1; //run mode 4 with 8x8 transform
 4389|      0|            }
 4390|       |
 4391|       |            // bypass if c_ipred_mode not used
 4392|      0|            SetModesAndRefframeForBlocks (mode);
 4393|      0|            if (currMB->c_ipred_mode == DC_PRED_8 || (IS_INTRA(currMB) ))
 4394|      0|            {
 4395|      0|              while(1)
 4396|      0|              {
 4397|      0|                if (RDCost_for_macroblocks (lambda_mode, mode, &min_rdcost, i16mode))
 4398|      0|                {
 4399|       |                  //Rate control
 4400|      0|                  if(mode == P8x8)
 4401|      0|                  {
 4402|      0|                    for (i=0; i<16; i++)
 4403|      0|                      for(j=0; j<16; j++)
 4404|      0|                        diffy[j][i] = imgY_org[img->opix_y+j][img->opix_x+i] - mpr8x8[j][i];
 4405|      0|                  }else
 4406|      0|                  {
 4407|      0|                    for (i=0; i<16; i++)
 4408|      0|                      for(j=0; j<16; j++)
 4409|      0|                        diffy[j][i] = imgY_org[img->opix_y+j][img->opix_x+i] - pred[j][i];
 4410|      0|                  }
 4411|       |
 4412|      0|                  store_macroblock_parameters (mode);
 4413|      0|                }
 4414|       |
 4415|      0|                if (input->AllowTransform8x8==1)
 4416|      0|                {
 4417|       |                  //=========== try mb_types 1,2,3 with 8x8 transform ===========
 4418|      0|                  if ((mode >= 1 && mode <= 3) && currMB->luma_transform_size_8x8_flag == 0)
 4419|      0|                  {
 4420|       |                    //try with 8x8 transform size
 4421|      0|                    currMB->luma_transform_size_8x8_flag = 1;
 4422|      0|                    continue;
 4423|      0|                  }
 4424|       |                  //=========== try DIRECT-MODE with 8x8 transform ===========
 4425|      0|                  else if (mode == 0 && bframe && active_sps->direct_8x8_inference_flag && currMB->luma_transform_size_8x8_flag == 0)
 4426|      0|                  {
 4427|       |                    //try with 8x8 transform size
 4428|      0|                    currMB->luma_transform_size_8x8_flag = 1;
 4429|      0|                    continue;
 4430|      0|                  }
 4431|       |                  //=========== try mb_type P8x8 for mode 4 with 4x4/8x8 transform ===========
 4432|      0|                  else if ((mode == P8x8) && (valid[4]) && (currMB->luma_transform_size_8x8_flag == 0))
 4433|      0|                  {
 4434|      0|                    currMB->luma_transform_size_8x8_flag = 1; //check 8x8 partition for transform size 8x8
 4435|      0|                    continue;
 4436|      0|                  }
 4437|      0|                  else
 4438|      0|                  {
 4439|      0|                    currMB->luma_transform_size_8x8_flag = 0;
 4440|      0|                    break;
 4441|      0|                  }
 4442|      0|                }
 4443|      0|                else
 4444|      0|                  break;
 4445|      0|              }
 4446|      0|            } // if (currMB->c_ipred_mode == DC_PRED_8 ||(IS_INTRA(currMB) ))
 4447|       |
 4448|      0|            if (valid[0] && bframe && mode == 0 && currMB->cbp && (currMB->cbp&15) != 15 && !input->nobskip) //g050
 4449|      0|            {
 4450|      0|              img->NoResidueDirect = 1;
 4451|      0|              if (RDCost_for_macroblocks (lambda_mode, mode, &min_rdcost, i16mode))
 4452|      0|              {
 4453|       |                //Rate control
 4454|      0|                for (i=0; i<16; i++)
 4455|      0|                  for(j=0; j<16; j++)
 4456|      0|                    diffy[j][i] = imgY_org[img->opix_y+j][img->opix_x+i] - pred[j][i];
 4457|      0|                  store_macroblock_parameters (mode);
 4458|      0|              }
 4459|      0|            }
 4460|       |        
 4461|      0|          } // if valid[mode]
 4462|      0|#if BI_PREDICTION            
 4463|      0|          if ((input->BiPredMotionEstimation) && (img->type==B_SLICE))
 4464|      0|          {
 4465|      0|            if (ctr16x16 == 2 && img->bi_pred_me[mode] < 2 && mode == 1 && best8x8pdir[1][0] == 2) 
 4466|      0|            {
 4467|      0|              img->bi_pred_me[mode] = img->bi_pred_me[mode] + 1;
 4468|      0|            }
 4469|      0|          }         
 4470|      0|#endif
 4471|      0|        }// for (ctr16x16=0, index=0; index<8; index++)
 4472|      0|      }//else - if (img->yuv_format != YUV400)
 4473|   109k|    }
 4474|      0|    else //rdopt off
 4475|      0|    {
 4476|      0|      tmp_8x8_flag = currMB->luma_transform_size_8x8_flag;	//save 8x8_flag
 4477|      0|      tmp_no_mbpart = currMB->NoMbPartLessThan8x8Flag;		  //save no-part-less
 4478|       |
 4479|      0|      if (img->yuv_format != YUV400)
 4480|       |        // precompute all chroma intra prediction modes
 4481|      0|        IntraChromaPrediction(NULL, NULL, NULL);
 4482|       |
 4483|      0|      if (valid[0] && bframe) // check DIRECT MODE
 4484|      0|      {
 4485|      0|        if(have_direct)
 4486|      0|        {
 4487|      0|          switch(input->AllowTransform8x8)
 4488|      0|          {
 4489|      0|          case 1: // Mixture of 8x8 & 4x4 transform
 4490|      0|                  if((cost8x8_direct<cost_direct)||
 4491|      0|                  !(valid[5] && valid[6] && valid[7]))
 4492|      0|                  {
 4493|      0|                    cost = cost8x8_direct;
 4494|      0|                  }
 4495|      0|                  else
 4496|      0|                  {
 4497|      0|                    cost = cost_direct;
 4498|      0|                  }
 4499|      0|                  break;
 4500|      0|          case 2: // 8x8 Transform only
 4501|      0|                  cost = cost8x8_direct;
 4502|      0|                  break;
 4503|      0|          default: // 4x4 Transform only
 4504|      0|                  cost = cost_direct;
 4505|      0|                  break;
 4506|      0|          }
 4507|      0|        }
 4508|      0|        else
 4509|      0|        { //!have_direct
 4510|      0|          cost = Get_Direct_CostMB (lambda_mode);
 4511|      0|        }
 4512|      0|        cost -= (int)floor(16*lambda_motion+0.4999);
 4513|      0|        if (cost <= min_cost)
 4514|      0|        {
 4515|      0|          if(active_sps->direct_8x8_inference_flag && input->AllowTransform8x8)
 4516|      0|          {
 4517|      0|            if(input->AllowTransform8x8==2)
 4518|      0|              currMB->luma_transform_size_8x8_flag=1;
 4519|      0|            else
 4520|      0|            {
 4521|      0|              if(cost8x8_direct<cost_direct)
 4522|      0|                currMB->luma_transform_size_8x8_flag=1;
 4523|      0|              else
 4524|      0|                currMB->luma_transform_size_8x8_flag=0;
 4525|      0|            }
 4526|      0|          }
 4527|      0|          else
 4528|      0|            currMB->luma_transform_size_8x8_flag=0;
 4529|       |          
 4530|       |          //Rate control
 4531|      0|          for (i=0; i<16; i++)
 4532|      0|            for(j=0; j<16; j++)
 4533|      0|              diffy[j][i] = imgY_org[img->pix_y+j][img->pix_x+i]-img->mpr[i][j];
 4534|       |
 4535|      0|          min_cost  = cost;
 4536|      0|          best_mode = 0;
 4537|      0|        }
 4538|      0|        else
 4539|      0|        {
 4540|      0|			    currMB->luma_transform_size_8x8_flag = tmp_8x8_flag; // restore if not best
 4541|      0|		      currMB->NoMbPartLessThan8x8Flag = tmp_no_mbpart; // restore if not best
 4542|      0|    		}
 4543|       |
 4544|      0|      }
 4545|      0|      if (valid[I8MB]) // check INTRA8x8
 4546|      0|      {
 4547|      0|        currMB->luma_transform_size_8x8_flag = 1; // at this point cost will ALWAYS be less than min_cost 
 4548|       |
 4549|      0|        currMB->mb_type = I8MB;
 4550|      0|        temp_cpb = Mode_Decision_for_new_Intra8x8Macroblock (lambda_mode, &cost);
 4551|       |
 4552|      0|        if (cost <= min_cost)
 4553|      0|        {
 4554|       |        // Residue Color Transform
 4555|      0|           if(img->residue_transform_flag)
 4556|      0|           {
 4557|       |
 4558|      0|               for(i=0; i<2; i++)
 4559|      0|                 for(j=0; j<4; j++)
 4560|      0|                   for(k=0; k<4; k++)
 4561|      0|                     if(cbp_chroma_block[i][j][k])
 4562|      0|                       cr_cbp = 2;
 4563|       |
 4564|      0|               cr_cbp = dct_chroma_DC(0, cr_cbp);
 4565|      0|               cr_cbp = dct_chroma_DC(1, cr_cbp);
 4566|       |
 4567|      0|               temp_cpb += (cr_cbp<<4);
 4568|      0|               for(j=0; j<MB_BLOCK_SIZE; j++)
 4569|      0|                 for(i=0; i<MB_BLOCK_SIZE; i++)
 4570|      0|                 {
 4571|      0|                   temp_imgU[j][i] = enc_picture->imgUV[0][img->pix_y+j][img->pix_x+i];
 4572|      0|                   temp_imgV[j][i] = enc_picture->imgUV[1][img->pix_y+j][img->pix_x+i];
 4573|      0|                 }
 4574|      0|           }
 4575|       |           
 4576|      0|           currMB->cbp = temp_cpb;
 4577|       |           
 4578|       |           //coeffs
 4579|      0|           if (input->AllowTransform8x8 != 2)
 4580|      0|           {
 4581|      0|             i4p=cofAC; cofAC=img->cofAC; img->cofAC=i4p;
 4582|      0|           }
 4583|       |           
 4584|      0|           for(j=0; j<MB_BLOCK_SIZE; j++)
 4585|      0|             for(i=0; i<MB_BLOCK_SIZE; i++)
 4586|      0|             {
 4587|      0|               temp_imgY[j][i] = enc_picture->imgY[img->pix_y+j][img->pix_x+i];
 4588|      0|             }
 4589|       |
 4590|       |           //Rate control
 4591|      0|           for (i=0; i<16; i++)
 4592|      0|             for(j=0; j<16; j++)
 4593|      0|               diffy[j][i] = imgY_org[img->pix_y+j][img->pix_x+i]-img->mpr[i][j];
 4594|       |
 4595|      0|           min_cost  = cost;
 4596|      0|           best_mode = I8MB;
 4597|      0|           tmp_8x8_flag = currMB->luma_transform_size_8x8_flag;
 4598|      0|        } 
 4599|      0|        else
 4600|      0|          currMB->luma_transform_size_8x8_flag = tmp_8x8_flag; // restore if not best
 4601|      0|      }
 4602|      0|      if (valid[I4MB]) // check INTRA4x4
 4603|      0|      {
 4604|      0|        currMB->luma_transform_size_8x8_flag = 0;
 4605|      0|        currMB->mb_type = I4MB;
 4606|      0|        temp_cpb = Mode_Decision_for_Intra4x4Macroblock (lambda_mode, &cost);
 4607|       |        
 4608|      0|        if (cost <= min_cost)
 4609|      0|        {
 4610|       |        // Residue Color Transform
 4611|      0|          if(img->residue_transform_flag)
 4612|      0|          {
 4613|      0|            for(i=0; i<2; i++)
 4614|      0|              for(j=0; j<4; j++)
 4615|      0|                for(k=0; k<4; k++)
 4616|      0|                  if(cbp_chroma_block[i][j][k])
 4617|      0|                    cr_cbp = 2;
 4618|       |
 4619|      0|            cr_cbp = dct_chroma_DC(0, cr_cbp);
 4620|      0|            cr_cbp = dct_chroma_DC(1, cr_cbp);
 4621|       |
 4622|      0|            temp_cpb += (cr_cbp<<4);
 4623|      0|          }
 4624|      0|          currMB->cbp = temp_cpb;
 4625|       |
 4626|       |          //Rate control
 4627|      0|          for (i=0; i<16; i++)
 4628|      0|            for(j=0; j<16; j++)
 4629|      0|              diffy[j][i] = imgY_org[img->pix_y+j][img->pix_x+i]-img->mpr[i][j];
 4630|       |
 4631|      0|          min_cost  = cost;
 4632|      0|          best_mode = I4MB;
 4633|      0|          tmp_8x8_flag = currMB->luma_transform_size_8x8_flag;
 4634|      0|        } 
 4635|      0|        else
 4636|      0|        {
 4637|      0|          currMB->luma_transform_size_8x8_flag = tmp_8x8_flag; // restore if not best
 4638|       |          //coeffs
 4639|      0|          i4p=cofAC; cofAC=img->cofAC; img->cofAC=i4p;
 4640|      0|        }
 4641|      0|      }
 4642|      0|      if (valid[I16MB]) // check INTRA16x16
 4643|      0|      {
 4644|      0|        currMB->luma_transform_size_8x8_flag = 0;
 4645|      0|        intrapred_luma_16x16 ();
 4646|      0|        cost = find_sad_16x16 (&i16mode);
 4647|       |
 4648|      0|        if (cost < min_cost)
 4649|      0|        {
 4650|       |          //Rate control
 4651|      0|          for (i=0; i<16; i++)
 4652|      0|            for(j=0; j<16; j++)
 4653|      0|              diffy[j][i] = imgY_org[img->pix_y+j][img->pix_x+i]-img->mprr_2[i16mode][j][i];
 4654|       |
 4655|       |          // Residue Color Transform
 4656|      0|          if(img->residue_transform_flag)
 4657|      0|          {
 4658|      0|            for (j=0; j<16; j++)
 4659|      0|              for (i=0; i<16; i++)
 4660|      0|              {
 4661|      0|                residue_B = imgUV_org[0][img->pix_y+j][img->pix_x+i] - img->mprr_c[0][currMB->c_ipred_mode][i][j];
 4662|      0|                residue_G = imgY_org[img->pix_y+j][img->pix_x+i] - img->mprr_2[i16mode][j][i];
 4663|      0|                residue_R = imgUV_org[1][img->pix_y+j][img->pix_x+i] - img->mprr_c[1][currMB->c_ipred_mode][i][j];
 4664|       |                
 4665|       |                /* Forward Residue Transform */
 4666|      0|                resTrans_R[i][j] = residue_R-residue_B;
 4667|      0|                temp = residue_B+(resTrans_R[i][j]>>1);
 4668|      0|                resTrans_B[i][j] = residue_G-temp;
 4669|      0|                resTrans_G[i][j] = temp+(resTrans_B[i][j]>>1);
 4670|       |                
 4671|      0|                img->m7[i][j]  = resTrans_G[i][j];
 4672|      0|              }
 4673|      0|          }
 4674|      0|          best_mode   = I16MB;
 4675|      0|          currMB->cbp = dct_luma_16x16 (i16mode);
 4676|       |
 4677|       |          // Residue Color Transform
 4678|      0|          if(img->residue_transform_flag)
 4679|      0|          {
 4680|      0|            for (j=0; j<16; j++)
 4681|      0|            for (i=0; i<16; i++)
 4682|      0|            {
 4683|      0|              rec_resG[i][j] = img->m7[i][j];
 4684|      0|              img->m7[i][j]  = resTrans_R[i][j];
 4685|      0|            }
 4686|       |
 4687|      0|            cr_cbp = dct_chroma(0, 0);
 4688|       |
 4689|      0|            for (j=0; j<16; j++)
 4690|      0|            for (i=0; i<16; i++)
 4691|      0|            {
 4692|      0|              rec_resR[i][j] = img->m7[i][j];
 4693|      0|              img->m7[i][j]  = resTrans_B[i][j];
 4694|      0|            }
 4695|       |
 4696|      0|            cr_cbp = dct_chroma(1, cr_cbp);
 4697|       |
 4698|      0|            for (j=0; j<16; j++)
 4699|      0|            for (i=0; i<16; i++)
 4700|      0|            {
 4701|      0|              rec_resB[i][j] = img->m7[i][j];
 4702|      0|            }
 4703|       |
 4704|      0|            currMB->cbp += (cr_cbp<<4);
 4705|       |
 4706|       |            /* Inverse Residue Transform */
 4707|      0|            for (j=0; j<16; j++)
 4708|      0|            for (i=0; i<16; i++)
 4709|      0|            {
 4710|      0|              temp      = rec_resG[i][j]-(rec_resB[i][j]>>1);
 4711|      0|              residue_G = rec_resB[i][j]+temp;
 4712|      0|              residue_B = temp - (rec_resR[i][j]>>1);
 4713|      0|              residue_R = residue_B+rec_resR[i][j];
 4714|       |
 4715|      0|              enc_picture->imgUV[0][img->pix_y+j][img->pix_x+i] = min(img->max_imgpel_value_uv,max(0,residue_B+(int)img->mprr_c[0][currMB->c_ipred_mode][i][j]));
 4716|      0|              enc_picture->imgY[img->pix_y+j][img->pix_x+i]     = min(img->max_imgpel_value,max(0,residue_G+(int)img->mprr_2[i16mode][j][i]));
 4717|      0|              enc_picture->imgUV[1][img->pix_y+j][img->pix_x+i] = min(img->max_imgpel_value_uv,max(0,residue_R+(int)img->mprr_c[1][currMB->c_ipred_mode][i][j]));
 4718|      0|            }
 4719|      0|          }
 4720|      0|        }
 4721|      0|        else
 4722|      0|        {
 4723|      0|			    currMB->luma_transform_size_8x8_flag = tmp_8x8_flag; // restore
 4724|      0|			    currMB->NoMbPartLessThan8x8Flag = tmp_no_mbpart;     // restore
 4725|      0|        }
 4726|      0|      }
 4727|      0|    }
 4728|       |
 4729|   109k|    if (rerun==0)
 4730|   109k|    {
 4731|   109k|      intra1 = (currMB->mb_type==I16MB || currMB->mb_type==I4MB || currMB->mb_type==I8MB ? 1 : 0);
 4732|   109k|    }
 4733|   109k|  } // for (rerun=0; rerun<runs; rerun++)
 4734|       |
 4735|       |
 4736|       |  //=====  S E T   F I N A L   M A C R O B L O C K   P A R A M E T E R S ======
 4737|       |  //---------------------------------------------------------------------------
 4738|       |
 4739|   109k|  if (input->rdopt)
 4740|   109k|  {
 4741|       |
 4742|   109k|    if ((cbp!=0 || best_mode==I16MB ))
 4743|  28.3k|      currMB->prev_cbp = 1;
 4744|  81.1k|    else if (cbp==0 && !input->RCEnable)
 4745|  81.1k|    {
 4746|  81.1k|      currMB->delta_qp = 0;
 4747|  81.1k|      currMB->qp = currMB->prev_qp;
 4748|  81.1k|      img->qp = currMB->qp;
 4749|  81.1k|      currMB->prev_cbp = 0;
 4750|  81.1k|    }
 4751|       |
 4752|   109k|    set_stored_macroblock_parameters ();
 4753|   109k|  }
 4754|      0|  else
 4755|      0|  {
 4756|       |    //===== set parameters for chosen mode =====
 4757|      0|    SetModesAndRefframeForBlocks (best_mode);
 4758|       |
 4759|      0|    if (best_mode==P8x8)
 4760|      0|    {
 4761|      0|      if (currMB->luma_transform_size_8x8_flag && (cbp8_8x8ts == 0) && input->AllowTransform8x8 != 2)
 4762|      0|        currMB->luma_transform_size_8x8_flag = 0;
 4763|       |
 4764|      0|      SetCoeffAndReconstruction8x8 (currMB);
 4765|       |
 4766|      0|      for (k=0, j=img->block_y; j<img->block_y+4; j++)
 4767|      0|        for (     i=img->block_x; i<img->block_x+4; i++, k++)
 4768|      0|        {
 4769|      0|          ipredmodes    [i][j] = DC_PRED;
 4770|      0|          currMB->intra_pred_modes[k] = DC_PRED;
 4771|      0|        }
 4772|      0|    }
 4773|      0|    else
 4774|      0|    {
 4775|       |      //===== set parameters for chosen mode =====
 4776|      0|      if (best_mode == I8MB)
 4777|      0|      {
 4778|      0|        for(i = k = 0; i < 4; i++)
 4779|      0|          for(j = 0; j < 4; j++,k++)
 4780|      0|          {
 4781|      0|            img->ipredmode[img->block_x+i][img->block_y+j] = img->ipredmode8x8[img->block_x+i][img->block_y+j];
 4782|       |            //only every fourth value relevant
 4783|      0|            currMB->intra_pred_modes[k] = currMB->intra_pred_modes8x8[k];
 4784|      0|          }
 4785|       |
 4786|       |        //--- restore reconstruction for 8x8 transform ---
 4787|      0|        for(j=0; j<MB_BLOCK_SIZE; j++)
 4788|      0|          for(i=0; i<MB_BLOCK_SIZE; i++)
 4789|      0|            enc_picture->imgY[img->pix_y+j][img->pix_x+i] = temp_imgY[j][i];
 4790|       |        // Residue Color Transform
 4791|      0|        if(img->residue_transform_flag)
 4792|      0|        {
 4793|       |
 4794|      0|           for(j=0; j<MB_BLOCK_SIZE; j++)
 4795|      0|             for(i=0; i<MB_BLOCK_SIZE; i++)
 4796|      0|             {
 4797|      0|               enc_picture->imgUV[0][img->pix_y+j][img->pix_x+i] = temp_imgU[j][i] ;
 4798|      0|               enc_picture->imgUV[1][img->pix_y+j][img->pix_x+i] = temp_imgV[j][i] ;
 4799|      0|             }
 4800|       |             
 4801|      0|        }
 4802|      0|      }
 4803|       |
 4804|      0|      if ((best_mode!=I4MB)&&(best_mode != I8MB))
 4805|      0|      {
 4806|      0|        for (k=0, j=img->block_y; j<img->block_y+4; j++)
 4807|      0|          for (     i=img->block_x; i<img->block_x+4; i++, k++)
 4808|      0|          {
 4809|      0|            ipredmodes    [i][j] = DC_PRED;
 4810|      0|            currMB->intra_pred_modes[k] = DC_PRED;
 4811|      0|          }
 4812|      0|          if (best_mode!=I16MB)
 4813|      0|          {
 4814|      0|            if((best_mode>=1) && (best_mode<=3))
 4815|      0|              currMB->luma_transform_size_8x8_flag = best_transform_flag;
 4816|      0|            LumaResidualCoding ();
 4817|       |
 4818|      0|            if((currMB->cbp==0)&&(best_mode==0))
 4819|      0|              currMB->luma_transform_size_8x8_flag = 0;
 4820|       |
 4821|       |            //Rate control
 4822|      0|            for (i=0; i<16; i++)
 4823|      0|              for(j=0; j<16; j++)
 4824|      0|                diffy[j][i] = imgY_org[img->pix_y+j][img->pix_x+i]-img->mpr[i][j];
 4825|      0|          }
 4826|      0|      }
 4827|      0|    }
 4828|       |
 4829|       |    //check luma cbp for transform size flag
 4830|      0|    if (((currMB->cbp&15) == 0) && !(IS_OLDINTRA(currMB) || currMB->mb_type == I8MB))
 4831|      0|      currMB->luma_transform_size_8x8_flag = 0;
 4832|       |
 4833|      0|    if (img->yuv_format != YUV400)
 4834|       |      // precompute all chroma intra prediction modes
 4835|      0|      IntraChromaPrediction(NULL, NULL, NULL);
 4836|      0|    img->i16offset = 0;
 4837|      0|    dummy = 0;
 4838|       |    // Residue Color Transform
 4839|      0|    if ((!(img->residue_transform_flag && (best_mode==I4MB || best_mode==I16MB || best_mode==I8MB))) && img->yuv_format!=YUV400)
 4840|      0|      ChromaResidualCoding (&dummy);
 4841|      0|    if (best_mode==I16MB)
 4842|      0|    {
 4843|      0|      img->i16offset = I16Offset  (currMB->cbp, i16mode);
 4844|      0|    }
 4845|      0|    SetMotionVectorsMB (currMB, bframe);
 4846|       |
 4847|       |    //===== check for SKIP mode =====
 4848|      0|    if ((img->type==P_SLICE || img->type==SP_SLICE) && best_mode==1 && currMB->cbp==0 &&
 4849|      0|      enc_picture->ref_idx[LIST_0][img->block_x][img->block_y]==0 &&
 4850|      0|      enc_picture->mv[LIST_0][img->block_x][img->block_y][0]==allmvs[0][0][0][0][0][0] &&
 4851|      0|      enc_picture->mv[LIST_0][img->block_x][img->block_y][1]==allmvs[0][0][0][0][0][1]               )
 4852|      0|    {
 4853|      0|      currMB->mb_type=currMB->b8mode[0]=currMB->b8mode[1]=currMB->b8mode[2]=currMB->b8mode[3]=0;
 4854|      0|      currMB->luma_transform_size_8x8_flag = 0;
 4855|      0|    }
 4856|       |
 4857|      0|    if(img->MbaffFrameFlag)
 4858|      0|      set_mbaff_parameters();
 4859|      0|  }
 4860|       |  
 4861|       |  // Rate control
 4862|   109k|  if(input->RCEnable)
 4863|      0|  {   
 4864|      0|    if(img->type==P_SLICE)
 4865|      0|    {
 4866|      0|      img->MADofMB[img->current_mb_nr] = calc_MAD();
 4867|       |      
 4868|      0|      if(input->basicunit<img->Frame_Total_Number_MB)
 4869|      0|      {
 4870|      0|        img->TotalMADBasicUnit +=img->MADofMB[img->current_mb_nr];
 4871|       |        
 4872|       |        /* delta_qp is present only for non-skipped macroblocks*/
 4873|      0|        if ((cbp!=0 || best_mode==I16MB))
 4874|      0|          currMB->prev_cbp = 1;
 4875|      0|        else
 4876|      0|        {
 4877|      0|   	      currMB->delta_qp = 0;
 4878|      0|          currMB->qp = currMB->prev_qp;
 4879|      0|          img->qp = currMB->qp;
 4880|      0|          currMB->prev_cbp = 0;
 4881|      0|        }
 4882|       |        /* When MBAFF is used, delta_qp is only present for the first non-skipped macroblock of each 
 4883|       |        macroblock pair*/
 4884|      0|        if (input->MbInterlace)
 4885|      0|        {
 4886|      0|          if(!currMB->mb_field)
 4887|      0|          {
 4888|      0|            DELTA_QP = currMB->delta_qp;
 4889|      0|            QP      = currMB->qp;
 4890|      0|          }
 4891|      0|          else
 4892|      0|          {
 4893|      0|            DELTA_QP2 = currMB->delta_qp;
 4894|      0|            QP2      = currMB->qp;
 4895|      0|          }
 4896|      0|        }       
 4897|      0|      }
 4898|      0|    }
 4899|      0|  }
 4900|       |  
 4901|   109k|  if(input->rdopt)
 4902|   109k|    rdopt->min_rdcost = min_rdcost;
 4903|      0|  else
 4904|      0|    rdopt->min_rdcost = min_cost;
 4905|       |
 4906|   109k|  if(img->MbaffFrameFlag)
 4907|      0|  {
 4908|      0|    if (img->current_mb_nr%2) //bottom
 4909|      0|    {
 4910|      0|      if ((currMB->mb_type ? 0:((img->type == B_SLICE) ? !currMB->cbp:1))  // bottom is skip
 4911|      0|        &&(prevMB->mb_type ? 0:((img->type == B_SLICE) ? !prevMB->cbp:1))) // top is skip
 4912|      0|      {
 4913|      0|        if (!(field_flag_inference() == curr_mb_field))
 4914|      0|        {
 4915|      0|          rdopt->min_rdcost = 1e30;  // don't allow coding of an MB pair as skip if wrong inference
 4916|      0|        }
 4917|      0|      }
 4918|      0|    }
 4919|      0|  }
 4920|       |
 4921|       |  //===== Decide if this MB will restrict the reference frames =====
 4922|   109k|  if (input->RestrictRef==1)
 4923|      0|  {
 4924|      0|    if (input->rdopt==1)
 4925|      0|    {
 4926|      0|      refresh_map[2*img->mb_y  ][2*img->mb_x  ] = (intra ? 1 : 0);
 4927|      0|      refresh_map[2*img->mb_y  ][2*img->mb_x+1] = (intra ? 1 : 0);
 4928|      0|      refresh_map[2*img->mb_y+1][2*img->mb_x  ] = (intra ? 1 : 0);
 4929|      0|      refresh_map[2*img->mb_y+1][2*img->mb_x+1] = (intra ? 1 : 0);
 4930|      0|    }
 4931|      0|    else if (input->rdopt==2)
 4932|      0|    {
 4933|      0|      refresh_map[2*img->mb_y  ][2*img->mb_x  ] = (intra1==0 && (currMB->mb_type==I16MB || currMB->mb_type==I4MB) ? 1 : 0);
 4934|      0|      refresh_map[2*img->mb_y  ][2*img->mb_x+1] = (intra1==0 && (currMB->mb_type==I16MB || currMB->mb_type==I4MB) ? 1 : 0);
 4935|      0|      refresh_map[2*img->mb_y+1][2*img->mb_x  ] = (intra1==0 && (currMB->mb_type==I16MB || currMB->mb_type==I4MB) ? 1 : 0);
 4936|      0|      refresh_map[2*img->mb_y+1][2*img->mb_x+1] = (intra1==0 && (currMB->mb_type==I16MB || currMB->mb_type==I4MB) ? 1 : 0);
 4937|      0|    }
 4938|      0|  }
 4939|   109k|  else if (input->RestrictRef==2)
 4940|      0|  {
 4941|      0|    refresh_map[2*img->mb_y  ][2*img->mb_x  ] = (currMB->mb_type==I16MB || currMB->mb_type==I4MB ? 1 : 0);
 4942|      0|    refresh_map[2*img->mb_y  ][2*img->mb_x+1] = (currMB->mb_type==I16MB || currMB->mb_type==I4MB ? 1 : 0);
 4943|      0|    refresh_map[2*img->mb_y+1][2*img->mb_x  ] = (currMB->mb_type==I16MB || currMB->mb_type==I4MB ? 1 : 0);
 4944|      0|    refresh_map[2*img->mb_y+1][2*img->mb_x+1] = (currMB->mb_type==I16MB || currMB->mb_type==I4MB ? 1 : 0);
 4945|      0|  }
 4946|       |
 4947|   109k|  if(input->FMEnable)
 4948|      0|    skip_intrabk_SAD(best_mode, listXsize[LIST_0+list_offset]);
 4949|   109k|}
 4950|       |
 4951|       |
 4952|       |void set_mbaff_parameters()
 4953|      0|{
 4954|      0|  int  i, j, k, l;
 4955|      0|  Macroblock  *currMB  = &img->mb_data[img->current_mb_nr];
 4956|      0|  int         mode     = best_mode;
 4957|      0|  int         bframe   = (img->type==B_SLICE);
 4958|      0|  int     **ipredmodes = img->ipredmode;
 4959|       |
 4960|      0|  if (!img->MbaffFrameFlag)
 4961|      0|    return;
 4962|       |
 4963|       |  //===== reconstruction values =====
 4964|      0|  for (j=0; j<16; j++)
 4965|      0|  for (i=0; i<16; i++)
 4966|      0|    rdopt->rec_mbY[j][i]           = enc_picture->imgY[img->pix_y+j][img->pix_x+i];
 4967|       |
 4968|      0|  if (img->yuv_format != YUV400)
 4969|      0|  {
 4970|      0|    for (j=0; j<img->mb_cr_size_y; j++)
 4971|      0|    for (i=0; i<img->mb_cr_size_x; i++)
 4972|      0|    {
 4973|      0|      rdopt->rec_mbU[j][i]           = enc_picture->imgUV[0][img->pix_c_y+j][img->pix_c_x+i];
 4974|      0|      rdopt->rec_mbV[j][i]           = enc_picture->imgUV[1][img->pix_c_y+j][img->pix_c_x+i];
 4975|      0|    }
 4976|      0|  }
 4977|       |
 4978|       |  //===== coefficients and cbp =====
 4979|      0|  rdopt->mode = mode;
 4980|      0|  rdopt->i16offset = img->i16offset;  // For MBINTLC  -Rajeev
 4981|      0|  rdopt->cbp = currMB->cbp;
 4982|      0|  rdopt->cbp_blk = currMB->cbp_blk;
 4983|      0|  rdopt->mb_type  =currMB->mb_type;
 4984|       |
 4985|      0|  rdopt->luma_transform_size_8x8_flag = currMB->luma_transform_size_8x8_flag;
 4986|       |
 4987|      0|  if(rdopt->mb_type == 0 && mode != 0)
 4988|      0|  {
 4989|      0|    mode=0;
 4990|      0|    rdopt->mode=0;
 4991|      0|  }
 4992|       |
 4993|      0|  for(i=0;i<4+img->num_blk8x8_uv;i++)
 4994|      0|    for(j=0;j<4;j++)
 4995|      0|      for(k=0;k<2;k++)
 4996|      0|        for(l=0;l<65;l++)
 4997|      0|          rdopt->cofAC[i][j][k][l] = img->cofAC[i][j][k][l];
 4998|       |
 4999|      0|  for(i=0;i<3;i++)
 5000|      0|    for(k=0;k<2;k++)
 5001|      0|      for(l=0;l<18;l++)
 5002|      0|        rdopt->cofDC[i][k][l] = img->cofDC[i][k][l];
 5003|       |
 5004|       |
 5005|      0|  for (i=0; i<4; i++)
 5006|      0|  {
 5007|      0|    rdopt->b8mode[i]  = currMB->b8mode[i];
 5008|      0|    rdopt->b8pdir[i]  = currMB->b8pdir[i];
 5009|      0|  }
 5010|       |
 5011|       |  //==== reference frames =====
 5012|      0|  for (j=0; j<4; j++)
 5013|      0|    for (i=0; i<4; i++)
 5014|      0|    {
 5015|      0|      rdopt->refar[LIST_0][j][i]       = enc_picture->ref_idx[LIST_0][img->block_x+i][img->block_y+j];
 5016|      0|    }
 5017|       |
 5018|      0|  if (bframe)
 5019|      0|  {
 5020|      0|    for (j=0; j<4; j++)
 5021|      0|      for (i=0; i<4; i++)
 5022|      0|      {
 5023|      0|        rdopt->refar[LIST_1][j][i]     = enc_picture->ref_idx[LIST_1][img->block_x+i][img->block_y+j];
 5024|      0|      }
 5025|      0|#if BI_PREDICTION
 5026|      0|    rdopt->bi_pred_me = currMB->bi_pred_me;
 5027|      0|#endif
 5028|      0|  }
 5029|       |
 5030|       |
 5031|      0|  for   (k=0, j=img->block_y; j<img->block_y+4; j++)
 5032|      0|    for (     i=img->block_x; i<img->block_x+4; i++, k++)
 5033|      0|    {
 5034|      0|      rdopt->ipredmode[i][j]     = ipredmodes[i][j];
 5035|      0|      rdopt->intra_pred_modes[k] = currMB->intra_pred_modes[k];
 5036|      0|    }
 5037|      0|}
 5038|       |
 5039|       |/*!
 5040|       |************************************************************************
 5041|       |* \brief
 5042|       |*    store coding state (for rd-optimized mode decision), used for 8x8 transformation
 5043|       |************************************************************************
 5044|       |*/
 5045|       |void store_coding_state_cs_cm()
 5046|      0|{
 5047|      0|  store_coding_state(cs_cm);
 5048|      0|}
 5049|       |
 5050|       |/*!
 5051|       |************************************************************************
 5052|       |* \brief
 5053|       |*    restore coding state (for rd-optimized mode decision), used for 8x8 transformation
 5054|       |************************************************************************
 5055|       |*/
 5056|       |void reset_coding_state_cs_cm()
 5057|      0|{
 5058|      0|  reset_coding_state(cs_cm);
 5059|      0|}

/home/xzp/speccpu2006-v1.0.1/benchspec/CPU2006/464.h264ref/run/build_base_ql_riscv_llvm17.0000/rdopt_coding_state.c:
    1|       |
    2|       |/*!
    3|       | ***************************************************************************
    4|       | * \file rdopt_coding_state.c
    5|       | *
    6|       | * \brief
    7|       | *    Storing/restoring coding state for
    8|       | *    Rate-Distortion optimized mode decision
    9|       | *
   10|       | * \author
   11|       | *    Heiko Schwarz
   12|       | *
   13|       | * \date
   14|       | *    17. April 2001
   15|       | **************************************************************************/
   16|       |
   17|       |#include <stdlib.h>
   18|       |#include <memory.h>
   19|       |
   20|       |#include "global.h"
   21|       |
   22|       |#include "rdopt_coding_state.h"
   23|       |#include "cabac.h"
   24|       |
   25|       |
   26|       |
   27|       |/*!
   28|       | ************************************************************************
   29|       | * \brief
   30|       | *    delete structure for storing coding state
   31|       | ************************************************************************
   32|       | */
   33|       |void
   34|       |delete_coding_state (CSptr cs)
   35|      7|{
   36|      7|  if (cs != NULL)
   37|      7|  {
   38|       |    //=== structures of data partition array ===
   39|      7|    if (cs->encenv    != NULL)   free (cs->encenv);
   40|      7|    if (cs->bitstream != NULL)   free (cs->bitstream);
   41|       |
   42|       |    //=== contexts for binary arithmetic coding ===
   43|      7|    delete_contexts_MotionInfo  (cs->mot_ctx);
   44|      7|    delete_contexts_TextureInfo (cs->tex_ctx);
   45|       |
   46|       |    //=== coding state structure ===
   47|      7|    free (cs);
   48|      7|    cs=NULL;
   49|      7|  }
   50|      7|}
   51|       |
   52|       |
   53|       |/*!
   54|       | ************************************************************************
   55|       | * \brief
   56|       | *    create structure for storing coding state
   57|       | ************************************************************************
   58|       | */
   59|       |CSptr
   60|       |create_coding_state ()
   61|      7|{
   62|      7|  CSptr cs;
   63|       |
   64|       |  //=== coding state structure ===
   65|      7|  if ((cs = (CSptr) calloc (1, sizeof(CSobj))) == NULL)
   66|      0|    no_mem_exit("init_coding_state: cs");
   67|       |
   68|       |  //=== important variables of data partition array ===
   69|      7|  cs->no_part = input->partition_mode==0?1:3;
   70|      7|  if (input->symbol_mode == CABAC)
   71|      7|  {
   72|      7|    if ((cs->encenv = (EncodingEnvironment*) calloc (cs->no_part, sizeof(EncodingEnvironment))) == NULL)
   73|      0|      no_mem_exit("init_coding_state: cs->encenv");
   74|      7|  }
   75|      0|  else
   76|      0|  {
   77|      0|    cs->encenv = NULL;
   78|      0|  }
   79|      7|  if ((cs->bitstream = (Bitstream*) calloc (cs->no_part, sizeof(Bitstream))) == NULL)
   80|      0|    no_mem_exit("init_coding_state: cs->bitstream");
   81|       |
   82|       |  //=== context for binary arithmetic coding ===
   83|      7|  cs->symbol_mode = input->symbol_mode;
   84|      7|  if (cs->symbol_mode == CABAC)
   85|      7|  {
   86|      7|    cs->mot_ctx = create_contexts_MotionInfo ();
   87|      7|    cs->tex_ctx = create_contexts_TextureInfo();
   88|      7|  }
   89|      0|  else
   90|      0|  {
   91|      0|    cs->mot_ctx = NULL;
   92|      0|    cs->tex_ctx = NULL;
   93|      0|  }
   94|       |
   95|      7|  return cs;
   96|      7|}
   97|       |
   98|       |
   99|       |/*!
  100|       | ************************************************************************
  101|       | * \brief
  102|       | *    store coding state (for rd-optimized mode decision)
  103|       | ************************************************************************
  104|       | */
  105|       |void
  106|       |store_coding_state (CSptr cs)
  107|   123M|{
  108|   123M|  int  i;
  109|       |
  110|   123M|  EncodingEnvironment  *ee_src, *ee_dest;
  111|   123M|  Bitstream            *bs_src, *bs_dest;
  112|       |
  113|   123M|  MotionInfoContexts   *mc_src  = img->currentSlice->mot_ctx;
  114|   123M|  TextureInfoContexts  *tc_src  = img->currentSlice->tex_ctx;
  115|   123M|  MotionInfoContexts   *mc_dest = cs->mot_ctx;
  116|   123M|  TextureInfoContexts  *tc_dest = cs->tex_ctx;
  117|   123M|  Macroblock           *currMB  = &(img->mb_data [img->current_mb_nr]);
  118|       |
  119|       |
  120|   123M|  if (!input->rdopt)  return;
  121|       |
  122|   123M|  if (cs->symbol_mode==CABAC)
  123|   123M|  {
  124|       |  //=== important variables of data partition array ===
  125|       |	//only one partition for IDR img
  126|   247M|  for (i = 0; i <(img->currentPicture->idr_flag? 1:cs->no_part); i++)
  127|   123M|  {
  128|   123M|    ee_src  = &(img->currentSlice->partArr[i].ee_cabac);
  129|   123M|    bs_src  =   img->currentSlice->partArr[i].bitstream;
  130|   123M|    ee_dest = &(cs->encenv   [i]);
  131|   123M|    bs_dest = &(cs->bitstream[i]);
  132|       |
  133|   123M|    memcpy (ee_dest, ee_src, sizeof(EncodingEnvironment));
  134|   123M|    memcpy (bs_dest, bs_src, sizeof(Bitstream));
  135|   123M|  }
  136|       |
  137|       |  //=== contexts for binary arithmetic coding ===
  138|   123M|    memcpy (mc_dest, mc_src, sizeof(MotionInfoContexts));
  139|   123M|    memcpy (tc_dest, tc_src, sizeof(TextureInfoContexts));
  140|       |  
  141|   123M|  }
  142|      0|  else
  143|      0|  {
  144|       |    //=== important variables of data partition array ===
  145|      0|  for (i = 0; i <(img->currentPicture->idr_flag? 1:cs->no_part); i++)
  146|      0|  {    
  147|      0|    bs_src  =   img->currentSlice->partArr[i].bitstream;   
  148|      0|    bs_dest = &(cs->bitstream[i]);
  149|      0|      memcpy (bs_dest, bs_src, sizeof(Bitstream));
  150|      0|    }
  151|      0|  }
  152|       |  //=== syntax element number and bitcounters ===
  153|   123M|  cs->currSEnr = currMB->currSEnr;
  154|   123M|  memcpy (cs->bitcounter, currMB->bitcounter, MAX_BITCOUNTER_MB*sizeof(int));
  155|       |
  156|       |  //=== elements of current macroblock ===
  157|   123M|  memcpy (cs->mvd, currMB->mvd, 2*2*BLOCK_MULTIPLE*BLOCK_MULTIPLE*sizeof(int));
  158|   123M|  cs->cbp_bits = currMB->cbp_bits;
  159|   123M|}
  160|       |
  161|       |
  162|       |/*!
  163|       | ************************************************************************
  164|       | * \brief
  165|       | *    restore coding state (for rd-optimized mode decision)
  166|       | ************************************************************************
  167|       | */
  168|       |void
  169|       |reset_coding_state (CSptr cs)
  170|   123M|{
  171|   123M|  int  i;
  172|       |
  173|   123M|  EncodingEnvironment  *ee_src, *ee_dest;
  174|   123M|  Bitstream            *bs_src, *bs_dest;
  175|       |
  176|   123M|  MotionInfoContexts   *mc_dest = img->currentSlice->mot_ctx;
  177|   123M|  TextureInfoContexts  *tc_dest = img->currentSlice->tex_ctx;
  178|   123M|  MotionInfoContexts   *mc_src  = cs->mot_ctx;
  179|   123M|  TextureInfoContexts  *tc_src  = cs->tex_ctx;
  180|   123M|  Macroblock           *currMB  = &(img->mb_data [img->current_mb_nr]);
  181|       |
  182|       |
  183|   123M|  if (!input->rdopt)  return;
  184|       |
  185|   123M|  if (cs->symbol_mode==CABAC) 
  186|   123M|  {
  187|       |  //=== important variables of data partition array ===
  188|       |  //only one partition for IDR img
  189|   247M|  for (i = 0; i <(img->currentPicture->idr_flag? 1:cs->no_part); i++)
  190|   123M|  {
  191|   123M|    ee_dest = &(img->currentSlice->partArr[i].ee_cabac);
  192|   123M|    bs_dest =   img->currentSlice->partArr[i].bitstream;
  193|   123M|    ee_src  = &(cs->encenv   [i]);
  194|   123M|    bs_src  = &(cs->bitstream[i]);
  195|       |
  196|       |    //--- parameters of encoding environments ---
  197|   123M|    memcpy (ee_dest, ee_src, sizeof(EncodingEnvironment));
  198|   123M|    memcpy (bs_dest, bs_src, sizeof(Bitstream));
  199|   123M|  }
  200|       |
  201|       |
  202|       |  //=== contexts for binary arithmetic coding ===
  203|   123M|    memcpy (mc_dest, mc_src, sizeof(MotionInfoContexts));
  204|   123M|    memcpy (tc_dest, tc_src, sizeof(TextureInfoContexts));
  205|       |    
  206|   123M|  }
  207|      0|  else
  208|      0|  {
  209|       |    //=== important variables of data partition array ===
  210|       |	//only one partition for IDR img
  211|      0|  for (i = 0; i <(img->currentPicture->idr_flag? 1:cs->no_part); i++)
  212|       |
  213|      0|    {
  214|      0|      bs_dest =   img->currentSlice->partArr[i].bitstream;
  215|      0|      bs_src  = &(cs->bitstream[i]);
  216|       |
  217|       |      //--- parameters of encoding environments ---   
  218|      0|      memcpy (bs_dest, bs_src, sizeof(Bitstream));
  219|      0|    }
  220|      0|  }
  221|       |
  222|       |  //=== syntax element number and bitcounters ===
  223|   123M|  currMB->currSEnr = cs->currSEnr;
  224|   123M|  memcpy (currMB->bitcounter, cs->bitcounter, MAX_BITCOUNTER_MB*sizeof(int));
  225|       |
  226|       |  //=== elements of current macroblock ===
  227|   123M|  memcpy (currMB->mvd, cs->mvd, 2*2*BLOCK_MULTIPLE*BLOCK_MULTIPLE*sizeof(int));
  228|   123M|  currMB->cbp_bits = cs->cbp_bits;
  229|   123M|}
  230|       |

/home/xzp/speccpu2006-v1.0.1/benchspec/CPU2006/464.h264ref/run/build_base_ql_riscv_llvm17.0000/rdpicdecision.c:
    1|       |
    2|       |/*!
    3|       |*************************************************************************************
    4|       |* \file rdpicdecision.c
    5|       |*
    6|       |* \brief
    7|       |*    Perform RD optimal decisions between multiple coded versions of the same picture
    8|       |*
    9|       |* \author
   10|       |*    Main contributors (see contributors.h for copyright, address and affiliation details)
   11|       |*     - Alexis Michael Tourapis         <alexismt@ieee.org>
   12|       |*************************************************************************************
   13|       |*/
   14|       |
   15|       |#include "global.h"
   16|       |#include <math.h>
   17|       |
   18|       |
   19|       |/*!
   20|       | ************************************************************************
   21|       | * \brief
   22|       | *    RD decision between possible encoding cases
   23|       | ************************************************************************
   24|       | */
   25|       |int rd_pic_decision(double snrY_version1, double snrY_version2, int bits_version1, int bits_version2, double lambda_picture)
   26|      0|{
   27|      0|  double cost_version1, cost_version2;
   28|       |
   29|      0|  cost_version1 = (double) bits_version1 * lambda_picture + snrY_version1;
   30|      0|  cost_version2 = (double) bits_version2 * lambda_picture + snrY_version2;
   31|       |  //printf("%d %d %.2f %.2f %.2f %.2f \n",bits_version1,bits_version2,snrY_version1,snrY_version2,cost_version1,cost_version2);
   32|      0|  if (cost_version2 > cost_version1 || (cost_version2 == cost_version1 && snrY_version2 >= snrY_version1) )
   33|      0|    return (0);
   34|      0|  else
   35|      0|    return (1);
   36|      0|}
   37|       |
   38|       |/*!
   39|       | ************************************************************************
   40|       | * \brief
   41|       | *    Picture Coding Decision
   42|       | ************************************************************************
   43|       | */
   44|       |int picture_coding_decision (Picture *picture1, Picture *picture2, int qp)
   45|      0|{
   46|      0|  double lambda_picture;
   47|      0|  int spframe = (img->type == SP_SLICE);
   48|      0|  int bframe = (img->type == B_SLICE);
   49|      0|  double snr_picture1, snr_picture2;
   50|      0|  int bit_picture1, bit_picture2;
   51|       |
   52|      0|  if (input->successive_Bframe)
   53|      0|    lambda_picture = 0.68 * pow (2, (qp - SHIFT_QP) / 3.0) * (bframe || spframe ? 2 : 1);    
   54|      0|  else
   55|      0|    lambda_picture = 0.68 * pow (2, (qp - SHIFT_QP) / 3.0);
   56|       |  
   57|      0|  snr_picture1 = picture1->distortion_y + picture1->distortion_u + picture1->distortion_v;  
   58|      0|  snr_picture2 = picture2->distortion_y + picture2->distortion_u + picture2->distortion_v;
   59|      0|  bit_picture2 = picture2->bits_per_picture ;
   60|      0|  bit_picture1 = picture1->bits_per_picture;
   61|       |  
   62|      0|  return rd_pic_decision(snr_picture1, snr_picture2, bit_picture1, bit_picture2, lambda_picture);
   63|      0|}
   64|       |

/home/xzp/speccpu2006-v1.0.1/benchspec/CPU2006/464.h264ref/run/build_base_ql_riscv_llvm17.0000/refbuf.c:
    1|       |
    2|       |/*!
    3|       | ************************************************************************
    4|       | * \file refbuf.c
    5|       | *
    6|       | * \brief
    7|       | *    Declarations of teh reference frame buffer types and functions
    8|       | ************************************************************************
    9|       | */
   10|       |
   11|       |#include <stdlib.h>
   12|       |
   13|       |#include "global.h"
   14|       |
   15|       |#include "refbuf.h"
   16|       |
   17|       |/*!
   18|       | ************************************************************************
   19|       | * \brief
   20|       | *    Reference buffer write routines
   21|       | ************************************************************************
   22|       | */
   23|       |void PutPel_14 (pel_t **Pic, int y, int x, pel_t val)
   24|   234M|{
   25|   234M|  Pic [IMG_PAD_SIZE*4+y][IMG_PAD_SIZE*4+x] = val;
   26|   234M|}
   27|       |
   28|       |void PutPel_11 (pel_t *Pic, int y, int x, pel_t val, int width)
   29|  14.0M|{
   30|  14.0M|  Pic [y*width+x] = val;
   31|  14.0M|}
   32|       |
   33|       |/*!
   34|       | ************************************************************************
   35|       | * \note
   36|       | *    The following functions returning line are NOT reentrant!  Use a buffer
   37|       | *    provided by the caller to change that (but it costs a memcpy()...
   38|       | ************************************************************************
   39|       | */
   40|       |static pel_t line[16];
   41|       |
   42|       |pel_t *FastLine16Y_11 (pel_t *Pic, int y, int x, int height, int width)//xxzp 检查inline了吗
   43|  7.97G|{
   44|  7.97G|  return &Pic [y*width+x];
   45|  7.97G|}
   46|       |
   47|       |
   48|       |pel_t *UMVLine16Y_11 (pel_t *Pic, int y, int x, int height, int width)
   49|   738M|{
   50|   738M|  int i, maxx;
   51|   738M|  pel_t *Picy;
   52|       |
   53|   738M|  Picy = &Pic [max(0,min(height-1,y)) * width];
   54|       |
   55|   738M|  if (x < 0) {                    // Left edge ? //xxzp 换一下分支顺序？
   56|       |
   57|   143M|    maxx = min(0,x+16);
   58|  1.37G|    for (i = x; i < maxx; i++)
   59|  1.23G|      line[i-x] = Picy [0];       // Replicate left edge pixel
   60|       |
   61|   143M|    maxx = x+16;
   62|  1.20G|    for (i = 0; i < maxx; i++)    // Copy non-edge pixels
   63|  1.05G|      line[i-x] = Picy [i];
   64|   143M|  }
   65|   595M|  else if (x > width-16)  {  // Right edge ?
   66|       |
   67|   127M|    maxx = width;
   68|  1.02G|    for (i = x; i < maxx; i++)
   69|   898M|      line[i-x] = Picy [i];       // Copy non-edge pixels
   70|       |
   71|   127M|    maxx = x+16;
   72|  1.26G|    for (i = max(width,x); i < maxx; i++)
   73|  1.13G|      line[i-x] = Picy [width-1];  // Replicate right edge pixel
   74|   127M|  }
   75|   468M|  else                            // No edge
   76|   468M|    return &Picy [x];
   77|       |
   78|   270M|  return line;
   79|   738M|}
   80|       |
   81|       |
   82|       |pel_t *FastLineX (int dummy, pel_t* Pic, int y, int x, int height, int width)
   83|      0|{
   84|      0|  return Pic + y*width + x;
   85|      0|}
   86|       |
   87|       |
   88|       |pel_t *UMVLineX (int size, pel_t* Pic, int y, int x, int height, int width)
   89|      0|{
   90|      0|  int i, maxx;
   91|      0|  pel_t *Picy;
   92|       |
   93|      0|  Picy = Pic + max(0,min(height-1,y)) * width;
   94|       |
   95|      0|  if (x < 0)                            // Left edge
   96|      0|  {
   97|      0|    maxx = min(0,x+size);
   98|      0|    for (i = x; i < maxx; i++)
   99|      0|    {
  100|      0|      line[i-x] = Picy [0];             // Replicate left edge pixel
  101|      0|    }
  102|      0|    maxx = x+size;
  103|      0|    for (i = 0; i < maxx; i++)          // Copy non-edge pixels
  104|      0|      line[i-x] = Picy [i];
  105|      0|  }
  106|      0|  else if (x > width-size)         // Right edge
  107|      0|  {
  108|      0|    maxx = width;
  109|      0|    for (i = x; i < maxx; i++)
  110|      0|    {
  111|      0|      line[i-x] = Picy [i];             // Copy non-edge pixels
  112|      0|    }
  113|      0|    maxx = x+size;
  114|      0|    for (i = max(width,x); i < maxx; i++)
  115|      0|    {
  116|      0|      line[i-x] = Picy [width-1];  // Replicate right edge pixel
  117|      0|    }
  118|      0|  }
  119|      0|  else                                  // No edge
  120|      0|  {
  121|      0|    return Picy + x;
  122|      0|  }
  123|       |
  124|      0|  return line;
  125|      0|}
  126|       |
  127|       |/*!
  128|       | ************************************************************************
  129|       | * \brief
  130|       | *    Reference buffer, 1/4 pel
  131|       | ************************************************************************
  132|       | */
  133|       |pel_t UMVPelY_14 (pel_t **Pic, int y, int x, int height, int width)
  134|  1.18G|{
  135|  1.18G|  int width4  = ((width+2*IMG_PAD_SIZE-1)<<2);
  136|  1.18G|  int height4 = ((height+2*IMG_PAD_SIZE-1)<<2);
  137|       |
  138|  1.18G|  x = x + IMG_PAD_SIZE*4;
  139|  1.18G|  y = y + IMG_PAD_SIZE*4;
  140|       |
  141|  1.18G|  if (x < 0)
  142|  22.6M|  {
  143|  22.6M|    if (y < 0)
  144|  14.0k|      return Pic [y&3][x&3];
  145|  22.6M|    if (y > height4)
  146|  97.8k|      return Pic [height4+(y&3)][x&3];
  147|  22.5M|    return Pic [y][x&3];
  148|  22.6M|  }
  149|       |
  150|  1.16G|  if (x > width4)
  151|  27.7M|  {
  152|  27.7M|    if (y < 0)
  153|  4.32k|      return Pic [y&3][width4+(x&3)];
  154|  27.7M|    if (y > height4)
  155|   242k|      return Pic [height4+(y&3)][width4+(x&3)];
  156|  27.5M|    return Pic [y][width4+(x&3)];
  157|  27.7M|  }
  158|       |
  159|  1.13G|  if (y < 0)    // note: corner pixels were already processed
  160|  13.2M|    return Pic [y&3][x];
  161|  1.11G|  if (y > height4)
  162|  41.0M|    return Pic [height4+(y&3)][x];
  163|       |
  164|  1.07G|  return Pic [y][x];
  165|  1.11G|}
  166|       |
  167|       |pel_t FastPelY_14 (pel_t **Pic, int y, int x, int height, int width)
  168|  12.6G|{
  169|  12.6G|  return Pic [IMG_PAD_SIZE*4+y][IMG_PAD_SIZE*4+x];
  170|  12.6G|}
  171|       |
  172|       |

/home/xzp/speccpu2006-v1.0.1/benchspec/CPU2006/464.h264ref/run/build_base_ql_riscv_llvm17.0000/rtp.c:
    1|       |
    2|       |/*!
    3|       | *****************************************************************************
    4|       | *
    5|       | * \file rtp.c
    6|       | *
    7|       | * \brief
    8|       | *    Functions to handle RTP headers and packets per RFC1889 and RTP NAL spec
    9|       | *    Functions support little endian systems only (Intel, not Motorola/Sparc)
   10|       | *
   11|       | * \date
   12|       | *    30 September 2001
   13|       | *
   14|       | * \author
   15|       | *    Stephan Wenger   stewe@cs.tu-berlin.de
   16|       | *****************************************************************************/
   17|       |
   18|       |#include <stdlib.h>
   19|       |#include <assert.h>
   20|       |#include <memory.h>
   21|       |
   22|       |#include "global.h"
   23|       |
   24|       |#include "rtp.h"
   25|       |
   26|       |// A little trick to avoid those horrible #if TRACE all over the source code
   27|       |#if TRACE
   28|       |#define SYMTRACESTRING(s) strncpy(sym.tracestring,s,TRACESTRING_SIZE)
   29|       |#else
   30|       |#define SYMTRACESTRING(s) // to nothing
   31|       |#endif
   32|       |
   33|       |
   34|       |int CurrentRTPTimestamp = 0;      //! The RTP timestamp of the current packet,
   35|       |                                  //! incremented with all P and I frames
   36|       |int CurrentRTPSequenceNumber = 0; //! The RTP sequence number of the current packet
   37|       |                                  //! incremented by one for each sent packet
   38|       |
   39|       |FILE *f;
   40|       |/*!
   41|       | *****************************************************************************
   42|       | *
   43|       | * \brief 
   44|       | *    ComposeRTPpacket composes the complete RTP packet using the various
   45|       | *    structure members of the RTPpacket_t structure
   46|       | *
   47|       | * \return
   48|       | *    0 in case of success
   49|       | *    negative error code in case of failure
   50|       | *
   51|       | * \par Parameters
   52|       | *    Caller is responsible to allocate enough memory for the generated packet
   53|       | *    in parameter->packet. Typically a malloc of 12+paylen bytes is sufficient
   54|       | *
   55|       | * \par Side effects
   56|       | *    none
   57|       | *
   58|       | * \note
   59|       | *    Function contains assert() tests for debug purposes (consistency checks
   60|       | *    for RTP header fields
   61|       | *
   62|       | * \date
   63|       | *    30 Spetember 2001
   64|       | *
   65|       | * \author
   66|       | *    Stephan Wenger   stewe@cs.tu-berlin.de
   67|       | *****************************************************************************/
   68|       |
   69|       |
   70|       |int ComposeRTPPacket (RTPpacket_t *p)
   71|       |
   72|      0|{
   73|       |  // Consistency checks through assert, only used for debug purposes
   74|      0|  assert (p->v == 2);
   75|      0|  assert (p->p == 0);
   76|      0|  assert (p->x == 0);
   77|      0|  assert (p->cc == 0);    // mixer designers need to change this one
   78|      0|  assert (p->m == 0 || p->m == 1);
   79|      0|  assert (p->pt < 128);
   80|      0|  assert (p->seq < 65536);
   81|      0|  assert (p->payload != NULL);
   82|      0|  assert (p->paylen < 65536 - 40);  // 2**16 -40 for IP/UDP/RTP header
   83|      0|  assert (p->packet != NULL);
   84|       |
   85|       |  // Compose RTP header, little endian
   86|       |
   87|      0|  p->packet[0] = (   (p->v)
   88|      0|                  |  (p->p << 2)
   89|      0|                  |  (p->x << 3)
   90|      0|                  |  (p->cc << 4) );
   91|      0|  p->packet[1] = (   (p->m)
   92|      0|                  |  (p->pt << 1) );
   93|      0|  p->packet[2] = p->seq & 0xff;
   94|      0|  p->packet[3] = (p->seq >> 8) & 0xff;
   95|       |
   96|      0|  memcpy (&p->packet[4], &p->timestamp, 4);  // change to shifts for unified byte sex
   97|      0|  memcpy (&p->packet[8], &p->ssrc, 4);// change to shifts for unified byte sex
   98|       |
   99|       |  // Copy payload 
  100|       |
  101|      0|  memcpy (&p->packet[12], p->payload, p->paylen);
  102|      0|  p->packlen = p->paylen+12;
  103|      0|  return 0;
  104|      0|}
  105|       |
  106|       |
  107|       |
  108|       |/*!
  109|       | *****************************************************************************
  110|       | *
  111|       | * \brief 
  112|       | *    WriteRTPPacket writes the supplied RTP packet to the output file
  113|       | *
  114|       | * \return
  115|       | *    0 in case of access
  116|       | *    <0 in case of write failure (typically fatal)
  117|       | *
  118|       | * \param p
  119|       | *    the RTP packet to be written (after ComposeRTPPacket() )
  120|       | * \param f
  121|       | *    output file
  122|       | *
  123|       | * \date
  124|       | *    October 23, 2001
  125|       | *
  126|       | * \author
  127|       | *    Stephan Wenger   stewe@cs.tu-berlin.de
  128|       | *****************************************************************************/
  129|       |
  130|       |int WriteRTPPacket (RTPpacket_t *p, FILE *f)
  131|       |
  132|      0|{
  133|      0|  int intime = -1;
  134|       |
  135|      0|  assert (f != NULL);
  136|      0|  assert (p != NULL);
  137|       |
  138|       |
  139|      0|  if (1 != fwrite (&p->packlen, 4, 1, f))
  140|      0|    return -1;
  141|      0|  if (1 != fwrite (&intime, 4, 1, f))
  142|      0|    return -1;
  143|      0|  if (1 != fwrite (p->packet, p->packlen, 1, f))
  144|      0|    return -1;
  145|      0|  return 0;
  146|      0|}
  147|       |
  148|       |
  149|       |
  150|       |
  151|       |
  152|       |/*!
  153|       | *****************************************************************************
  154|       | *
  155|       | * \brief 
  156|       | *    int RTPWriteNALU write a NALU to the RTP file
  157|       | *
  158|       | * \return
  159|       | *    Number of bytes written to output file
  160|       | *
  161|       | * \par Side effects
  162|       | *    Packet written, RTPSequenceNumber and RTPTimestamp updated
  163|       | *   
  164|       | * \date
  165|       | *    December 13, 2002
  166|       | *
  167|       | * \author
  168|       | *    Stephan Wenger   stewe@cs.tu-berlin.de
  169|       | *****************************************************************************/
  170|       |
  171|       |
  172|       |int WriteRTPNALU (NALU_t *n)
  173|      0|{
  174|      0|  RTPpacket_t *p;
  175|       |
  176|      0|  assert (f != NULL);
  177|      0|  assert (n != NULL);
  178|      0|  assert (n->len < 65000);
  179|       |
  180|      0|  n->buf[0] =
  181|      0|    n->forbidden_bit << 7      |
  182|      0|    n->nal_reference_idc << 5  |
  183|      0|    n->nal_unit_type;
  184|       |
  185|       |  // Set RTP structure elements and alloca() memory foor the buffers
  186|      0|  if ((p = (RTPpacket_t *) malloc (sizeof (RTPpacket_t))) == NULL)
  187|      0|    no_mem_exit ("RTPWriteNALU-1");
  188|      0|  if ((p->packet = malloc (MAXRTPPACKETSIZE)) == NULL)
  189|      0|    no_mem_exit ("RTPWriteNALU-2");
  190|      0|  if ((p->payload = malloc (MAXRTPPACKETSIZE)) == NULL)
  191|      0|    no_mem_exit ("RTPWriteNALU-3");
  192|       |
  193|      0|  p->v=2;
  194|      0|  p->p=0;
  195|      0|  p->x=0;
  196|      0|  p->cc=0;
  197|      0|  p->m=(n->startcodeprefix_len==4)&1;     // a long startcode of Annex B sets marker bit of RTP
  198|       |                                          // Not exactly according to the RTP paylaod spec, but
  199|       |                                          // good enough for now (hopefully).
  200|       |                                          //! For error resilience work, we need the correct
  201|       |                                          //! marker bit.  Introduce a nalu->marker and set it in
  202|       |                                          //! terminate_slice()?
  203|      0|  p->pt=H26LPAYLOADTYPE;
  204|      0|  p->seq=CurrentRTPSequenceNumber++;
  205|      0|  p->timestamp=CurrentRTPTimestamp;
  206|      0|  p->ssrc=H26LSSRC;
  207|      0|  p->paylen = n->len;
  208|      0|  memcpy (p->payload, n->buf, n->len);
  209|       |
  210|       |
  211|       |
  212|       |  // Generate complete RTP packet
  213|      0|  if (ComposeRTPPacket (p) < 0)
  214|      0|  {
  215|      0|    printf ("Cannot compose RTP packet, exit\n");
  216|      0|    exit (-1);
  217|      0|  }
  218|      0|  if (WriteRTPPacket (p, f) < 0)
  219|      0|  {
  220|      0|    printf ("Cannot write %d bytes of RTP packet to outfile, exit\n", p->packlen);
  221|      0|    exit (-1);
  222|      0|  }
  223|      0|  free (p->packet);
  224|      0|  free (p->payload);
  225|      0|  free (p);
  226|      0|  return (n->len * 8);
  227|      0|}
  228|       |
  229|       |
  230|       |/*!
  231|       | ********************************************************************************************
  232|       | * \brief 
  233|       | *    RTPUpdateTimestamp: patches the RTP timestamp depending on the TR
  234|       | *
  235|       | * \param 
  236|       | *    tr: TRof the following NALUs
  237|       | *
  238|       | * \return
  239|       | *    none.  
  240|       | *
  241|       | ********************************************************************************************
  242|       |*/
  243|       |
  244|       |
  245|       |void RTPUpdateTimestamp (int tr)
  246|    171|{
  247|    171|  int delta;
  248|    171|  static int oldtr = -1;
  249|       |
  250|    171|  if (oldtr == -1)            // First invocation
  251|      1|  {
  252|      1|    CurrentRTPTimestamp = 0;  //! This is a violation of the security req. of
  253|       |                              //! RTP (random timestamp), but easier to debug
  254|      1|    oldtr = 0;
  255|      1|    return;
  256|      1|  }
  257|       |
  258|       |  /*! The following code assumes a wrap around of TR at 256, and
  259|       |      needs to be changed as soon as this is no more true.
  260|       |      
  261|       |      The support for B frames is a bit tricky, because it is not easy to distinguish
  262|       |      between a natural wrap-around of the tr, and the intentional going back of the
  263|       |      tr because of a B frame.  It is solved here by a heuristic means: It is assumed that
  264|       |      B frames are never "older" than 10 tr ticks.  Everything higher than 10 is considered
  265|       |      a wrap around.
  266|       |  */
  267|       |
  268|    170|  delta = tr - oldtr;
  269|       |
  270|    170|  if (delta < -10)        // wrap-around
  271|      0|    delta+=256;
  272|       |
  273|    170|  CurrentRTPTimestamp += delta * RTP_TR_TIMESTAMP_MULT;
  274|    170|  oldtr = tr;
  275|    170|}
  276|       |
  277|       |
  278|       |/*!
  279|       | ********************************************************************************************
  280|       | * \brief 
  281|       | *    Opens the output file for the RTP packet stream
  282|       | *
  283|       | * \param Filename
  284|       | *    The filename of the file to be opened
  285|       | *
  286|       | * \return
  287|       | *    none.  Function terminates the program in case of an error
  288|       | *
  289|       | ********************************************************************************************
  290|       |*/
  291|       |
  292|       |void OpenRTPFile (char *Filename)
  293|      0|{
  294|      0|  if ((f = fopen (Filename, "wb")) == NULL)
  295|      0|  {
  296|      0|    printf ("Fatal: cannot open bitstream file '%s', exit (-1)\n", Filename);
  297|      0|    exit (-1);
  298|      0|  }
  299|      0|}
  300|       |
  301|       |
  302|       |/*!
  303|       | ********************************************************************************************
  304|       | * \brief 
  305|       | *    Closes the output file for the RTP packet stream
  306|       | *
  307|       | * \return
  308|       | *    none.  Function terminates the program in case of an error
  309|       | *
  310|       | ********************************************************************************************
  311|       |*/
  312|       |
  313|       |void CloseRTPFile ()
  314|      0|{
  315|      0|  fclose(f);
  316|      0|}
  317|       |
  318|       |
  319|       |
  320|       |
  321|       |
  322|       |
  323|       |
  324|       |
  325|       |#if 0
  326|       |/*!
  327|       | *****************************************************************************
  328|       | *
  329|       | * \brief 
  330|       | *    int aggregationRTPWriteBits (int marker) write the Slice header for the RTP NAL      
  331|       | *
  332|       | * \return
  333|       | *    Number of bytes written to output file
  334|       | *
  335|       | * \param marker
  336|       | *    marker bit,
  337|       | *
  338|       | * \par Side effects
  339|       | *    Packet written, RTPSequenceNumber and RTPTimestamp updated
  340|       | *   
  341|       | * \date
  342|       | *    September 10, 2002
  343|       | *
  344|       | * \author
  345|       | *    Dong Tian   tian@cs.tut.fi
  346|       | *****************************************************************************/
  347|       |
  348|       |int aggregationRTPWriteBits (int Marker, int PacketType, int subPacketType, void * bitstream, 
  349|       |                    int BitStreamLenInByte, FILE *out)
  350|       |{
  351|       |  RTPpacket_t *p;
  352|       |  int offset;
  353|       |
  354|       |//  printf( "writing aggregation packet...\n");
  355|       |  assert (out != NULL);
  356|       |  assert (BitStreamLenInByte < 65000);
  357|       |  assert (bitstream != NULL);
  358|       |  assert ((PacketType&0xf) == 4);
  359|       |
  360|       |  // Set RTP structure elements and alloca() memory foor the buffers
  361|       |  p = (RTPpacket_t *) alloca (sizeof (RTPpacket_t));
  362|       |  p->packet=alloca (MAXRTPPACKETSIZE);
  363|       |  p->payload=alloca (MAXRTPPACKETSIZE);
  364|       |  p->v=2;
  365|       |  p->p=0;
  366|       |  p->x=0;
  367|       |  p->cc=0;
  368|       |  p->m=Marker&1;
  369|       |  p->pt=H26LPAYLOADTYPE;
  370|       |  p->seq=CurrentRTPSequenceNumber++;
  371|       |  p->timestamp=CurrentRTPTimestamp;
  372|       |  p->ssrc=H26LSSRC;
  373|       |
  374|       |  offset = 0;
  375|       |  p->payload[offset++] = PacketType; // This is the first byte of the compound packet
  376|       |
  377|       |  // FIRST, write the sei message to aggregation packet, if it is available
  378|       |  if ( HaveAggregationSEI() )
  379|       |  {
  380|       |    p->payload[offset++] = sei_message[AGGREGATION_SEI].subPacketType; // this is the first byte of the first subpacket
  381|       |    *(short*)&(p->payload[offset]) = sei_message[AGGREGATION_SEI].payloadSize;
  382|       |    offset += 2;
  383|       |    memcpy (&p->payload[offset], sei_message[AGGREGATION_SEI].data, sei_message[AGGREGATION_SEI].payloadSize);
  384|       |    offset += sei_message[AGGREGATION_SEI].payloadSize;
  385|       |
  386|       |    clear_sei_message(AGGREGATION_SEI);
  387|       |  }
  388|       |
  389|       |  // SECOND, write other payload to the aggregation packet
  390|       |  // to do ...
  391|       |
  392|       |  // LAST, write the slice data to the aggregation packet
  393|       |  p->payload[offset++] = subPacketType;  // this is the first byte of the second subpacket
  394|       |  *(short*)&(p->payload[offset]) = BitStreamLenInByte;
  395|       |  offset += 2;
  396|       |  memcpy (&p->payload[offset], bitstream, BitStreamLenInByte);
  397|       |  offset += BitStreamLenInByte;
  398|       |
  399|       |  p->paylen = offset;  // 1 +3 +seiPayload.payloadSize +3 +BitStreamLenInByte
  400|       |
  401|       |  // Now the payload is ready, we can ...
  402|       |  // Generate complete RTP packet
  403|       |  if (ComposeRTPPacket (p) < 0)
  404|       |  {
  405|       |    printf ("Cannot compose RTP packet, exit\n");
  406|       |    exit (-1);
  407|       |  }
  408|       |  if (WriteRTPPacket (p, out) < 0)
  409|       |  {
  410|       |    printf ("Cannot write %d bytes of RTP packet to outfile, exit\n", p->packlen);
  411|       |    exit (-1);
  412|       |  }
  413|       |  return (p->packlen);
  414|       |
  415|       |}
  416|       |
  417|       |
  418|       |/*!
  419|       | *****************************************************************************
  420|       | * \isAggregationPacket
  421|       | * \brief 
  422|       | *    Determine if current packet is normal packet or compound packet (aggregation
  423|       | *    packet)
  424|       | *
  425|       | * \return
  426|       | *    return TRUE, if it is compound packet.
  427|       | *    return FALSE, otherwise.
  428|       | *   
  429|       | * \date
  430|       | *    September 10, 2002
  431|       | *
  432|       | * \author
  433|       | *    Dong Tian   tian@cs.tut.fi
  434|       | *****************************************************************************/
  435|       |Boolean isAggregationPacket()
  436|       |{
  437|       |  if (HaveAggregationSEI())
  438|       |  {
  439|       |    return TRUE;
  440|       |  }
  441|       |  // Until Sept 2002, the JM will produce aggregation packet only for some SEI messages
  442|       |
  443|       |  return FALSE;
  444|       |}
  445|       |
  446|       |/*!
  447|       | *****************************************************************************
  448|       | * \PrepareAggregationSEIMessage
  449|       | * \brief 
  450|       | *    Prepare the aggregation sei message.
  451|       | *    
  452|       | * \date
  453|       | *    September 10, 2002
  454|       | *
  455|       | * \author
  456|       | *    Dong Tian   tian@cs.tut.fi
  457|       | *****************************************************************************/
  458|       |void PrepareAggregationSEIMessage()
  459|       |{
  460|       |  Boolean has_aggregation_sei_message = FALSE;
  461|       |  // prepare the sei message here
  462|       |  // write the spare picture sei payload to the aggregation sei message
  463|       |  if (seiHasSparePicture && img->type != B_SLICE)
  464|       |  {
  465|       |    FinalizeSpareMBMap();
  466|       |    assert(seiSparePicturePayload.data->byte_pos == seiSparePicturePayload.payloadSize);
  467|       |    write_sei_message(AGGREGATION_SEI, seiSparePicturePayload.data->streamBuffer, seiSparePicturePayload.payloadSize, SEI_SPARE_PICTURE);
  468|       |    has_aggregation_sei_message = TRUE;
  469|       |  }
  470|       |  // write the sub sequence information sei paylaod to the aggregation sei message
  471|       |  if (seiHasSubseqInfo)
  472|       |  {
  473|       |    FinalizeSubseqInfo(img->layer);
  474|       |    write_sei_message(AGGREGATION_SEI, seiSubseqInfo[img->layer].data->streamBuffer, seiSubseqInfo[img->layer].payloadSize, SEI_SUBSEQ_INFORMATION);
  475|       |    ClearSubseqInfoPayload(img->layer);
  476|       |    has_aggregation_sei_message = TRUE;
  477|       |  }
  478|       |  // write the sub sequence layer information sei paylaod to the aggregation sei message
  479|       |  if (seiHasSubseqLayerInfo && img->number == 0)
  480|       |  {
  481|       |    FinalizeSubseqLayerInfo();
  482|       |    write_sei_message(AGGREGATION_SEI, seiSubseqLayerInfo.data, seiSubseqLayerInfo.payloadSize, SEI_SUBSEQ_LAYER_CHARACTERISTICS);
  483|       |    seiHasSubseqLayerInfo = FALSE;
  484|       |    has_aggregation_sei_message = TRUE;
  485|       |  }
  486|       |  // write the sub sequence characteristics payload to the aggregation sei message
  487|       |  if (seiHasSubseqChar)
  488|       |  {
  489|       |    FinalizeSubseqChar();
  490|       |    write_sei_message(AGGREGATION_SEI, seiSubseqChar.data->streamBuffer, seiSubseqChar.payloadSize, SEI_SUBSEQ_CHARACTERISTICS);
  491|       |    ClearSubseqCharPayload();
  492|       |    has_aggregation_sei_message = TRUE;
  493|       |  }
  494|       |  // write the pan scan rectangle info sei playload to the aggregation sei message
  495|       |  if (seiHasPanScanRectInfo)
  496|       |  {
  497|       |    FinalizePanScanRectInfo();
  498|       |    write_sei_message(AGGREGATION_SEI, seiPanScanRectInfo.data->streamBuffer, seiPanScanRectInfo.payloadSize, SEI_PANSCAN_RECT);
  499|       |    ClearPanScanRectInfoPayload();
  500|       |    has_aggregation_sei_message = TRUE;
  501|       |  }
  502|       |  // write the arbitrary (unregistered) info sei playload to the aggregation sei message
  503|       |  if (seiHasUser_data_unregistered_info)
  504|       |  {
  505|       |    FinalizeUser_data_unregistered();
  506|       |    write_sei_message(AGGREGATION_SEI, seiUser_data_unregistered.data->streamBuffer, seiUser_data_unregistered.payloadSize, SEI_USER_DATA_UNREGISTERED);
  507|       |    ClearUser_data_unregistered();
  508|       |    has_aggregation_sei_message = TRUE;
  509|       |  }
  510|       |  // write the arbitrary (unregistered) info sei playload to the aggregation sei message
  511|       |  if (seiHasUser_data_registered_itu_t_t35_info)
  512|       |  {
  513|       |    FinalizeUser_data_registered_itu_t_t35();
  514|       |    write_sei_message(AGGREGATION_SEI, seiUser_data_registered_itu_t_t35.data->streamBuffer, seiUser_data_registered_itu_t_t35.payloadSize, SEI_USER_DATA_REGISTERED_ITU_T_T35);
  515|       |    ClearUser_data_registered_itu_t_t35();
  516|       |    has_aggregation_sei_message = TRUE;
  517|       |  }
  518|       |  //write RandomAccess info sei payload to the aggregation sei message
  519|       |  if (seiHasRandomAccess_info)
  520|       |  {
  521|       |    FinalizeRandomAccess();
  522|       |    write_sei_message(AGGREGATION_SEI, seiRandomAccess.data->streamBuffer, seiRandomAccess.payloadSize, SEI_RANDOM_ACCESS_POINT);
  523|       |    ClearRandomAccess();
  524|       |    has_aggregation_sei_message = TRUE;
  525|       |  }
  526|       |  // more aggregation sei payload is written here...
  527|       |
  528|       |  // JVT-D099 write the scene information SEI payload
  529|       |  if (seiHasSceneInformation)
  530|       |  {
  531|       |    FinalizeSceneInformation();
  532|       |    write_sei_message(AGGREGATION_SEI, seiSceneInformation.data->streamBuffer, seiSceneInformation.payloadSize, SEI_SCENE_INFORMATION);
  533|       |    has_aggregation_sei_message = TRUE;
  534|       |  }
  535|       |  // End JVT-D099
  536|       |
  537|       |  // after all the sei payload is written
  538|       |  if (has_aggregation_sei_message)
  539|       |    finalize_sei_message(AGGREGATION_SEI);
  540|       |}
  541|       |
  542|       |/*!
  543|       | *****************************************************************************
  544|       | * \begin_sub_sequence_rtp
  545|       | * \brief 
  546|       | *    do some initialization for sub-sequence under rtp
  547|       | *    
  548|       | * \date
  549|       | *    September 10, 2002
  550|       | *
  551|       | * \author
  552|       | *    Dong Tian   tian@cs.tut.fi
  553|       | *****************************************************************************/
  554|       |
  555|       |void begin_sub_sequence_rtp()
  556|       |{
  557|       |  if ( input->of_mode != PAR_OF_RTP || input->NumFramesInELSubSeq == 0 ) 
  558|       |    return;
  559|       |
  560|       |  // begin to encode the base layer subseq
  561|       |  if ( IMG_NUMBER == 0 )
  562|       |  {
  563|       |//    printf("begin to encode the base layer subseq\n");
  564|       |    InitSubseqInfo(0);
  565|       |    if (1)
  566|       |      UpdateSubseqChar();
  567|       |  }
  568|       |  // begin to encode the enhanced layer subseq
  569|       |  if ( IMG_NUMBER % (input->NumFramesInELSubSeq+1) == 1 )
  570|       |  {
  571|       |//    printf("begin to encode the enhanced layer subseq\n");
  572|       |    InitSubseqInfo(1);  // init the sub-sequence in the enhanced layer
  573|       |//    add_dependent_subseq(1);
  574|       |    if (1)
  575|       |      UpdateSubseqChar();
  576|       |  }
  577|       |}
  578|       |
  579|       |/*!
  580|       | *****************************************************************************
  581|       | * \end_sub_sequence_rtp
  582|       | * \brief 
  583|       | *    do nothing
  584|       | *    
  585|       | * \date
  586|       | *    September 10, 2002
  587|       | *
  588|       | * \author
  589|       | *    Dong Tian   tian@cs.tut.fi
  590|       | *****************************************************************************/
  591|       |void end_sub_sequence_rtp()
  592|       |{
  593|       |  // end of the base layer:
  594|       |  if ( img->number == input->no_frames-1 )
  595|       |  {
  596|       |//    printf("end of encoding the base layer subseq\n");
  597|       |    CloseSubseqInfo(0);
  598|       |//    updateSubSequenceBox(0);
  599|       |  }
  600|       |  // end of the enhanced layer:
  601|       |  if ( ((IMG_NUMBER%(input->NumFramesInELSubSeq+1)==0) && (input->successive_Bframe != 0) && (IMG_NUMBER>0)) || // there are B frames
  602|       |    ((IMG_NUMBER%(input->NumFramesInELSubSeq+1)==input->NumFramesInELSubSeq) && (input->successive_Bframe==0))   // there are no B frames
  603|       |    )
  604|       |  {
  605|       |//    printf("end of encoding the enhanced layer subseq\n");
  606|       |    CloseSubseqInfo(1);
  607|       |//    add_dependent_subseq(1);
  608|       |//    updateSubSequenceBox(1);
  609|       |  }
  610|       |}
  611|       |
  612|       |#endif
  613|       |

/home/xzp/speccpu2006-v1.0.1/benchspec/CPU2006/464.h264ref/run/build_base_ql_riscv_llvm17.0000/rtp.h:
    1|       |
    2|       |/*!
    3|       | ***************************************************************************
    4|       | *
    5|       | * \file rtp.h
    6|       | *
    7|       | * \brief
    8|       | *    Definition of structures and functions to handle RTP headers.  For a
    9|       | *    description of RTP see RFC1889 on http://www.ietf.org
   10|       | *
   11|       | * \date
   12|       | *    30 September 2001
   13|       | *
   14|       | * \author
   15|       | *    Stephan Wenger   stewe@cs.tu-berlin.de
   16|       | **************************************************************************/
   17|       |
   18|       |#ifndef _RTP_H_
   19|       |#define _RTP_H_
   20|       |
   21|       |#include "nalu.h"
   22|       |
   23|     22|#define MAXRTPPAYLOADLEN  (65536 - 40)    //!< Maximum payload size of an RTP packet
   24|      0|#define MAXRTPPACKETSIZE  (65536 - 28)    //!< Maximum size of an RTP packet incl. header
   25|      0|#define H26LPAYLOADTYPE 105               //!< RTP paylaod type fixed here for simplicity
   26|      0|#define H26LSSRC 0x12345678               //!< SSRC, chosen to simplify debugging
   27|    170|#define RTP_TR_TIMESTAMP_MULT 1000        //!< should be something like 27 Mhz / 29.97 Hz
   28|       |
   29|       |typedef struct 
   30|       |{
   31|       |  unsigned int v;          //!< Version, 2 bits, MUST be 0x2
   32|       |  unsigned int p;          //!< Padding bit, Padding MUST NOT be used
   33|       |  unsigned int x;          //!< Extension, MUST be zero */
   34|       |  unsigned int cc;         /*!< CSRC count, normally 0 in the absence 
   35|       |                                of RTP mixers */
   36|       |  unsigned int m;          //!< Marker bit
   37|       |  unsigned int pt;         //!< 7 bits, Payload Type, dynamically established
   38|       |  unsigned int seq;        /*!< RTP sequence number, incremented by one for 
   39|       |                                each sent packet */
   40|       |  unsigned int timestamp;  //!< timestamp, 27 MHz for H.264
   41|       |  unsigned int ssrc;       //!< Synchronization Source, chosen randomly
   42|       |  byte *       payload;    //!< the payload including payload headers
   43|       |  unsigned int paylen;     //!< length of payload in bytes
   44|       |  byte *       packet;     //!< complete packet including header and payload
   45|       |  unsigned int packlen;    //!< length of packet, typically paylen+12
   46|       |} RTPpacket_t;
   47|       |
   48|       |#if 0
   49|       |int  ComposeRTPPacket (RTPpacket_t *p);
   50|       |int  DecomposeRTPpacket (RTPpacket_t *p);
   51|       |int  WriteRTPPacket (RTPpacket_t *p, FILE *f);
   52|       |void DumpRTPHeader (RTPpacket_t *p);
   53|       |void RTPUpdateTimestamp (int tr);
   54|       |int  RTPWriteBits (int Marker, int PacketType, void * bitstream, 
   55|       |                   int BitStreamLenInByte, FILE *out);
   56|       |
   57|       |Boolean isAggregationPacket();
   58|       |int aggregationRTPWriteBits (int Marker, int PacketType, int subPacketType, void * bitstream, int BitStreamLenInByte, FILE *out);
   59|       |
   60|       |void begin_sub_sequence_rtp();
   61|       |void end_sub_sequence_rtp();
   62|       |#endif
   63|       |
   64|       |void RTPUpdateTimestamp (int tr);
   65|       |void OpenRTPFile (char *Filename);
   66|       |void CloseRTPFile ();
   67|       |int WriteRTPNALU (NALU_t *n);
   68|       |
   69|       |
   70|       |
   71|       |#endif
   72|       |

/home/xzp/speccpu2006-v1.0.1/benchspec/CPU2006/464.h264ref/run/build_base_ql_riscv_llvm17.0000/sei.c:
    1|       |
    2|       |/*!
    3|       | ************************************************************************
    4|       | *  \file
    5|       | *     sei.c
    6|       | *  \brief
    7|       | *     implementation of SEI related functions
    8|       | *  \author(s)
    9|       | *      - Dong Tian                             <tian@cs.tut.fi>
   10|       | *
   11|       | ************************************************************************
   12|       | */
   13|       |
   14|       |#include <stdlib.h>
   15|       |#include <assert.h>
   16|       |#include <memory.h>
   17|       |
   18|       |#include "global.h"
   19|       |
   20|       |#include "memalloc.h"
   21|       |#include "rtp.h"
   22|       |#include "mbuffer.h"
   23|       |#include "sei.h"
   24|       |#include "vlc.h"
   25|       |
   26|       |#if defined(SPEC_CPU)
   27|       |Boolean seiHasRandomAccess_info;
   28|       |randomaccess_information_struct seiRandomAccess;
   29|       |Boolean seiHasUser_data_registered_itu_t_t35_info;
   30|       |user_data_registered_itu_t_t35_information_struct seiUser_data_registered_itu_t_t35;
   31|       |Boolean seiHasUser_data_unregistered_info;
   32|       |user_data_unregistered_information_struct seiUser_data_unregistered;
   33|       |#endif
   34|       |
   35|       |Boolean seiHasTemporal_reference=FALSE;
   36|       |Boolean seiHasClock_timestamp=FALSE;
   37|       |Boolean seiHasPanscan_rect=FALSE;
   38|       |Boolean seiHasBuffering_period=FALSE;
   39|       |Boolean seiHasHrd_picture=FALSE;
   40|       |Boolean seiHasFiller_payload=FALSE;
   41|       |Boolean seiHasUser_data_registered_itu_t_t35=FALSE;
   42|       |Boolean seiHasUser_data_unregistered=FALSE;
   43|       |Boolean seiHasRandom_access_point=FALSE;
   44|       |Boolean seiHasRef_pic_buffer_management_repetition=FALSE;
   45|       |Boolean seiHasSpare_picture=FALSE;
   46|       |
   47|       |Boolean seiHasSceneInformation=FALSE; // JVT-D099
   48|       |
   49|       |Boolean seiHasSubseq_information=FALSE;
   50|       |Boolean seiHasSubseq_layer_characteristics=FALSE;
   51|       |Boolean seiHasSubseq_characteristics=FALSE;
   52|       |
   53|       |/*
   54|       | ************************************************************************
   55|       | *  \basic functions on supplemental enhancement information
   56|       | *  \brief
   57|       | *     The implementations are based on FCD
   58|       | ************************************************************************
   59|       | */
   60|       |
   61|       |//! sei_message[0]: this struct is to store the sei message packetized independently 
   62|       |//! sei_message[1]: this struct is to store the sei message packetized together with slice data
   63|       |sei_struct sei_message[2];
   64|       |
   65|       |void InitSEIMessages()
   66|      1|{
   67|      1|  int i;
   68|      3|  for (i=0; i<2; i++)
   69|      2|  {
   70|      2|    sei_message[i].data = malloc(MAXRTPPAYLOADLEN);
   71|      2|    if( sei_message[i].data == NULL ) no_mem_exit("InitSEIMessages: sei_message[i].data");
   72|      2|    sei_message[i].subPacketType = SEI_PACKET_TYPE;
   73|      2|    clear_sei_message(i);
   74|      2|  }
   75|       |
   76|       |  // init sei messages
   77|      1|  seiSparePicturePayload.data = NULL;
   78|      1|  InitSparePicture();
   79|      1|  InitSubseqChar();
   80|      1|  if (input->NumFramesInELSubSeq != 0)
   81|      0|    InitSubseqLayerInfo();
   82|      1|  InitSceneInformation(); // JVT-D099
   83|       |  // init panscanrect sei message
   84|      1|  InitPanScanRectInfo();
   85|       |  // init user_data_unregistered
   86|      1|  InitUser_data_unregistered();
   87|       |  // init user_data_unregistered
   88|      1|  InitUser_data_registered_itu_t_t35();
   89|       |  // init user_RandomAccess
   90|      1|  InitRandomAccess();
   91|      1|}
   92|       |
   93|       |void CloseSEIMessages()
   94|      1|{
   95|      1|  int i;
   96|       |  
   97|      1|  if (input->NumFramesInELSubSeq != 0)
   98|      0|    CloseSubseqLayerInfo();
   99|       |
  100|      1|  CloseSubseqChar();
  101|      1|  CloseSparePicture();
  102|      1|  CloseSceneInformation(); // JVT-D099
  103|       |  //Shankar Regunathan Oct 2002
  104|      1|  ClosePanScanRectInfo();
  105|      1|  CloseUser_data_unregistered();
  106|      1|  CloseUser_data_registered_itu_t_t35();
  107|      1|  CloseRandomAccess();
  108|       |
  109|      3|  for (i=0; i<MAX_LAYER_NUMBER; i++)
  110|      2|  {
  111|      2|    if ( sei_message[i].data ) free( sei_message[i].data );
  112|      2|    sei_message[i].data = NULL;
  113|      2|  }
  114|      1|}
  115|       |
  116|       |Boolean HaveAggregationSEI()
  117|      0|{
  118|      0|  if (sei_message[AGGREGATION_SEI].available && img->type != B_SLICE) 
  119|      0|    return TRUE;
  120|      0|  if (seiHasSubseqInfo)
  121|      0|    return TRUE;
  122|      0|  if (seiHasSubseqLayerInfo && img->number == 0)
  123|      0|    return TRUE;
  124|      0|  if (seiHasSubseqChar)
  125|      0|    return TRUE;
  126|      0|  if (seiHasSceneInformation) // JVT-D099
  127|      0|    return TRUE;
  128|      0|  if (seiHasPanScanRectInfo) // Shankar Regunathan Oct 2002
  129|      0|    return TRUE;
  130|      0|  if (seiHasUser_data_unregistered_info)
  131|      0|    return TRUE;
  132|      0|  if (seiHasUser_data_registered_itu_t_t35_info)
  133|      0|    return TRUE;
  134|      0|  if (seiHasRandomAccess_info)
  135|      0|    return TRUE;
  136|      0|  return FALSE;
  137|       |//  return input->SparePictureOption && ( seiHasSpare_picture || seiHasSubseq_information || 
  138|       |//    seiHasSubseq_layer_characteristics || seiHasSubseq_characteristics );
  139|      0|}
  140|       |
  141|       |/*!
  142|       | ************************************************************************
  143|       | *  \brief
  144|       | *     write one sei payload to the sei message
  145|       | *  \param id
  146|       | *    0, if this is the normal packet\n
  147|       | *    1, if this is a aggregation packet
  148|       | *  \param payload
  149|       | *    a pointer that point to the sei payload. Note that the bitstream
  150|       | *    should have be byte aligned already. 
  151|       | *  \param payload_size
  152|       | *    the size of the sei payload
  153|       | *  \param payload_type
  154|       | *    the type of the sei payload
  155|       | *  \par Output
  156|       | *    the content of the sei message (sei_message[id]) is updated.
  157|       | ************************************************************************
  158|       | */
  159|       |void write_sei_message(int id, byte* payload, int payload_size, int payload_type)
  160|      0|{
  161|      0|  int offset, type, size;
  162|      0|  assert(payload_type > SEI_ZERO && payload_type < SEI_MAX_ELEMENTS);
  163|       |
  164|      0|  type = payload_type;
  165|      0|  size = payload_size;
  166|      0|  offset = sei_message[id].payloadSize;
  167|       |
  168|      0|  while ( type > 255 )
  169|      0|  {
  170|      0|    sei_message[id].data[offset++] = 0xFF;
  171|      0|    type = type - 255;
  172|      0|  }
  173|      0|  sei_message[id].data[offset++] = type;
  174|       |
  175|      0|  while ( size > 255 )
  176|      0|  {
  177|      0|    sei_message[id].data[offset++] = 0xFF;
  178|      0|    size = size - 255;
  179|      0|  }
  180|      0|  sei_message[id].data[offset++] = size;
  181|       |
  182|      0|  memcpy(sei_message[id].data + offset, payload, payload_size);
  183|      0|  offset += payload_size;
  184|       |
  185|      0|  sei_message[id].payloadSize = offset;
  186|      0|}
  187|       |
  188|       |/*!
  189|       | ************************************************************************
  190|       | *  \brief
  191|       | *     write rbsp_trailing_bits to the sei message
  192|       | *  \param id
  193|       | *    0, if this is the normal packet \n
  194|       | *    1, if this is a aggregation packet
  195|       | *  \par Output
  196|       | *    the content of the sei message is updated and ready for packetisation
  197|       | ************************************************************************
  198|       | */
  199|       |void finalize_sei_message(int id)
  200|      0|{
  201|      0|  int offset = sei_message[id].payloadSize;
  202|       |
  203|      0|  sei_message[id].data[offset] = 0x80;
  204|      0|  sei_message[id].payloadSize++;
  205|       |
  206|      0|  sei_message[id].available = TRUE;
  207|      0|}
  208|       |
  209|       |/*!
  210|       | ************************************************************************
  211|       | *  \brief
  212|       | *     empty the sei message buffer
  213|       | *  \param id
  214|       | *    0, if this is the normal packet \n
  215|       | *    1, if this is a aggregation packet
  216|       | *  \par Output
  217|       | *    the content of the sei message is cleared and ready for storing new 
  218|       | *      messages
  219|       | ************************************************************************
  220|       | */
  221|       |void clear_sei_message(int id)
  222|      2|{
  223|      2|  memset( sei_message[id].data, 0, MAXRTPPAYLOADLEN);
  224|      2|  sei_message[id].payloadSize       = 0;
  225|      2|  sei_message[id].available         = FALSE;
  226|      2|}
  227|       |
  228|       |/*!
  229|       | ************************************************************************
  230|       | *  \brief
  231|       | *     copy the bits from one bitstream buffer to another one
  232|       | *  \param dest
  233|       | *    pointer to the dest bitstream buffer
  234|       | *  \param source
  235|       | *    pointer to the source bitstream buffer
  236|       | *  \par Output
  237|       | *    the content of the dest bitstream is changed.
  238|       | ************************************************************************
  239|       | */
  240|       |void AppendTmpbits2Buf( Bitstream* dest, Bitstream* source )
  241|      0|{
  242|      0|  int i, j;
  243|      0|  unsigned char mask;
  244|      0|  int bits_in_last_byte;
  245|       |
  246|       |  // copy the first bytes in source buffer
  247|      0|  for (i=0; i<source->byte_pos; i++)
  248|      0|  {
  249|      0|    mask = 0x80;
  250|      0|    for (j=0; j<8; j++)
  251|      0|    {
  252|      0|      dest->byte_buf <<= 1;
  253|      0|      if (source->streamBuffer[i] & mask)
  254|      0|        dest->byte_buf |= 1;
  255|      0|      dest->bits_to_go--;
  256|      0|      mask >>= 1;
  257|      0|      if (dest->bits_to_go==0)
  258|      0|      {
  259|      0|        dest->bits_to_go = 8;
  260|      0|        dest->streamBuffer[dest->byte_pos++]=dest->byte_buf;
  261|      0|        dest->byte_buf = 0;
  262|      0|      }
  263|      0|    }
  264|      0|  }
  265|       |  // copy the last byte, there are still (8-source->bits_to_go) bits in the source buffer
  266|      0|  bits_in_last_byte = 8-source->bits_to_go;
  267|      0|  if ( bits_in_last_byte > 0 )
  268|      0|  {
  269|      0|    mask = 1 << (bits_in_last_byte-1);
  270|      0|    for (j=0; j<bits_in_last_byte; j++)
  271|      0|    {
  272|      0|      dest->byte_buf <<= 1;
  273|      0|      if (source->byte_buf & mask)
  274|      0|        dest->byte_buf |= 1;
  275|      0|      dest->bits_to_go--;
  276|      0|      mask >>= 1;
  277|      0|      if (dest->bits_to_go==0)
  278|      0|      {
  279|      0|        dest->bits_to_go = 8;
  280|      0|        dest->streamBuffer[dest->byte_pos++]=dest->byte_buf;
  281|      0|        dest->byte_buf = 0;
  282|      0|      }
  283|      0|    }
  284|      0|  }
  285|      0|}
  286|       |
  287|       |/*
  288|       | **++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  289|       | *  \functions on spare pictures
  290|       | *  \brief
  291|       | *     implementation of Spare Pictures related functions based on 
  292|       | *      JVT-D100
  293|       | *  \author
  294|       | *      Dong Tian                 <tian@cs.tut.fi>
  295|       | **++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  296|       | */
  297|       |
  298|       |// global variables for spare pictures
  299|       |
  300|       |// Tian Dong (Sept 2002)
  301|       |// In current implementation, Sept 2002, the spare picture info is 
  302|       |// paketized together with the immediately following frame. Thus we 
  303|       |// define one set of global variables to save the info.
  304|       |Boolean seiHasSparePicture = FALSE;
  305|       |spare_picture_struct seiSparePicturePayload;
  306|       |
  307|       |/*!
  308|       | ************************************************************************
  309|       | *  \brief
  310|       | *      Init the global variables for spare picture information
  311|       | ************************************************************************
  312|       | */
  313|       |void InitSparePicture()
  314|      1|{
  315|      1|  if ( seiSparePicturePayload.data != NULL ) CloseSparePicture();
  316|       |
  317|      1|  seiSparePicturePayload.data = malloc( sizeof(Bitstream) );
  318|      1|  if ( seiSparePicturePayload.data == NULL ) no_mem_exit("InitSparePicture: seiSparePicturePayload.data"); 
  319|      1|  seiSparePicturePayload.data->streamBuffer = malloc(MAXRTPPAYLOADLEN);
  320|      1|  if ( seiSparePicturePayload.data->streamBuffer == NULL ) no_mem_exit("InitSparePicture: seiSparePicturePayload.data->streamBuffer"); 
  321|      1|  memset( seiSparePicturePayload.data->streamBuffer, 0, MAXRTPPAYLOADLEN);
  322|      1|  seiSparePicturePayload.num_spare_pics = 0;
  323|      1|  seiSparePicturePayload.target_frame_num = 0;
  324|       |
  325|      1|  seiSparePicturePayload.data->bits_to_go  = 8;
  326|      1|  seiSparePicturePayload.data->byte_pos    = 0;
  327|      1|  seiSparePicturePayload.data->byte_buf    = 0;
  328|      1|}
  329|       |
  330|       |/*!
  331|       | ************************************************************************
  332|       | *  \brief
  333|       | *      Close the global variables for spare picture information
  334|       | ************************************************************************
  335|       | */
  336|       |void CloseSparePicture()
  337|      1|{
  338|      1|  if (seiSparePicturePayload.data->streamBuffer) 
  339|      1|    free(seiSparePicturePayload.data->streamBuffer);
  340|      1|  seiSparePicturePayload.data->streamBuffer = NULL;
  341|      1|  if (seiSparePicturePayload.data) 
  342|      1|    free(seiSparePicturePayload.data);
  343|      1|  seiSparePicturePayload.data = NULL;
  344|      1|  seiSparePicturePayload.num_spare_pics = 0;
  345|      1|  seiSparePicturePayload.target_frame_num = 0;
  346|      1|}
  347|       |
  348|       |/*!
  349|       | ************************************************************************
  350|       | *  \brief
  351|       | *     Calculate the spare picture info, save the result in map_sp
  352|       | *      then compose the spare picture information.
  353|       | *  \par Output
  354|       | *      the spare picture payload is available in *seiSparePicturePayload*
  355|       | *      the syntax elements in the loop (see FCD), excluding the two elements
  356|       | *      at the beginning.
  357|       | ************************************************************************
  358|       | */
  359|       |void CalculateSparePicture()
  360|      0|{
  361|       |  /*
  362|       |  int i, j, tmp, i0, j0, m;
  363|       |  byte **map_sp;
  364|       |  int delta_spare_frame_num;
  365|       |  Bitstream *tmpBitstream;
  366|       |
  367|       |  int num_of_mb=(img->height/16) * (img->width/16);
  368|       |  int threshold1 = 16*16*input->SPDetectionThreshold;
  369|       |  int threshold2 = num_of_mb * input->SPPercentageThreshold / 100;
  370|       |  int ref_area_indicator;
  371|       |  int CandidateSpareFrameNum, SpareFrameNum;
  372|       |  int possible_spare_pic_num;
  373|       |
  374|       |  // define it for debug purpose
  375|       |  #define WRITE_MAP_IMAGE
  376|       |
  377|       |#ifdef WRITE_MAP_IMAGE
  378|       |  byte **y;
  379|       |  int k;
  380|       |  FILE* fp;
  381|       |  static int first = 1;
  382|       |  char map_file_name[255]="map.yuv";
  383|       |#endif
  384|       |
  385|       |  // basic check
  386|       |  if (fb->picbuf_short[0]->used==0 || fb->picbuf_short[1]->used==0)
  387|       |  { 
  388|       |#ifdef WRITE_MAP_IMAGE
  389|       |    fp = fopen( map_file_name, "wb" );
  390|       |    assert( fp != NULL );
  391|       |    // write the map image
  392|       |    for (i=0; i < img->height; i++)
  393|       |      for (j=0; j < img->width; j++)
  394|       |        fputc(0, fp);
  395|       |
  396|       |    for (k=0; k < 2; k++)
  397|       |      for (i=0; i < img->height/2; i++)
  398|       |        for (j=0; j < img->width/2; j++)
  399|       |          fputc(128, fp);
  400|       |    fclose( fp );
  401|       |#endif
  402|       |    seiHasSparePicture = FALSE;
  403|       |    return;
  404|       |  }
  405|       |  seiHasSparePicture = TRUE;
  406|       |
  407|       |  // set the global bitstream memory. 
  408|       |  InitSparePicture();
  409|       |  seiSparePicturePayload.target_frame_num = img->number % MAX_FN;
  410|       |  // init the local bitstream memory.
  411|       |  tmpBitstream = malloc(sizeof(Bitstream));
  412|       |  if ( tmpBitstream == NULL ) no_mem_exit("CalculateSparePicture: tmpBitstream");
  413|       |  tmpBitstream->streamBuffer = malloc(MAXRTPPAYLOADLEN);
  414|       |  if ( tmpBitstream->streamBuffer == NULL ) no_mem_exit("CalculateSparePicture: tmpBitstream->streamBuffer");
  415|       |  memset( tmpBitstream->streamBuffer, 0, MAXRTPPAYLOADLEN);
  416|       |
  417|       |#ifdef WRITE_MAP_IMAGE
  418|       |  if ( first )
  419|       |  {
  420|       |    fp = fopen( map_file_name, "wb" );
  421|       |    first = 0;
  422|       |  }
  423|       |  else
  424|       |    fp = fopen( map_file_name, "ab" );
  425|       |  get_mem2D(&y, img->height, img->width);
  426|       |#endif
  427|       |  get_mem2D(&map_sp, img->height/16, img->width/16);
  428|       |
  429|       |  if (fb->picbuf_short[2]->used!=0) possible_spare_pic_num = 2;
  430|       |  else possible_spare_pic_num = 1;
  431|       |  // loop over the spare pictures
  432|       |  for (m=0; m<possible_spare_pic_num; m++)
  433|       |  {
  434|       |    // clear the temporal bitstream buffer
  435|       |    tmpBitstream->bits_to_go  = 8;
  436|       |    tmpBitstream->byte_pos    = 0;
  437|       |    tmpBitstream->byte_buf    = 0;
  438|       |    memset( tmpBitstream->streamBuffer, 0, MAXRTPPAYLOADLEN);
  439|       |
  440|       |    // set delta_spare_frame_num
  441|       |    // the order of the following lines cannot be changed.
  442|       |    if (m==0)
  443|       |      CandidateSpareFrameNum = seiSparePicturePayload.target_frame_num - 1; // TargetFrameNum - 1;
  444|       |    else
  445|       |      CandidateSpareFrameNum = SpareFrameNum - 1;
  446|       |    if ( CandidateSpareFrameNum < 0 ) CandidateSpareFrameNum = MAX_FN - 1;
  447|       |    SpareFrameNum = fb->picbuf_short[m+1]->frame_num_256;
  448|       |    delta_spare_frame_num = CandidateSpareFrameNum - SpareFrameNum;
  449|       |    assert( delta_spare_frame_num == 0 );
  450|       |
  451|       |    // calculate the spare macroblock map of one spare picture
  452|       |    // the results are stored into map_sp[][]
  453|       |    for (i=0; i < img->height/16; i++)
  454|       |      for (j=0; j < img->width/16; j++)
  455|       |      {
  456|       |        tmp = 0;
  457|       |        for (i0=0; i0<16; i0++)
  458|       |          for (j0=0; j0<16; j0++)
  459|       |            tmp+=abs(fb->picbuf_short[m+1]->Refbuf11[(i*16+i0)*img->width+j*16+j0]-
  460|       |                       fb->picbuf_short[0]->Refbuf11[(i*16+i0)*img->width+j*16+j0]);
  461|       |        tmp = (tmp<=threshold1? 255 : 0);
  462|       |        map_sp[i][j] = (tmp==0? 1 : 0);
  463|       |#ifdef WRITE_MAP_IMAGE
  464|       |//        if (m==0)
  465|       |        {
  466|       |        for (i0=0; i0<16; i0++)
  467|       |          for (j0=0; j0<16; j0++)
  468|       |            y[i*16+i0][j*16+j0]=tmp;
  469|       |        }
  470|       |#endif
  471|       |      }
  472|       |
  473|       |    // based on map_sp[][], compose the spare picture information
  474|       |    // and write the spare picture information to a temp bitstream
  475|       |    tmp = 0;
  476|       |    for (i=0; i < img->height/16; i++)
  477|       |      for (j=0; j < img->width/16; j++)
  478|       |        if (map_sp[i][j]==0) tmp++;
  479|       |    if ( tmp > threshold2 )
  480|       |      ref_area_indicator = 0;
  481|       |    else if ( !CompressSpareMBMap(map_sp, tmpBitstream) )
  482|       |      ref_area_indicator = 1;
  483|       |    else
  484|       |      ref_area_indicator = 2;
  485|       |
  486|       |//    printf( "ref_area_indicator = %d\n", ref_area_indicator );
  487|       |
  488|       |#ifdef WRITE_MAP_IMAGE
  489|       |    // write the map to a file
  490|       |//    if (m==0)
  491|       |    {
  492|       |      // write the map image
  493|       |      for (i=0; i < img->height; i++)
  494|       |        for (j=0; j < img->width; j++)
  495|       |        {
  496|       |          if ( ref_area_indicator == 0 ) fputc(255, fp);
  497|       |          else fputc(y[i][j], fp);
  498|       |        }
  499|       |
  500|       |      for (k=0; k < 2; k++)
  501|       |        for (i=0; i < img->height/2; i++)
  502|       |          for (j=0; j < img->width/2; j++)
  503|       |            fputc(128, fp);
  504|       |    }
  505|       |#endif
  506|       |
  507|       |    // Finnally, write the current spare picture information to 
  508|       |    // the global variable: seiSparePicturePayload
  509|       |    ComposeSparePictureMessage(delta_spare_frame_num, ref_area_indicator, tmpBitstream);
  510|       |    seiSparePicturePayload.num_spare_pics++;
  511|       |  }  // END for (m=0; m<2; m++)
  512|       |
  513|       |  free_mem2D( map_sp );
  514|       |  free( tmpBitstream->streamBuffer );
  515|       |  free( tmpBitstream );
  516|       |
  517|       |#ifdef WRITE_MAP_IMAGE
  518|       |  free_mem2D( y );
  519|       |  fclose( fp );
  520|       |#undef WRITE_MAP_IMAGE
  521|       |#endif
  522|       |  */
  523|      0|}
  524|       |
  525|       |/*!
  526|       | ************************************************************************
  527|       | *  \brief
  528|       | *      compose the spare picture information.
  529|       | *  \param delta_spare_frame_num
  530|       | *      see FCD
  531|       | *  \param ref_area_indicator
  532|       | *      Indicate how to represent the spare mb map
  533|       | *  \param tmpBitstream
  534|       | *      pointer to a buffer to save the payload
  535|       | *  \par Output
  536|       | *      bitstream: the composed spare picture payload are 
  537|       | *        ready to put into the sei_message. 
  538|       | ************************************************************************
  539|       | */
  540|       |void ComposeSparePictureMessage(int delta_spare_frame_num, int ref_area_indicator, Bitstream *tmpBitstream)
  541|      0|{
  542|      0|  Bitstream *bitstream = seiSparePicturePayload.data;
  543|      0|  SyntaxElement sym;
  544|       |
  545|      0|  sym.type = SE_HEADER;
  546|      0|  sym.mapping = ue_linfo;
  547|       |
  548|      0|  sym.value1 = delta_spare_frame_num;
  549|      0|  writeSyntaxElement2Buf_UVLC(&sym, bitstream);
  550|      0|  sym.value1 = ref_area_indicator;
  551|      0|  writeSyntaxElement2Buf_UVLC(&sym, bitstream);
  552|       |
  553|      0|  AppendTmpbits2Buf( bitstream, tmpBitstream );
  554|      0|}
  555|       |
  556|       |/*!
  557|       | ************************************************************************
  558|       | *  \brief
  559|       | *      test if the compressed spare mb map will occupy less mem and
  560|       | *      fill the payload buffer.
  561|       | *  \param map_sp
  562|       | *      in which the spare picture information are stored.
  563|       | *  \param bitstream
  564|       | *      pointer to a buffer to save the payload
  565|       | *  \return
  566|       | *      TRUE: If it is compressed version, \n
  567|       | *             FALSE: If it is not compressed.
  568|       | ************************************************************************
  569|       | */
  570|       |Boolean CompressSpareMBMap(unsigned char **map_sp, Bitstream *bitstream)
  571|      0|{
  572|      0|  int j, k;
  573|      0|  int noc, bit0, bit1, bitc;
  574|      0|  SyntaxElement sym;
  575|      0|  int x, y, left, right, bottom, top, directx, directy;
  576|       |
  577|       |  // this is the size of the uncompressed mb map:
  578|      0|  int size_uncompressed = (img->height/16) * (img->width/16);
  579|      0|  int size_compressed   = 0;
  580|      0|  Boolean ret;
  581|       |
  582|       |  // initialization
  583|      0|  sym.type = SE_HEADER;
  584|      0|  sym.mapping = ue_linfo;
  585|      0|  noc = 0;
  586|      0|  bit0 = 0;
  587|      0|  bit1 = 1;
  588|      0|  bitc = bit0;
  589|       |
  590|       |  // compress the map, the result goes to the temporal bitstream buffer
  591|      0|  x = ( img->width/16 - 1 ) / 2;
  592|      0|  y = ( img->height/16 - 1 ) / 2;
  593|      0|  left = right = x;
  594|      0|  top = bottom = y;
  595|      0|  directx = 0;
  596|      0|  directy = 1;
  597|      0|  for (j=0; j<img->height/16; j++)
  598|      0|    for (k=0; k<img->width/16; k++)
  599|      0|    {
  600|       |      // check current mb
  601|      0|      if ( map_sp[y][x] == bitc ) noc++;
  602|      0|      else
  603|      0|      {
  604|      0|        sym.value1 = noc;
  605|      0|        size_compressed += writeSyntaxElement2Buf_UVLC(&sym, bitstream);    // the return value indicate the num of bits written
  606|      0|        noc=0;
  607|      0|      }
  608|       |      // go to the next mb:
  609|      0|      if ( directx == -1 && directy == 0 )
  610|      0|      {
  611|      0|        if (x > left) x--;
  612|      0|        else if (x == 0)
  613|      0|        {
  614|      0|          y = bottom + 1;
  615|      0|          bottom++;
  616|      0|          directx = 1;
  617|      0|          directy = 0;
  618|      0|        }
  619|      0|        else if (x == left)
  620|      0|        {
  621|      0|          x--;
  622|      0|          left--;
  623|      0|          directx = 0;
  624|      0|          directy = 1;
  625|      0|        }
  626|      0|      }
  627|      0|      else if ( directx == 1 && directy == 0 )
  628|      0|      {
  629|      0|        if (x < right) x++;
  630|      0|        else if (x == img->width/16 - 1)
  631|      0|        {
  632|      0|          y = top - 1;
  633|      0|          top--;
  634|      0|          directx = -1;
  635|      0|          directy = 0;
  636|      0|        }
  637|      0|        else if (x == right)
  638|      0|        {
  639|      0|          x++;
  640|      0|          right++;
  641|      0|          directx = 0;
  642|      0|          directy = -1;
  643|      0|        }
  644|      0|      }
  645|      0|      else if ( directx == 0 && directy == -1 )
  646|      0|      {
  647|      0|        if ( y > top) y--;
  648|      0|        else if (y == 0)
  649|      0|        {
  650|      0|          x = left - 1;
  651|      0|          left--;
  652|      0|          directx = 0;
  653|      0|          directy = 1;
  654|      0|        }
  655|      0|        else if (y == top)
  656|      0|        {
  657|      0|          y--;
  658|      0|          top--;
  659|      0|          directx = -1;
  660|      0|          directy = 0;
  661|      0|        }
  662|      0|      }
  663|      0|      else if ( directx == 0 && directy == 1 )
  664|      0|      {
  665|      0|        if (y < bottom) y++;
  666|      0|        else if (y == img->height/16 - 1)
  667|      0|        {
  668|      0|          x = right+1;
  669|      0|          right++;
  670|      0|          directx = 0;
  671|      0|          directy = -1;
  672|      0|        }
  673|      0|        else if (y == bottom)
  674|      0|        {
  675|      0|          y++;
  676|      0|          bottom++;
  677|      0|          directx = 1;
  678|      0|          directy = 0;
  679|      0|        }
  680|      0|      }
  681|      0|    }
  682|      0|  if (noc!=0)
  683|      0|  {
  684|      0|    sym.value1 = noc;
  685|      0|    size_compressed += writeSyntaxElement2Buf_UVLC(&sym, bitstream);
  686|      0|  }
  687|       |
  688|      0|  ret = (size_compressed<size_uncompressed? TRUE : FALSE);
  689|      0|  if ( !ret ) // overwrite the streambuffer with the original mb map
  690|      0|  {
  691|       |    // write the mb map to payload bit by bit
  692|      0|    bitstream->byte_buf = 0;
  693|      0|    bitstream->bits_to_go = 8;
  694|      0|    bitstream->byte_pos = 0;
  695|      0|    for (j=0; j<img->height/16; j++)
  696|      0|    {
  697|      0|      for (k=0; k<img->width/16; k++)
  698|      0|      {
  699|      0|        bitstream->byte_buf <<= 1;
  700|      0|        if (map_sp[j][k]) bitstream->byte_buf |= 1;
  701|      0|        bitstream->bits_to_go--;
  702|      0|        if (bitstream->bits_to_go==0)
  703|      0|        {
  704|      0|          bitstream->bits_to_go = 8;
  705|      0|          bitstream->streamBuffer[bitstream->byte_pos++]=bitstream->byte_buf;
  706|      0|          bitstream->byte_buf = 0;
  707|      0|        }
  708|      0|      }
  709|      0|    }
  710|      0|  }
  711|       |
  712|      0|  return ret;
  713|      0|}
  714|       |
  715|       |/*!
  716|       | ************************************************************************
  717|       | *  \brief
  718|       | *      Finalize the spare picture SEI payload.
  719|       | *        The spare picture paylaod will be ready for encapsulation, and it
  720|       | *        should be called before current picture packetized.
  721|       | *  \par Input
  722|       | *      seiSparePicturePayload.data: points to the payload starting from
  723|       | *        delta_spare_frame_num. (See FCD)
  724|       | *  \par Output
  725|       | *      seiSparePicturePayload.data is updated, pointing to the whole spare
  726|       | *        picture information: spare_picture( PayloadSize ) (See FCD)
  727|       | *        Make sure it is byte aligned.
  728|       | ************************************************************************
  729|       | */
  730|       |void FinalizeSpareMBMap()
  731|      0|{
  732|      0|  int CurrFrameNum = img->number % MAX_FN;
  733|      0|  int delta_frame_num;
  734|      0|  SyntaxElement sym;
  735|      0|  Bitstream *dest, *source;
  736|       |
  737|      0|  sym.type = SE_HEADER;
  738|      0|  sym.mapping = ue_linfo;
  739|       |
  740|      0|  source = seiSparePicturePayload.data;
  741|      0|  dest = malloc(sizeof(Bitstream));
  742|      0|  if ( dest == NULL ) no_mem_exit("FinalizeSpareMBMap: dest");
  743|      0|  dest->streamBuffer = malloc(MAXRTPPAYLOADLEN);
  744|      0|  if ( dest->streamBuffer == NULL ) no_mem_exit("FinalizeSpareMBMap: dest->streamBuffer");
  745|      0|  dest->bits_to_go  = 8;
  746|      0|  dest->byte_pos    = 0;
  747|      0|  dest->byte_buf    = 0;
  748|      0|  memset( dest->streamBuffer, 0, MAXRTPPAYLOADLEN);
  749|       |
  750|       |  //    delta_frame_num
  751|      0|  delta_frame_num = CurrFrameNum - seiSparePicturePayload.target_frame_num;
  752|      0|  if ( delta_frame_num < 0 ) delta_frame_num += MAX_FN;
  753|      0|  sym.value1 = delta_frame_num;
  754|      0|  writeSyntaxElement2Buf_UVLC(&sym, dest);
  755|       |
  756|       |  // num_spare_pics_minus1
  757|      0|  sym.value1 = seiSparePicturePayload.num_spare_pics - 1;
  758|      0|  writeSyntaxElement2Buf_UVLC(&sym, dest);
  759|       |
  760|       |  // copy the other bits
  761|      0|  AppendTmpbits2Buf( dest, source);
  762|       |
  763|       |  // make sure the payload is byte aligned, stuff bits are 10..0
  764|      0|  if ( dest->bits_to_go != 8 )
  765|      0|  {
  766|      0|    (dest->byte_buf) <<= 1;
  767|      0|    dest->byte_buf |= 1;
  768|      0|    dest->bits_to_go--;
  769|      0|    if ( dest->bits_to_go != 0 ) (dest->byte_buf) <<= (dest->bits_to_go);
  770|      0|    dest->bits_to_go = 8;
  771|      0|    dest->streamBuffer[dest->byte_pos++]=dest->byte_buf;
  772|      0|    dest->byte_buf = 0;
  773|      0|  }
  774|      0|  seiSparePicturePayload.payloadSize = dest->byte_pos;
  775|       |
  776|       |  // the payload is ready now
  777|      0|  seiSparePicturePayload.data = dest;
  778|      0|  free( source->streamBuffer );
  779|      0|  free( source );
  780|      0|}
  781|       |
  782|       |/*
  783|       | **++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  784|       | *  \functions on subseq information sei messages
  785|       | *  \brief
  786|       | *      JVT-D098
  787|       | *  \author
  788|       | *      Dong Tian                 <tian@cs.tut.fi>
  789|       | **++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  790|       | */
  791|       |
  792|       |Boolean seiHasSubseqInfo = FALSE;
  793|       |subseq_information_struct seiSubseqInfo[MAX_LAYER_NUMBER];
  794|       |
  795|       |/*!
  796|       | ************************************************************************
  797|       | *  \brief
  798|       | *      init subseqence info
  799|       | ************************************************************************
  800|       | */
  801|       |void InitSubseqInfo(int currLayer)
  802|      0|{
  803|      0|  static unsigned short id = 0;
  804|       |
  805|      0|  seiHasSubseqInfo = TRUE;
  806|      0|  seiSubseqInfo[currLayer].subseq_layer_num = currLayer;
  807|      0|  seiSubseqInfo[currLayer].subseq_id = id++;
  808|      0|  seiSubseqInfo[currLayer].last_picture_flag = 0;
  809|      0|  seiSubseqInfo[currLayer].stored_frame_cnt = -1;
  810|      0|  seiSubseqInfo[currLayer].payloadSize = 0;
  811|       |
  812|      0|  seiSubseqInfo[currLayer].data = malloc( sizeof(Bitstream) );
  813|      0|  if ( seiSubseqInfo[currLayer].data == NULL ) no_mem_exit("InitSubseqInfo: seiSubseqInfo[currLayer].data");
  814|      0|  seiSubseqInfo[currLayer].data->streamBuffer = malloc( MAXRTPPAYLOADLEN );
  815|      0|  if ( seiSubseqInfo[currLayer].data->streamBuffer == NULL ) no_mem_exit("InitSubseqInfo: seiSubseqInfo[currLayer].data->streamBuffer");
  816|      0|  seiSubseqInfo[currLayer].data->bits_to_go  = 8;
  817|      0|  seiSubseqInfo[currLayer].data->byte_pos    = 0;
  818|      0|  seiSubseqInfo[currLayer].data->byte_buf    = 0;
  819|      0|  memset( seiSubseqInfo[currLayer].data->streamBuffer, 0, MAXRTPPAYLOADLEN );
  820|      0|}
  821|       |
  822|       |/*!
  823|       | ************************************************************************
  824|       | *  \brief
  825|       | *      update subseqence info
  826|       | ************************************************************************
  827|       | */
  828|       |void UpdateSubseqInfo(int currLayer)
  829|    171|{
  830|    171|  if (img->type != B_SLICE)
  831|     86|  {
  832|     86|    seiSubseqInfo[currLayer].stored_frame_cnt ++;
  833|     86|    seiSubseqInfo[currLayer].stored_frame_cnt = seiSubseqInfo[currLayer].stored_frame_cnt % MAX_FN;
  834|     86|  }
  835|       |
  836|    171|  if ( currLayer == 0 )
  837|    171|  {
  838|    171|    if ( img->number == input->no_frames-1 )
  839|      2|      seiSubseqInfo[currLayer].last_picture_flag = 1;
  840|    169|    else
  841|    169|      seiSubseqInfo[currLayer].last_picture_flag = 0;
  842|    171|  }
  843|    171|  if ( currLayer == 1 )
  844|      0|  {
  845|      0|    if ( ((IMG_NUMBER%(input->NumFramesInELSubSeq+1)==0) && (input->successive_Bframe != 0) && (IMG_NUMBER>0)) || // there are B frames
  846|      0|      ((IMG_NUMBER%(input->NumFramesInELSubSeq+1)==input->NumFramesInELSubSeq) && (input->successive_Bframe==0))  // there are no B frames
  847|      0|      )
  848|      0|      seiSubseqInfo[currLayer].last_picture_flag = 1;
  849|      0|    else
  850|      0|      seiSubseqInfo[currLayer].last_picture_flag = 0;
  851|      0|  }
  852|    171|}
  853|       |
  854|       |/*!
  855|       | ************************************************************************
  856|       | *  \brief
  857|       | *      Finalize subseqence info
  858|       | ************************************************************************
  859|       | */
  860|       |void FinalizeSubseqInfo(int currLayer)
  861|      0|{
  862|      0|  SyntaxElement sym;
  863|      0|  Bitstream *dest = seiSubseqInfo[currLayer].data;
  864|       |
  865|      0|  sym.type = SE_HEADER;
  866|      0|  sym.mapping = ue_linfo;
  867|       |
  868|      0|  sym.value1 = seiSubseqInfo[currLayer].subseq_layer_num;
  869|      0|  writeSyntaxElement2Buf_UVLC(&sym, dest);
  870|      0|  sym.value1 = seiSubseqInfo[currLayer].subseq_id;
  871|      0|  writeSyntaxElement2Buf_UVLC(&sym, dest);
  872|      0|  sym.bitpattern = seiSubseqInfo[currLayer].last_picture_flag;
  873|      0|  sym.len = 1;
  874|      0|  writeSyntaxElement2Buf_Fixed(&sym, dest);
  875|      0|  sym.value1 = seiSubseqInfo[currLayer].stored_frame_cnt;
  876|      0|  writeSyntaxElement2Buf_UVLC(&sym, dest);
  877|       |
  878|       |  // make sure the payload is byte aligned, stuff bits are 10..0
  879|      0|  if ( dest->bits_to_go != 8 )
  880|      0|  {
  881|      0|    (dest->byte_buf) <<= 1;
  882|      0|    dest->byte_buf |= 1;
  883|      0|    dest->bits_to_go--;
  884|      0|    if ( dest->bits_to_go != 0 ) (dest->byte_buf) <<= (dest->bits_to_go);
  885|      0|    dest->bits_to_go = 8;
  886|      0|    dest->streamBuffer[dest->byte_pos++]=dest->byte_buf;
  887|      0|    dest->byte_buf = 0;
  888|      0|  }
  889|      0|  seiSubseqInfo[currLayer].payloadSize = dest->byte_pos;
  890|       |
  891|       |//  printf("layer %d, last picture %d, stored_cnt %d\n", currLayer, seiSubseqInfo[currLayer].last_picture_flag, seiSubseqInfo[currLayer].stored_frame_cnt );
  892|      0|}
  893|       |
  894|       |/*!
  895|       | ************************************************************************
  896|       | *  \brief
  897|       | *      Clear the payload buffer
  898|       | ************************************************************************
  899|       | */
  900|       |void ClearSubseqInfoPayload(int currLayer)
  901|      0|{
  902|      0|  seiSubseqInfo[currLayer].data->bits_to_go  = 8;
  903|      0|  seiSubseqInfo[currLayer].data->byte_pos    = 0;
  904|      0|  seiSubseqInfo[currLayer].data->byte_buf    = 0;
  905|      0|  memset( seiSubseqInfo[currLayer].data->streamBuffer, 0, MAXRTPPAYLOADLEN );
  906|      0|  seiSubseqInfo[currLayer].payloadSize = 0;
  907|      0|}
  908|       |
  909|       |/*!
  910|       | ************************************************************************
  911|       | *  \brief
  912|       | *      Close the global variables for spare picture information
  913|       | ************************************************************************
  914|       | */
  915|       |void CloseSubseqInfo(int currLayer)
  916|      0|{
  917|      0|  seiSubseqInfo[currLayer].stored_frame_cnt = -1;
  918|      0|  seiSubseqInfo[currLayer].payloadSize = 0;
  919|       |
  920|      0|  free( seiSubseqInfo[currLayer].data->streamBuffer );
  921|      0|  free( seiSubseqInfo[currLayer].data );
  922|      0|}
  923|       |
  924|       |/*
  925|       | **++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  926|       | *  \functions on subseq layer characteristic sei messages
  927|       | *  \brief
  928|       | *      JVT-D098
  929|       | *  \author
  930|       | *      Dong Tian                 <tian@cs.tut.fi>
  931|       | **++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  932|       | */
  933|       |
  934|       |Boolean seiHasSubseqLayerInfo = FALSE;
  935|       |subseq_layer_information_struct seiSubseqLayerInfo;
  936|       |
  937|       |/*!
  938|       | ************************************************************************
  939|       | *  \brief
  940|       | *      Init the global variables for spare picture information
  941|       | ************************************************************************
  942|       | */
  943|       |void InitSubseqLayerInfo()
  944|      0|{
  945|      0|  int i;
  946|      0|  seiHasSubseqLayerInfo = TRUE;
  947|      0|  seiSubseqLayerInfo.layer_number = 0;
  948|      0|  for (i=0; i<MAX_LAYER_NUMBER; i++)
  949|      0|  {
  950|      0|    seiSubseqLayerInfo.bit_rate[i] = 0;
  951|      0|    seiSubseqLayerInfo.frame_rate[i] = 0;
  952|      0|    seiSubseqLayerInfo.layer_number++;
  953|      0|  }
  954|      0|}
  955|       |
  956|       |/*!
  957|       | ************************************************************************
  958|       | *  \brief
  959|       | *      
  960|       | ************************************************************************
  961|       | */
  962|       |void CloseSubseqLayerInfo()
  963|      0|{
  964|      0|}
  965|       |
  966|       |/*!
  967|       | ************************************************************************
  968|       | *  \brief
  969|       | *      Write the data to buffer, which is byte aligned
  970|       | ************************************************************************
  971|       | */
  972|       |void FinalizeSubseqLayerInfo()
  973|      0|{
  974|      0|  int i, pos;
  975|      0|  pos = 0;
  976|      0|  seiSubseqLayerInfo.payloadSize = 0;
  977|      0|  for (i=0; i<seiSubseqLayerInfo.layer_number; i++)
  978|      0|  {
  979|      0|    *((unsigned short*)&(seiSubseqLayerInfo.data[pos])) = seiSubseqLayerInfo.bit_rate[i];
  980|      0|    pos += 2;
  981|      0|    *((unsigned short*)&(seiSubseqLayerInfo.data[pos])) = seiSubseqLayerInfo.frame_rate[i];
  982|      0|    pos += 2;
  983|      0|    seiSubseqLayerInfo.payloadSize += 4;
  984|      0|  }
  985|      0|}
  986|       |
  987|       |/*
  988|       | **++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  989|       | *  \functions on subseq characteristic sei messages
  990|       | *  \brief
  991|       | *      JVT-D098
  992|       | *  \author
  993|       | *      Dong Tian                 <tian@cs.tut.fi>
  994|       | **++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  995|       | */
  996|       |
  997|       |Boolean seiHasSubseqChar = FALSE;
  998|       |subseq_char_information_struct seiSubseqChar;
  999|       |
 1000|       |void InitSubseqChar()
 1001|      1|{
 1002|      1|  seiSubseqChar.data = malloc( sizeof(Bitstream) );
 1003|      1|  if( seiSubseqChar.data == NULL ) no_mem_exit("InitSubseqChar: seiSubseqChar.data");
 1004|      1|  seiSubseqChar.data->streamBuffer = malloc(MAXRTPPAYLOADLEN);
 1005|      1|  if( seiSubseqChar.data->streamBuffer == NULL ) no_mem_exit("InitSubseqChar: seiSubseqChar.data->streamBuffer");
 1006|      1|  ClearSubseqCharPayload();
 1007|       |
 1008|      1|  seiSubseqChar.subseq_layer_num = img->layer;
 1009|      1|  seiSubseqChar.subseq_id = seiSubseqInfo[img->layer].subseq_id;
 1010|      1|  seiSubseqChar.duration_flag = 0;
 1011|      1|  seiSubseqChar.average_rate_flag = 0;
 1012|      1|  seiSubseqChar.num_referenced_subseqs = 0;
 1013|      1|}
 1014|       |
 1015|       |void ClearSubseqCharPayload()
 1016|      1|{
 1017|      1|  memset( seiSubseqChar.data->streamBuffer, 0, MAXRTPPAYLOADLEN);
 1018|      1|  seiSubseqChar.data->bits_to_go  = 8;
 1019|      1|  seiSubseqChar.data->byte_pos    = 0;
 1020|      1|  seiSubseqChar.data->byte_buf    = 0;
 1021|      1|  seiSubseqChar.payloadSize       = 0;
 1022|       |
 1023|      1|  seiHasSubseqChar = FALSE;
 1024|      1|}
 1025|       |
 1026|       |void UpdateSubseqChar()
 1027|      0|{
 1028|      0|  seiSubseqChar.subseq_layer_num = img->layer;
 1029|      0|  seiSubseqChar.subseq_id = seiSubseqInfo[img->layer].subseq_id;
 1030|      0|  seiSubseqChar.duration_flag = 0;
 1031|      0|  seiSubseqChar.average_rate_flag = 0;
 1032|      0|  seiSubseqChar.average_bit_rate = 100;
 1033|      0|  seiSubseqChar.average_frame_rate = 30;
 1034|      0|  seiSubseqChar.num_referenced_subseqs = 0;
 1035|      0|  seiSubseqChar.ref_subseq_layer_num[0] = 1;
 1036|      0|  seiSubseqChar.ref_subseq_id[0] = 2;
 1037|      0|  seiSubseqChar.ref_subseq_layer_num[1] = 3;
 1038|      0|  seiSubseqChar.ref_subseq_id[1] = 4;
 1039|       |
 1040|      0|  seiHasSubseqChar = TRUE;
 1041|      0|}
 1042|       |
 1043|       |void FinalizeSubseqChar()
 1044|      0|{
 1045|      0|  int i;
 1046|      0|  SyntaxElement sym;
 1047|      0|  Bitstream *dest = seiSubseqChar.data;
 1048|       |
 1049|      0|  sym.type = SE_HEADER;
 1050|      0|  sym.mapping = ue_linfo;
 1051|       |
 1052|      0|  sym.value1 = seiSubseqChar.subseq_layer_num;
 1053|      0|  writeSyntaxElement2Buf_UVLC(&sym, dest);
 1054|      0|  sym.value1 = seiSubseqChar.subseq_id;
 1055|      0|  writeSyntaxElement2Buf_UVLC(&sym, dest);
 1056|      0|  sym.bitpattern = seiSubseqChar.duration_flag;
 1057|      0|  sym.len = 1;
 1058|      0|  writeSyntaxElement2Buf_Fixed(&sym, dest);
 1059|      0|  if ( seiSubseqChar.duration_flag )
 1060|      0|  {
 1061|      0|    sym.bitpattern = seiSubseqChar.subseq_duration;
 1062|      0|    sym.len = 32;
 1063|      0|    writeSyntaxElement2Buf_Fixed(&sym, dest);
 1064|      0|  }
 1065|      0|  sym.bitpattern = seiSubseqChar.average_rate_flag;
 1066|      0|  sym.len = 1;
 1067|      0|  writeSyntaxElement2Buf_Fixed(&sym, dest);
 1068|      0|  if ( seiSubseqChar.average_rate_flag )
 1069|      0|  {
 1070|      0|    sym.bitpattern = seiSubseqChar.average_bit_rate;
 1071|      0|    sym.len = 16;
 1072|      0|    writeSyntaxElement2Buf_Fixed(&sym, dest);
 1073|      0|    sym.bitpattern = seiSubseqChar.average_frame_rate;
 1074|      0|    sym.len = 16;
 1075|      0|    writeSyntaxElement2Buf_Fixed(&sym, dest);
 1076|      0|  }
 1077|      0|  sym.value1 = seiSubseqChar.num_referenced_subseqs;
 1078|      0|  writeSyntaxElement2Buf_UVLC(&sym, dest);
 1079|      0|  for (i=0; i<seiSubseqChar.num_referenced_subseqs; i++)
 1080|      0|  {
 1081|      0|    sym.value1 = seiSubseqChar.ref_subseq_layer_num[i];
 1082|      0|    writeSyntaxElement2Buf_UVLC(&sym, dest);
 1083|      0|    sym.value1 = seiSubseqChar.ref_subseq_id[i];
 1084|      0|    writeSyntaxElement2Buf_UVLC(&sym, dest);
 1085|      0|  }
 1086|       |
 1087|       |  // make sure the payload is byte aligned, stuff bits are 10..0
 1088|      0|  if ( dest->bits_to_go != 8 )
 1089|      0|  {
 1090|      0|    (dest->byte_buf) <<= 1;
 1091|      0|    dest->byte_buf |= 1;
 1092|      0|    dest->bits_to_go--;
 1093|      0|    if ( dest->bits_to_go != 0 ) (dest->byte_buf) <<= (dest->bits_to_go);
 1094|      0|    dest->bits_to_go = 8;
 1095|      0|    dest->streamBuffer[dest->byte_pos++]=dest->byte_buf;
 1096|      0|    dest->byte_buf = 0;
 1097|      0|  }
 1098|      0|  seiSubseqChar.payloadSize = dest->byte_pos;
 1099|      0|}
 1100|       |
 1101|       |void CloseSubseqChar()
 1102|      1|{
 1103|      1|  if (seiSubseqChar.data)
 1104|      1|  {
 1105|      1|    free(seiSubseqChar.data->streamBuffer);
 1106|      1|    free(seiSubseqChar.data);
 1107|      1|  }
 1108|      1|  seiSubseqChar.data = NULL;
 1109|      1|}
 1110|       |
 1111|       |
 1112|       |// JVT-D099
 1113|       |/*
 1114|       | **++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 1115|       | *  \functions on scene information SEI message
 1116|       | *  \brief
 1117|       | *      JVT-D099
 1118|       | *  \author
 1119|       | *      Ye-Kui Wang                 <wyk@ieee.org>
 1120|       | **++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 1121|       | */
 1122|       |
 1123|       |scene_information_struct seiSceneInformation;
 1124|       |
 1125|       |void InitSceneInformation()
 1126|      1|{
 1127|      1|  seiHasSceneInformation = TRUE;
 1128|       |
 1129|      1|  seiSceneInformation.scene_id = 0;
 1130|      1|  seiSceneInformation.scene_transition_type = 0;
 1131|      1|  seiSceneInformation.second_scene_id = -1;
 1132|       |
 1133|      1|  seiSceneInformation.data = malloc( sizeof(Bitstream) );
 1134|      1|  if( seiSceneInformation.data == NULL ) no_mem_exit("InitSceneInformation: seiSceneInformation.data");
 1135|      1|  seiSceneInformation.data->streamBuffer = malloc( MAXRTPPAYLOADLEN );
 1136|      1|  if( seiSceneInformation.data->streamBuffer == NULL ) no_mem_exit("InitSceneInformation: seiSceneInformation.data->streamBuffer");
 1137|      1|  seiSceneInformation.data->bits_to_go  = 8;
 1138|      1|  seiSceneInformation.data->byte_pos    = 0;
 1139|      1|  seiSceneInformation.data->byte_buf    = 0;
 1140|      1|  memset( seiSceneInformation.data->streamBuffer, 0, MAXRTPPAYLOADLEN );
 1141|      1|}
 1142|       |
 1143|       |void CloseSceneInformation()
 1144|      1|{
 1145|      1|  if (seiSceneInformation.data)
 1146|      1|  {
 1147|      1|    free(seiSceneInformation.data->streamBuffer);
 1148|      1|    free(seiSceneInformation.data);
 1149|      1|  }
 1150|      1|  seiSceneInformation.data = NULL;
 1151|      1|}
 1152|       |
 1153|       |void FinalizeSceneInformation()
 1154|      0|{
 1155|      0|  SyntaxElement sym;
 1156|      0|  Bitstream *dest = seiSceneInformation.data;
 1157|       |
 1158|      0|  sym.type = SE_HEADER;
 1159|      0|  sym.mapping = ue_linfo;
 1160|       |
 1161|      0|  sym.bitpattern = seiSceneInformation.scene_id;
 1162|      0|  sym.len = 8;
 1163|      0|  writeSyntaxElement2Buf_Fixed(&sym, dest);
 1164|       |
 1165|      0|  sym.value1 = seiSceneInformation.scene_transition_type;
 1166|      0|  writeSyntaxElement2Buf_UVLC(&sym, dest);
 1167|       |
 1168|      0|  if(seiSceneInformation.scene_transition_type > 3)
 1169|      0|  {
 1170|      0|    sym.bitpattern = seiSceneInformation.second_scene_id;
 1171|      0|    sym.len = 8;
 1172|      0|    writeSyntaxElement2Buf_Fixed(&sym, dest);
 1173|      0|  }
 1174|       |
 1175|       |  // make sure the payload is byte aligned, stuff bits are 10..0
 1176|      0|  if ( dest->bits_to_go != 8 )
 1177|      0|  {
 1178|      0|    (dest->byte_buf) <<= 1;
 1179|      0|    dest->byte_buf |= 1;
 1180|      0|    dest->bits_to_go--;
 1181|      0|    if ( dest->bits_to_go != 0 ) (dest->byte_buf) <<= (dest->bits_to_go);
 1182|      0|    dest->bits_to_go = 8;
 1183|      0|    dest->streamBuffer[dest->byte_pos++]=dest->byte_buf;
 1184|      0|    dest->byte_buf = 0;
 1185|      0|  }
 1186|      0|  seiSceneInformation.payloadSize = dest->byte_pos;
 1187|      0|}
 1188|       |
 1189|       |// HasSceneInformation: To include a scene information SEI into the next slice/DP, 
 1190|       |//      set HasSceneInformation to be TRUE when calling this function. Otherwise, 
 1191|       |//      set HasSceneInformation to be FALSE.
 1192|       |void UpdateSceneInformation(Boolean HasSceneInformation, int sceneID, int sceneTransType, int secondSceneID)
 1193|    171|{
 1194|    171|  seiHasSceneInformation = HasSceneInformation;
 1195|       |
 1196|    171|  assert (sceneID < 256);
 1197|    171|  seiSceneInformation.scene_id = sceneID;
 1198|       |
 1199|    171|  assert (sceneTransType <= 6 );
 1200|    171|  seiSceneInformation.scene_transition_type = sceneTransType;
 1201|       |
 1202|    171|  if(sceneTransType > 3)
 1203|      0|  {
 1204|      0|    assert (secondSceneID < 256);
 1205|      0|    seiSceneInformation.second_scene_id = secondSceneID;
 1206|      0|  }
 1207|    171|}
 1208|       |// End JVT-D099
 1209|       |
 1210|       |
 1211|       |/*
 1212|       | **++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 1213|       | *  \functions on Pan Scan messages
 1214|       | *  \brief
 1215|       | *      Based on FCD
 1216|       | *  \author
 1217|       | *      Shankar Regunathan                 <tian@cs.tut.fi>
 1218|       | **++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 1219|       | */
 1220|       |
 1221|       |Boolean seiHasPanScanRectInfo = FALSE;
 1222|       |panscanrect_information_struct seiPanScanRectInfo;
 1223|       |
 1224|       |void InitPanScanRectInfo()
 1225|      1|{
 1226|       |
 1227|      1|  seiPanScanRectInfo.data = malloc( sizeof(Bitstream) );
 1228|      1|  if( seiPanScanRectInfo.data == NULL ) no_mem_exit("InitPanScanRectInfo: seiPanScanRectInfo.data");
 1229|      1|  seiPanScanRectInfo.data->streamBuffer = malloc(MAXRTPPAYLOADLEN);
 1230|      1|  if( seiPanScanRectInfo.data->streamBuffer == NULL ) no_mem_exit("InitPanScanRectInfo: seiPanScanRectInfo.data->streamBuffer");
 1231|      1|  ClearPanScanRectInfoPayload();
 1232|       |
 1233|      1|  seiPanScanRectInfo.pan_scan_rect_left_offset = 0;
 1234|      1|  seiPanScanRectInfo.pan_scan_rect_right_offset = 0;
 1235|      1|  seiPanScanRectInfo.pan_scan_rect_top_offset = 0;
 1236|      1|  seiPanScanRectInfo.pan_scan_rect_bottom_offset = 0;
 1237|       |
 1238|      1|}
 1239|       |
 1240|       |
 1241|       |void ClearPanScanRectInfoPayload()
 1242|      1|{
 1243|      1|  memset( seiPanScanRectInfo.data->streamBuffer, 0, MAXRTPPAYLOADLEN);
 1244|      1|  seiPanScanRectInfo.data->bits_to_go  = 8;
 1245|      1|  seiPanScanRectInfo.data->byte_pos    = 0;
 1246|      1|  seiPanScanRectInfo.data->byte_buf    = 0;
 1247|      1|  seiPanScanRectInfo.payloadSize       = 0;
 1248|       |
 1249|      1|  seiHasPanScanRectInfo = TRUE;
 1250|      1|}
 1251|       |
 1252|       |void UpdatePanScanRectInfo()
 1253|      0|{
 1254|      0|  seiPanScanRectInfo.pan_scan_rect_id = 3;
 1255|      0|  seiPanScanRectInfo.pan_scan_rect_left_offset = 10;
 1256|      0|  seiPanScanRectInfo.pan_scan_rect_right_offset = 40;
 1257|      0|  seiPanScanRectInfo.pan_scan_rect_top_offset = 20;
 1258|      0|  seiPanScanRectInfo.pan_scan_rect_bottom_offset =32;
 1259|      0|  seiHasPanScanRectInfo = TRUE;
 1260|      0|}
 1261|       |
 1262|       |void FinalizePanScanRectInfo()
 1263|      0|{
 1264|      0|  SyntaxElement sym;
 1265|      0|  Bitstream *dest = seiPanScanRectInfo.data;
 1266|       |
 1267|       |
 1268|      0|  sym.type = SE_HEADER;
 1269|      0|  sym.mapping = ue_linfo;
 1270|       |
 1271|      0|  sym.value1 = seiPanScanRectInfo.pan_scan_rect_id;
 1272|      0|  writeSyntaxElement2Buf_UVLC(&sym, dest);
 1273|      0|  sym.value1 = seiPanScanRectInfo.pan_scan_rect_left_offset;
 1274|      0|  writeSyntaxElement2Buf_UVLC(&sym, dest);
 1275|      0|  sym.value1 = seiPanScanRectInfo.pan_scan_rect_right_offset;
 1276|      0|  writeSyntaxElement2Buf_UVLC(&sym, dest);
 1277|      0|  sym.value1 = seiPanScanRectInfo.pan_scan_rect_top_offset;
 1278|      0|  writeSyntaxElement2Buf_UVLC(&sym, dest);
 1279|      0|  sym.value1 = seiPanScanRectInfo.pan_scan_rect_bottom_offset;
 1280|      0|  writeSyntaxElement2Buf_UVLC(&sym, dest);
 1281|       |
 1282|       |// #define PRINT_PAN_SCAN_RECT
 1283|       |#ifdef PRINT_PAN_SCAN_RECT
 1284|       |  printf("Pan Scan Id %d Left %d Right %d Top %d Bottom %d \n", seiPanScanRectInfo.pan_scan_rect_id, seiPanScanRectInfo.pan_scan_rect_left_offset, seiPanScanRectInfo.pan_scan_rect_right_offset, seiPanScanRectInfo.pan_scan_rect_top_offset, seiPanScanRectInfo.pan_scan_rect_bottom_offset);
 1285|       |#endif
 1286|       |#ifdef PRINT_PAN_SCAN_RECT
 1287|       |#undef PRINT_PAN_SCAN_RECT
 1288|       |#endif
 1289|       |  // make sure the payload is byte aligned, stuff bits are 10..0
 1290|      0|  if ( dest->bits_to_go != 8 )
 1291|      0|  {
 1292|      0|    (dest->byte_buf) <<= 1;
 1293|      0|    dest->byte_buf |= 1;
 1294|      0|    dest->bits_to_go--;
 1295|      0|    if ( dest->bits_to_go != 0 ) (dest->byte_buf) <<= (dest->bits_to_go);
 1296|      0|    dest->bits_to_go = 8;
 1297|      0|    dest->streamBuffer[dest->byte_pos++]=dest->byte_buf;
 1298|      0|    dest->byte_buf = 0;
 1299|      0|  }
 1300|      0|  seiPanScanRectInfo.payloadSize = dest->byte_pos;
 1301|      0|}
 1302|       |
 1303|       |
 1304|       |
 1305|       |void ClosePanScanRectInfo()
 1306|      1|{
 1307|      1|  if (seiPanScanRectInfo.data)
 1308|      1|  {
 1309|      1|    free(seiPanScanRectInfo.data->streamBuffer);
 1310|      1|    free(seiPanScanRectInfo.data);
 1311|      1|  }
 1312|      1|  seiPanScanRectInfo.data = NULL;
 1313|      1|}
 1314|       |
 1315|       |/*
 1316|       | **++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 1317|       | *  \functions on arbitrary (unregistered) data
 1318|       | *  \brief
 1319|       | *      Based on FCD
 1320|       | *  \author
 1321|       | *      Shankar Regunathan                 <tian@cs.tut.fi>
 1322|       | **++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 1323|       | */
 1324|       |Boolean seiHasUser_data_unregistered_info;
 1325|       |user_data_unregistered_information_struct seiUser_data_unregistered;
 1326|       |void InitUser_data_unregistered()
 1327|      1|{
 1328|       |
 1329|      1|  seiUser_data_unregistered.data = malloc( sizeof(Bitstream) );
 1330|      1|  if( seiUser_data_unregistered.data == NULL ) no_mem_exit("InitUser_data_unregistered: seiUser_data_unregistered.data");
 1331|      1|  seiUser_data_unregistered.data->streamBuffer = malloc(MAXRTPPAYLOADLEN);
 1332|      1|  if( seiUser_data_unregistered.data->streamBuffer == NULL ) no_mem_exit("InitUser_data_unregistered: seiUser_data_unregistered.data->streamBuffer");
 1333|      1|  seiUser_data_unregistered.byte = malloc(MAXRTPPAYLOADLEN);
 1334|      1|  if( seiUser_data_unregistered.byte == NULL ) no_mem_exit("InitUser_data_unregistered: seiUser_data_unregistered.byte");
 1335|      1|  ClearUser_data_unregistered();
 1336|       |
 1337|      1|}
 1338|       |
 1339|       |
 1340|       |void ClearUser_data_unregistered()
 1341|      1|{
 1342|      1|  memset( seiUser_data_unregistered.data->streamBuffer, 0, MAXRTPPAYLOADLEN);
 1343|      1|  seiUser_data_unregistered.data->bits_to_go  = 8;
 1344|      1|  seiUser_data_unregistered.data->byte_pos    = 0;
 1345|      1|  seiUser_data_unregistered.data->byte_buf    = 0;
 1346|      1|  seiUser_data_unregistered.payloadSize       = 0;
 1347|       |
 1348|      1|  memset( seiUser_data_unregistered.byte, 0, MAXRTPPAYLOADLEN);
 1349|      1|  seiUser_data_unregistered.total_byte = 0;
 1350|       |
 1351|      1|  seiHasUser_data_unregistered_info = TRUE;
 1352|      1|}
 1353|       |
 1354|       |void UpdateUser_data_unregistered()
 1355|      0|{
 1356|      0|  int i, temp_data;
 1357|      0|  int total_byte;
 1358|       |
 1359|       |
 1360|      0|  total_byte = 7;
 1361|      0|  for(i = 0; i < total_byte; i++)
 1362|      0|  {
 1363|      0|    temp_data = i * 4;
 1364|      0|    seiUser_data_unregistered.byte[i] = max(0, min(temp_data, 255));
 1365|      0|  }
 1366|      0|  seiUser_data_unregistered.total_byte = total_byte;
 1367|      0|}
 1368|       |
 1369|       |void FinalizeUser_data_unregistered()
 1370|      0|{
 1371|      0|  int i;
 1372|      0|  SyntaxElement sym;
 1373|      0|  Bitstream *dest = seiUser_data_unregistered.data;
 1374|       |
 1375|      0|  sym.type = SE_HEADER;
 1376|      0|  sym.mapping = ue_linfo;
 1377|       |
 1378|       |// #define PRINT_USER_DATA_UNREGISTERED_INFO
 1379|      0|  for( i = 0; i < seiUser_data_unregistered.total_byte; i++)
 1380|      0|  {
 1381|      0|    sym.bitpattern = seiUser_data_unregistered.byte[i];
 1382|      0|    sym.len = 8; // b (8)
 1383|      0|    writeSyntaxElement2Buf_Fixed(&sym, dest);
 1384|       |#ifdef PRINT_USER_DATA_UNREGISTERED_INFO
 1385|       |    printf("Unreg data payload_byte = %d\n", seiUser_data_unregistered.byte[i]);
 1386|       |#endif
 1387|      0|  }
 1388|       |#ifdef PRINT_USER_DATA_UNREGISTERED_INFO
 1389|       |#undef PRINT_USER_DATA_UNREGISTERED_INFO
 1390|       |#endif
 1391|       |  // make sure the payload is byte aligned, stuff bits are 10..0
 1392|      0|  if ( dest->bits_to_go != 8 )
 1393|      0|  {
 1394|      0|    (dest->byte_buf) <<= 1;
 1395|      0|    dest->byte_buf |= 1;
 1396|      0|    dest->bits_to_go--;
 1397|      0|    if ( dest->bits_to_go != 0 ) (dest->byte_buf) <<= (dest->bits_to_go);
 1398|      0|    dest->bits_to_go = 8;
 1399|      0|    dest->streamBuffer[dest->byte_pos++]=dest->byte_buf;
 1400|      0|    dest->byte_buf = 0;
 1401|      0|  }
 1402|      0|  seiUser_data_unregistered.payloadSize = dest->byte_pos;
 1403|      0|}
 1404|       |
 1405|       |void CloseUser_data_unregistered()
 1406|      1|{
 1407|      1|  if (seiUser_data_unregistered.data)
 1408|      1|  {
 1409|      1|    free(seiUser_data_unregistered.data->streamBuffer);
 1410|      1|    free(seiUser_data_unregistered.data);
 1411|      1|  }
 1412|      1|  seiUser_data_unregistered.data = NULL;
 1413|      1|  if(seiUser_data_unregistered.byte)
 1414|      1|  {
 1415|      1|    free(seiUser_data_unregistered.byte);
 1416|      1|  }
 1417|      1|}
 1418|       |
 1419|       |
 1420|       |/*
 1421|       | **++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 1422|       | *  \functions on registered ITU_T_T35 user data
 1423|       | *  \brief
 1424|       | *      Based on FCD
 1425|       | *  \author
 1426|       | *      Shankar Regunathan                 <tian@cs.tut.fi>
 1427|       | **++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 1428|       | */
 1429|       |Boolean seiHasUser_data_registered_itu_t_t35_info;
 1430|       |user_data_registered_itu_t_t35_information_struct seiUser_data_registered_itu_t_t35;
 1431|       |void InitUser_data_registered_itu_t_t35()
 1432|      1|{
 1433|       |
 1434|      1|  seiUser_data_registered_itu_t_t35.data = malloc( sizeof(Bitstream) );
 1435|      1|  if( seiUser_data_registered_itu_t_t35.data == NULL ) no_mem_exit("InitUser_data_unregistered: seiUser_data_registered_itu_t_t35.data");
 1436|      1|  seiUser_data_registered_itu_t_t35.data->streamBuffer = malloc(MAXRTPPAYLOADLEN);
 1437|      1|  if( seiUser_data_registered_itu_t_t35.data->streamBuffer == NULL ) no_mem_exit("InitUser_data_unregistered: seiUser_data_registered_itu_t_t35.data->streamBuffer");
 1438|      1|  seiUser_data_registered_itu_t_t35.byte = malloc(MAXRTPPAYLOADLEN);
 1439|      1|  if( seiUser_data_registered_itu_t_t35.data == NULL ) no_mem_exit("InitUser_data_unregistered: seiUser_data_registered_itu_t_t35.byte");
 1440|      1|  ClearUser_data_registered_itu_t_t35();
 1441|       |
 1442|      1|}
 1443|       |
 1444|       |
 1445|       |void ClearUser_data_registered_itu_t_t35()
 1446|      1|{
 1447|      1|  memset( seiUser_data_registered_itu_t_t35.data->streamBuffer, 0, MAXRTPPAYLOADLEN);
 1448|      1|  seiUser_data_registered_itu_t_t35.data->bits_to_go  = 8;
 1449|      1|  seiUser_data_registered_itu_t_t35.data->byte_pos    = 0;
 1450|      1|  seiUser_data_registered_itu_t_t35.data->byte_buf    = 0;
 1451|      1|  seiUser_data_registered_itu_t_t35.payloadSize       = 0;
 1452|       |
 1453|      1|  memset( seiUser_data_registered_itu_t_t35.byte, 0, MAXRTPPAYLOADLEN);
 1454|      1|  seiUser_data_registered_itu_t_t35.total_byte = 0;
 1455|      1|  seiUser_data_registered_itu_t_t35.itu_t_t35_country_code = 0;
 1456|      1|  seiUser_data_registered_itu_t_t35.itu_t_t35_country_code_extension_byte = 0;
 1457|       |
 1458|      1|  seiHasUser_data_registered_itu_t_t35_info = TRUE;
 1459|      1|}
 1460|       |
 1461|       |void UpdateUser_data_registered_itu_t_t35()
 1462|      0|{
 1463|      0|  int i, temp_data;
 1464|      0|  int total_byte;
 1465|      0|  int country_code;
 1466|       |
 1467|      0|  country_code = 82; // Country_code for India
 1468|       |
 1469|      0|  if(country_code < 0xFF) 
 1470|      0|  {
 1471|      0|    seiUser_data_registered_itu_t_t35.itu_t_t35_country_code = country_code;
 1472|      0|  }
 1473|      0|  else 
 1474|      0|  {
 1475|      0|    seiUser_data_registered_itu_t_t35.itu_t_t35_country_code = 0xFF;
 1476|      0|    seiUser_data_registered_itu_t_t35.itu_t_t35_country_code_extension_byte = country_code - 0xFF;
 1477|      0|  }
 1478|       |
 1479|      0|  total_byte = 7;
 1480|      0|  for(i = 0; i < total_byte; i++)
 1481|      0|  {
 1482|      0|    temp_data = i * 3;
 1483|      0|    seiUser_data_registered_itu_t_t35.byte[i] = max(0, min(temp_data, 255));
 1484|      0|  }
 1485|      0|  seiUser_data_registered_itu_t_t35.total_byte = total_byte;
 1486|      0|}
 1487|       |
 1488|       |void FinalizeUser_data_registered_itu_t_t35()
 1489|      0|{
 1490|      0|  int i;
 1491|      0|  SyntaxElement sym;
 1492|      0|  Bitstream *dest = seiUser_data_registered_itu_t_t35.data;
 1493|       |
 1494|      0|  sym.type = SE_HEADER;
 1495|      0|  sym.mapping = ue_linfo;
 1496|       |
 1497|      0|  sym.bitpattern = seiUser_data_registered_itu_t_t35.itu_t_t35_country_code;
 1498|      0|  sym.len = 8;
 1499|      0|  writeSyntaxElement2Buf_Fixed(&sym, dest);
 1500|       |
 1501|       |// #define PRINT_USER_DATA_REGISTERED_ITU_T_T35_INFO
 1502|       |#ifdef PRINT_USER_DATA_REGISTERED_ITU_T_T35_INFO
 1503|       |  printf(" ITU_T_T35_COUNTRTY_CODE %d \n", seiUser_data_registered_itu_t_t35.itu_t_t35_country_code);
 1504|       |#endif
 1505|       |
 1506|      0|  if(seiUser_data_registered_itu_t_t35.itu_t_t35_country_code == 0xFF)
 1507|      0|  {
 1508|      0|    sym.bitpattern = seiUser_data_registered_itu_t_t35.itu_t_t35_country_code_extension_byte;
 1509|      0|    sym.len = 8;
 1510|      0|    writeSyntaxElement2Buf_Fixed(&sym, dest);
 1511|       |#ifdef PRINT_USER_DATA_REGISTERED_ITU_T_T35_INFO
 1512|       |    printf(" ITU_T_T35_COUNTRTY_CODE_EXTENSION_BYTE %d \n", seiUser_data_registered_itu_t_t35.itu_t_t35_country_code_extension_byte);
 1513|       |#endif
 1514|      0|  }
 1515|       |
 1516|      0|  for( i = 0; i < seiUser_data_registered_itu_t_t35.total_byte; i++)
 1517|      0|  {
 1518|      0|    sym.bitpattern = seiUser_data_registered_itu_t_t35.byte[i];
 1519|      0|    sym.len = 8; // b (8)
 1520|      0|    writeSyntaxElement2Buf_Fixed(&sym, dest);
 1521|       |#ifdef PRINT_USER_DATA_REGISTERED_ITU_T_T35_INFO
 1522|       |    printf("itu_t_t35 payload_byte = %d\n", seiUser_data_registered_itu_t_t35.byte[i]);
 1523|       |#endif
 1524|      0|  }
 1525|       |#ifdef PRINT_USER_DATA_REGISTERED_ITU_T_T35_INFO
 1526|       |#undef PRINT_USER_DATA_REGISTERED_ITU_T_T35_INFO
 1527|       |#endif
 1528|       |  // make sure the payload is byte aligned, stuff bits are 10..0
 1529|      0|  if ( dest->bits_to_go != 8 )
 1530|      0|  {
 1531|      0|    (dest->byte_buf) <<= 1;
 1532|      0|    dest->byte_buf |= 1;
 1533|      0|    dest->bits_to_go--;
 1534|      0|    if ( dest->bits_to_go != 0 ) (dest->byte_buf) <<= (dest->bits_to_go);
 1535|      0|    dest->bits_to_go = 8;
 1536|      0|    dest->streamBuffer[dest->byte_pos++]=dest->byte_buf;
 1537|      0|    dest->byte_buf = 0;
 1538|      0|  }
 1539|      0|  seiUser_data_registered_itu_t_t35.payloadSize = dest->byte_pos;
 1540|      0|}
 1541|       |
 1542|       |void CloseUser_data_registered_itu_t_t35()
 1543|      1|{
 1544|      1|  if (seiUser_data_registered_itu_t_t35.data)
 1545|      1|  {
 1546|      1|    free(seiUser_data_registered_itu_t_t35.data->streamBuffer);
 1547|      1|    free(seiUser_data_registered_itu_t_t35.data);
 1548|      1|  }
 1549|      1|  seiUser_data_registered_itu_t_t35.data = NULL;
 1550|      1|  if(seiUser_data_registered_itu_t_t35.byte)
 1551|      1|  {
 1552|      1|    free(seiUser_data_registered_itu_t_t35.byte);
 1553|      1|  }
 1554|      1|}
 1555|       |
 1556|       |/*
 1557|       | **++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 1558|       | *  \functions on random access message
 1559|       | *  \brief
 1560|       | *      Based on FCD
 1561|       | *  \author
 1562|       | *      Shankar Regunathan                 <tian@cs.tut.fi>
 1563|       | **++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 1564|       | */
 1565|       |Boolean seiHasRandomAccess_info;
 1566|       |randomaccess_information_struct seiRandomAccess;
 1567|       |void InitRandomAccess()
 1568|      1|{
 1569|       |
 1570|      1|  seiRandomAccess.data = malloc( sizeof(Bitstream) );
 1571|      1|  if( seiRandomAccess.data == NULL ) no_mem_exit("InitRandomAccess: seiRandomAccess.data");
 1572|      1|  seiRandomAccess.data->streamBuffer = malloc(MAXRTPPAYLOADLEN);
 1573|      1|  if( seiRandomAccess.data->streamBuffer == NULL ) no_mem_exit("InitRandomAccess: seiRandomAccess.data->streamBuffer");
 1574|      1|  ClearRandomAccess();
 1575|       |
 1576|      1|}
 1577|       |
 1578|       |
 1579|       |void ClearRandomAccess()
 1580|      1|{
 1581|      1|  memset( seiRandomAccess.data->streamBuffer, 0, MAXRTPPAYLOADLEN);
 1582|      1|  seiRandomAccess.data->bits_to_go  = 8;
 1583|      1|  seiRandomAccess.data->byte_pos    = 0;
 1584|      1|  seiRandomAccess.data->byte_buf    = 0;
 1585|      1|  seiRandomAccess.payloadSize       = 0;
 1586|       |
 1587|      1|  seiRandomAccess.recovery_point_flag = 0;
 1588|      1|  seiRandomAccess.broken_link_flag = 0;
 1589|      1|  seiRandomAccess.exact_match_flag = 0;
 1590|       |
 1591|      1|  seiHasRandomAccess_info = FALSE;
 1592|      1|}
 1593|       |
 1594|       |void UpdateRandomAccess()
 1595|      0|{
 1596|       |
 1597|      0|  if(img->type == I_SLICE)
 1598|      0|  {
 1599|      0|    seiRandomAccess.recovery_point_flag = 0;
 1600|      0|    seiRandomAccess.exact_match_flag = 1;
 1601|      0|    seiRandomAccess.broken_link_flag = 0;
 1602|      0|    seiHasRandomAccess_info = TRUE;
 1603|      0|  }
 1604|      0|  else
 1605|      0|  {
 1606|      0|    seiHasRandomAccess_info = FALSE;
 1607|      0|  }
 1608|      0|}
 1609|       |
 1610|       |void FinalizeRandomAccess()
 1611|      0|{
 1612|      0|  SyntaxElement sym;
 1613|      0|  Bitstream *dest = seiRandomAccess.data;
 1614|       |
 1615|      0|  sym.type = SE_HEADER;
 1616|      0|  sym.mapping = ue_linfo;
 1617|       |
 1618|      0|  sym.value1 = seiRandomAccess.recovery_point_flag;
 1619|      0|  writeSyntaxElement2Buf_UVLC(&sym, dest);
 1620|       |
 1621|      0|  sym.bitpattern = seiRandomAccess.exact_match_flag;
 1622|      0|  sym.len = 1;
 1623|      0|  writeSyntaxElement2Buf_Fixed(&sym, dest);
 1624|       |
 1625|      0|  sym.bitpattern = seiRandomAccess.broken_link_flag;
 1626|      0|  sym.len = 1;
 1627|      0|  writeSyntaxElement2Buf_Fixed(&sym, dest);
 1628|       |
 1629|       |// #define PRINT_RANDOM_ACCESS
 1630|       |#ifdef PRINT_RANDOM_ACCESS
 1631|       |  printf(" recovery_point_flag %d exact_match_flag %d broken_link_flag %d \n", seiRandomAccess.recovery_point_flag, seiRandomAccess.exact_match_flag, seiRandomAccess.broken_link_flag);
 1632|       |  printf(" %d %d \n", dest->byte_pos, dest->bits_to_go);
 1633|       |#endif
 1634|       |#ifdef PRINT_RANDOM_ACCESS
 1635|       |#undef PRINT_RANDOM_ACCESS
 1636|       |#endif
 1637|       |  // make sure the payload is byte aligned, stuff bits are 10..0
 1638|      0|  if ( dest->bits_to_go != 8 )
 1639|      0|  {
 1640|      0|    (dest->byte_buf) <<= 1;
 1641|      0|    dest->byte_buf |= 1;
 1642|      0|    dest->bits_to_go--;
 1643|      0|    if ( dest->bits_to_go != 0 ) (dest->byte_buf) <<= (dest->bits_to_go);
 1644|      0|    dest->bits_to_go = 8;
 1645|      0|    dest->streamBuffer[dest->byte_pos++]=dest->byte_buf;
 1646|      0|    dest->byte_buf = 0;
 1647|      0|  }
 1648|      0|  seiRandomAccess.payloadSize = dest->byte_pos;
 1649|      0|}
 1650|       |
 1651|       |void CloseRandomAccess()
 1652|      1|{
 1653|      1|  if (seiRandomAccess.data)
 1654|      1|  {
 1655|      1|    free(seiRandomAccess.data->streamBuffer);
 1656|      1|    free(seiRandomAccess.data);
 1657|      1|  }
 1658|      1|  seiRandomAccess.data = NULL;
 1659|      1|}

/home/xzp/speccpu2006-v1.0.1/benchspec/CPU2006/464.h264ref/run/build_base_ql_riscv_llvm17.0000/sei.h:
    1|       |
    2|       |/*!
    3|       | ************************************************************************
    4|       | *  \file
    5|       | *     sei.h
    6|       | *  \brief
    7|       | *     definitions for Supplemental Enhanced Information
    8|       | *  \author(s)
    9|       | *      - Dong Tian                             <tian@cs.tut.fi>
   10|       | *      - TBD
   11|       | *
   12|       | * ************************************************************************
   13|       | */
   14|       |
   15|       |#ifndef SEI_H
   16|       |#define SEI_H
   17|       |
   18|      3|#define MAX_LAYER_NUMBER 2
   19|       |#define MAX_DEPENDENT_SUBSEQ 5
   20|       |
   21|       |
   22|       |//! definition of SEI payload type
   23|       |typedef enum {
   24|       |  SEI_ZERO,        //!< 0 is undefined, useless
   25|       |  SEI_TEMPORAL_REF,
   26|       |  SEI_CLOCK_TIMESTAMP,
   27|       |  SEI_PANSCAN_RECT,
   28|       |  SEI_BUFFERING_PERIOD,
   29|       |  SEI_HRD_PICTURE,
   30|       |  SEI_FILLER_PAYLOAD,
   31|       |  SEI_USER_DATA_REGISTERED_ITU_T_T35,
   32|       |  SEI_USER_DATA_UNREGISTERED,
   33|       |  SEI_RANDOM_ACCESS_POINT,
   34|       |  SEI_REF_PIC_BUFFER_MANAGEMENT_REPETITION,
   35|       |  SEI_SPARE_PICTURE,
   36|       |  SEI_SCENE_INFORMATION,
   37|       |  SEI_SUBSEQ_INFORMATION,
   38|       |  SEI_SUBSEQ_LAYER_CHARACTERISTICS,
   39|       |  SEI_SUBSEQ_CHARACTERISTICS,
   40|       |  SEI_MAX_ELEMENTS  //!< number of maximum syntax elements
   41|       |} SEI_type;
   42|       |
   43|     86|#define MAX_FN 256
   44|       |
   45|       |#define AGGREGATION_PACKET_TYPE 4
   46|      2|#define SEI_PACKET_TYPE 5  // Tian Dong: See VCEG-N72, it need updates
   47|       |
   48|       |#define NORMAL_SEI 0
   49|      0|#define AGGREGATION_SEI 1
   50|       |
   51|       |//! SEI structure
   52|       |typedef struct
   53|       |{
   54|       |  Boolean available;
   55|       |  int payloadSize;
   56|       |  unsigned char subPacketType;
   57|       |  byte* data;
   58|       |} sei_struct;
   59|       |
   60|       |//!< sei_message[0]: this struct is to store the sei message packtized independently 
   61|       |//!< sei_message[1]: this struct is to store the sei message packtized together with slice data
   62|       |extern sei_struct sei_message[2];
   63|       |
   64|       |void InitSEIMessages();
   65|       |void CloseSEIMessages();
   66|       |Boolean HaveAggregationSEI();
   67|       |void write_sei_message(int id, byte* payload, int payload_size, int payload_type);
   68|       |void finalize_sei_message(int id);
   69|       |void clear_sei_message(int id);
   70|       |void AppendTmpbits2Buf( Bitstream* dest, Bitstream* source );
   71|       |
   72|       |void PrepareAggregationSEIMessage();
   73|       |
   74|       |
   75|       |//! Spare Picture
   76|       |typedef struct
   77|       |{
   78|       |  int target_frame_num;
   79|       |  int num_spare_pics;
   80|       |  int payloadSize;
   81|       |  Bitstream* data;
   82|       |} spare_picture_struct;
   83|       |
   84|       |extern Boolean seiHasSparePicture;
   85|       |//extern Boolean sei_has_sp;
   86|       |extern spare_picture_struct seiSparePicturePayload;
   87|       |
   88|       |void InitSparePicture();
   89|       |void CloseSparePicture();
   90|       |void CalculateSparePicture();
   91|       |void ComposeSparePictureMessage(int delta_spare_frame_num, int ref_area_indicator, Bitstream *tmpBitstream);
   92|       |Boolean CompressSpareMBMap(unsigned char **map_sp, Bitstream *bitstream);
   93|       |void FinalizeSpareMBMap();
   94|       |
   95|       |//! Subseq Information
   96|       |typedef struct
   97|       |{
   98|       |  int subseq_layer_num;
   99|       |  int subseq_id;
  100|       |  unsigned int last_picture_flag;
  101|       |  unsigned int stored_frame_cnt;
  102|       |
  103|       |  int payloadSize;
  104|       |  Bitstream* data;
  105|       |} subseq_information_struct;
  106|       |
  107|       |extern Boolean seiHasSubseqInfo;
  108|       |extern subseq_information_struct seiSubseqInfo[MAX_LAYER_NUMBER];
  109|       |
  110|       |void InitSubseqInfo(int currLayer);
  111|       |void UpdateSubseqInfo(int currLayer);
  112|       |void FinalizeSubseqInfo(int currLayer);
  113|       |void ClearSubseqInfoPayload(int currLayer);
  114|       |void CloseSubseqInfo(int currLayer);
  115|       |
  116|       |//! Subseq Layer Information
  117|       |typedef struct
  118|       |{
  119|       |  unsigned short bit_rate[MAX_LAYER_NUMBER];
  120|       |  unsigned short frame_rate[MAX_LAYER_NUMBER];
  121|       |  byte data[4*MAX_LAYER_NUMBER];
  122|       |  int layer_number;
  123|       |  int payloadSize;
  124|       |} subseq_layer_information_struct;
  125|       |
  126|       |extern Boolean seiHasSubseqLayerInfo;
  127|       |extern subseq_layer_information_struct seiSubseqLayerInfo;
  128|       |
  129|       |void InitSubseqLayerInfo();
  130|       |void CloseSubseqLayerInfo();
  131|       |void FinalizeSubseqLayerInfo();
  132|       |
  133|       |//! Subseq Characteristics
  134|       |typedef struct
  135|       |{
  136|       |  int subseq_layer_num;
  137|       |  int subseq_id;
  138|       |  int duration_flag;
  139|       |  unsigned int subseq_duration;
  140|       |  unsigned int average_rate_flag;
  141|       |  unsigned int average_bit_rate;
  142|       |  unsigned int average_frame_rate;
  143|       |  int num_referenced_subseqs;
  144|       |  int ref_subseq_layer_num[MAX_DEPENDENT_SUBSEQ];
  145|       |  int ref_subseq_id[MAX_DEPENDENT_SUBSEQ];
  146|       |
  147|       |  Bitstream* data;
  148|       |  int payloadSize;
  149|       |} subseq_char_information_struct;
  150|       |
  151|       |extern Boolean seiHasSubseqChar;
  152|       |extern subseq_char_information_struct seiSubseqChar;
  153|       |
  154|       |void InitSubseqChar();
  155|       |void ClearSubseqCharPayload();
  156|       |void UpdateSubseqChar();
  157|       |void FinalizeSubseqChar();
  158|       |void CloseSubseqChar();
  159|       |
  160|       |
  161|       |//! JVT-D099 Scene information SEI message
  162|       |typedef struct
  163|       |{
  164|       |  int scene_id;
  165|       |  int scene_transition_type;
  166|       |  int second_scene_id;
  167|       |
  168|       |  Bitstream* data;
  169|       |  int payloadSize;
  170|       |} scene_information_struct;
  171|       |
  172|       |extern Boolean seiHasSceneInformation;
  173|       |extern scene_information_struct seiSceneInformation;
  174|       |
  175|       |void InitSceneInformation();
  176|       |void CloseSceneInformation();
  177|       |void UpdateSceneInformation(Boolean HasSceneInformation, int sceneID, int sceneTransType, int secondSceneID);
  178|       |void FinalizeSceneInformation();
  179|       |//! End JVT-D099 Scene information SEI message
  180|       |
  181|       |//! Shankar Regunathan Oct 2002
  182|       |//! PanScanRect Information
  183|       |typedef struct
  184|       |{
  185|       |  int pan_scan_rect_id; 
  186|       |  int pan_scan_rect_left_offset;
  187|       |  int pan_scan_rect_right_offset;
  188|       |  int pan_scan_rect_top_offset;
  189|       |  int pan_scan_rect_bottom_offset;
  190|       |
  191|       |  Bitstream *data;
  192|       |  int payloadSize;
  193|       |} panscanrect_information_struct;
  194|       |
  195|       |extern Boolean seiHasPanScanRectInfo;
  196|       |extern panscanrect_information_struct seiPanScanRectInfo;
  197|       |
  198|       |void InitPanScanRectInfo();
  199|       |void ClearPanScanRectInfoPayload();
  200|       |void UpdatePanScanRectInfo();
  201|       |void FinalizePanScanRectInfo();
  202|       |void ClosePanScanRectInfo();
  203|       |
  204|       |//! User_data_unregistered Information
  205|       |typedef struct
  206|       |{
  207|       |  char *byte;
  208|       |  int total_byte;
  209|       |  Bitstream *data;
  210|       |  int payloadSize;
  211|       |} user_data_unregistered_information_struct;
  212|       |#if defined(SPEC_CPU)
  213|       |extern Boolean seiHasUser_data_unregistered_info;
  214|       |extern user_data_unregistered_information_struct seiUser_data_unregistered;
  215|       |#else
  216|       |Boolean seiHasUser_data_unregistered_info;
  217|       |user_data_unregistered_information_struct seiUser_data_unregistered;
  218|       |#endif /* SPEC_CPU */
  219|       |
  220|       |void InitUser_data_unregistered();
  221|       |void ClearUser_data_unregistered();
  222|       |void UpdateUser_data_unregistered();
  223|       |void FinalizeUser_data_unregistered();
  224|       |void CloseUser_data_unregistered();
  225|       |
  226|       |//! User_data_registered_itu_t_t35 Information
  227|       |typedef struct
  228|       |{
  229|       |  char *byte;
  230|       |  int total_byte;
  231|       |  int itu_t_t35_country_code;
  232|       |  int itu_t_t35_country_code_extension_byte;
  233|       |  Bitstream *data;
  234|       |  int payloadSize;
  235|       |} user_data_registered_itu_t_t35_information_struct;
  236|       |#if defined(SPEC_CPU)
  237|       |extern Boolean seiHasUser_data_registered_itu_t_t35_info;
  238|       |extern user_data_registered_itu_t_t35_information_struct seiUser_data_registered_itu_t_t35;
  239|       |#else
  240|       |Boolean seiHasUser_data_registered_itu_t_t35_info;
  241|       |user_data_registered_itu_t_t35_information_struct seiUser_data_registered_itu_t_t35;
  242|       |#endif /* !SPEC_CPU */
  243|       |
  244|       |void InitUser_data_registered_itu_t_t35();
  245|       |void ClearUser_data_registered_itu_t_t35();
  246|       |void UpdateUser_data_registered_itu_t_t35();
  247|       |void FinalizeUser_data_registered_itu_t_t35();
  248|       |void CloseUser_data_registered_itu_t_t35();
  249|       |
  250|       |//! RandomAccess Information
  251|       |typedef struct
  252|       |{
  253|       |  unsigned char recovery_point_flag;
  254|       |  unsigned char exact_match_flag;
  255|       |  unsigned char broken_link_flag;
  256|       |
  257|       |  Bitstream *data;
  258|       |  int payloadSize;
  259|       |} randomaccess_information_struct;
  260|       |#if defined(SPEC_CPU)
  261|       |extern Boolean seiHasRandomAccess_info;
  262|       |extern randomaccess_information_struct seiRandomAccess;
  263|       |#else
  264|       |Boolean seiHasRandomAccess_info;
  265|       |randomaccess_information_struct seiRandomAccess;
  266|       |#endif /* SPEC_CPU */
  267|       |
  268|       |void InitRandomAccess();
  269|       |void ClearRandomAccess();
  270|       |void UpdateRandomAccess();
  271|       |void FinalizeRandomAccess();
  272|       |void CloseRandomAccess();
  273|       |
  274|       |#endif

/home/xzp/speccpu2006-v1.0.1/benchspec/CPU2006/464.h264ref/run/build_base_ql_riscv_llvm17.0000/slice.c:
    1|       |
    2|       |/*!
    3|       | **************************************************************************************
    4|       | * \file
    5|       | *    slice.c
    6|       | * \brief
    7|       | *    generate the slice header, setup the bit buffer for slices,
    8|       | *    and generates the slice NALU(s)
    9|       |
   10|       | * \author
   11|       | *    Main contributors (see contributors.h for copyright, address and affiliation details)
   12|       | *      - Thomas Stockhammer            <stockhammer@ei.tum.de>
   13|       | *      - Detlev Marpe                  <marpe@hhi.de>
   14|       | *      - Stephan Wenger                <stewe@cs.tu-berlin.de>
   15|       | *      - Alexis Michael Tourapis       <alexismt@ieee.org>
   16|       | ***************************************************************************************
   17|       | */
   18|       |
   19|       |#include "contributors.h"
   20|       |
   21|       |#include <stdlib.h>
   22|       |#include <assert.h>
   23|       |
   24|       |#include "global.h"
   25|       |
   26|       |#include "header.h"
   27|       |#include "rtp.h"
   28|       |#include "fmo.h"
   29|       |#include "vlc.h"
   30|       |#include "image.h"
   31|       |#include "cabac.h"
   32|       |#include "elements.h"
   33|       |
   34|       |// Local declarations
   35|       |
   36|       |static Slice *malloc_slice();
   37|       |static void  free_slice(Slice *slice);
   38|       |static void  init_slice(int start_mb_addr);
   39|       |static void set_ref_pic_num();
   40|       |extern ColocatedParams *Co_located;
   41|       |extern StorablePicture **listX[6];
   42|       |void poc_ref_pic_reorder(StorablePicture **list, unsigned num_ref_idx_lX_active, int *remapping_of_pic_nums_idc, int *abs_diff_pic_num_minus1, int *long_term_pic_idx, int weighted_prediction, int list_no);
   43|       |
   44|       |/*!
   45|       | ************************************************************************
   46|       | * \brief
   47|       | *    init_ref_pic_list_reordering initializations should go here
   48|       | ************************************************************************
   49|       | */
   50|       |void init_ref_pic_list_reordering()
   51|    171|{
   52|    171|  Slice* currSlice = img->currentSlice;
   53|       |
   54|    171|  currSlice->ref_pic_list_reordering_flag_l0 = 0;
   55|    171|  currSlice->ref_pic_list_reordering_flag_l1 = 0;
   56|    171|}
   57|       |
   58|       |
   59|       |/*!
   60|       | ************************************************************************
   61|       | *  \brief
   62|       | *     This function generates the slice (and partition) header(s) 
   63|       | *
   64|       | *  \return number of bits used for the slice (and partition) header(s)
   65|       | *
   66|       | *  \par Side effects:
   67|       | *      Adds slice/partition header symbols to the symbol buffer
   68|       | *      increments Picture->no_slices, allocates memory for the
   69|       | *      slice, sets img->currSlice
   70|       | ************************************************************************
   71|       |*/
   72|       |int start_slice()
   73|    171|{
   74|    171|  EncodingEnvironmentPtr eep;
   75|    171|  Slice *currSlice = img->currentSlice;
   76|    171|  Bitstream *currStream;
   77|    171|  int header_len = 0;
   78|    171|  int i;
   79|    171|  int NumberOfPartitions = (input->partition_mode == PAR_DP_1?1:3);
   80|       |
   81|       |  //one  partition for IDR img
   82|    171|  if(img->currentPicture->idr_flag)
   83|      1|  {
   84|      1|     NumberOfPartitions = 1;
   85|      1|  }
   86|       |
   87|    171|  RTPUpdateTimestamp (img->tr);   // this has no side effects, just leave it for all NALs
   88|       |
   89|    342|  for (i=0; i<NumberOfPartitions; i++)
   90|    171|  {
   91|    171|    currStream = (currSlice->partArr[i]).bitstream;
   92|       |
   93|    171|    currStream->write_flag = 0;
   94|    171|    if (i==0)     // First partition
   95|    171|      header_len += SliceHeader (0);
   96|      0|    else          // Second/Third partition
   97|      0|      header_len += Partition_BC_Header(i);
   98|       |     
   99|       |    //! Initialize CABAC
  100|    171|    if (input->symbol_mode == CABAC)
  101|    171|    {
  102|    171|      eep = &((currSlice->partArr[i]).ee_cabac);
  103|    171|      if (currStream->bits_to_go != 8)
  104|    170|        header_len+=currStream->bits_to_go;
  105|    171|      writeVlcByteAlign(currStream);
  106|    171|      arienco_start_encoding(eep, currStream->streamBuffer, &(currStream->byte_pos)/*, &(currStream->last_startcode)*/,img->type);
  107|    171|      cabac_new_slice();
  108|    171|    } else 
  109|      0|    {
  110|       |      // Initialize CA-VLC
  111|      0|      CAVLC_init();
  112|      0|    }
  113|    171|  }
  114|    171|  if(input->symbol_mode == CABAC)
  115|    171|  {
  116|    171|    init_contexts();
  117|    171|  }
  118|    171|  return header_len;
  119|    171|}
  120|       |
  121|       |
  122|       |
  123|       |/*!
  124|       | ************************************************************************
  125|       | * \brief
  126|       | *    This function terminates a slice (but doesn't write it out), 
  127|       | *    the old terminate_slice (0)
  128|       | * \return
  129|       | *    0 if OK,                                                         \n
  130|       | *    1 in case of error
  131|       | *
  132|       | ************************************************************************
  133|       | */
  134|       |int terminate_slice()
  135|    171|{
  136|    171|  int bytes_written;
  137|    171|  Bitstream *currStream;
  138|    171|  Slice *currSlice = img->currentSlice;
  139|    171|  EncodingEnvironmentPtr eep;
  140|    171|  int i;
  141|    171|  int byte_pos_before_startcode_emu_prevention;
  142|       |
  143|    171|  if (input->symbol_mode == CABAC)
  144|    171|    write_terminating_bit (1);      // only once, not for all partitions
  145|       |  
  146|    342|  for (i=0; i<currSlice->max_part_nr; i++)
  147|    171|  {
  148|    171|    currStream = (currSlice->partArr[i]).bitstream;
  149|    171|    if (input->symbol_mode == UVLC)
  150|      0|    {
  151|      0|      SODBtoRBSP(currStream);
  152|      0|      byte_pos_before_startcode_emu_prevention = currStream->byte_pos;
  153|      0|      currStream->byte_pos = RBSPtoEBSP(currStream->streamBuffer, 0 , currStream->byte_pos, 0);
  154|      0|      *(stats->em_prev_bits) += (currStream->byte_pos - byte_pos_before_startcode_emu_prevention) * 8;
  155|      0|    }
  156|    171|    else     // CABAC
  157|    171|    {
  158|    171|      eep = &((currSlice->partArr[i]).ee_cabac);
  159|       |      // terminate the arithmetic code
  160|    171|      arienco_done_encoding(eep);
  161|    171|      currStream->bits_to_go = eep->Ebits_to_go;
  162|    171|      currStream->byte_buf = 0;
  163|    171|      bytes_written = currStream->byte_pos;
  164|    171|      byte_pos_before_startcode_emu_prevention= currStream->byte_pos;
  165|    171|      currStream->byte_pos = RBSPtoEBSP(currStream->streamBuffer, 0, currStream->byte_pos, eep->E);
  166|    171|      *(stats->em_prev_bits) += (currStream->byte_pos - byte_pos_before_startcode_emu_prevention) * 8;
  167|    171|    }           // CABAC
  168|    171|  }           // partition loop
  169|    171|  if( input->symbol_mode == CABAC )
  170|    171|  {
  171|    171|    store_contexts();
  172|    171|  }
  173|       |
  174|    171|  return 0;   
  175|    171|}
  176|       |
  177|       |/*!
  178|       |************************************************************************
  179|       |* \brief
  180|       |*    Encodes one slice
  181|       |* \par
  182|       |*   returns the number of coded MBs in the SLice 
  183|       |************************************************************************
  184|       |*/
  185|       |int encode_one_slice (int SliceGroupId, Picture *pic)
  186|    171|{
  187|    171|  Boolean end_of_slice = FALSE;
  188|    171|  Boolean recode_macroblock;
  189|    171|  int len;
  190|    171|  int NumberOfCodedMBs = 0;
  191|    171|  int CurrentMbAddr;
  192|    171|  double FrameRDCost, FieldRDCost;
  193|       |  
  194|    171|  img->cod_counter = 0;
  195|       |
  196|    171|  CurrentMbAddr = FmoGetFirstMacroblockInSlice (SliceGroupId);
  197|       |// printf ("\n\nEncode_one_slice: PictureID %d SliceGroupId %d  SliceID %d  FirstMB %d \n", img->tr, SliceGroupId, img->current_slice_nr, CurrentMbInScanOrder);
  198|       |
  199|    171|  init_slice (CurrentMbAddr);
  200|    171|  Bytes_After_Header = img->currentSlice->partArr[0].bitstream->byte_pos;
  201|       |
  202|    171|  if (input->symbol_mode==CABAC)
  203|    171|  {
  204|    171|    SetCtxModelNumber ();
  205|    171|  }
  206|       |
  207|       |/*
  208|       |  // Tian Dong: June 7, 2002 JVT-B042
  209|       |  // When the pictures are put into different layers and subseq, not all the reference frames
  210|       |  // in multi-frame buffer are valid for prediction. The acutual number of the valid reference
  211|       |  // frames, fb->num_short_used, will be given by start_slice(sym).
  212|       |  // Save the fb->short_used.
  213|       |  if (input->NumFramesInELSubSeq)
  214|       |    {
  215|       |      short_used = fb->short_used;
  216|       |      img_ref = img->nb_references;
  217|       |    }
  218|       |*/
  219|       |
  220|    171|  len = start_slice ();
  221|       |
  222|       |  // Rate control
  223|    171|  img->NumberofHeaderBits +=len;
  224|       |
  225|       |  // basic unit layer rate control
  226|    171|  if(img->BasicUnit<img->Frame_Total_Number_MB)
  227|      0|    img->NumberofBasicUnitHeaderBits +=len;
  228|       |
  229|       |//  printf("short size, used, num-used: (%d,%d,%d)\n", fb->short_size, fb->short_used, fb->num_short_used);
  230|       |
  231|       |/*
  232|       |  // Tian Dong: June 7, 2002 JVT-B042
  233|       |  if (input->NumFramesInELSubSeq)
  234|       |    {
  235|       |      fb->short_used = fb->num_short_used;
  236|       |      img->nb_references = fb->short_used + fb->long_used;
  237|       |    }
  238|       |*/
  239|       |  // Update statistics
  240|    171|  stats->bit_slice += len;
  241|    171|  stats->bit_use_header[img->type] += len;
  242|       |// printf ("\n\n");
  243|       |
  244|   109k|  while (end_of_slice == FALSE) // loop over macroblocks
  245|   109k|  {
  246|       |    //sw paff
  247|   109k|    if (!img->MbaffFrameFlag)
  248|   109k|    {
  249|   109k|      recode_macroblock = FALSE;
  250|   109k|      rdopt = &rddata_top_frame_mb;   // store data in top frame MB 
  251|       |      
  252|   109k|      start_macroblock (CurrentMbAddr, FALSE);
  253|   109k|      encode_one_macroblock ();
  254|   109k|      write_one_macroblock (1);
  255|       |
  256|   109k|      terminate_macroblock (&end_of_slice, &recode_macroblock);
  257|       |
  258|       |// printf ("encode_one_slice: mb %d,  slice %d,   bitbuf bytepos %d EOS %d\n", 
  259|       |//       img->current_mb_nr, img->current_slice_nr, 
  260|       |//       img->currentSlice->partArr[0].bitstream->byte_pos, end_of_slice);
  261|       |
  262|   109k|      if (recode_macroblock == FALSE)       // The final processing of the macroblock has been done
  263|   109k|      {
  264|   109k|        CurrentMbAddr = FmoGetNextMBNr (CurrentMbAddr);
  265|   109k|        if (CurrentMbAddr == -1)   // end of slice
  266|    171|        {
  267|       |// printf ("FMO End of Slice Group detected, current MBs %d, force end of slice\n", NumberOfCodedMBs+1);
  268|    171|          end_of_slice = TRUE;
  269|    171|        }
  270|   109k|        NumberOfCodedMBs++;       // only here we are sure that the coded MB is actually included in the slice
  271|   109k|        proceed2nextMacroblock (CurrentMbAddr);
  272|   109k|      }
  273|      0|      else
  274|      0|      {
  275|       |        //!Go back to the previous MB to recode it
  276|      0|        img->current_mb_nr = FmoGetPreviousMBNr(img->current_mb_nr);
  277|      0|        if(img->current_mb_nr == -1 )   // The first MB of the slice group  is too big,
  278|       |                                        // which means it's impossible to encode picture using current slice bits restriction
  279|      0|        {
  280|      0|          snprintf (errortext, ET_SIZE, "Error encoding first MB with spcified parameter, bits of current MB may be too big");
  281|      0|          error (errortext, 300);
  282|      0|        }
  283|      0|      }
  284|   109k|    }
  285|      0|    else                      // TBD -- Addition of FMO
  286|      0|    {
  287|       |
  288|       |//! This following ugly code breaks slices, at least for a slice mode that accumulates a certain
  289|       |//! number of bits into one slice.  
  290|       |//! The suggested algorithm is as follows:
  291|       |//!
  292|       |//! SaveState (Bitstream, stats,  etc. etc.);
  293|       |//! BitsForThisMBPairInFrameMode = CodeMB (Upper, FRAME_MODE) + CodeMB (Lower, FRAME_MODE);
  294|       |//! DistortionForThisMBPairInFrameMode = CalculateDistortion(Upper) + CalculateDistortion (Lower);
  295|       |//! RestoreState();
  296|       |//! BitsForThisMBPairInFieldMode = CodeMB (Upper, FIELD_MODE) + CodeMB (Lower, FIELD_MODE);
  297|       |//! DistortionForThisMBPairInFrameMode = CalculateDistortion(Upper) + CalculateDistortion (Lower);
  298|       |//! FrameFieldMode = Decision (...)
  299|       |//! RestoreState()
  300|       |//! if (FrameFieldMode == FRAME) {
  301|       |//!   CodeMB (Upper, FRAME); CodeMB (Lower, FRAME);
  302|       |//! } else {
  303|       |//!   CodeMB (Upper FIELD); CodeMB (Lower, FIELD);
  304|       |//! }
  305|       |//!
  306|       |//! Open questions/issues:
  307|       |//!   1. CABAC/CA-VLC state:  It seems that the CABAC/CA_VLC states are changed during the
  308|       |//!      dummy encoding processes (for the R-D based selection), but that they are never
  309|       |//!      reset, once the selection is made.  I believe that this breaks the MB-adaptive
  310|       |//!      frame/field coding.  The necessary code for the state saves is readily available
  311|       |//!      in macroblock.c, start_macroblock() and terminate_macroblock() (this code needs
  312|       |//!      to be double checked that it works with CA-VLC as well
  313|       |//!   2. would it be an option to allocate Bitstreams with zero data in them (or copy the
  314|       |//!      already generated bitstream) for the "test coding"?  
  315|       |
  316|      0|      if (input->MbInterlace == ADAPTIVE_CODING)
  317|      0|      {
  318|       |        //================ code MB pair as frame MB ================
  319|       |        //----------------------------------------------------------
  320|      0|        recode_macroblock = FALSE;
  321|       |        
  322|       |        
  323|      0|        img->field_mode = 0;  // MB coded as frame
  324|      0|        img->top_field = 0;   // Set top field to 0
  325|       |        
  326|       |        //Rate control
  327|      0|        img->write_macroblock = 0;
  328|      0|        img->bot_MB = 0;   
  329|       |        
  330|      0|        start_macroblock (CurrentMbAddr, FALSE);
  331|       |        
  332|      0|        rdopt = &rddata_top_frame_mb; // store data in top frame MB 
  333|      0|        encode_one_macroblock ();     // code the MB as frame
  334|      0|        FrameRDCost = rdopt->min_rdcost;
  335|       |        //***   Top MB coded as frame MB ***//
  336|       |
  337|       |        //Rate control
  338|      0|        img->bot_MB = 1; //for Rate control
  339|       |        
  340|       |        // go to the bottom MB in the MB pair
  341|      0|        img->field_mode = 0;  // MB coded as frame  //GB
  342|       |        
  343|      0|        start_macroblock (CurrentMbAddr+1, FALSE);
  344|      0|        rdopt = &rddata_bot_frame_mb; // store data in top frame MB
  345|      0|        encode_one_macroblock ();     // code the MB as frame
  346|      0|        FrameRDCost += rdopt->min_rdcost;
  347|       |
  348|       |        //***   Bottom MB coded as frame MB ***//
  349|      0|      }
  350|       |
  351|      0|      if ((input->MbInterlace == ADAPTIVE_CODING) || (input->MbInterlace == FIELD_CODING))
  352|      0|      {
  353|       |        //Rate control
  354|      0|        img->bot_MB = 0; 
  355|       |        
  356|       |        //=========== start coding the MB pair as a field MB pair =============
  357|       |        //---------------------------------------------------------------------
  358|      0|        img->field_mode = 1;  // MB coded as frame
  359|      0|        img->top_field = 1;   // Set top field to 1
  360|      0|        img->buf_cycle <<= 1;
  361|      0|        input->num_ref_frames <<= 1;
  362|      0|        img->num_ref_idx_l0_active <<= 1;
  363|      0|        img->num_ref_idx_l0_active += 1;
  364|      0|        start_macroblock (CurrentMbAddr, TRUE);
  365|       |        
  366|       |
  367|      0|        rdopt = &rddata_top_field_mb; // store data in top frame MB 
  368|       |//        TopFieldIsSkipped = 0;        // set the top field MB skipped flag to 0
  369|      0|        encode_one_macroblock ();     // code the MB as frame
  370|      0|        FieldRDCost = rdopt->min_rdcost;
  371|       |        //***   Top MB coded as field MB ***//
  372|       |        //Rate control
  373|      0|        img->bot_MB = 1;//for Rate control
  374|       |
  375|      0|        img->top_field = 0;   // Set top field to 0
  376|      0|        start_macroblock (CurrentMbAddr+1, TRUE);
  377|      0|        rdopt = &rddata_bot_field_mb; // store data in top frame MB 
  378|      0|        encode_one_macroblock ();     // code the MB as frame
  379|      0|        FieldRDCost += rdopt->min_rdcost;
  380|       |        //***   Bottom MB coded as field MB ***//
  381|      0|      }
  382|       |
  383|       |      //Rate control
  384|      0|      img->write_macroblock_frame = 0;  //Rate control
  385|       |
  386|       |      //=========== decide between frame/field MB pair ============
  387|       |      //-----------------------------------------------------------
  388|      0|      if ((input->MbInterlace == ADAPTIVE_CODING) && (FrameRDCost < FieldRDCost))
  389|      0|      {
  390|      0|        img->field_mode = 0;
  391|      0|        img->buf_cycle >>= 1;
  392|      0|        input->num_ref_frames >>= 1;
  393|      0|        MBPairIsField = 0;
  394|      0|        img->num_ref_idx_l0_active -= 1;
  395|      0|        img->num_ref_idx_l0_active >>= 1;
  396|       |        
  397|       |        //Rate control
  398|      0|        img->write_macroblock_frame = 1;  //for Rate control
  399|      0|      }
  400|      0|      else
  401|      0|      {
  402|      0|        img->field_mode = 1;
  403|      0|        MBPairIsField = 1;
  404|      0|      }
  405|       |      
  406|       |      //Rate control
  407|      0|      img->write_macroblock = 1;//Rate control 
  408|       |      
  409|      0|      if (MBPairIsField)
  410|      0|        img->top_field = 1;
  411|      0|      else
  412|      0|        img->top_field = 0;
  413|       |      
  414|       |      //Rate control
  415|      0|      img->bot_MB = 0;// for Rate control
  416|       |
  417|       |      // go back to the Top MB in the MB pair
  418|      0|      start_macroblock (CurrentMbAddr, img->field_mode);
  419|       |      
  420|      0|      rdopt =  img->field_mode ? &rddata_top_field_mb : &rddata_top_frame_mb;
  421|      0|      copy_rdopt_data (0);  // copy the MB data for Top MB from the temp buffers
  422|      0|      write_one_macroblock (1);     // write the Top MB data to the bitstream
  423|      0|      NumberOfCodedMBs++;   // only here we are sure that the coded MB is actually included in the slice
  424|      0|      terminate_macroblock (&end_of_slice, &recode_macroblock);     // done coding the Top MB 
  425|      0|      proceed2nextMacroblock (CurrentMbAddr);        // Go to next macroblock
  426|       |      
  427|       |      //Rate control
  428|      0|      img->bot_MB = 1;//for Rate control
  429|       |      // go to the Bottom MB in the MB pair
  430|      0|      img->top_field = 0;
  431|      0|      start_macroblock (CurrentMbAddr+1, img->field_mode);
  432|       |
  433|      0|      rdopt = img->field_mode ? &rddata_bot_field_mb : &rddata_bot_frame_mb;
  434|      0|      copy_rdopt_data (1);  // copy the MB data for Bottom MB from the temp buffers
  435|       |      
  436|      0|      write_one_macroblock (0);     // write the Bottom MB data to the bitstream
  437|      0|      NumberOfCodedMBs++;   // only here we are sure that the coded MB is actually included in the slice
  438|      0|      terminate_macroblock (&end_of_slice, &recode_macroblock);     // done coding the Top MB 
  439|      0|      proceed2nextMacroblock (CurrentMbAddr);        // Go to next macroblock
  440|       |      
  441|      0|      if (MBPairIsField)    // if MB Pair was coded as field the buffer size variables back to frame mode
  442|      0|      {
  443|      0|        img->buf_cycle >>= 1;
  444|      0|        input->num_ref_frames >>= 1;
  445|      0|        img->num_ref_idx_l0_active -= 1;
  446|      0|        img->num_ref_idx_l0_active >>= 1;
  447|      0|      }
  448|      0|      img->field_mode = img->top_field = 0; // reset to frame mode
  449|       |      
  450|       |      
  451|       |      // go to next MB pair, not next MB
  452|      0|      CurrentMbAddr = FmoGetNextMBNr (CurrentMbAddr);
  453|      0|      CurrentMbAddr = FmoGetNextMBNr (CurrentMbAddr);
  454|       |      
  455|      0|      if (CurrentMbAddr == FmoGetLastCodedMBOfSliceGroup (FmoMB2SliceGroup (CurrentMbAddr)))
  456|      0|        end_of_slice = TRUE;        // just in case it does n't get set in terminate_macroblock
  457|      0|    }
  458|   109k|  }  
  459|       |/*
  460|       |  // Tian Dong: June 7, 2002 JVT-B042
  461|       |  // Restore the short_used
  462|       |  if (input->NumFramesInELSubSeq)
  463|       |    {
  464|       |      fb->short_used = short_used;
  465|       |      img->nb_references = img_ref;
  466|       |    }
  467|       |*/
  468|    171|  terminate_slice ();
  469|    171|  return NumberOfCodedMBs;
  470|    171|}
  471|       |
  472|       |
  473|       |
  474|       |/*!
  475|       | ************************************************************************
  476|       | * \brief
  477|       | *    Initializes the parameters for a new slice and
  478|       | *     allocates the memory for the coded slice in the Picture structure
  479|       | *  \par Side effects:
  480|       | *      Adds slice/partition header symbols to the symbol buffer
  481|       | *      increments Picture->no_slices, allocates memory for the
  482|       | *      slice, sets img->currSlice
  483|       | ************************************************************************
  484|       | */
  485|       |static void init_slice (int start_mb_addr)
  486|    171|{
  487|    171|  int i;
  488|    171|  Picture *currPic = img->currentPicture;
  489|    171|  DataPartition *dataPart;
  490|    171|  Bitstream *currStream;
  491|    171|  Slice *currSlice;
  492|       |
  493|    171|  img->current_mb_nr = start_mb_addr;
  494|       |
  495|       |  // Allocate new Slice in the current Picture, and set img->currentSlice
  496|    171|  assert (currPic != NULL);
  497|    171|  currPic->no_slices++;
  498|    171|  if (currPic->no_slices >= MAXSLICEPERPICTURE)
  499|      0|    error ("Too many slices per picture, increase MAXLSICESPERPICTURE in global.h.", -1);
  500|       |
  501|    171|  currPic->slices[currPic->no_slices-1] = malloc_slice();
  502|    171|  currSlice = currPic->slices[currPic->no_slices-1];
  503|       |
  504|    171|  img->currentSlice = currSlice;
  505|       |
  506|    171|  currSlice->picture_id = img->tr % 256;
  507|    171|  currSlice->qp = img->qp;
  508|    171|  currSlice->start_mb_nr = start_mb_addr;
  509|    171|  currSlice->slice_too_big = dummy_slice_too_big;
  510|       |
  511|    342|  for (i = 0; i < currSlice->max_part_nr; i++)
  512|    171|  {
  513|    171|    dataPart = &(currSlice->partArr[i]);
  514|    171|    if (input->symbol_mode == UVLC)
  515|      0|      dataPart->writeSyntaxElement = writeSyntaxElement_UVLC;
  516|    171|    else
  517|    171|      dataPart->writeSyntaxElement = writeSyntaxElement_CABAC;
  518|       |    
  519|    171|    currStream = dataPart->bitstream;
  520|    171|    currStream->bits_to_go = 8;
  521|    171|    currStream->byte_pos = 0;
  522|    171|    currStream->byte_buf = 0;
  523|    171|  }
  524|       |
  525|       |    // restrict list 1 size
  526|       |//  img->num_ref_idx_l0_active = max(1, (img->type==B_SLICE ? active_pps->num_ref_idx_l0_active_minus1 + 1: active_pps->num_ref_idx_l0_active_minus1 +1 )); 
  527|       |//  img->num_ref_idx_l1_active = (img->type==B_SLICE ? active_pps->num_ref_idx_l1_active_minus1 + 1 : 0);
  528|    171|  img->num_ref_idx_l0_active = active_pps->num_ref_idx_l0_active_minus1 + 1; 
  529|    171|  img->num_ref_idx_l1_active = active_pps->num_ref_idx_l1_active_minus1 + 1;
  530|       |
  531|       |  // generate reference picture lists
  532|    171|  init_lists(img->type, img->structure);
  533|       |
  534|       |  // assign list 0 size from list size
  535|    171|  img->num_ref_idx_l0_active = listXsize[0];
  536|    171|  img->num_ref_idx_l1_active = listXsize[1];
  537|       |
  538|       |  //if (!img->MbaffFrameFlag)
  539|    171|  {
  540|    171|    if ((img->type == P_SLICE || img->type == SP_SLICE) && input->P_List0_refs)
  541|      0|    {
  542|      0|      img->num_ref_idx_l0_active = min(img->num_ref_idx_l0_active, input->P_List0_refs);
  543|      0|      listXsize[0] = min(listXsize[0], input->P_List0_refs);  
  544|      0|    }
  545|    171|    if (img->type == B_SLICE )
  546|     85|    {
  547|       |      
  548|     85|      if (input->B_List0_refs)
  549|      0|      {
  550|      0|        img->num_ref_idx_l0_active = min(img->num_ref_idx_l0_active, input->B_List0_refs);
  551|      0|        listXsize[0] = min(listXsize[0], input->B_List0_refs);  
  552|      0|      }
  553|     85|      if (input->B_List1_refs)
  554|     85|      {
  555|       |        
  556|     85|        img->num_ref_idx_l1_active = min(img->num_ref_idx_l1_active, input->B_List1_refs);
  557|     85|        listXsize[1] = min(listXsize[1], input->B_List1_refs);  
  558|     85|      }
  559|     85|    }
  560|    171|  } 
  561|       |
  562|       |  //Perform memory management based on poc distances for PyramidCoding
  563|    171|  if (img->nal_reference_idc  && input->PyramidCoding && input->PocMemoryManagement && dpb.used_size == dpb.size)
  564|      0|  {    
  565|      0|    poc_based_ref_management(img->frame_num);
  566|      0|  }
  567|       |
  568|    171|  init_ref_pic_list_reordering();
  569|       |
  570|       |  //Perform reordering based on poc distances for PyramidCoding
  571|    171|  if (img->type==P_SLICE && input->PyramidCoding && input->PyramidRefReorder)
  572|      0|  {
  573|       |    
  574|      0|    int i, num_ref;
  575|       |
  576|      0|    alloc_ref_pic_list_reordering_buffer(currSlice);
  577|       |    
  578|      0|    if ((img->type != I_SLICE) && (img->type !=SI_SLICE))
  579|      0|    {
  580|      0|      for (i=0; i<img->num_ref_idx_l0_active + 1; i++)
  581|      0|      {
  582|      0|        currSlice->remapping_of_pic_nums_idc_l0[i] = 3;
  583|      0|        currSlice->abs_diff_pic_num_minus1_l0[i] = 0;
  584|      0|        currSlice->long_term_pic_idx_l0[i] = 0;
  585|      0|      }
  586|       |      
  587|      0|      if (img->type == B_SLICE)
  588|      0|      {
  589|      0|        for (i=0; i<img->num_ref_idx_l1_active + 1; i++)
  590|      0|        {
  591|      0|          currSlice->remapping_of_pic_nums_idc_l1[i] = 3;
  592|      0|          currSlice->abs_diff_pic_num_minus1_l1[i] = 0;
  593|      0|          currSlice->long_term_pic_idx_l1[i] = 0;
  594|      0|        }
  595|      0|      }
  596|      0|    }
  597|       |    
  598|      0|    if ((img->type != I_SLICE) && (img->type !=SI_SLICE))
  599|      0|    {
  600|      0|      num_ref = img->num_ref_idx_l0_active;
  601|      0|      poc_ref_pic_reorder(listX[LIST_0], 
  602|      0|                          num_ref, 
  603|      0|                          currSlice->remapping_of_pic_nums_idc_l0, 
  604|      0|                          currSlice->abs_diff_pic_num_minus1_l0, 
  605|      0|                          currSlice->long_term_pic_idx_l0, 0, LIST_0);
  606|       |      
  607|       |      //reference picture reordering
  608|      0|      reorder_ref_pic_list(listX[LIST_0], &listXsize[LIST_0], 
  609|      0|                           img->num_ref_idx_l0_active - 1, 
  610|      0|                           currSlice->remapping_of_pic_nums_idc_l0, 
  611|      0|                           currSlice->abs_diff_pic_num_minus1_l0, 
  612|      0|                           currSlice->long_term_pic_idx_l0);
  613|       |      
  614|       |		// This is not necessary since order is already poc based...  
  615|      0|      if (img->type == B_SLICE)
  616|      0|      {
  617|      0|        num_ref = img->num_ref_idx_l1_active;
  618|      0|        poc_ref_pic_reorder(listX[LIST_1], 
  619|      0|                            num_ref, 
  620|      0|                            currSlice->remapping_of_pic_nums_idc_l1, 
  621|      0|                            currSlice->abs_diff_pic_num_minus1_l1, 
  622|      0|                            currSlice->long_term_pic_idx_l1, 0, LIST_1);
  623|       |        
  624|       |        //reference picture reordering
  625|      0|        reorder_ref_pic_list(listX[LIST_1], &listXsize[LIST_1], 
  626|      0|                             img->num_ref_idx_l1_active - 1, 
  627|      0|                             currSlice->remapping_of_pic_nums_idc_l1, 
  628|      0|                             currSlice->abs_diff_pic_num_minus1_l1, 
  629|      0|                             currSlice->long_term_pic_idx_l1);
  630|      0|      }
  631|      0|    }
  632|      0|  }
  633|       |
  634|       |
  635|       |  //if (img->MbaffFrameFlag)
  636|    171|  if (img->structure==FRAME)
  637|    171|    init_mbaff_lists();
  638|       |
  639|    171|  if (img->type != I_SLICE && (active_pps->weighted_pred_flag == 1 || (active_pps->weighted_bipred_idc > 0 && (img->type == B_SLICE))))
  640|      0|  {
  641|      0|  	if (img->type==P_SLICE || img->type==SP_SLICE)
  642|      0|    {
  643|      0|      if (input->GenerateMultiplePPS && input->RDPictureDecision)
  644|      0|      {
  645|      0|        if (enc_picture==enc_frame_picture2)
  646|      0|          estimate_weighting_factor_P_slice (0);
  647|      0|        else
  648|      0|          estimate_weighting_factor_P_slice (1);
  649|      0|      }
  650|      0|      else
  651|      0|        estimate_weighting_factor_P_slice (0);
  652|       |      
  653|      0|    }
  654|      0|    else
  655|      0|       estimate_weighting_factor_B_slice ();
  656|      0|  }
  657|       |
  658|    171|  set_ref_pic_num();
  659|       |
  660|    171|  if (img->type == B_SLICE)
  661|     85|    compute_colocated(Co_located, listX);
  662|       |
  663|    171|}
  664|       |
  665|       |
  666|       |/*!
  667|       | ************************************************************************
  668|       | * \brief
  669|       | *    Allocates a slice structure along with its dependent data structures
  670|       | * \return
  671|       | *    Pointer to a Slice
  672|       | ************************************************************************
  673|       | */
  674|       |static Slice *malloc_slice()
  675|    171|{
  676|    171|  int i;
  677|    171|  DataPartition *dataPart;
  678|    171|  Slice *slice;
  679|    171|  const int buffer_size = (img->width * img->height * 4); // AH 190202: There can be data expansion with 
  680|       |                                                          // low QP values. So, we make sure that buffer 
  681|       |                                                          // does not overflow. 4 is probably safe multiplier.
  682|       |
  683|    171|  if ((slice = (Slice *) calloc(1, sizeof(Slice))) == NULL) no_mem_exit ("malloc_slice: slice structure");
  684|       |
  685|    171|  if (input->symbol_mode == CABAC)
  686|    171|    {
  687|       |      // create all context models
  688|    171|      slice->mot_ctx = create_contexts_MotionInfo();
  689|    171|      slice->tex_ctx = create_contexts_TextureInfo();
  690|    171|    }
  691|       |
  692|    171|  slice->max_part_nr = input->partition_mode==0?1:3;
  693|       |
  694|       |  //for IDR img there should be only one partition
  695|    171|  if(img->currentPicture->idr_flag)
  696|      1|    slice->max_part_nr = 1;
  697|       |  
  698|    171|  assignSE2partition[0] = assignSE2partition_NoDP;
  699|       |  //ZL 
  700|       |  //for IDR img all the syntax element should be mapped to one partition        
  701|    171|  if(!img->currentPicture->idr_flag&&input->partition_mode==1)
  702|      0|    assignSE2partition[1] =  assignSE2partition_DP;
  703|    171|  else
  704|    171|    assignSE2partition[1] =  assignSE2partition_NoDP;        
  705|       |
  706|       |
  707|       |
  708|    171|  slice->num_mb = 0;          // no coded MBs so far
  709|       |
  710|    171|  if ((slice->partArr = (DataPartition *) calloc(slice->max_part_nr, sizeof(DataPartition))) == NULL) no_mem_exit ("malloc_slice: partArr");
  711|    342|  for (i=0; i<slice->max_part_nr; i++) // loop over all data partitions
  712|    171|  {
  713|    171|    dataPart = &(slice->partArr[i]);
  714|    171|    if ((dataPart->bitstream = (Bitstream *) calloc(1, sizeof(Bitstream))) == NULL) no_mem_exit ("malloc_slice: Bitstream");
  715|    171|    if ((dataPart->bitstream->streamBuffer = (byte *) calloc(buffer_size, sizeof(byte))) == NULL) no_mem_exit ("malloc_slice: StreamBuffer");
  716|       |    // Initialize storage of bitstream parameters
  717|    171|  }
  718|    171|  return slice;
  719|    171|}
  720|       |
  721|       |
  722|       |/*!
  723|       | ************************************************************************
  724|       | * \brief
  725|       | *    Memory frees of all Slice structures and of its dependent
  726|       | *    data structures
  727|       | * \par Input:
  728|       | *    Image Parameters struct struct img_par *img
  729|       | ************************************************************************
  730|       | */
  731|       |void free_slice_list(Picture *currPic)
  732|    172|{
  733|    172|  int i;
  734|       |
  735|    344|  for (i=0; i<currPic->no_slices; i++)
  736|    172|  {
  737|    172|    free_slice (currPic->slices[i]);
  738|    172|    currPic->slices[i]=NULL;
  739|    172|  }
  740|    172|}
  741|       |
  742|       |
  743|       |/*!
  744|       | ************************************************************************
  745|       | * \brief
  746|       | *    Memory frees of the Slice structure and of its dependent
  747|       | *    data structures
  748|       | * \param slice:
  749|       | *    Slice to be freed
  750|       | ************************************************************************
  751|       | */
  752|       |static void free_slice(Slice *slice)
  753|    172|{
  754|    172|  int i;
  755|    172|  DataPartition *dataPart;
  756|       |
  757|    172|  if (slice != NULL)
  758|    171|  {
  759|    342|    for (i=0; i<slice->max_part_nr; i++) // loop over all data partitions
  760|    171|    {
  761|    171|      dataPart = &(slice->partArr[i]);
  762|    171|      if (dataPart != NULL)
  763|    171|      {
  764|    171|        if (dataPart->bitstream->streamBuffer != NULL)
  765|    171|          free(dataPart->bitstream->streamBuffer);
  766|    171|        if (dataPart->bitstream != NULL)
  767|    171|          free(dataPart->bitstream);
  768|    171|      }
  769|    171|    }
  770|    171|    if (slice->partArr != NULL)
  771|    171|      free(slice->partArr);
  772|    171|    if (input->symbol_mode == CABAC)
  773|    171|    {
  774|    171|      delete_contexts_MotionInfo(slice->mot_ctx);
  775|    171|      delete_contexts_TextureInfo(slice->tex_ctx);
  776|    171|    }
  777|       |    //free(img->currentSlice);
  778|    171|    free(slice);
  779|    171|  }
  780|    172|}
  781|       |
  782|       |
  783|       |/*!
  784|       | ************************************************************************
  785|       | * \brief
  786|       | *    This function set the value of a bit in a bitstream to 1
  787|       | ************************************************************************
  788|       | */
  789|       |void modify_redundant_pic_cnt(unsigned char *buffer)
  790|      0|{
  791|      0|  unsigned char tmp = 1 << (rpc_bits_to_go-1);
  792|      0|  buffer[rpc_bytes_to_go] |= tmp;
  793|      0|}
  794|       |
  795|       |void set_ref_pic_num()
  796|    171|{
  797|    171|  int i,j;
  798|       |  
  799|       |  //! need to add field ref_pic_num that handles field pair.
  800|       |
  801|    867|  for (i=0;i<listXsize[LIST_0];i++)
  802|    696|  {
  803|    696|    enc_picture->ref_pic_num        [LIST_0][i]=listX[LIST_0][i]->poc * 2 + ((listX[LIST_0][i]->structure==BOTTOM_FIELD)?1:0) ; 
  804|    696|    enc_picture->frm_ref_pic_num    [LIST_0][i]=listX[LIST_0][i]->frame_poc * 2; 
  805|    696|    enc_picture->top_ref_pic_num    [LIST_0][i]=listX[LIST_0][i]->top_poc * 2; 
  806|    696|    enc_picture->bottom_ref_pic_num [LIST_0][i]=listX[LIST_0][i]->bottom_poc * 2 + 1; 
  807|    696|  }
  808|       |
  809|    256|  for (i=0;i<listXsize[LIST_1];i++)
  810|     85|  {
  811|     85|    enc_picture->ref_pic_num        [LIST_1][i]=listX[LIST_1][i]->poc  *2 + ((listX[LIST_1][i]->structure==BOTTOM_FIELD)?1:0);
  812|     85|    enc_picture->frm_ref_pic_num    [LIST_1][i]=listX[LIST_1][i]->frame_poc * 2; 
  813|     85|    enc_picture->top_ref_pic_num    [LIST_1][i]=listX[LIST_1][i]->top_poc * 2; 
  814|     85|    enc_picture->bottom_ref_pic_num [LIST_1][i]=listX[LIST_1][i]->bottom_poc * 2 + 1; 
  815|     85|  }
  816|       |
  817|    171|  if (!active_sps->frame_mbs_only_flag)
  818|      0|  {
  819|      0|    if (img->structure==FRAME)
  820|      0|      for (j=2;j<6;j++)
  821|      0|        for (i=0;i<listXsize[j];i++)
  822|      0|        {    
  823|      0|          enc_picture->ref_pic_num[j][i] = listX[j][i]->poc * 2 + ((listX[j][i]->structure==BOTTOM_FIELD)?1:0);
  824|      0|          enc_picture->frm_ref_pic_num[j][i] = listX[j][i]->frame_poc * 2 ;
  825|      0|          enc_picture->top_ref_pic_num[j][i] = listX[j][i]->top_poc * 2 ;
  826|      0|          enc_picture->bottom_ref_pic_num[j][i] = listX[j][i]->bottom_poc * 2 + 1;
  827|      0|        }
  828|      0|  }
  829|       |
  830|    171|}
  831|       |
  832|       |/*!
  833|       |************************************************************************
  834|       |* \brief
  835|       |*    decide reference picture reordering, Frame only
  836|       |************************************************************************
  837|       |*/
  838|       |void poc_ref_pic_reorder(StorablePicture **list, unsigned num_ref_idx_lX_active, int *remapping_of_pic_nums_idc, int *abs_diff_pic_num_minus1, int *long_term_pic_idx, int weighted_prediction, int list_no)
  839|      0|{
  840|      0|  unsigned i,j,k;
  841|       |  
  842|      0|  int currPicNum, picNumLXPred;
  843|       |
  844|      0|  int default_order[32];
  845|      0|  int re_order[32];
  846|      0|  int tmp_reorder[32];
  847|      0|  int list_sign[32];
  848|      0|  int reorder_stop, no_reorder;
  849|      0|  int poc_diff[32];
  850|      0|  int tmp_value, diff;  
  851|       |
  852|      0|  int abs_poc_dist;
  853|      0|  int maxPicNum, MaxFrameNum = 1 << (log2_max_frame_num_minus4 + 4);
  854|       |  
  855|      0|  if (img->structure==FRAME)
  856|      0|  {
  857|      0|    maxPicNum  = MaxFrameNum;
  858|      0|    currPicNum = img->frame_num;
  859|      0|  }
  860|      0|  else
  861|      0|  {
  862|      0|    maxPicNum  = 2 * MaxFrameNum;
  863|      0|    currPicNum = 2 * img->frame_num + 1;
  864|      0|  }
  865|       |  
  866|      0|  picNumLXPred = currPicNum;
  867|       |  
  868|       |  // First assign default list order. 
  869|      0|  for (i=0; i<num_ref_idx_lX_active; i++)
  870|      0|  {
  871|      0|    default_order[i] = list[i]->pic_num;
  872|      0|  }
  873|       |  
  874|       |  // Now access all references in buffer and assign them
  875|       |  // to a pottential reordering list. For each one of these 
  876|       |  // references compute the poc distance compared to current
  877|       |  // frame.
  878|      0|  for (i=0; i<dpb.ref_frames_in_buffer; i++)
  879|      0|  {
  880|      0|    re_order[i] = dpb.fs_ref[i]->frame->pic_num;
  881|       |  
  882|      0|    if (dpb.fs_ref[i]->is_used==3 && (dpb.fs_ref[i]->frame->used_for_reference)&&(!dpb.fs_ref[i]->frame->is_long_term))
  883|      0|    {
  884|      0|      abs_poc_dist = abs(dpb.fs_ref[i]->frame->poc - enc_picture->poc) ;
  885|      0|      poc_diff[i] = abs_poc_dist;
  886|      0|      if (list_no == LIST_0)
  887|      0|      {
  888|      0|        if ( enc_picture->poc < dpb.fs_ref[i]->frame->poc)
  889|      0|        {
  890|      0|          list_sign[i] = +1;
  891|      0|        }
  892|      0|        else
  893|      0|        {
  894|      0|          list_sign[i] = -1;
  895|      0|        }
  896|      0|      }
  897|      0|      else
  898|      0|      {
  899|      0|        if (enc_picture->poc > dpb.fs_ref[i]->frame->poc)
  900|      0|        {
  901|      0|          list_sign[i] = +1;
  902|      0|        }
  903|      0|        else
  904|      0|        {
  905|      0|          list_sign[i] = -1;
  906|      0|        }
  907|      0|      }
  908|      0|    }
  909|      0|  }
  910|       |  
  911|       |  
  912|       |  // now sort these references based on poc (temporal) distance
  913|      0|  for (i=0; i< dpb.ref_frames_in_buffer-1; i++)
  914|      0|  {
  915|      0|    for (j=i+1; j< dpb.ref_frames_in_buffer; j++)
  916|      0|    {
  917|       |      
  918|      0|      if (poc_diff[i]>poc_diff[j] || (poc_diff[i] == poc_diff[j] && list_sign[j] > list_sign[i]))
  919|      0|      {
  920|       |        
  921|      0|        tmp_value = poc_diff[i];
  922|      0|        poc_diff[i] = poc_diff[j];
  923|      0|        poc_diff[j] = tmp_value;
  924|      0|        tmp_value  = re_order[i];
  925|      0|        re_order[i] = re_order[j];
  926|      0|        re_order[j] = tmp_value ;
  927|      0|        tmp_value  = list_sign[i];
  928|      0|        list_sign[i] = list_sign[j];        
  929|      0|        list_sign[j] = tmp_value ;
  930|      0|      }
  931|      0|    }
  932|      0|  }
  933|       |  
  934|       |  // Check versus default list to see if any
  935|       |  // change has happened
  936|      0|  no_reorder = 1;
  937|      0|  for (i=0; i<num_ref_idx_lX_active; i++)
  938|      0|  {
  939|      0|    if (default_order[i] != re_order[i])
  940|      0|    {
  941|      0|      no_reorder = 0;
  942|      0|    }
  943|      0|  }
  944|       |  
  945|       |  // If different, then signal reordering
  946|      0|  if (no_reorder==0)
  947|      0|  {
  948|      0|    for (i=0; i<num_ref_idx_lX_active; i++)
  949|      0|    {
  950|      0|      diff = re_order[i]-picNumLXPred;
  951|      0|      if (diff <= 0)
  952|      0|      {
  953|      0|        remapping_of_pic_nums_idc[i] = 0;
  954|      0|        abs_diff_pic_num_minus1[i] = abs(diff)-1;
  955|      0|        if (abs_diff_pic_num_minus1[i] < 0)
  956|      0|          abs_diff_pic_num_minus1[i] = maxPicNum -1; 
  957|      0|      }
  958|      0|      else
  959|      0|      {
  960|      0|        remapping_of_pic_nums_idc[i] = 1;
  961|      0|        abs_diff_pic_num_minus1[i] = abs(diff)-1;
  962|      0|      }
  963|      0|      picNumLXPred = re_order[i];
  964|       |      
  965|      0|      tmp_reorder[i] = re_order[i];
  966|       |      
  967|      0|      k = i;
  968|      0|      for (j=i; j<num_ref_idx_lX_active; j++)
  969|      0|      {
  970|      0|        if (default_order[j] != re_order[i])
  971|      0|        {
  972|      0|          ++k;
  973|      0|          tmp_reorder[k] = default_order[j];
  974|      0|        }
  975|      0|      }
  976|      0|      reorder_stop = 1;
  977|      0|      for(j=i+1; j<num_ref_idx_lX_active; j++)
  978|      0|      {
  979|      0|        if (tmp_reorder[j] != re_order[j])
  980|      0|        {
  981|      0|          reorder_stop = 0;
  982|      0|          break;
  983|      0|        }
  984|      0|      }
  985|       |      
  986|      0|      if (reorder_stop==1)
  987|      0|      {
  988|      0|        ++i;
  989|      0|        break;
  990|      0|      }
  991|       |      
  992|       |      
  993|      0|      for(j=0; j<num_ref_idx_lX_active; j++)
  994|      0|      {
  995|      0|        default_order[j] = tmp_reorder[j];
  996|      0|      }
  997|       |            
  998|      0|    }
  999|      0|    remapping_of_pic_nums_idc[i] = 3;
 1000|       |    
 1001|      0|    for(j=0; j<num_ref_idx_lX_active; j++)
 1002|      0|    {
 1003|      0|      default_order[j] = tmp_reorder[j];
 1004|      0|    }
 1005|       |    
 1006|      0|    if (list_no==0)
 1007|      0|    {
 1008|      0|      img->currentSlice->ref_pic_list_reordering_flag_l0=1;
 1009|      0|    }
 1010|      0|    else
 1011|      0|    {
 1012|      0|      img->currentSlice->ref_pic_list_reordering_flag_l1=1;
 1013|      0|    }
 1014|      0|  }
 1015|      0|}

/home/xzp/speccpu2006-v1.0.1/benchspec/CPU2006/464.h264ref/run/build_base_ql_riscv_llvm17.0000/specrand.c:
    1|       |/*
    2|       | ****************************************************************************
    3|       | *
    4|       | * HEY!
    5|       | * 
    6|       | * Absolutely do NOT forget to include "specrand.h" in any file in which you
    7|       | * call EITHER spec_rand OR spec_srand.
    8|       | *
    9|       | * Failure to heed this warning will likely result in strange, hard-to-diagnose
   10|       | * bugs.  YOU HAVE BEEN WARNED!
   11|       | *
   12|       | ****************************************************************************
   13|       | */
   14|       |static int seedi;
   15|       |
   16|      1|void spec_srand(int seed) {
   17|      1|  seedi = seed;
   18|      1|}
   19|       |
   20|       |/* See "Random Number Generators: Good Ones Are Hard To Find", */
   21|       |/*     Park & Miller, CACM 31#10 October 1988 pages 1192-1201. */
   22|       |/***********************************************************/
   23|       |/* THIS IMPLEMENTATION REQUIRES AT LEAST 32 BIT INTEGERS ! */
   24|       |/***********************************************************/
   25|       |double spec_rand(void)
   26|  4.20k|#define _A_MULTIPLIER  16807L
   27|  4.26k|#define _M_MODULUS     2147483647L /* (2**31)-1 */
   28|  8.41k|#define _Q_QUOTIENT    127773L     /* 2147483647 / 16807 */
   29|  4.20k|#define _R_REMAINDER   2836L       /* 2147483647 % 16807 */
   30|  4.20k|{
   31|  4.20k|  int lo;
   32|  4.20k|  int hi;
   33|  4.20k|  int test;
   34|       |
   35|  4.20k|  hi = seedi / _Q_QUOTIENT;
   36|  4.20k|  lo = seedi % _Q_QUOTIENT;
   37|  4.20k|  test = _A_MULTIPLIER * lo - _R_REMAINDER * hi;
   38|  4.20k|  if (test > 0) {
   39|  4.15k|    seedi = test;
   40|  4.15k|  } else {
   41|     55|    seedi = test + _M_MODULUS;
   42|     55|  }
   43|  4.20k|  return ( (double) seedi / _M_MODULUS);
   44|  4.20k|}

/home/xzp/speccpu2006-v1.0.1/benchspec/CPU2006/464.h264ref/run/build_base_ql_riscv_llvm17.0000/transform8x8.c:
    1|       |/*!
    2|       | ***************************************************************************
    3|       | * \file transform8x8.c
    4|       | *
    5|       | * \brief
    6|       | *    8x8 transform functions
    7|       | *
    8|       | * \author
    9|       | *    Main contributors (see contributors.h for copyright, address and affiliation details) 
   10|       | *    - Yuri Vatis                      <vatis@hhi.de>
   11|       | *    - Jan Muenster                    <muenster@hhi.de>
   12|       | *    - Lowell Winger                   <lwinger@lsil.com>
   13|       | * \date
   14|       | *    12. October 2003
   15|       | **************************************************************************
   16|       | */
   17|       |
   18|       |#include <stdlib.h>
   19|       |#include <string.h>
   20|       |#include <math.h>
   21|       |#include <limits.h>
   22|       |
   23|       |#include "global.h"
   24|       |
   25|       |#include "image.h"
   26|       |#include "mb_access.h"
   27|       |#include "elements.h"
   28|       |#include "cabac.h"
   29|       |#include "vlc.h"
   30|       |
   31|       |#include "transform8x8.h"
   32|       |
   33|       |int   cofAC8x8_chroma[2][4][2][18];
   34|       |
   35|       |
   36|       |#define max(a, b) (((a) > (b)) ? (a) : (b))
   37|      0|#define min(a, b) (((a) < (b)) ? (a) : (b))
   38|       |
   39|       |
   40|       |const int quant_coef8[6][8][8] = 
   41|       |{
   42|       |  { 
   43|       |    {13107, 12222,  16777,  12222,  13107,  12222,  16777,  12222},
   44|       |    {12222, 11428,  15481,  11428,  12222,  11428,  15481,  11428},
   45|       |    {16777, 15481,  20972,  15481,  16777,  15481,  20972,  15481},
   46|       |    {12222, 11428,  15481,  11428,  12222,  11428,  15481,  11428},
   47|       |    {13107, 12222,  16777,  12222,  13107,  12222,  16777,  12222},
   48|       |    {12222, 11428,  15481,  11428,  12222,  11428,  15481,  11428},
   49|       |    {16777, 15481,  20972,  15481,  16777,  15481,  20972,  15481},
   50|       |    {12222, 11428,  15481,  11428,  12222,  11428,  15481,  11428}
   51|       |  },
   52|       |  {
   53|       |    {11916, 11058,  14980,  11058,  11916,  11058,  14980,  11058},
   54|       |    {11058, 10826,  14290,  10826,  11058,  10826,  14290,  10826},
   55|       |    {14980, 14290,  19174,  14290,  14980,  14290,  19174,  14290},
   56|       |    {11058, 10826,  14290,  10826,  11058,  10826,  14290,  10826},
   57|       |    {11916, 11058,  14980,  11058,  11916,  11058,  14980,  11058},
   58|       |    {11058, 10826,  14290,  10826,  11058,  10826,  14290,  10826},
   59|       |    {14980, 14290,  19174,  14290,  14980,  14290,  19174,  14290},
   60|       |    {11058, 10826,  14290,  10826,  11058,  10826,  14290,  10826}
   61|       |  },
   62|       |  {
   63|       |    {10082, 9675,   12710,  9675,   10082,  9675, 12710,  9675},
   64|       |    {9675,  8943,   11985,  8943,   9675,   8943, 11985,  8943},
   65|       |    {12710, 11985,  15978,  11985,  12710,  11985,  15978,  11985},
   66|       |    {9675,  8943,   11985,  8943,   9675,   8943, 11985,  8943},
   67|       |    {10082, 9675,   12710,  9675,   10082,  9675, 12710,  9675},
   68|       |    {9675,  8943,   11985,  8943,   9675, 8943, 11985,  8943},
   69|       |    {12710, 11985,  15978,  11985,  12710,  11985,  15978,  11985},
   70|       |    {9675,  8943,   11985,  8943,   9675, 8943, 11985,  8943}
   71|       |  },
   72|       |  {
   73|       |    {9362,  8931, 11984,  8931, 9362, 8931, 11984,  8931},
   74|       |    {8931,  8228, 11259,  8228, 8931, 8228, 11259,  8228},
   75|       |    {11984, 11259,  14913,  11259,  11984,  11259,  14913,  11259},
   76|       |    {8931,  8228, 11259,  8228, 8931, 8228, 11259,  8228},
   77|       |    {9362,  8931, 11984,  8931, 9362, 8931, 11984,  8931},
   78|       |    {8931,  8228, 11259,  8228, 8931, 8228, 11259,  8228},
   79|       |    {11984, 11259,  14913,  11259,  11984,  11259,  14913,  11259},
   80|       |    {8931,  8228, 11259,  8228, 8931, 8228, 11259,  8228}
   81|       |  },
   82|       |  {
   83|       |    {8192,  7740, 10486,  7740, 8192, 7740, 10486,  7740},
   84|       |    {7740,  7346, 9777, 7346, 7740, 7346, 9777, 7346},
   85|       |    {10486, 9777, 13159,  9777, 10486,  9777, 13159,  9777},
   86|       |    {7740,  7346, 9777, 7346, 7740, 7346, 9777, 7346},
   87|       |    {8192,  7740, 10486,  7740, 8192, 7740, 10486,  7740},
   88|       |    {7740,  7346, 9777, 7346, 7740, 7346, 9777, 7346},
   89|       |    {10486, 9777, 13159,  9777, 10486,  9777, 13159,  9777},
   90|       |    {7740,  7346, 9777, 7346, 7740, 7346, 9777, 7346}
   91|       |  },
   92|       |  {
   93|       |    {7282,  6830, 9118, 6830, 7282, 6830, 9118, 6830},
   94|       |    {6830,  6428, 8640, 6428, 6830, 6428, 8640, 6428},
   95|       |    {9118,  8640, 11570,  8640, 9118, 8640, 11570,  8640},
   96|       |    {6830,  6428, 8640, 6428, 6830, 6428, 8640, 6428},
   97|       |    {7282,  6830, 9118, 6830, 7282, 6830, 9118, 6830},
   98|       |    {6830,  6428, 8640, 6428, 6830, 6428, 8640, 6428},
   99|       |    {9118,  8640, 11570,  8640, 9118, 8640, 11570,  8640},
  100|       |    {6830,  6428, 8640, 6428, 6830, 6428, 8640, 6428}
  101|       |  }
  102|       |};
  103|       |
  104|       |
  105|       |const int dequant_coef8[6][8][8] = 
  106|       |{
  107|       |  {
  108|       |    {20,  19, 25, 19, 20, 19, 25, 19},
  109|       |    {19,  18, 24, 18, 19, 18, 24, 18},
  110|       |    {25,  24, 32, 24, 25, 24, 32, 24},
  111|       |    {19,  18, 24, 18, 19, 18, 24, 18},
  112|       |    {20,  19, 25, 19, 20, 19, 25, 19},
  113|       |    {19,  18, 24, 18, 19, 18, 24, 18},
  114|       |    {25,  24, 32, 24, 25, 24, 32, 24},
  115|       |    {19,  18, 24, 18, 19, 18, 24, 18}
  116|       |  },
  117|       |  {
  118|       |    {22,  21, 28, 21, 22, 21, 28, 21},
  119|       |    {21,  19, 26, 19, 21, 19, 26, 19},
  120|       |    {28,  26, 35, 26, 28, 26, 35, 26},
  121|       |    {21,  19, 26, 19, 21, 19, 26, 19},
  122|       |    {22,  21, 28, 21, 22, 21, 28, 21},
  123|       |    {21,  19, 26, 19, 21, 19, 26, 19},
  124|       |    {28,  26, 35, 26, 28, 26, 35, 26},
  125|       |    {21,  19, 26, 19, 21, 19, 26, 19}
  126|       |  },
  127|       |  {
  128|       |    {26,  24, 33, 24, 26, 24, 33, 24},
  129|       |    {24,  23, 31, 23, 24, 23, 31, 23},
  130|       |    {33,  31, 42, 31, 33, 31, 42, 31},
  131|       |    {24,  23, 31, 23, 24, 23, 31, 23},
  132|       |    {26,  24, 33, 24, 26, 24, 33, 24},
  133|       |    {24,  23, 31, 23, 24, 23, 31, 23},
  134|       |    {33,  31, 42, 31, 33, 31, 42, 31},
  135|       |    {24,  23, 31, 23, 24, 23, 31, 23}
  136|       |  },
  137|       |  {
  138|       |    {28,  26, 35, 26, 28, 26, 35, 26},
  139|       |    {26,  25, 33, 25, 26, 25, 33, 25},
  140|       |    {35,  33, 45, 33, 35, 33, 45, 33},
  141|       |    {26,  25, 33, 25, 26, 25, 33, 25},
  142|       |    {28,  26, 35, 26, 28, 26, 35, 26},
  143|       |    {26,  25, 33, 25, 26, 25, 33, 25},
  144|       |    {35,  33, 45, 33, 35, 33, 45, 33},
  145|       |    {26,  25, 33, 25, 26, 25, 33, 25}
  146|       |  },
  147|       |  {
  148|       |    {32,  30, 40, 30, 32, 30, 40, 30},
  149|       |    {30,  28, 38, 28, 30, 28, 38, 28},
  150|       |    {40,  38, 51, 38, 40, 38, 51, 38},
  151|       |    {30,  28, 38, 28, 30, 28, 38, 28},
  152|       |    {32,  30, 40, 30, 32, 30, 40, 30},
  153|       |    {30,  28, 38, 28, 30, 28, 38, 28},
  154|       |    {40,  38, 51, 38, 40, 38, 51, 38},
  155|       |    {30,  28, 38, 28, 30, 28, 38, 28}
  156|       |  },
  157|       |  {
  158|       |    {36,  34, 46, 34, 36, 34, 46, 34},
  159|       |    {34,  32, 43, 32, 34, 32, 43, 32},
  160|       |    {46,  43, 58, 43, 46, 43, 58, 43},
  161|       |    {34,  32, 43, 32, 34, 32, 43, 32},
  162|       |    {36,  34, 46, 34, 36, 34, 46, 34},
  163|       |    {34,  32, 43, 32, 34, 32, 43, 32},
  164|       |    {46,  43, 58, 43, 46, 43, 58, 43},
  165|       |    {34,  32, 43, 32, 34, 32, 43, 32}
  166|       |  }
  167|       |
  168|       |};
  169|       |
  170|       |
  171|       |//! single scan pattern
  172|       |const byte SNGL_SCAN8x8[64][2] = {
  173|       |  {0,0}, {1,0}, {0,1}, {0,2}, {1,1}, {2,0}, {3,0}, {2,1}, 
  174|       |  {1,2}, {0,3}, {0,4}, {1,3}, {2,2}, {3,1}, {4,0}, {5,0},
  175|       |  {4,1}, {3,2}, {2,3}, {1,4}, {0,5}, {0,6}, {1,5}, {2,4},
  176|       |  {3,3}, {4,2}, {5,1}, {6,0}, {7,0}, {6,1}, {5,2}, {4,3},
  177|       |  {3,4}, {2,5}, {1,6}, {0,7}, {1,7}, {2,6}, {3,5}, {4,4},
  178|       |  {5,3}, {6,2}, {7,1}, {7,2}, {6,3}, {5,4}, {4,5}, {3,6},
  179|       |  {2,7}, {3,7}, {4,6}, {5,5}, {6,4}, {7,3}, {7,4}, {6,5},
  180|       |  {5,6}, {4,7}, {5,7}, {6,6}, {7,5}, {7,6}, {6,7}, {7,7}
  181|       |};
  182|       |
  183|       |
  184|       |//! field scan pattern
  185|       |const byte FIELD_SCAN8x8[64][2] = {   // 8x8
  186|       |  {0,0}, {0,1}, {0,2}, {1,0}, {1,1}, {0,3}, {0,4}, {1,2}, 
  187|       |  {2,0}, {1,3}, {0,5}, {0,6}, {0,7}, {1,4}, {2,1}, {3,0}, 
  188|       |  {2,2}, {1,5}, {1,6}, {1,7}, {2,3}, {3,1}, {4,0}, {3,2}, 
  189|       |  {2,4}, {2,5}, {2,6}, {2,7}, {3,3}, {4,1}, {5,0}, {4,2}, 
  190|       |  {3,4}, {3,5}, {3,6}, {3,7}, {4,3}, {5,1}, {6,0}, {5,2}, 
  191|       |  {4,4}, {4,5}, {4,6}, {4,7}, {5,3}, {6,1}, {6,2}, {5,4}, 
  192|       |  {5,5}, {5,6}, {5,7}, {6,3}, {7,0}, {7,1}, {6,4}, {6,5}, 
  193|       |  {6,6}, {6,7}, {7,2}, {7,3}, {7,4}, {7,5}, {7,6}, {7,7}
  194|       |};
  195|       |
  196|       |
  197|       |//! array used to find expensive coefficients
  198|       |const byte COEFF_COST8x8[2][64] =
  199|       |{
  200|       |  {3,3,3,3,2,2,2,2,2,2,2,2,1,1,1,1,
  201|       |  1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,
  202|       |  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  203|       |   0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
  204|       |  {9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
  205|       |   9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
  206|       |   9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
  207|       |   9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9}
  208|       |};
  209|       |
  210|       |/*! 
  211|       | *************************************************************************************
  212|       | * \brief
  213|       | *    8x8 Intra mode decision for a macroblock
  214|       | *************************************************************************************
  215|       | */
  216|       |
  217|       |int Mode_Decision_for_new_Intra8x8Macroblock (double lambda, int *min_cost)
  218|      0|{
  219|      0|  int  cbp=0, b8, cost8x8;
  220|       |
  221|      0|  *min_cost = (int)floor(6.0 * lambda + 0.4999);
  222|       |
  223|      0|  for (b8=0; b8<4; b8++)
  224|      0|  {
  225|      0|    if (Mode_Decision_for_new_8x8IntraBlocks (b8, lambda, &cost8x8))
  226|      0|    {
  227|      0|      cbp |= (1<<b8);
  228|      0|    }
  229|      0|    *min_cost += cost8x8;
  230|      0|  }
  231|       |
  232|      0|  return cbp;
  233|      0|}
  234|       |
  235|       |/*! 
  236|       | *************************************************************************************
  237|       | * \brief
  238|       | *    8x8 Intra mode decision for a macroblock
  239|       | *************************************************************************************
  240|       | */
  241|       |
  242|       |int Mode_Decision_for_new_8x8IntraBlocks (int b8, double lambda, int *min_cost)
  243|      0|{
  244|      0|  int     ipmode, best_ipmode = 0, i, j, k, x, y, cost, dummy;
  245|      0|  int     c_nz, nonzero = 0, diff[64];
  246|      0|  imgpel  rec8x8[8][8];
  247|      0|  double  rdcost = 0.0;
  248|      0|  int     block4x4_x, block4x4_y;
  249|      0|  int     block_x     = 8*(b8%2);
  250|      0|  int     block_y     = 8*(b8/2);
  251|      0|  int     pic_pix_x   = img->pix_x+block_x;
  252|      0|  int     pic_pix_y   = img->pix_y+block_y;
  253|      0|  int     pic_opix_x   = img->opix_x+block_x;
  254|      0|  int     pic_opix_y   = img->opix_y+block_y;
  255|      0|  int     pic_block_x = pic_pix_x/4;
  256|      0|  int     pic_block_y = pic_pix_y/4;
  257|      0|  double  min_rdcost  = 1e30;
  258|      0|  imgpel    **imgY_orig  = imgY_org;
  259|      0|  extern  int ****cofAC8x8; 
  260|       |
  261|      0|  int left_available, up_available, all_available;
  262|       |
  263|      0|  int     upMode;
  264|      0|  int     leftMode;
  265|      0|  int     mostProbableMode;  
  266|       |
  267|      0|  PixelPos left_block;
  268|      0|  PixelPos top_block;
  269|       |
  270|       |  // Residue Color Transform
  271|      0|  int residue_R, residue_G, residue_B;
  272|      0|  int rate, distortion, temp, b4;
  273|      0|  int c_ipmode = img->mb_data[img->current_mb_nr].c_ipred_mode;
  274|      0|  int rec8x8_c[2][4][4][4];
  275|       |
  276|      0|  getLuma4x4Neighbour(img->current_mb_nr, block_x/4, block_y/4, -1,  0, &left_block);
  277|      0|  getLuma4x4Neighbour(img->current_mb_nr, block_x/4, block_y/4,  0, -1, &top_block);
  278|       |
  279|      0|  if (input->UseConstrainedIntraPred)
  280|      0|  {
  281|      0|    top_block.available  = top_block.available ? img->intra_block [top_block.mb_addr] : 0;
  282|      0|    left_block.available = left_block.available ? img->intra_block [left_block.mb_addr] : 0;
  283|      0|  }
  284|       |
  285|      0|  if(b8/2)
  286|      0|    upMode            = top_block.available ? img->ipredmode8x8[top_block.pos_x ][top_block.pos_y ] : -1; 
  287|      0|  else
  288|      0|    upMode            = top_block.available ? img->ipredmode[top_block.pos_x ][top_block.pos_y ] : -1;
  289|      0|  if(b8%2)
  290|      0|    leftMode          = left_block.available ? img->ipredmode8x8[left_block.pos_x][left_block.pos_y] : -1;
  291|      0|  else
  292|      0|    leftMode          = left_block.available ? img->ipredmode[left_block.pos_x][left_block.pos_y] : -1;
  293|       |
  294|      0|  mostProbableMode  = (upMode < 0 || leftMode < 0) ? DC_PRED : upMode < leftMode ? upMode : leftMode;
  295|       |
  296|      0|  *min_cost = INT_MAX;
  297|       |
  298|       |  //===== INTRA PREDICTION FOR 8x8 BLOCK =====
  299|      0|  intrapred_luma8x8 (pic_pix_x, pic_pix_y, &left_available, &up_available, &all_available);
  300|       |
  301|       |  //===== LOOP OVER ALL 8x8 INTRA PREDICTION MODES =====
  302|      0|  for (ipmode=0; ipmode<NO_INTRA_PMODE; ipmode++)
  303|      0|  {
  304|      0|    if( (ipmode==DC_PRED) ||
  305|      0|        ((ipmode==VERT_PRED||ipmode==VERT_LEFT_PRED||ipmode==DIAG_DOWN_LEFT_PRED) && up_available ) ||
  306|      0|        ((ipmode==HOR_PRED||ipmode==HOR_UP_PRED) && left_available ) ||
  307|      0|        (all_available) )
  308|      0|    {
  309|      0|      if (!input->rdopt)
  310|      0|      {
  311|      0|        for (k=j=0; j<8; j++)
  312|      0|          for (i=0; i<8; i++, k++)
  313|      0|          {
  314|      0|            diff[k] = imgY_orig[pic_opix_y+j][pic_opix_x+i] - img->mprr_3[ipmode][j][i];
  315|      0|          }
  316|      0|        cost  = (ipmode == mostProbableMode) ? 0 : (int)floor(4 * lambda );
  317|      0|        cost += SATD8X8 (diff, input->hadamard);
  318|      0|        if (cost < *min_cost)
  319|      0|        {
  320|      0|          best_ipmode = ipmode;
  321|      0|          *min_cost   = cost;
  322|      0|        }
  323|      0|      }
  324|      0|      else
  325|      0|      {
  326|       |        // Residue Color Transform
  327|      0|        if(!img->residue_transform_flag)
  328|      0|        {
  329|       |          // get prediction and prediction error
  330|      0|          for (j=0; j<8; j++)
  331|      0|            for (i=0; i<8; i++)
  332|      0|            {
  333|      0|              img->mpr[block_x+i][block_y+j]  = img->mprr_3[ipmode][j][i];
  334|      0|              img->m7[i][j]                   = imgY_orig[pic_opix_y+j][pic_opix_x+i] - img->mprr_3[ipmode][j][i];
  335|      0|            }
  336|       |
  337|       |          //===== store the coding state =====
  338|      0|          store_coding_state_cs_cm();
  339|       |          // get and check rate-distortion cost
  340|       |          
  341|      0|          if ((rdcost = RDCost_for_8x8IntraBlocks (&c_nz, b8, ipmode, lambda, min_rdcost, mostProbableMode)) < min_rdcost)
  342|      0|          {
  343|       |            //--- set coefficients ---
  344|      0|            for (j=0; j<2; j++)
  345|      0|              for (i=0; i<65;i++)  
  346|      0|                for(k=0; k<4; k++) // do 4x now
  347|      0|                  cofAC8x8[b8][k][j][i]=img->cofAC[b8][k][j][i]; // k vs 0
  348|       |
  349|       |            //--- set reconstruction ---
  350|      0|            for (y=0; y<8; y++)
  351|      0|              for (x=0; x<8; x++)  
  352|      0|                rec8x8[y][x] = enc_picture->imgY[pic_pix_y+y][pic_pix_x+x];
  353|       |              
  354|       |              //--- flag if dct-coefficients must be coded ---
  355|      0|              nonzero = c_nz;
  356|       |              
  357|       |              //--- set best mode update minimum cost ---
  358|      0|              min_rdcost  = rdcost;
  359|      0|              best_ipmode = ipmode;
  360|      0|          }
  361|      0|          reset_coding_state_cs_cm();  
  362|      0|        }
  363|      0|        else
  364|      0|        {
  365|       |
  366|      0|          for (j=0; j<8; j++)
  367|      0|          for (i=0; i<8; i++)
  368|      0|          {
  369|      0|            residue_B = imgUV_org[0][pic_opix_y+j][pic_opix_x+i] - img->mprr_c[0][c_ipmode][block_x+i][block_y+j];
  370|      0|            residue_G = imgY_org[pic_opix_y+j][pic_opix_x+i] - img->mprr_3[ipmode][j][i];
  371|      0|            residue_R = imgUV_org[1][pic_opix_y+j][pic_opix_x+i] - img->mprr_c[1][c_ipmode][block_x+i][block_y+j];
  372|       |
  373|       |            /* Forward Residue Transform */
  374|      0|            resTrans_R[i][j] = residue_R-residue_B;
  375|      0|            temp = residue_B+(resTrans_R[i][j]>>1);
  376|      0|            resTrans_B[i][j] = residue_G-temp;
  377|      0|            resTrans_G[i][j] = temp+(resTrans_B[i][j]>>1);
  378|      0|          }
  379|       |
  380|      0|          for (j=0; j<8; j++)
  381|      0|          for (i=0; i<8; i++)
  382|      0|          {
  383|      0|            img->m7[i][j]  = resTrans_G[i][j];
  384|      0|          }
  385|       |
  386|      0|          store_coding_state_cs_cm();
  387|      0|          rate = (int) RDCost_for_8x8IntraBlocks (&c_nz, b8, ipmode, lambda, min_rdcost, mostProbableMode);
  388|      0|          reset_coding_state_cs_cm();
  389|       |
  390|      0|          for (j=0; j<8; j++)
  391|      0|            for (i=0; i<8; i++)
  392|      0|            {
  393|      0|              rec_resG[i][j] = img->m7[i][j];            
  394|      0|            }
  395|       |
  396|      0|          store_coding_state_cs_cm();
  397|      0|          for(b4=0;b4<4;b4++)
  398|      0|          {
  399|       |            
  400|      0|            block4x4_x = 4*(b4%2);
  401|      0|            block4x4_y = 4*(b4/2);
  402|       |            
  403|      0|            for (j=0; j<4; j++)
  404|      0|              for (i=0; i<4; i++)
  405|      0|              {
  406|      0|                img->m7[i][j]  = resTrans_R[i+block4x4_x][j+block4x4_y];
  407|      0|              }
  408|      0|            rate += RDCost_for_4x4Blocks_Chroma (b8+4, b4, 0);
  409|      0|            for (j=0; j<4; j++)
  410|      0|              for (i=0; i<4; i++)
  411|      0|              {
  412|      0|                rec_resR[i+block4x4_x][j+block4x4_y] = img->m7[i][j];
  413|      0|                img->m7[i][j]  = resTrans_B[i+block4x4_x][j+block4x4_y];
  414|      0|              }
  415|      0|            rate += RDCost_for_4x4Blocks_Chroma (b8+8, b4, 1);
  416|      0|            for (j=0; j<4; j++)
  417|      0|              for (i=0; i<4; i++)
  418|      0|              {
  419|      0|                rec_resB[i+block4x4_x][j+block4x4_y] = img->m7[i][j];
  420|      0|              }
  421|      0|          }
  422|      0|          reset_coding_state_cs_cm();
  423|       |
  424|      0|          for (j=0; j<8; j++)
  425|      0|            for (i=0; i<8; i++)
  426|      0|            {
  427|       |              /* Inverse Residue Transform */
  428|      0|              temp      = rec_resG[i][j]-(rec_resB[i][j]>>1);
  429|      0|              residue_G = rec_resB[i][j]+temp;
  430|      0|              residue_B = temp - (rec_resR[i][j]>>1);
  431|      0|              residue_R = residue_B+rec_resR[i][j];
  432|      0|              enc_picture->imgUV[0][pic_pix_y+j][pic_pix_x+i] = min(img->max_imgpel_value_uv,max(0,residue_B+(int)img->mprr_c[0][c_ipmode][block_x+i][block_y+j]));
  433|      0|              enc_picture->imgY[pic_pix_y+j][pic_pix_x+i]     = min(img->max_imgpel_value,max(0,residue_G+(int)img->mprr_3[ipmode][j][i]));
  434|      0|              enc_picture->imgUV[1][pic_pix_y+j][pic_pix_x+i] = min(img->max_imgpel_value_uv,max(0,residue_R+(int)img->mprr_c[1][c_ipmode][block_x+i][block_y+j]));
  435|      0|            }
  436|       |          //===== get distortion (SSD) of 8x8 block =====
  437|      0|          distortion = 0;
  438|      0|          for (y=0; y<8; y++)
  439|      0|            for (x=pic_pix_x; x<pic_pix_x+8; x++)
  440|      0|            {
  441|      0|              distortion += (imgY_org[pic_pix_y+y][x] - enc_picture->imgY[pic_pix_y+y][x])*(imgY_org[pic_pix_y+y][x] - enc_picture->imgY[pic_pix_y+y][x]);
  442|      0|              distortion += (imgUV_org[0][pic_pix_y+y][x] - enc_picture->imgUV[0][pic_pix_y+y][x])*(imgUV_org[0][pic_pix_y+y][x] - enc_picture->imgUV[0][pic_pix_y+y][x]);
  443|      0|              distortion += (imgUV_org[1][pic_pix_y+y][x] - enc_picture->imgUV[1][pic_pix_y+y][x])*(imgUV_org[1][pic_pix_y+y][x] - enc_picture->imgUV[1][pic_pix_y+y][x]);
  444|      0|            }
  445|      0|          rdcost = (double)distortion + lambda*(double)rate;
  446|       |
  447|      0|          if (rdcost < min_rdcost)
  448|      0|          {
  449|       |            //--- set coefficients ---
  450|      0|            for (j=0; j<2; j++)
  451|      0|              for (i=0; i<65;i++)  
  452|      0|                for(k=0; k<4; k++) //do 4x now
  453|      0|                  cofAC8x8[b8][k][j][i]=img->cofAC[b8][k][j][i]; //k vs 0
  454|       |
  455|      0|            for(b4=0; b4<4; b4++)
  456|      0|            {
  457|      0|              block4x4_x = 4*(b4%2);
  458|      0|              block4x4_y = 4*(b4/2);
  459|       |
  460|      0|              for (j=0; j<2; j++)
  461|      0|                for (i=0; i<18;i++)  cofAC8x8_chroma[0][b4][j][i]=img->cofAC[b8+4][b4][j][i];
  462|      0|              for (j=0; j<2; j++)
  463|      0|                for (i=0; i<18;i++)  cofAC8x8_chroma[1][b4][j][i]=img->cofAC[b8+8][b4][j][i];
  464|       |
  465|      0|              for (i=0; i<2; i++)
  466|      0|              { //uv
  467|      0|                dc_level[i][2*(b8%2)+(b4%2)][2*(b8/2)+(b4/2)] = dc_level_temp[i][2*(b8%2)+(b4%2)][2*(b8/2)+(b4/2)];
  468|      0|                cbp_chroma_block[i][2*(b8%2)+(b4%2)][2*(b8/2)+(b4/2)] = cbp_chroma_block_temp[i][2*(b8%2)+(b4%2)][2*(b8/2)+(b4/2)];
  469|       |                //--- set reconstruction ---
  470|      0|                for (y=0; y<4; y++)
  471|      0|                  for (x=0; x<4; x++)  rec8x8_c[i][b4][y][x] = enc_picture->imgUV[i][pic_pix_y+y+block4x4_y][pic_pix_x+x+block4x4_x];
  472|      0|              }
  473|      0|            }
  474|       |
  475|       |            //--- set reconstruction ---
  476|      0|            for (y=0; y<8; y++)
  477|      0|              for (x=0; x<8; x++)  
  478|      0|                rec8x8[y][x] = enc_picture->imgY[pic_pix_y+y][pic_pix_x+x];
  479|       |
  480|       |            //--- flag if dct-coefficients must be coded ---
  481|      0|            nonzero = c_nz;
  482|       |
  483|       |            //--- set best mode update minimum cost ---
  484|      0|            min_rdcost  = rdcost;
  485|      0|            best_ipmode = ipmode;
  486|      0|          }
  487|      0|         }
  488|      0|      }
  489|      0|    }
  490|      0|  }
  491|       |
  492|       |  //===== set intra mode prediction =====
  493|      0|  img->ipredmode8x8[pic_block_x][pic_block_y] = best_ipmode;
  494|      0|  img->mb_data[img->current_mb_nr].intra_pred_modes8x8[4*b8] = mostProbableMode == best_ipmode ? -1 : best_ipmode < mostProbableMode ? best_ipmode : best_ipmode-1;
  495|       |
  496|      0|  for(j = 0; j < 2; j++)   //loop 4x4s in the subblock for 8x8 prediction setting
  497|      0|    for(i = 0; i < 2; i++)
  498|      0|      img->ipredmode8x8[i+img->mb_x*4+(b8%2)*2][j+img->mb_y*4+(b8/2)*2]=best_ipmode;    //offsets
  499|       |
  500|       |
  501|      0|  if (!input->rdopt)
  502|      0|  {
  503|       |    // Residue Color Transform
  504|      0|    if(!img->residue_transform_flag)
  505|      0|    {
  506|       |      // get prediction and prediction error
  507|      0|      for (j=0; j<8; j++)
  508|      0|      for (i=0; i<8; i++)
  509|      0|      {
  510|      0|        img->mpr[block_x+i][block_y+j]  = img->mprr_3[best_ipmode][j][i];
  511|      0|        img->m7[i][j]                   = imgY_orig[pic_opix_y+j][pic_opix_x+i] - img->mprr_3[best_ipmode][j][i];
  512|      0|      }
  513|       |
  514|      0|      nonzero = dct_luma8x8 (b8, &dummy, 1);
  515|      0|    } 
  516|      0|    else 
  517|      0|    {
  518|      0|      for (j=0; j<8; j++)
  519|      0|        for (i=0; i<8; i++)
  520|      0|        {
  521|      0|          img->mpr[block_x+i][block_y+j]  = img->mprr_3[best_ipmode][j][i];
  522|      0|          residue_B = imgUV_org[0][pic_opix_y+j][pic_opix_x+i] - img->mprr_c[0][c_ipmode][block_x+i][block_y+j];
  523|      0|          residue_G = imgY_org[pic_opix_y+j][pic_opix_x+i] - img->mprr_3[best_ipmode][j][i];
  524|      0|          residue_R = imgUV_org[1][pic_opix_y+j][pic_opix_x+i] - img->mprr_c[1][c_ipmode][block_x+i][block_y+j];
  525|       |          
  526|       |          /* Forward Residue Transform */
  527|      0|          resTrans_R[i][j] = residue_R-residue_B;
  528|      0|          temp = residue_B+(resTrans_R[i][j]>>1);
  529|      0|          resTrans_B[i][j] = residue_G-temp;
  530|      0|          resTrans_G[i][j] = temp+(resTrans_B[i][j]>>1);
  531|      0|        }
  532|       |
  533|      0|      for (j=0; j<8; j++)
  534|      0|        for (i=0; i<8; i++)
  535|      0|        {
  536|      0|          img->m7[i][j]  = resTrans_G[i][j];
  537|      0|        }
  538|       |
  539|      0|      nonzero = dct_luma8x8 (b8, &dummy, 1);
  540|       |
  541|      0|      for (j=0; j<8; j++)
  542|      0|        for (i=0; i<8; i++)
  543|      0|        {
  544|      0|          rec_resG[i][j] = img->m7[i][j];
  545|      0|        }
  546|       |
  547|      0|      for(b4=0;b4<4;b4++)
  548|      0|      {
  549|      0|        block4x4_x = 4*(b4%2);
  550|      0|        block4x4_y = 4*(b4/2);
  551|       |
  552|      0|        for (j=0; j<4; j++)
  553|      0|          for (i=0; i<4; i++)
  554|      0|          {
  555|      0|            img->m7[i][j]  = resTrans_R[i+block4x4_x][j+block4x4_y];
  556|      0|          }
  557|      0|        cbp_chroma_block[0][2*(b8%2)+(b4%2)][2*(b8/2)+(b4/2)] = dct_chroma4x4 (0, b8+4, b4);
  558|      0|        dc_level[0][2*(b8%2)+(b4%2)][2*(b8/2)+(b4/2)] = dc_level_temp[0][2*(b8%2)+(b4%2)][2*(b8/2)+(b4/2)];
  559|      0|        for (j=0; j<4; j++)
  560|      0|          for (i=0; i<4; i++)
  561|      0|          {
  562|      0|            rec_resR[i+block4x4_x][j+block4x4_y] = img->m7[i][j];
  563|      0|            img->m7[i][j]  = resTrans_B[i+block4x4_x][j+block4x4_y];
  564|      0|          }
  565|      0|        cbp_chroma_block[1][2*(b8%2)+(b4%2)][2*(b8/2)+(b4/2)] = dct_chroma4x4 (1, b8+8, b4);
  566|      0|        dc_level[1][2*(b8%2)+(b4%2)][2*(b8/2)+(b4/2)] = dc_level_temp[1][2*(b8%2)+(b4%2)][2*(b8/2)+(b4/2)];
  567|      0|        for (j=0; j<4; j++)
  568|      0|          for (i=0; i<4; i++)
  569|      0|          {
  570|      0|            rec_resB[i+block4x4_x][j+block4x4_y] = img->m7[i][j];
  571|      0|          }
  572|      0|      }
  573|       |
  574|      0|      for (j=0; j<8; j++)
  575|      0|        for (i=0; i<8; i++)
  576|      0|        {
  577|       |          /* Inverse Residue Transform */
  578|      0|          temp      = rec_resG[i][j]-(rec_resB[i][j]>>1);
  579|      0|          residue_G = rec_resB[i][j]+temp;
  580|      0|          residue_B = temp - (rec_resR[i][j]>>1);
  581|      0|          residue_R = residue_B+rec_resR[i][j];
  582|      0|          enc_picture->imgUV[0][pic_pix_y+j][pic_pix_x+i] = min(img->max_imgpel_value_uv,max(0,residue_B+(int)img->mprr_c[0][c_ipmode][block_x+i][block_y+j]));
  583|      0|          enc_picture->imgY[pic_pix_y+j][pic_pix_x+i]     = min(img->max_imgpel_value,max(0,residue_G+(int)img->mprr_3[best_ipmode][j][i]));
  584|      0|          enc_picture->imgUV[1][pic_pix_y+j][pic_pix_x+i] = min(img->max_imgpel_value_uv,max(0,residue_R+(int)img->mprr_c[1][c_ipmode][block_x+i][block_y+j]));
  585|      0|        }
  586|      0|    }
  587|      0|  }
  588|      0|  else
  589|      0|  {
  590|       |    //===== restore coefficients =====
  591|      0|    for (j=0; j<2; j++)
  592|      0|      for (i=0; i<65;i++)
  593|      0|	  	for(k=0; k<4; k++) // do 4x now
  594|      0|			img->cofAC[b8][k][j][i]=cofAC8x8[b8][k][j][i]; // k vs. 0
  595|       |
  596|       |    // Residue Color Transform
  597|      0|    if(img->residue_transform_flag)
  598|      0|    for(b4=0; b4<4; b4++){
  599|      0|      for (j=0; j<2; j++)
  600|      0|      for (i=0; i<18;i++)  img->cofAC[b8+4][b4][j][i]=cofAC8x8_chroma[0][b4][j][i];
  601|      0|      for (j=0; j<2; j++)
  602|      0|      for (i=0; i<18;i++)  img->cofAC[b8+8][b4][j][i]=cofAC8x8_chroma[1][b4][j][i];
  603|      0|    }
  604|       |
  605|       |    //===== restore reconstruction and prediction (needed if single coeffs are removed) =====
  606|      0|    for (y=0; y<8; y++)
  607|      0|      for (x=0; x<8; x++)
  608|      0|      {
  609|      0|        enc_picture->imgY[pic_pix_y+y][pic_pix_x+x] = rec8x8[y][x];
  610|      0|        img->mpr[block_x+x][block_y+y] = img->mprr_3[best_ipmode][y][x];
  611|      0|      }
  612|       |
  613|       |    // Residue Color Transform
  614|      0|      if(img->residue_transform_flag)
  615|      0|      {
  616|      0|        for(b4=0; b4<4; b4++)
  617|      0|        {
  618|      0|          block4x4_x = 4*(b4%2);
  619|      0|          block4x4_y = 4*(b4/2);
  620|      0|          for (i=0; i<2; i++)
  621|      0|          { //uv
  622|       |            //--- set reconstruction ---
  623|      0|            for (y=0; y<4; y++)
  624|      0|              for (x=0; x<4; x++) enc_picture->imgUV[i][pic_pix_y+y+block4x4_y][pic_pix_x+x+block4x4_x] = rec8x8_c[i][b4][y][x];
  625|      0|          }
  626|      0|        }
  627|      0|      }
  628|      0|  }
  629|       |
  630|      0|  return nonzero;
  631|      0|}
  632|       |
  633|       |
  634|       |
  635|       |// Notation for comments regarding prediction and predictors.
  636|       |// The pels of the 4x4 block are labelled a..p. The predictor pels above
  637|       |// are labelled A..H, from the left I..P, and from above left X, as follows:
  638|       |//
  639|       |//  Z  A  B  C  D  E  F  G  H  I  J  K  L  M   N  O  P  
  640|       |//  Q  a1 b1 c1 d1 e1 f1 g1 h1
  641|       |//  R  a2 b2 c2 d2 e2 f2 g2 h2
  642|       |//  S  a3 b3 c3 d3 e3 f3 g3 h3
  643|       |//  T  a4 b4 c4 d4 e4 f4 g4 h4
  644|       |//  U  a5 b5 c5 d5 e5 f5 g5 h5
  645|       |//  V  a6 b6 c6 d6 e6 f6 g6 h6
  646|       |//  W  a7 b7 c7 d7 e7 f7 g7 h7
  647|       |//  X  a8 b8 c8 d8 e8 f8 g8 h8
  648|       |
  649|       |
  650|       |// Predictor array index definitions
  651|      0|#define P_Z (PredPel[0])
  652|      0|#define P_A (PredPel[1])
  653|      0|#define P_B (PredPel[2])
  654|      0|#define P_C (PredPel[3])
  655|      0|#define P_D (PredPel[4])
  656|      0|#define P_E (PredPel[5])
  657|      0|#define P_F (PredPel[6])
  658|      0|#define P_G (PredPel[7])
  659|      0|#define P_H (PredPel[8])
  660|      0|#define P_I (PredPel[9])
  661|      0|#define P_J (PredPel[10])
  662|      0|#define P_K (PredPel[11])
  663|      0|#define P_L (PredPel[12])
  664|      0|#define P_M (PredPel[13])
  665|      0|#define P_N (PredPel[14])
  666|      0|#define P_O (PredPel[15])
  667|      0|#define P_P (PredPel[16])
  668|      0|#define P_Q (PredPel[17])
  669|      0|#define P_R (PredPel[18])
  670|      0|#define P_S (PredPel[19])
  671|      0|#define P_T (PredPel[20])
  672|      0|#define P_U (PredPel[21])
  673|      0|#define P_V (PredPel[22])
  674|      0|#define P_W (PredPel[23])
  675|      0|#define P_X (PredPel[24])
  676|       |
  677|       |/*!
  678|       | ************************************************************************
  679|       | * \brief
  680|       | *    Make intra 8x8 prediction according to all 9 prediction modes.
  681|       | *    The routine uses left and upper neighbouring points from
  682|       | *    previous coded blocks to do this (if available). Notice that
  683|       | *    inaccessible neighbouring points are signalled with a negative
  684|       | *    value in the predmode array .
  685|       | *
  686|       | *  \par Input:
  687|       | *     Starting point of current 8x8 block image posision
  688|       | *
  689|       | *  \par Output:
  690|       | *      none
  691|       | ************************************************************************
  692|       | */
  693|       |void intrapred_luma8x8(int img_x,int img_y, int *left_available, int *up_available, int *all_available)
  694|      0|{
  695|      0|  int i,j;
  696|      0|  int s0;
  697|      0|  int PredPel[25];  // array of predictor pels
  698|      0|  imgpel **imgY = enc_picture->imgY;  // For MB level frame/field coding tools -- set default to imgY
  699|       |
  700|      0|  int ioff = (img_x & 15);
  701|      0|  int joff = (img_y & 15);
  702|      0|  int mb_nr=img->current_mb_nr;
  703|       |
  704|      0|  PixelPos pix_a[8];
  705|      0|  PixelPos pix_b, pix_c, pix_d;
  706|       |
  707|      0|  int block_available_up;
  708|      0|  int block_available_left;
  709|      0|  int block_available_up_left;
  710|      0|  int block_available_up_right;
  711|       |
  712|      0|  for (i=0;i<8;i++)
  713|      0|  {
  714|      0|    getNeighbour(mb_nr, ioff -1 , joff +i , 1, &pix_a[i]);
  715|      0|  }
  716|       |
  717|      0|  getNeighbour(mb_nr, ioff    , joff -1 , 1, &pix_b);
  718|      0|  getNeighbour(mb_nr, ioff +8 , joff -1 , 1, &pix_c);
  719|      0|  getNeighbour(mb_nr, ioff -1 , joff -1 , 1, &pix_d);
  720|       |  
  721|      0|  pix_c.available = pix_c.available &&!(ioff == 8 && joff == 8);
  722|       |
  723|      0|  if (input->UseConstrainedIntraPred)
  724|      0|  {
  725|      0|    for (i=0, block_available_left=1; i<8;i++)
  726|      0|      block_available_left  &= pix_a[i].available ? img->intra_block[pix_a[i].mb_addr]: 0;
  727|      0|    block_available_up       = pix_b.available ? img->intra_block [pix_b.mb_addr] : 0;
  728|      0|    block_available_up_right = pix_c.available ? img->intra_block [pix_c.mb_addr] : 0;
  729|      0|    block_available_up_left  = pix_d.available ? img->intra_block [pix_d.mb_addr] : 0;
  730|      0|  }
  731|      0|  else
  732|      0|  {
  733|      0|    block_available_left     = pix_a[0].available;
  734|      0|    block_available_up       = pix_b.available;
  735|      0|    block_available_up_right = pix_c.available;
  736|      0|    block_available_up_left  = pix_d.available;
  737|      0|  }
  738|       |
  739|      0|  *left_available = block_available_left;
  740|      0|  *up_available   = block_available_up;
  741|      0|  *all_available  = block_available_up && block_available_left && block_available_up_left;
  742|       |
  743|      0|  i = (img_x & 15);
  744|      0|  j = (img_y & 15);
  745|       |
  746|       |  // form predictor pels
  747|       |  // form predictor pels
  748|      0|  if (block_available_up)
  749|      0|  {
  750|      0|    P_A = imgY[pix_b.pos_y][pix_b.pos_x+0];
  751|      0|    P_B = imgY[pix_b.pos_y][pix_b.pos_x+1];
  752|      0|    P_C = imgY[pix_b.pos_y][pix_b.pos_x+2];
  753|      0|    P_D = imgY[pix_b.pos_y][pix_b.pos_x+3];
  754|      0|    P_E = imgY[pix_b.pos_y][pix_b.pos_x+4];
  755|      0|    P_F = imgY[pix_b.pos_y][pix_b.pos_x+5];
  756|      0|    P_G = imgY[pix_b.pos_y][pix_b.pos_x+6];
  757|      0|    P_H = imgY[pix_b.pos_y][pix_b.pos_x+7];
  758|      0|  }
  759|      0|  else
  760|      0|  {
  761|      0|    P_A = P_B = P_C = P_D = P_E = P_F = P_G = P_H = img->dc_pred_value;
  762|      0|  }
  763|       |
  764|      0|  if (block_available_up_right)
  765|      0|  {
  766|      0|    P_I = imgY[pix_c.pos_y][pix_c.pos_x+0];
  767|      0|    P_J = imgY[pix_c.pos_y][pix_c.pos_x+1];
  768|      0|    P_K = imgY[pix_c.pos_y][pix_c.pos_x+2];
  769|      0|    P_L = imgY[pix_c.pos_y][pix_c.pos_x+3];
  770|      0|    P_M = imgY[pix_c.pos_y][pix_c.pos_x+4];
  771|      0|    P_N = imgY[pix_c.pos_y][pix_c.pos_x+5];
  772|      0|    P_O = imgY[pix_c.pos_y][pix_c.pos_x+6];
  773|      0|    P_P = imgY[pix_c.pos_y][pix_c.pos_x+7];
  774|       |
  775|      0|  }
  776|      0|  else
  777|      0|  {
  778|      0|    P_I = P_J = P_K = P_L = P_M = P_N = P_O = P_P = P_H;
  779|      0|  }
  780|       |
  781|      0|  if (block_available_left)
  782|      0|  {
  783|      0|    P_Q = imgY[pix_a[0].pos_y][pix_a[0].pos_x];
  784|      0|    P_R = imgY[pix_a[1].pos_y][pix_a[1].pos_x];
  785|      0|    P_S = imgY[pix_a[2].pos_y][pix_a[2].pos_x];
  786|      0|    P_T = imgY[pix_a[3].pos_y][pix_a[3].pos_x];
  787|      0|    P_U = imgY[pix_a[4].pos_y][pix_a[4].pos_x];
  788|      0|    P_V = imgY[pix_a[5].pos_y][pix_a[5].pos_x];
  789|      0|    P_W = imgY[pix_a[6].pos_y][pix_a[6].pos_x];
  790|      0|    P_X = imgY[pix_a[7].pos_y][pix_a[7].pos_x];
  791|      0|  }
  792|      0|  else
  793|      0|  {
  794|      0|    P_Q = P_R = P_S = P_T = P_U = P_V = P_W = P_X = img->dc_pred_value;
  795|      0|  }
  796|       |
  797|      0|  if (block_available_up_left)
  798|      0|  {
  799|      0|    P_Z = imgY[pix_d.pos_y][pix_d.pos_x];
  800|      0|  }
  801|      0|  else
  802|      0|  {
  803|      0|    P_Z = img->dc_pred_value;
  804|      0|  }
  805|       |
  806|      0|  for(i=0;i<9;i++)
  807|      0|    img->mprr_3[i][0][0]=-1;
  808|       |
  809|      0|  LowPassForIntra8x8Pred(&(P_Z), block_available_up_left, block_available_up, block_available_left);
  810|       |
  811|       |  ///////////////////////////////
  812|       |  // make DC prediction
  813|       |  ///////////////////////////////
  814|      0|  s0 = 0;
  815|      0|  if (block_available_up && block_available_left)
  816|      0|  {   
  817|       |    // no edge
  818|      0|    s0 = (P_A + P_B + P_C + P_D + P_E + P_F + P_G + P_H + P_Q + P_R + P_S + P_T + P_U + P_V + P_W + P_X + 8) >> 4;
  819|      0|  }
  820|      0|  else if (!block_available_up && block_available_left)
  821|      0|  {
  822|       |    // upper edge
  823|      0|    s0 = (P_Q + P_R + P_S + P_T + P_U + P_V + P_W + P_X + 4) >> 3;             
  824|      0|  }
  825|      0|  else if (block_available_up && !block_available_left)
  826|      0|  {
  827|       |    // left edge
  828|      0|    s0 = (P_A + P_B + P_C + P_D + P_E + P_F + P_G + P_H + 4) >> 3;             
  829|      0|  }
  830|      0|  else //if (!block_available_up && !block_available_left)
  831|      0|  {
  832|       |    // top left corner, nothing to predict from
  833|      0|    s0 = img->dc_pred_value;                           
  834|      0|  }
  835|       |
  836|      0|  for (j=0; j < 2*BLOCK_SIZE; j++)
  837|      0|  {
  838|      0|    for (i=0; i < 2*BLOCK_SIZE; i++)
  839|      0|    {
  840|       |      // store DC prediction
  841|      0|      img->mprr_3[DC_PRED][i][j] = s0;
  842|      0|    }
  843|      0|  }
  844|       |
  845|       |  
  846|       |  ///////////////////////////////
  847|       |  // make horiz and vert prediction
  848|       |  ///////////////////////////////
  849|       |
  850|      0|  for (i=0; i < 2*BLOCK_SIZE; i++)
  851|      0|  {
  852|      0|    img->mprr_3[VERT_PRED][0][i] = 
  853|      0|    img->mprr_3[VERT_PRED][1][i] = 
  854|      0|    img->mprr_3[VERT_PRED][2][i] = 
  855|      0|    img->mprr_3[VERT_PRED][3][i] = 
  856|      0|    img->mprr_3[VERT_PRED][4][i] = 
  857|      0|    img->mprr_3[VERT_PRED][5][i] = 
  858|      0|    img->mprr_3[VERT_PRED][6][i] = 
  859|      0|    img->mprr_3[VERT_PRED][7][i] = (&P_A)[i];
  860|      0|    img->mprr_3[HOR_PRED][i][0]  = 
  861|      0|    img->mprr_3[HOR_PRED][i][1]  = 
  862|      0|    img->mprr_3[HOR_PRED][i][2]  = 
  863|      0|    img->mprr_3[HOR_PRED][i][3]  = 
  864|      0|    img->mprr_3[HOR_PRED][i][4]  = 
  865|      0|    img->mprr_3[HOR_PRED][i][5]  = 
  866|      0|    img->mprr_3[HOR_PRED][i][6]  = 
  867|      0|    img->mprr_3[HOR_PRED][i][7]  = (&P_Q)[i];
  868|      0|  }
  869|       |
  870|      0|  if(!block_available_up)img->mprr_3[VERT_PRED][0][0]=-1;
  871|      0|  if(!block_available_left)img->mprr_3[HOR_PRED][0][0]=-1;
  872|       |
  873|       |  ///////////////////////////////////
  874|       |  // make diagonal down left prediction
  875|       |  ///////////////////////////////////
  876|      0|  if (block_available_up) 
  877|      0|  {
  878|       |    // Mode DIAG_DOWN_LEFT_PRED
  879|      0|    img->mprr_3[DIAG_DOWN_LEFT_PRED][0][0] = (P_A + P_C + 2*(P_B) + 2) >> 2;
  880|      0|    img->mprr_3[DIAG_DOWN_LEFT_PRED][0][1] = 
  881|      0|    img->mprr_3[DIAG_DOWN_LEFT_PRED][1][0] = (P_B + P_D + 2*(P_C) + 2) >> 2;
  882|      0|    img->mprr_3[DIAG_DOWN_LEFT_PRED][0][2] =
  883|      0|    img->mprr_3[DIAG_DOWN_LEFT_PRED][1][1] =
  884|      0|    img->mprr_3[DIAG_DOWN_LEFT_PRED][2][0] = (P_C + P_E + 2*(P_D) + 2) >> 2;
  885|      0|    img->mprr_3[DIAG_DOWN_LEFT_PRED][0][3] = 
  886|      0|    img->mprr_3[DIAG_DOWN_LEFT_PRED][1][2] = 
  887|      0|    img->mprr_3[DIAG_DOWN_LEFT_PRED][2][1] = 
  888|      0|    img->mprr_3[DIAG_DOWN_LEFT_PRED][3][0] = (P_D + P_F + 2*(P_E) + 2) >> 2;
  889|      0|    img->mprr_3[DIAG_DOWN_LEFT_PRED][0][4] = 
  890|      0|    img->mprr_3[DIAG_DOWN_LEFT_PRED][1][3] = 
  891|      0|    img->mprr_3[DIAG_DOWN_LEFT_PRED][2][2] = 
  892|      0|    img->mprr_3[DIAG_DOWN_LEFT_PRED][3][1] = 
  893|      0|    img->mprr_3[DIAG_DOWN_LEFT_PRED][4][0] = (P_E + P_G + 2*(P_F) + 2) >> 2;
  894|      0|    img->mprr_3[DIAG_DOWN_LEFT_PRED][0][5] = 
  895|      0|    img->mprr_3[DIAG_DOWN_LEFT_PRED][1][4] = 
  896|      0|    img->mprr_3[DIAG_DOWN_LEFT_PRED][2][3] = 
  897|      0|    img->mprr_3[DIAG_DOWN_LEFT_PRED][3][2] = 
  898|      0|    img->mprr_3[DIAG_DOWN_LEFT_PRED][4][1] = 
  899|      0|    img->mprr_3[DIAG_DOWN_LEFT_PRED][5][0] = (P_F + P_H + 2*(P_G) + 2) >> 2;
  900|      0|    img->mprr_3[DIAG_DOWN_LEFT_PRED][0][6] = 
  901|      0|    img->mprr_3[DIAG_DOWN_LEFT_PRED][1][5] = 
  902|      0|    img->mprr_3[DIAG_DOWN_LEFT_PRED][2][4] = 
  903|      0|    img->mprr_3[DIAG_DOWN_LEFT_PRED][3][3] = 
  904|      0|    img->mprr_3[DIAG_DOWN_LEFT_PRED][4][2] = 
  905|      0|    img->mprr_3[DIAG_DOWN_LEFT_PRED][5][1] = 
  906|      0|    img->mprr_3[DIAG_DOWN_LEFT_PRED][6][0] = (P_G + P_I + 2*(P_H) + 2) >> 2;
  907|      0|    img->mprr_3[DIAG_DOWN_LEFT_PRED][0][7] = 
  908|      0|    img->mprr_3[DIAG_DOWN_LEFT_PRED][1][6] = 
  909|      0|    img->mprr_3[DIAG_DOWN_LEFT_PRED][2][5] = 
  910|      0|    img->mprr_3[DIAG_DOWN_LEFT_PRED][3][4] = 
  911|      0|    img->mprr_3[DIAG_DOWN_LEFT_PRED][4][3] = 
  912|      0|    img->mprr_3[DIAG_DOWN_LEFT_PRED][5][2] = 
  913|      0|    img->mprr_3[DIAG_DOWN_LEFT_PRED][6][1] = 
  914|      0|    img->mprr_3[DIAG_DOWN_LEFT_PRED][7][0] = (P_H + P_J + 2*(P_I) + 2) >> 2;
  915|      0|    img->mprr_3[DIAG_DOWN_LEFT_PRED][1][7] = 
  916|      0|    img->mprr_3[DIAG_DOWN_LEFT_PRED][2][6] = 
  917|      0|    img->mprr_3[DIAG_DOWN_LEFT_PRED][3][5] = 
  918|      0|    img->mprr_3[DIAG_DOWN_LEFT_PRED][4][4] = 
  919|      0|    img->mprr_3[DIAG_DOWN_LEFT_PRED][5][3] = 
  920|      0|    img->mprr_3[DIAG_DOWN_LEFT_PRED][6][2] = 
  921|      0|    img->mprr_3[DIAG_DOWN_LEFT_PRED][7][1] = (P_I + P_K + 2*(P_J) + 2) >> 2;
  922|      0|    img->mprr_3[DIAG_DOWN_LEFT_PRED][2][7] = 
  923|      0|    img->mprr_3[DIAG_DOWN_LEFT_PRED][3][6] = 
  924|      0|    img->mprr_3[DIAG_DOWN_LEFT_PRED][4][5] = 
  925|      0|    img->mprr_3[DIAG_DOWN_LEFT_PRED][5][4] = 
  926|      0|    img->mprr_3[DIAG_DOWN_LEFT_PRED][6][3] = 
  927|      0|    img->mprr_3[DIAG_DOWN_LEFT_PRED][7][2] = (P_J + P_L + 2*(P_K) + 2) >> 2;
  928|      0|    img->mprr_3[DIAG_DOWN_LEFT_PRED][3][7] = 
  929|      0|    img->mprr_3[DIAG_DOWN_LEFT_PRED][4][6] = 
  930|      0|    img->mprr_3[DIAG_DOWN_LEFT_PRED][5][5] = 
  931|      0|    img->mprr_3[DIAG_DOWN_LEFT_PRED][6][4] = 
  932|      0|    img->mprr_3[DIAG_DOWN_LEFT_PRED][7][3] = (P_K + P_M + 2*(P_L) + 2) >> 2;
  933|      0|    img->mprr_3[DIAG_DOWN_LEFT_PRED][4][7] = 
  934|      0|    img->mprr_3[DIAG_DOWN_LEFT_PRED][5][6] = 
  935|      0|    img->mprr_3[DIAG_DOWN_LEFT_PRED][6][5] = 
  936|      0|    img->mprr_3[DIAG_DOWN_LEFT_PRED][7][4] = (P_L + P_N + 2*(P_M) + 2) >> 2;
  937|      0|    img->mprr_3[DIAG_DOWN_LEFT_PRED][5][7] = 
  938|      0|    img->mprr_3[DIAG_DOWN_LEFT_PRED][6][6] = 
  939|      0|    img->mprr_3[DIAG_DOWN_LEFT_PRED][7][5] = (P_M + P_O + 2*(P_N) + 2) >> 2;
  940|      0|    img->mprr_3[DIAG_DOWN_LEFT_PRED][6][7] = 
  941|      0|    img->mprr_3[DIAG_DOWN_LEFT_PRED][7][6] = (P_N + P_P + 2*(P_O) + 2) >> 2;
  942|      0|    img->mprr_3[DIAG_DOWN_LEFT_PRED][7][7] = (P_O + 3*(P_P) + 2) >> 2;
  943|       |
  944|       |    ///////////////////////////////////
  945|       |    // make vertical left prediction
  946|       |    ///////////////////////////////////
  947|      0|    img->mprr_3[VERT_LEFT_PRED][0][0] = (P_A + P_B + 1) >> 1;
  948|      0|    img->mprr_3[VERT_LEFT_PRED][0][1] = 
  949|      0|    img->mprr_3[VERT_LEFT_PRED][2][0] = (P_B + P_C + 1) >> 1;
  950|      0|    img->mprr_3[VERT_LEFT_PRED][0][2] = 
  951|      0|    img->mprr_3[VERT_LEFT_PRED][2][1] = 
  952|      0|    img->mprr_3[VERT_LEFT_PRED][4][0] = (P_C + P_D + 1) >> 1;
  953|      0|    img->mprr_3[VERT_LEFT_PRED][0][3] = 
  954|      0|    img->mprr_3[VERT_LEFT_PRED][2][2] = 
  955|      0|    img->mprr_3[VERT_LEFT_PRED][4][1] = 
  956|      0|    img->mprr_3[VERT_LEFT_PRED][6][0] = (P_D + P_E + 1) >> 1;
  957|      0|    img->mprr_3[VERT_LEFT_PRED][0][4] = 
  958|      0|    img->mprr_3[VERT_LEFT_PRED][2][3] = 
  959|      0|    img->mprr_3[VERT_LEFT_PRED][4][2] = 
  960|      0|    img->mprr_3[VERT_LEFT_PRED][6][1] = (P_E + P_F + 1) >> 1;
  961|      0|    img->mprr_3[VERT_LEFT_PRED][0][5] = 
  962|      0|    img->mprr_3[VERT_LEFT_PRED][2][4] = 
  963|      0|    img->mprr_3[VERT_LEFT_PRED][4][3] = 
  964|      0|    img->mprr_3[VERT_LEFT_PRED][6][2] = (P_F + P_G + 1) >> 1;
  965|      0|    img->mprr_3[VERT_LEFT_PRED][0][6] = 
  966|      0|    img->mprr_3[VERT_LEFT_PRED][2][5] = 
  967|      0|    img->mprr_3[VERT_LEFT_PRED][4][4] = 
  968|      0|    img->mprr_3[VERT_LEFT_PRED][6][3] = (P_G + P_H + 1) >> 1;
  969|      0|    img->mprr_3[VERT_LEFT_PRED][0][7] = 
  970|      0|    img->mprr_3[VERT_LEFT_PRED][2][6] = 
  971|      0|    img->mprr_3[VERT_LEFT_PRED][4][5] = 
  972|      0|    img->mprr_3[VERT_LEFT_PRED][6][4] = (P_H + P_I + 1) >> 1;
  973|      0|    img->mprr_3[VERT_LEFT_PRED][2][7] = 
  974|      0|    img->mprr_3[VERT_LEFT_PRED][4][6] = 
  975|      0|    img->mprr_3[VERT_LEFT_PRED][6][5] = (P_I + P_J + 1) >> 1;
  976|      0|    img->mprr_3[VERT_LEFT_PRED][4][7] = 
  977|      0|    img->mprr_3[VERT_LEFT_PRED][6][6] = (P_J + P_K + 1) >> 1;
  978|      0|    img->mprr_3[VERT_LEFT_PRED][6][7] = (P_K + P_L + 1) >> 1;
  979|      0|    img->mprr_3[VERT_LEFT_PRED][1][0] = (P_A + P_C + 2*P_B + 2) >> 2;
  980|      0|    img->mprr_3[VERT_LEFT_PRED][1][1] = 
  981|      0|    img->mprr_3[VERT_LEFT_PRED][3][0] = (P_B + P_D + 2*P_C + 2) >> 2;
  982|      0|    img->mprr_3[VERT_LEFT_PRED][1][2] = 
  983|      0|    img->mprr_3[VERT_LEFT_PRED][3][1] = 
  984|      0|    img->mprr_3[VERT_LEFT_PRED][5][0] = (P_C + P_E + 2*P_D + 2) >> 2;
  985|      0|    img->mprr_3[VERT_LEFT_PRED][1][3] = 
  986|      0|    img->mprr_3[VERT_LEFT_PRED][3][2] = 
  987|      0|    img->mprr_3[VERT_LEFT_PRED][5][1] = 
  988|      0|    img->mprr_3[VERT_LEFT_PRED][7][0] = (P_D + P_F + 2*P_E + 2) >> 2;
  989|      0|    img->mprr_3[VERT_LEFT_PRED][1][4] = 
  990|      0|    img->mprr_3[VERT_LEFT_PRED][3][3] = 
  991|      0|    img->mprr_3[VERT_LEFT_PRED][5][2] = 
  992|      0|    img->mprr_3[VERT_LEFT_PRED][7][1] = (P_E + P_G + 2*P_F + 2) >> 2;
  993|      0|    img->mprr_3[VERT_LEFT_PRED][1][5] = 
  994|      0|    img->mprr_3[VERT_LEFT_PRED][3][4] = 
  995|      0|    img->mprr_3[VERT_LEFT_PRED][5][3] = 
  996|      0|    img->mprr_3[VERT_LEFT_PRED][7][2] = (P_F + P_H + 2*P_G + 2) >> 2;
  997|      0|    img->mprr_3[VERT_LEFT_PRED][1][6] = 
  998|      0|    img->mprr_3[VERT_LEFT_PRED][3][5] = 
  999|      0|    img->mprr_3[VERT_LEFT_PRED][5][4] = 
 1000|      0|    img->mprr_3[VERT_LEFT_PRED][7][3] = (P_G + P_I + 2*P_H + 2) >> 2;
 1001|      0|    img->mprr_3[VERT_LEFT_PRED][1][7] = 
 1002|      0|    img->mprr_3[VERT_LEFT_PRED][3][6] = 
 1003|      0|    img->mprr_3[VERT_LEFT_PRED][5][5] = 
 1004|      0|    img->mprr_3[VERT_LEFT_PRED][7][4] = (P_H + P_J + 2*P_I + 2) >> 2;
 1005|      0|    img->mprr_3[VERT_LEFT_PRED][3][7] = 
 1006|      0|    img->mprr_3[VERT_LEFT_PRED][5][6] = 
 1007|      0|    img->mprr_3[VERT_LEFT_PRED][7][5] = (P_I + P_K + 2*P_J + 2) >> 2;
 1008|      0|    img->mprr_3[VERT_LEFT_PRED][5][7] = 
 1009|      0|    img->mprr_3[VERT_LEFT_PRED][7][6] = (P_J + P_L + 2*P_K + 2) >> 2;
 1010|      0|    img->mprr_3[VERT_LEFT_PRED][7][7] = (P_K + P_M + 2*P_L + 2) >> 2;
 1011|      0|  }
 1012|       |
 1013|       |  ///////////////////////////////////
 1014|       |  // make diagonal down right prediction
 1015|       |  ///////////////////////////////////
 1016|      0|  if (block_available_up && block_available_left && block_available_up_left) 
 1017|      0|  {
 1018|       |    // Mode DIAG_DOWN_RIGHT_PRED
 1019|      0|    img->mprr_3[DIAG_DOWN_RIGHT_PRED][7][0] = (P_X + P_V + 2*(P_W) + 2) >> 2;
 1020|      0|    img->mprr_3[DIAG_DOWN_RIGHT_PRED][6][0] = 
 1021|      0|    img->mprr_3[DIAG_DOWN_RIGHT_PRED][7][1] = (P_W + P_U + 2*(P_V) + 2) >> 2;
 1022|      0|    img->mprr_3[DIAG_DOWN_RIGHT_PRED][5][0] = 
 1023|      0|    img->mprr_3[DIAG_DOWN_RIGHT_PRED][6][1] = 
 1024|      0|    img->mprr_3[DIAG_DOWN_RIGHT_PRED][7][2] = (P_V + P_T + 2*(P_U) + 2) >> 2;
 1025|      0|    img->mprr_3[DIAG_DOWN_RIGHT_PRED][4][0] = 
 1026|      0|    img->mprr_3[DIAG_DOWN_RIGHT_PRED][5][1] = 
 1027|      0|    img->mprr_3[DIAG_DOWN_RIGHT_PRED][6][2] = 
 1028|      0|    img->mprr_3[DIAG_DOWN_RIGHT_PRED][7][3] = (P_U + P_S + 2*(P_T) + 2) >> 2;
 1029|      0|    img->mprr_3[DIAG_DOWN_RIGHT_PRED][3][0] = 
 1030|      0|    img->mprr_3[DIAG_DOWN_RIGHT_PRED][4][1] = 
 1031|      0|    img->mprr_3[DIAG_DOWN_RIGHT_PRED][5][2] = 
 1032|      0|    img->mprr_3[DIAG_DOWN_RIGHT_PRED][6][3] = 
 1033|      0|    img->mprr_3[DIAG_DOWN_RIGHT_PRED][7][4] = (P_T + P_R + 2*(P_S) + 2) >> 2;
 1034|      0|    img->mprr_3[DIAG_DOWN_RIGHT_PRED][2][0] = 
 1035|      0|    img->mprr_3[DIAG_DOWN_RIGHT_PRED][3][1] = 
 1036|      0|    img->mprr_3[DIAG_DOWN_RIGHT_PRED][4][2] = 
 1037|      0|    img->mprr_3[DIAG_DOWN_RIGHT_PRED][5][3] = 
 1038|      0|    img->mprr_3[DIAG_DOWN_RIGHT_PRED][6][4] = 
 1039|      0|    img->mprr_3[DIAG_DOWN_RIGHT_PRED][7][5] = (P_S + P_Q + 2*(P_R) + 2) >> 2;
 1040|      0|    img->mprr_3[DIAG_DOWN_RIGHT_PRED][1][0] = 
 1041|      0|    img->mprr_3[DIAG_DOWN_RIGHT_PRED][2][1] = 
 1042|      0|    img->mprr_3[DIAG_DOWN_RIGHT_PRED][3][2] = 
 1043|      0|    img->mprr_3[DIAG_DOWN_RIGHT_PRED][4][3] = 
 1044|      0|    img->mprr_3[DIAG_DOWN_RIGHT_PRED][5][4] = 
 1045|      0|    img->mprr_3[DIAG_DOWN_RIGHT_PRED][6][5] = 
 1046|      0|    img->mprr_3[DIAG_DOWN_RIGHT_PRED][7][6] = (P_R + P_Z + 2*(P_Q) + 2) >> 2;
 1047|      0|    img->mprr_3[DIAG_DOWN_RIGHT_PRED][0][0] = 
 1048|      0|    img->mprr_3[DIAG_DOWN_RIGHT_PRED][1][1] = 
 1049|      0|    img->mprr_3[DIAG_DOWN_RIGHT_PRED][2][2] = 
 1050|      0|    img->mprr_3[DIAG_DOWN_RIGHT_PRED][3][3] = 
 1051|      0|    img->mprr_3[DIAG_DOWN_RIGHT_PRED][4][4] = 
 1052|      0|    img->mprr_3[DIAG_DOWN_RIGHT_PRED][5][5] = 
 1053|      0|    img->mprr_3[DIAG_DOWN_RIGHT_PRED][6][6] = 
 1054|      0|    img->mprr_3[DIAG_DOWN_RIGHT_PRED][7][7] = (P_Q + P_A + 2*(P_Z) + 2) >> 2;
 1055|      0|    img->mprr_3[DIAG_DOWN_RIGHT_PRED][0][1] = 
 1056|      0|    img->mprr_3[DIAG_DOWN_RIGHT_PRED][1][2] = 
 1057|      0|    img->mprr_3[DIAG_DOWN_RIGHT_PRED][2][3] = 
 1058|      0|    img->mprr_3[DIAG_DOWN_RIGHT_PRED][3][4] = 
 1059|      0|    img->mprr_3[DIAG_DOWN_RIGHT_PRED][4][5] = 
 1060|      0|    img->mprr_3[DIAG_DOWN_RIGHT_PRED][5][6] = 
 1061|      0|    img->mprr_3[DIAG_DOWN_RIGHT_PRED][6][7] = (P_Z + P_B + 2*(P_A) + 2) >> 2;
 1062|      0|    img->mprr_3[DIAG_DOWN_RIGHT_PRED][0][2] = 
 1063|      0|    img->mprr_3[DIAG_DOWN_RIGHT_PRED][1][3] = 
 1064|      0|    img->mprr_3[DIAG_DOWN_RIGHT_PRED][2][4] = 
 1065|      0|    img->mprr_3[DIAG_DOWN_RIGHT_PRED][3][5] = 
 1066|      0|    img->mprr_3[DIAG_DOWN_RIGHT_PRED][4][6] = 
 1067|      0|    img->mprr_3[DIAG_DOWN_RIGHT_PRED][5][7] = (P_A + P_C + 2*(P_B) + 2) >> 2;
 1068|      0|    img->mprr_3[DIAG_DOWN_RIGHT_PRED][0][3] = 
 1069|      0|    img->mprr_3[DIAG_DOWN_RIGHT_PRED][1][4] = 
 1070|      0|    img->mprr_3[DIAG_DOWN_RIGHT_PRED][2][5] = 
 1071|      0|    img->mprr_3[DIAG_DOWN_RIGHT_PRED][3][6] = 
 1072|      0|    img->mprr_3[DIAG_DOWN_RIGHT_PRED][4][7] = (P_B + P_D + 2*(P_C) + 2) >> 2;
 1073|      0|    img->mprr_3[DIAG_DOWN_RIGHT_PRED][0][4] = 
 1074|      0|    img->mprr_3[DIAG_DOWN_RIGHT_PRED][1][5] = 
 1075|      0|    img->mprr_3[DIAG_DOWN_RIGHT_PRED][2][6] = 
 1076|      0|    img->mprr_3[DIAG_DOWN_RIGHT_PRED][3][7] = (P_C + P_E + 2*(P_D) + 2) >> 2;
 1077|      0|    img->mprr_3[DIAG_DOWN_RIGHT_PRED][0][5] = 
 1078|      0|    img->mprr_3[DIAG_DOWN_RIGHT_PRED][1][6] = 
 1079|      0|    img->mprr_3[DIAG_DOWN_RIGHT_PRED][2][7] = (P_D + P_F + 2*(P_E) + 2) >> 2;
 1080|      0|    img->mprr_3[DIAG_DOWN_RIGHT_PRED][0][6] = 
 1081|      0|    img->mprr_3[DIAG_DOWN_RIGHT_PRED][1][7] = (P_E + P_G + 2*(P_F) + 2) >> 2;
 1082|      0|    img->mprr_3[DIAG_DOWN_RIGHT_PRED][0][7] = (P_F + P_H + 2*(P_G) + 2) >> 2;
 1083|       |
 1084|       |  ///////////////////////////////////
 1085|       |  // make vertical right prediction
 1086|       |  ///////////////////////////////////
 1087|      0|    img->mprr_3[VERT_RIGHT_PRED][0][0] = 
 1088|      0|    img->mprr_3[VERT_RIGHT_PRED][2][1] = 
 1089|      0|    img->mprr_3[VERT_RIGHT_PRED][4][2] = 
 1090|      0|    img->mprr_3[VERT_RIGHT_PRED][6][3] = (P_Z + P_A + 1) >> 1;
 1091|      0|    img->mprr_3[VERT_RIGHT_PRED][0][1] = 
 1092|      0|    img->mprr_3[VERT_RIGHT_PRED][2][2] = 
 1093|      0|    img->mprr_3[VERT_RIGHT_PRED][4][3] = 
 1094|      0|    img->mprr_3[VERT_RIGHT_PRED][6][4] = (P_A + P_B + 1) >> 1;
 1095|      0|    img->mprr_3[VERT_RIGHT_PRED][0][2] = 
 1096|      0|    img->mprr_3[VERT_RIGHT_PRED][2][3] = 
 1097|      0|    img->mprr_3[VERT_RIGHT_PRED][4][4] = 
 1098|      0|    img->mprr_3[VERT_RIGHT_PRED][6][5] = (P_B + P_C + 1) >> 1;
 1099|      0|    img->mprr_3[VERT_RIGHT_PRED][0][3] = 
 1100|      0|    img->mprr_3[VERT_RIGHT_PRED][2][4] = 
 1101|      0|    img->mprr_3[VERT_RIGHT_PRED][4][5] = 
 1102|      0|    img->mprr_3[VERT_RIGHT_PRED][6][6] = (P_C + P_D + 1) >> 1;
 1103|      0|    img->mprr_3[VERT_RIGHT_PRED][0][4] = 
 1104|      0|    img->mprr_3[VERT_RIGHT_PRED][2][5] = 
 1105|      0|    img->mprr_3[VERT_RIGHT_PRED][4][6] = 
 1106|      0|    img->mprr_3[VERT_RIGHT_PRED][6][7] = (P_D + P_E + 1) >> 1;
 1107|      0|    img->mprr_3[VERT_RIGHT_PRED][0][5] = 
 1108|      0|    img->mprr_3[VERT_RIGHT_PRED][2][6] = 
 1109|      0|    img->mprr_3[VERT_RIGHT_PRED][4][7] = (P_E + P_F + 1) >> 1;
 1110|      0|    img->mprr_3[VERT_RIGHT_PRED][0][6] = 
 1111|      0|    img->mprr_3[VERT_RIGHT_PRED][2][7] = (P_F + P_G + 1) >> 1;
 1112|      0|    img->mprr_3[VERT_RIGHT_PRED][0][7] = (P_G + P_H + 1) >> 1;
 1113|      0|    img->mprr_3[VERT_RIGHT_PRED][1][0] = 
 1114|      0|    img->mprr_3[VERT_RIGHT_PRED][3][1] = 
 1115|      0|    img->mprr_3[VERT_RIGHT_PRED][5][2] = 
 1116|      0|    img->mprr_3[VERT_RIGHT_PRED][7][3] = (P_Q + P_A + 2*P_Z + 2) >> 2;
 1117|      0|    img->mprr_3[VERT_RIGHT_PRED][1][1] = 
 1118|      0|    img->mprr_3[VERT_RIGHT_PRED][3][2] = 
 1119|      0|    img->mprr_3[VERT_RIGHT_PRED][5][3] = 
 1120|      0|    img->mprr_3[VERT_RIGHT_PRED][7][4] = (P_Z + P_B + 2*P_A + 2) >> 2;
 1121|      0|    img->mprr_3[VERT_RIGHT_PRED][1][2] = 
 1122|      0|    img->mprr_3[VERT_RIGHT_PRED][3][3] = 
 1123|      0|    img->mprr_3[VERT_RIGHT_PRED][5][4] = 
 1124|      0|    img->mprr_3[VERT_RIGHT_PRED][7][5] = (P_A + P_C + 2*P_B + 2) >> 2;
 1125|      0|    img->mprr_3[VERT_RIGHT_PRED][1][3] = 
 1126|      0|    img->mprr_3[VERT_RIGHT_PRED][3][4] = 
 1127|      0|    img->mprr_3[VERT_RIGHT_PRED][5][5] = 
 1128|      0|    img->mprr_3[VERT_RIGHT_PRED][7][6] = (P_B + P_D + 2*P_C + 2) >> 2;
 1129|      0|    img->mprr_3[VERT_RIGHT_PRED][1][4] = 
 1130|      0|    img->mprr_3[VERT_RIGHT_PRED][3][5] = 
 1131|      0|    img->mprr_3[VERT_RIGHT_PRED][5][6] = 
 1132|      0|    img->mprr_3[VERT_RIGHT_PRED][7][7] = (P_C + P_E + 2*P_D + 2) >> 2;
 1133|      0|    img->mprr_3[VERT_RIGHT_PRED][1][5] = 
 1134|      0|    img->mprr_3[VERT_RIGHT_PRED][3][6] = 
 1135|      0|    img->mprr_3[VERT_RIGHT_PRED][5][7] = (P_D + P_F + 2*P_E + 2) >> 2;
 1136|      0|    img->mprr_3[VERT_RIGHT_PRED][1][6] = 
 1137|      0|    img->mprr_3[VERT_RIGHT_PRED][3][7] = (P_E + P_G + 2*P_F + 2) >> 2;
 1138|      0|    img->mprr_3[VERT_RIGHT_PRED][1][7] = (P_F + P_H + 2*P_G + 2) >> 2;
 1139|      0|    img->mprr_3[VERT_RIGHT_PRED][2][0] =
 1140|      0|    img->mprr_3[VERT_RIGHT_PRED][4][1] =
 1141|      0|    img->mprr_3[VERT_RIGHT_PRED][6][2] = (P_R + P_Z + 2*P_Q + 2) >> 2;
 1142|      0|    img->mprr_3[VERT_RIGHT_PRED][3][0] =
 1143|      0|    img->mprr_3[VERT_RIGHT_PRED][5][1] =
 1144|      0|    img->mprr_3[VERT_RIGHT_PRED][7][2] = (P_S + P_Q + 2*P_R + 2) >> 2;
 1145|      0|    img->mprr_3[VERT_RIGHT_PRED][4][0] =
 1146|      0|    img->mprr_3[VERT_RIGHT_PRED][6][1] = (P_T + P_R + 2*P_S + 2) >> 2;
 1147|      0|    img->mprr_3[VERT_RIGHT_PRED][5][0] =
 1148|      0|    img->mprr_3[VERT_RIGHT_PRED][7][1] = (P_U + P_S + 2*P_T + 2) >> 2;
 1149|      0|    img->mprr_3[VERT_RIGHT_PRED][6][0] = (P_V + P_T + 2*P_U + 2) >> 2;
 1150|      0|    img->mprr_3[VERT_RIGHT_PRED][7][0] = (P_W + P_U + 2*P_V + 2) >> 2;
 1151|       |
 1152|       |  ///////////////////////////////////
 1153|       |  // make horizontal down prediction
 1154|       |  ///////////////////////////////////
 1155|       |    
 1156|      0|    img->mprr_3[HOR_DOWN_PRED][0][0] = 
 1157|      0|    img->mprr_3[HOR_DOWN_PRED][1][2] = 
 1158|      0|    img->mprr_3[HOR_DOWN_PRED][2][4] = 
 1159|      0|    img->mprr_3[HOR_DOWN_PRED][3][6] = (P_Q + P_Z + 1) >> 1;
 1160|      0|    img->mprr_3[HOR_DOWN_PRED][1][0] = 
 1161|      0|    img->mprr_3[HOR_DOWN_PRED][2][2] = 
 1162|      0|    img->mprr_3[HOR_DOWN_PRED][3][4] = 
 1163|      0|    img->mprr_3[HOR_DOWN_PRED][4][6] = (P_R + P_Q + 1) >> 1;
 1164|      0|    img->mprr_3[HOR_DOWN_PRED][2][0] = 
 1165|      0|    img->mprr_3[HOR_DOWN_PRED][3][2] = 
 1166|      0|    img->mprr_3[HOR_DOWN_PRED][4][4] = 
 1167|      0|    img->mprr_3[HOR_DOWN_PRED][5][6] = (P_S + P_R + 1) >> 1;
 1168|      0|    img->mprr_3[HOR_DOWN_PRED][3][0] = 
 1169|      0|    img->mprr_3[HOR_DOWN_PRED][4][2] = 
 1170|      0|    img->mprr_3[HOR_DOWN_PRED][5][4] = 
 1171|      0|    img->mprr_3[HOR_DOWN_PRED][6][6] = (P_T + P_S + 1) >> 1;
 1172|      0|    img->mprr_3[HOR_DOWN_PRED][4][0] = 
 1173|      0|    img->mprr_3[HOR_DOWN_PRED][5][2] = 
 1174|      0|    img->mprr_3[HOR_DOWN_PRED][6][4] = 
 1175|      0|    img->mprr_3[HOR_DOWN_PRED][7][6] = (P_U + P_T + 1) >> 1;
 1176|      0|    img->mprr_3[HOR_DOWN_PRED][5][0] = 
 1177|      0|    img->mprr_3[HOR_DOWN_PRED][6][2] = 
 1178|      0|    img->mprr_3[HOR_DOWN_PRED][7][4] = (P_V + P_U + 1) >> 1;
 1179|      0|    img->mprr_3[HOR_DOWN_PRED][6][0] = 
 1180|      0|    img->mprr_3[HOR_DOWN_PRED][7][2] = (P_W + P_V + 1) >> 1;
 1181|      0|    img->mprr_3[HOR_DOWN_PRED][7][0] = (P_X + P_W + 1) >> 1;
 1182|      0|    img->mprr_3[HOR_DOWN_PRED][0][1] =
 1183|      0|    img->mprr_3[HOR_DOWN_PRED][1][3] =
 1184|      0|    img->mprr_3[HOR_DOWN_PRED][2][5] =
 1185|      0|    img->mprr_3[HOR_DOWN_PRED][3][7] = (P_Q + P_A + 2*P_Z + 2) >> 2;
 1186|      0|    img->mprr_3[HOR_DOWN_PRED][1][1] =
 1187|      0|    img->mprr_3[HOR_DOWN_PRED][2][3] =
 1188|      0|    img->mprr_3[HOR_DOWN_PRED][3][5] =
 1189|      0|    img->mprr_3[HOR_DOWN_PRED][4][7] = (P_Z + P_R + 2*P_Q + 2) >> 2;
 1190|      0|    img->mprr_3[HOR_DOWN_PRED][2][1] =
 1191|      0|    img->mprr_3[HOR_DOWN_PRED][3][3] =
 1192|      0|    img->mprr_3[HOR_DOWN_PRED][4][5] =
 1193|      0|    img->mprr_3[HOR_DOWN_PRED][5][7] = (P_Q + P_S + 2*P_R + 2) >> 2;
 1194|      0|    img->mprr_3[HOR_DOWN_PRED][3][1] =
 1195|      0|    img->mprr_3[HOR_DOWN_PRED][4][3] =
 1196|      0|    img->mprr_3[HOR_DOWN_PRED][5][5] =
 1197|      0|    img->mprr_3[HOR_DOWN_PRED][6][7] = (P_R + P_T + 2*P_S + 2) >> 2;
 1198|      0|    img->mprr_3[HOR_DOWN_PRED][4][1] =
 1199|      0|    img->mprr_3[HOR_DOWN_PRED][5][3] =
 1200|      0|    img->mprr_3[HOR_DOWN_PRED][6][5] =
 1201|      0|    img->mprr_3[HOR_DOWN_PRED][7][7] = (P_S + P_U + 2*P_T + 2) >> 2;
 1202|      0|    img->mprr_3[HOR_DOWN_PRED][5][1] =
 1203|      0|    img->mprr_3[HOR_DOWN_PRED][6][3] =
 1204|      0|    img->mprr_3[HOR_DOWN_PRED][7][5] = (P_T + P_V + 2*P_U + 2) >> 2;
 1205|      0|    img->mprr_3[HOR_DOWN_PRED][6][1] =
 1206|      0|    img->mprr_3[HOR_DOWN_PRED][7][3] = (P_U + P_W + 2*P_V + 2) >> 2;
 1207|      0|    img->mprr_3[HOR_DOWN_PRED][7][1] = (P_V + P_X + 2*P_W + 2) >> 2;
 1208|      0|    img->mprr_3[HOR_DOWN_PRED][0][2] = 
 1209|      0|    img->mprr_3[HOR_DOWN_PRED][1][4] = 
 1210|      0|    img->mprr_3[HOR_DOWN_PRED][2][6] = (P_Z + P_B + 2*P_A + 2) >> 2;
 1211|      0|    img->mprr_3[HOR_DOWN_PRED][0][3] = 
 1212|      0|    img->mprr_3[HOR_DOWN_PRED][1][5] = 
 1213|      0|    img->mprr_3[HOR_DOWN_PRED][2][7] = (P_A + P_C + 2*P_B + 2) >> 2;
 1214|      0|    img->mprr_3[HOR_DOWN_PRED][0][4] = 
 1215|      0|    img->mprr_3[HOR_DOWN_PRED][1][6] = (P_B + P_D + 2*P_C + 2) >> 2;
 1216|      0|    img->mprr_3[HOR_DOWN_PRED][0][5] = 
 1217|      0|    img->mprr_3[HOR_DOWN_PRED][1][7] = (P_C + P_E + 2*P_D + 2) >> 2;
 1218|      0|    img->mprr_3[HOR_DOWN_PRED][0][6] = (P_D + P_F + 2*P_E + 2) >> 2;
 1219|      0|    img->mprr_3[HOR_DOWN_PRED][0][7] = (P_E + P_G + 2*P_F + 2) >> 2;
 1220|      0|  }
 1221|       |
 1222|       |  ///////////////////////////////////
 1223|       |  // make horizontal up prediction
 1224|       |  ///////////////////////////////////
 1225|      0|  if (block_available_left)
 1226|      0|  {
 1227|      0|    img->mprr_3[HOR_UP_PRED][0][0] = (P_Q + P_R + 1) >> 1;
 1228|      0|    img->mprr_3[HOR_UP_PRED][1][0] =
 1229|      0|    img->mprr_3[HOR_UP_PRED][0][2] = (P_R + P_S + 1) >> 1;
 1230|      0|    img->mprr_3[HOR_UP_PRED][2][0] =
 1231|      0|    img->mprr_3[HOR_UP_PRED][1][2] =
 1232|      0|    img->mprr_3[HOR_UP_PRED][0][4] = (P_S + P_T + 1) >> 1;
 1233|      0|    img->mprr_3[HOR_UP_PRED][3][0] =
 1234|      0|    img->mprr_3[HOR_UP_PRED][2][2] =
 1235|      0|    img->mprr_3[HOR_UP_PRED][1][4] =
 1236|      0|    img->mprr_3[HOR_UP_PRED][0][6] = (P_T + P_U + 1) >> 1;
 1237|      0|    img->mprr_3[HOR_UP_PRED][4][0] =
 1238|      0|    img->mprr_3[HOR_UP_PRED][3][2] =
 1239|      0|    img->mprr_3[HOR_UP_PRED][2][4] =
 1240|      0|    img->mprr_3[HOR_UP_PRED][1][6] = (P_U + P_V + 1) >> 1;
 1241|      0|    img->mprr_3[HOR_UP_PRED][5][0] =
 1242|      0|    img->mprr_3[HOR_UP_PRED][4][2] =
 1243|      0|    img->mprr_3[HOR_UP_PRED][3][4] =
 1244|      0|    img->mprr_3[HOR_UP_PRED][2][6] = (P_V + P_W + 1) >> 1;
 1245|      0|    img->mprr_3[HOR_UP_PRED][6][0] =
 1246|      0|    img->mprr_3[HOR_UP_PRED][5][2] =
 1247|      0|    img->mprr_3[HOR_UP_PRED][4][4] =
 1248|      0|    img->mprr_3[HOR_UP_PRED][3][6] = (P_W + P_X + 1) >> 1;
 1249|      0|    img->mprr_3[HOR_UP_PRED][4][6] =
 1250|      0|    img->mprr_3[HOR_UP_PRED][4][7] =
 1251|      0|    img->mprr_3[HOR_UP_PRED][5][4] =
 1252|      0|    img->mprr_3[HOR_UP_PRED][5][5] =
 1253|      0|    img->mprr_3[HOR_UP_PRED][5][6] =
 1254|      0|    img->mprr_3[HOR_UP_PRED][5][7] =
 1255|      0|    img->mprr_3[HOR_UP_PRED][6][2] =
 1256|      0|    img->mprr_3[HOR_UP_PRED][6][3] =
 1257|      0|    img->mprr_3[HOR_UP_PRED][6][4] =
 1258|      0|    img->mprr_3[HOR_UP_PRED][6][5] =
 1259|      0|    img->mprr_3[HOR_UP_PRED][6][6] =
 1260|      0|    img->mprr_3[HOR_UP_PRED][6][7] =
 1261|      0|    img->mprr_3[HOR_UP_PRED][7][0] =
 1262|      0|    img->mprr_3[HOR_UP_PRED][7][1] =
 1263|      0|    img->mprr_3[HOR_UP_PRED][7][2] =
 1264|      0|    img->mprr_3[HOR_UP_PRED][7][3] =
 1265|      0|    img->mprr_3[HOR_UP_PRED][7][4] =
 1266|      0|    img->mprr_3[HOR_UP_PRED][7][5] =
 1267|      0|    img->mprr_3[HOR_UP_PRED][7][6] =
 1268|      0|    img->mprr_3[HOR_UP_PRED][7][7] = P_X;
 1269|      0|    img->mprr_3[HOR_UP_PRED][6][1] =
 1270|      0|    img->mprr_3[HOR_UP_PRED][5][3] =
 1271|      0|    img->mprr_3[HOR_UP_PRED][4][5] =
 1272|      0|    img->mprr_3[HOR_UP_PRED][3][7] = (P_W + 3*P_X + 2) >> 2;
 1273|      0|    img->mprr_3[HOR_UP_PRED][5][1] =
 1274|      0|    img->mprr_3[HOR_UP_PRED][4][3] =
 1275|      0|    img->mprr_3[HOR_UP_PRED][3][5] =
 1276|      0|    img->mprr_3[HOR_UP_PRED][2][7] = (P_X + P_V + 2*P_W + 2) >> 2;
 1277|      0|    img->mprr_3[HOR_UP_PRED][4][1] =
 1278|      0|    img->mprr_3[HOR_UP_PRED][3][3] =
 1279|      0|    img->mprr_3[HOR_UP_PRED][2][5] =
 1280|      0|    img->mprr_3[HOR_UP_PRED][1][7] = (P_W + P_U + 2*P_V + 2) >> 2;
 1281|      0|    img->mprr_3[HOR_UP_PRED][3][1] =
 1282|      0|    img->mprr_3[HOR_UP_PRED][2][3] =
 1283|      0|    img->mprr_3[HOR_UP_PRED][1][5] =
 1284|      0|    img->mprr_3[HOR_UP_PRED][0][7] = (P_V + P_T + 2*P_U + 2) >> 2;
 1285|      0|    img->mprr_3[HOR_UP_PRED][2][1] =
 1286|      0|    img->mprr_3[HOR_UP_PRED][1][3] =
 1287|      0|    img->mprr_3[HOR_UP_PRED][0][5] = (P_U + P_S + 2*P_T + 2) >> 2;
 1288|      0|    img->mprr_3[HOR_UP_PRED][1][1] =
 1289|      0|    img->mprr_3[HOR_UP_PRED][0][3] = (P_T + P_R + 2*P_S + 2) >> 2;
 1290|      0|    img->mprr_3[HOR_UP_PRED][0][1] = (P_S + P_Q + 2*P_R + 2) >> 2;
 1291|      0|  }
 1292|      0|}
 1293|       |
 1294|       |/*! 
 1295|       | *************************************************************************************
 1296|       | * \brief
 1297|       | *    Prefiltering for Intra8x8 prediction
 1298|       | *************************************************************************************
 1299|       | */
 1300|       |void LowPassForIntra8x8Pred(int *PredPel, int block_up_left, int block_up, int block_left)
 1301|      0|{
 1302|      0|  int i;
 1303|      0|  int LoopArray[25];
 1304|       | 
 1305|       |
 1306|      0|  for(i = 0; i < 25; i++)
 1307|      0|     LoopArray[i] = PredPel[i] ;
 1308|       |
 1309|      0| 	if(block_up)
 1310|      0|	{
 1311|      0|		if(block_up_left) 
 1312|      0|		{
 1313|      0|			LoopArray[1] = ((&P_Z)[0] + ((&P_Z)[1]<<1) + (&P_Z)[2] + 2)>>2;
 1314|      0|		}
 1315|      0|		else
 1316|      0|			LoopArray[1] = ((&P_Z)[1] + ((&P_Z)[1]<<1) + (&P_Z)[2] + 2)>>2; 
 1317|       |
 1318|       |
 1319|      0|		for(i = 2; i <16; i++)
 1320|      0|		{
 1321|      0|			LoopArray[i] = ((&P_Z)[i-1] + ((&P_Z)[i]<<1) + (&P_Z)[i+1] + 2)>>2;
 1322|      0|		}
 1323|      0|		LoopArray[16] = (P_P + (P_P<<1) + P_O + 2)>>2;
 1324|      0|	}
 1325|       |
 1326|      0|	if(block_up_left) 
 1327|      0|	{
 1328|       |		
 1329|      0|		if(block_up && block_left)
 1330|      0|		{
 1331|      0|				LoopArray[0] = (P_Q + (P_Z<<1) + P_A +2)>>2;
 1332|      0|		}
 1333|      0|		else
 1334|      0|		{
 1335|      0|			if(block_up)
 1336|      0|				LoopArray[0] = (P_Z + (P_Z<<1) + P_A +2)>>2;
 1337|      0|			else
 1338|      0|				if(block_left)
 1339|      0|					LoopArray[0] = (P_Z + (P_Z<<1) + P_Q +2)>>2;
 1340|      0|		}
 1341|       |
 1342|      0|	}
 1343|       |
 1344|      0|	if(block_left)
 1345|      0|	{
 1346|      0|		if(block_up_left)
 1347|      0|			LoopArray[17] = (P_Z + (P_Q<<1) + P_R + 2)>>2; 
 1348|      0|		else
 1349|      0|			LoopArray[17] = (P_Q + (P_Q<<1) + P_R + 2)>>2;
 1350|       |
 1351|      0|		for(i = 18; i <24; i++)
 1352|      0|		{
 1353|      0|			LoopArray[i] = ((&P_Z)[i-1] + ((&P_Z)[i]<<1) + (&P_Z)[i+1] + 2)>>2;
 1354|      0|		}
 1355|      0|		LoopArray[24] = (P_W + (P_X<<1) + P_X + 2)>>2;
 1356|      0|	}
 1357|       |
 1358|      0|  for(i = 0; i < 25; i++)
 1359|      0|    PredPel[i] = LoopArray[i];
 1360|      0|}
 1361|       |
 1362|       |
 1363|       |
 1364|       |
 1365|       |
 1366|       |/*! 
 1367|       | *************************************************************************************
 1368|       | * \brief
 1369|       | *    R-D Cost for an 8x8 Intra block
 1370|       | *************************************************************************************
 1371|       | */
 1372|       |
 1373|       |double RDCost_for_8x8IntraBlocks(int *nonzero, int b8, int ipmode, double lambda, double min_rdcost, int mostProbableMode)
 1374|      0|{
 1375|      0|  double  rdcost = 0.0;
 1376|      0|  int     dummy, x, y, rate;
 1377|      0|  int64   distortion  = 0;
 1378|      0|  int     block_x     = 8*(b8%2);
 1379|      0|  int     block_y     = 8*(b8/2);
 1380|      0|  int     pic_pix_x   = img->pix_x+block_x;
 1381|      0|  int     pic_pix_y   = img->pix_y+block_y;
 1382|      0|  int     pic_opix_y  = img->opix_y+block_y;
 1383|      0|  imgpel    **imgY_orig  = imgY_org;
 1384|      0|  imgpel    **imgY       = enc_picture->imgY;
 1385|       |
 1386|      0|  Slice          *currSlice    =  img->currentSlice;
 1387|      0|  Macroblock     *currMB       = &img->mb_data[img->current_mb_nr];
 1388|      0|  SyntaxElement  *currSE       = &img->MB_SyntaxElements[currMB->currSEnr];
 1389|      0|  const int      *partMap      = assignSE2partition[input->partition_mode];
 1390|      0|  DataPartition  *dataPart;
 1391|       |
 1392|       |  //===== perform DCT, Q, IQ, IDCT, Reconstruction =====
 1393|      0|  dummy = 0;
 1394|       |
 1395|      0|  *nonzero = dct_luma8x8 (b8, &dummy, 1);
 1396|       |
 1397|       |  //===== get distortion (SSD) of 8x8 block =====
 1398|      0|  for (y=0; y<8; y++)
 1399|      0|    for (x=pic_pix_x; x<pic_pix_x+8; x++)  
 1400|      0|      distortion += img->quad [imgY_orig[pic_opix_y+y][x] - imgY[pic_pix_y+y][x]];
 1401|       |
 1402|       |  //===== RATE for INTRA PREDICTION MODE  (SYMBOL MODE MUST BE SET TO UVLC) =====
 1403|      0|  currSE->value1 = (mostProbableMode == ipmode) ? -1 : ipmode < mostProbableMode ? ipmode : ipmode-1;
 1404|       |
 1405|       |  //--- set position and type ---
 1406|      0|  currSE->context = b8;
 1407|      0|  currSE->type    = SE_INTRAPREDMODE;
 1408|       |
 1409|       |  //--- set function pointer ----
 1410|      0|  if (input->symbol_mode != UVLC)    
 1411|      0|    currSE->writing = writeIntraPredMode_CABAC;
 1412|       |
 1413|       |  //--- choose data partition ---
 1414|      0|  if (img->type!=B_SLICE)
 1415|      0|    dataPart = &(currSlice->partArr[partMap[SE_INTRAPREDMODE]]);
 1416|      0|  else
 1417|      0|    dataPart = &(currSlice->partArr[partMap[SE_BFRAME]]);
 1418|       |
 1419|       |  //--- encode and update rate ---
 1420|      0|  if (input->symbol_mode == UVLC)
 1421|      0|    writeSyntaxElement_Intra4x4PredictionMode(currSE, dataPart);
 1422|      0|  else
 1423|      0|    dataPart->writeSyntaxElement (currSE, dataPart);
 1424|       |
 1425|      0|  rate = currSE->len;
 1426|      0|  currSE++;
 1427|      0|  currMB->currSEnr++;
 1428|       |
 1429|       |  //===== RATE for LUMINANCE COEFFICIENTS =====
 1430|       |
 1431|      0|  if (input->symbol_mode == UVLC)
 1432|      0|  {
 1433|      0|	int b4;
 1434|      0|	for(b4=0; b4<4; b4++)
 1435|      0|		rate  += writeCoeff4x4_CAVLC (LUMA, b8, b4, 0);
 1436|      0|  }
 1437|      0|  else
 1438|      0|  {
 1439|      0|    rate  += writeLumaCoeff8x8_CABAC (b8, 1);
 1440|      0|  }
 1441|       |
 1442|       |
 1443|      0|  rdcost = (double)distortion + lambda*(double)rate;
 1444|       |
 1445|      0|  if(img->residue_transform_flag)
 1446|      0|    return (double)rate;
 1447|      0|  else
 1448|      0|    return rdcost;
 1449|      0|}
 1450|       |
 1451|       |
 1452|       |/*!
 1453|       | ************************************************************************
 1454|       | * \brief
 1455|       | *    The routine performs transform,quantization,inverse transform, adds the diff.
 1456|       | *    to the prediction and writes the result to the decoded luma frame. Includes the
 1457|       | *    RD constrained quantization also.
 1458|       | *
 1459|       | * \par Input:
 1460|       | *    b8: Block position inside a macro block (0,1,2,3).
 1461|       | *
 1462|       | * \par Output:
 1463|       | *    nonzero: 0 if no levels are nonzero.  1 if there are nonzero levels.  
 1464|       | *    coeff_cost: Counter for nonzero coefficients, used to discard expensive levels.
 1465|       | ************************************************************************
 1466|       | */
 1467|       |
 1468|      0|#define MC(coeff) ((coeff)&3)
 1469|       |
 1470|       |int dct_luma8x8(int b8,int *coeff_cost, int intra)
 1471|      0|{
 1472|      0|  int sign(int a,int b);
 1473|       |
 1474|      0|  int i,j,ilev,coeff_ctr;
 1475|      0|  int qp_const,level,scan_pos,run;
 1476|      0|  int nonzero;
 1477|      0|  int qp_per,qp_rem,q_bits;
 1478|      0|  int dq_lshift = 0, dq_rshift = 0, dq_round = 0;
 1479|       |
 1480|      0|  int block_x = 8*(b8%2);
 1481|      0|  int block_y = 8*(b8/2);
 1482|      0|  int*  ACLevel = img->cofAC[b8][0][0];
 1483|      0|  int*  ACRun   = img->cofAC[b8][0][1];
 1484|      0|  int m6[8][8];
 1485|      0|  int scan_poss[4],runs[4];
 1486|       |
 1487|      0|  Macroblock *currMB = &img->mb_data[img->current_mb_nr];
 1488|      0|  Boolean lossless_qpprime = ((img->qp + img->bitdepth_luma_qp_scale)==0 && img->lossless_qpprime_flag==1);
 1489|       |  
 1490|      0|  qp_per    = (img->qp + img->bitdepth_luma_qp_scale - MIN_QP)/6;
 1491|      0|  qp_rem    = (img->qp + img->bitdepth_luma_qp_scale - MIN_QP)%6;
 1492|      0|  q_bits    = Q_BITS_8+qp_per;
 1493|       |
 1494|      0|  if (qp_per < 6)
 1495|      0|  {
 1496|      0|    dq_rshift = 6 - qp_per;
 1497|      0|    dq_round  = 1<<(5-qp_per);
 1498|      0|  }
 1499|      0|  else
 1500|      0|    dq_lshift = qp_per - 6;
 1501|       |
 1502|       |/*
 1503|       |  if (intra == 1)
 1504|       |    qp_const=(1<<q_bits)/3;
 1505|       |  else 
 1506|       |    qp_const=(1<<q_bits)/6;
 1507|       |*/
 1508|       |  
 1509|      0|  if (img->type == I_SLICE)
 1510|      0|    qp_const=(1<<q_bits)/3;    // intra
 1511|      0|  else
 1512|      0|    qp_const=(1<<q_bits)/6;    // inter
 1513|       |  
 1514|       |
 1515|       |  // horizontal transform
 1516|      0|  for( i=0; i<8 && !lossless_qpprime; i++)
 1517|      0|  {
 1518|      0|    int a[8], b[8];
 1519|      0|    a[0] = img->m7[0][i] + img->m7[7][i];
 1520|      0|    a[1] = img->m7[1][i] + img->m7[6][i];
 1521|      0|    a[2] = img->m7[2][i] + img->m7[5][i];
 1522|      0|    a[3] = img->m7[3][i] + img->m7[4][i];
 1523|       |
 1524|      0|    b[0] = a[0] + a[3];
 1525|      0|    b[1] = a[1] + a[2];
 1526|      0|    b[2] = a[0] - a[3];
 1527|      0|    b[3] = a[1] - a[2];
 1528|       |
 1529|      0|    a[4] = img->m7[0][i] - img->m7[7][i];
 1530|      0|    a[5] = img->m7[1][i] - img->m7[6][i];
 1531|      0|    a[6] = img->m7[2][i] - img->m7[5][i];
 1532|      0|    a[7] = img->m7[3][i] - img->m7[4][i];
 1533|       |
 1534|      0|    b[4]= a[5] + a[6] + ((a[4]>>1) + a[4]);
 1535|      0|    b[5]= a[4] - a[7] - ((a[6]>>1) + a[6]);
 1536|      0|    b[6]= a[4] + a[7] - ((a[5]>>1) + a[5]);
 1537|      0|    b[7]= a[5] - a[6] + ((a[7]>>1) + a[7]);
 1538|       |
 1539|      0|    m6[0][i] = b[0] + b[1];
 1540|      0|    m6[2][i] = b[2] + (b[3]>>1);
 1541|      0|    m6[4][i] = b[0] - b[1];
 1542|      0|    m6[6][i] = (b[2]>>1) - b[3];
 1543|      0|    m6[1][i] =   b[4] + (b[7]>>2);
 1544|      0|    m6[3][i] =   b[5] + (b[6]>>2);
 1545|      0|    m6[5][i] =   b[6] - (b[5]>>2);
 1546|      0|    m6[7][i] = - b[7] + (b[4]>>2);
 1547|       |
 1548|      0|  }
 1549|       |  // vertical transform
 1550|      0|  for( i=0; i<8 && !lossless_qpprime; i++)
 1551|      0|  {
 1552|      0|    int a[8], b[8];
 1553|      0|    a[0] = m6[i][0] + m6[i][7];
 1554|      0|    a[1] = m6[i][1] + m6[i][6];
 1555|      0|    a[2] = m6[i][2] + m6[i][5];
 1556|      0|    a[3] = m6[i][3] + m6[i][4];
 1557|       |    
 1558|      0|    b[0] = a[0] + a[3];
 1559|      0|    b[1] = a[1] + a[2];
 1560|      0|    b[2] = a[0] - a[3];
 1561|      0|    b[3] = a[1] - a[2];
 1562|       |    
 1563|      0|    a[4] = m6[i][0] - m6[i][7];
 1564|      0|    a[5] = m6[i][1] - m6[i][6];
 1565|      0|    a[6] = m6[i][2] - m6[i][5];
 1566|      0|    a[7] = m6[i][3] - m6[i][4];
 1567|       |    
 1568|      0|    b[4]= a[5] + a[6] + ((a[4]>>1) + a[4]);
 1569|      0|    b[5]= a[4] - a[7] - ((a[6]>>1) + a[6]);
 1570|      0|    b[6]= a[4] + a[7] - ((a[5]>>1) + a[5]);
 1571|      0|    b[7]= a[5] - a[6] + ((a[7]>>1) + a[7]);
 1572|       |    
 1573|      0|    img->m7[i][0] = b[0] + b[1];
 1574|      0|    img->m7[i][2] = b[2] + (b[3]>>1);
 1575|      0|    img->m7[i][4] = b[0] - b[1];
 1576|      0|    img->m7[i][6] = (b[2]>>1) - b[3];
 1577|      0|    img->m7[i][1] =   b[4] + (b[7]>>2);
 1578|      0|    img->m7[i][3] =   b[5] + (b[6]>>2);
 1579|      0|    img->m7[i][5] =   b[6] - (b[5]>>2);
 1580|      0|    img->m7[i][7] = - b[7] + (b[4]>>2);
 1581|      0|  }
 1582|       |
 1583|       |
 1584|       |  // Quant
 1585|       |  
 1586|      0|  nonzero=FALSE;
 1587|       |  
 1588|      0|  run=-1;
 1589|      0|  scan_pos=0;
 1590|       |  
 1591|      0|  runs[0]=runs[1]=runs[2]=runs[3]=-1;
 1592|      0|  scan_poss[0]=scan_poss[1]=scan_poss[2]=scan_poss[3]=0;
 1593|       |  
 1594|      0|  for (coeff_ctr=0;coeff_ctr < 64;coeff_ctr++)
 1595|      0|  {
 1596|       |    
 1597|      0|    if (img->field_picture || ( img->MbaffFrameFlag && currMB->mb_field )) 
 1598|      0|    {  // Alternate scan for field coding
 1599|      0|      i=FIELD_SCAN8x8[coeff_ctr][0];
 1600|      0|      j=FIELD_SCAN8x8[coeff_ctr][1];
 1601|      0|    }
 1602|      0|    else 
 1603|      0|    {
 1604|      0|      i=SNGL_SCAN8x8[coeff_ctr][0];
 1605|      0|      j=SNGL_SCAN8x8[coeff_ctr][1];
 1606|      0|    }
 1607|       |    
 1608|      0|    run++;
 1609|      0|    ilev=0;
 1610|       |    
 1611|      0|    runs[MC(coeff_ctr)]++;
 1612|       |    
 1613|      0|    if(lossless_qpprime)
 1614|      0|      level = abs (img->m7[i][j]);
 1615|      0|    else if(intra == 1)      
 1616|      0|      level = (abs (img->m7[i][j]) * LevelScale8x8Luma_Intra[qp_rem][i][j] + LevelOffset8x8Luma_Intra[qp_per][i][j]) >> q_bits;
 1617|       |    //level = (abs (img->m7[i][j]) * LevelScale8x8Luma_Intra[qp_rem][i][j] + qp_const) >> q_bits;
 1618|      0|    else
 1619|      0|      level = (abs (img->m7[i][j]) * LevelScale8x8Luma_Inter[qp_rem][i][j] + LevelOffset8x8Luma_Inter[qp_per][i][j]) >> q_bits;
 1620|       |    //level = (abs (img->m7[i][j]) * LevelScale8x8Luma_Inter[qp_rem][i][j] + qp_const) >> q_bits;
 1621|       |    
 1622|      0|    if (level != 0)
 1623|      0|    {
 1624|      0|      nonzero=TRUE;
 1625|       |      
 1626|      0|      if (currMB->luma_transform_size_8x8_flag && input->symbol_mode == UVLC)
 1627|      0|      {
 1628|      0|        if (level > 1)
 1629|      0|          *coeff_cost += MAX_VALUE;                // set high cost, shall not be discarded
 1630|      0|        else
 1631|      0|          *coeff_cost += COEFF_COST8x8[input->disthres][runs[MC(coeff_ctr)]];
 1632|       |        
 1633|      0|        img->cofAC[b8][MC(coeff_ctr)][0][scan_poss[MC(coeff_ctr)]] = sign(level,img->m7[i][j]);
 1634|      0|        img->cofAC[b8][MC(coeff_ctr)][1][scan_poss[MC(coeff_ctr)]] = runs[MC(coeff_ctr)];
 1635|      0|        ++scan_poss[MC(coeff_ctr)];
 1636|      0|        runs[MC(coeff_ctr)]=-1;
 1637|      0|      }
 1638|      0|      else
 1639|      0|      {
 1640|      0|        if (level > 1)
 1641|      0|          *coeff_cost += MAX_VALUE;                // set high cost, shall not be discarded
 1642|      0|        else
 1643|      0|          *coeff_cost += COEFF_COST8x8[input->disthres][run];
 1644|      0|        ACLevel[scan_pos] = sign(level,img->m7[i][j]);
 1645|      0|        ACRun  [scan_pos] = run;
 1646|      0|        ++scan_pos;
 1647|      0|        run=-1;                     // reset zero level counter
 1648|      0|      }      
 1649|      0|      level = sign(level, img->m7[i][j]);
 1650|      0|      if(lossless_qpprime)
 1651|      0|      {
 1652|      0|        ilev = level;
 1653|      0|      }
 1654|      0|      else if(intra == 1)
 1655|      0|      {
 1656|      0|        if (qp_per>=6)
 1657|      0|          ilev = level*InvLevelScale8x8Luma_Intra[qp_rem][i][j]<<dq_lshift; // dequantization
 1658|      0|        else
 1659|      0|          ilev = (level*InvLevelScale8x8Luma_Intra[qp_rem][i][j] + dq_round)>>dq_rshift; // dequantization
 1660|      0|      }
 1661|      0|      else
 1662|      0|      {
 1663|      0|        if (qp_per>=6)
 1664|      0|          ilev = level*InvLevelScale8x8Luma_Inter[qp_rem][i][j]<<dq_lshift; // dequantization
 1665|      0|        else
 1666|      0|          ilev = (level*InvLevelScale8x8Luma_Inter[qp_rem][i][j] + dq_round)>>dq_rshift; // dequantization
 1667|      0|      }
 1668|      0|    }
 1669|      0|    if(!lossless_qpprime)
 1670|      0|      img->m7[i][j] = ilev;
 1671|      0|  }
 1672|      0|  if (!currMB->luma_transform_size_8x8_flag || input->symbol_mode != UVLC)
 1673|      0|    ACLevel[scan_pos] = 0;
 1674|      0|  else
 1675|      0|    for(i=0; i<4; i++)
 1676|      0|      img->cofAC[b8][i][0][scan_poss[i]] = 0;
 1677|       |
 1678|       | 
 1679|       |
 1680|       | 
 1681|       |  
 1682|       |  //    Inverse Transform
 1683|       |  // horizontal inverse transform
 1684|      0|  for( i=0; i<8 && !lossless_qpprime; i++)
 1685|      0|  {
 1686|      0|    int a[8], b[8];
 1687|      0|    a[0] = img->m7[0][i] + img->m7[4][i];
 1688|      0|    a[4] = img->m7[0][i] - img->m7[4][i];
 1689|      0|    a[2] = (img->m7[2][i]>>1) - img->m7[6][i];
 1690|      0|    a[6] = img->m7[2][i] + (img->m7[6][i]>>1);
 1691|       |
 1692|      0|    b[0] = a[0] + a[6];
 1693|      0|    b[2] = a[4] + a[2];
 1694|      0|    b[4] = a[4] - a[2];
 1695|      0|    b[6] = a[0] - a[6];
 1696|       |
 1697|      0|    a[1] = -img->m7[3][i] + img->m7[5][i] - img->m7[7][i] - (img->m7[7][i]>>1);
 1698|      0|    a[3] = img->m7[1][i] + img->m7[7][i] - img->m7[3][i] - (img->m7[3][i]>>1);
 1699|      0|    a[5] = -img->m7[1][i] + img->m7[7][i] + img->m7[5][i] + (img->m7[5][i]>>1);
 1700|      0|    a[7] = img->m7[3][i] + img->m7[5][i] + img->m7[1][i] + (img->m7[1][i]>>1);
 1701|       |
 1702|      0|    b[1] = a[1] + (a[7]>>2);
 1703|      0|    b[7] = -(a[1]>>2) + a[7];
 1704|      0|    b[3] = a[3] + (a[5]>>2);
 1705|      0|    b[5] = (a[3]>>2) - a[5];
 1706|       |
 1707|      0|    m6[0][i] = b[0] + b[7];
 1708|      0|    m6[1][i] = b[2] + b[5];
 1709|      0|    m6[2][i] = b[4] + b[3];
 1710|      0|    m6[3][i] = b[6] + b[1];
 1711|      0|    m6[4][i] = b[6] - b[1];
 1712|      0|    m6[5][i] = b[4] - b[3];
 1713|      0|    m6[6][i] = b[2] - b[5];
 1714|      0|    m6[7][i] = b[0] - b[7];
 1715|      0|  }
 1716|       |
 1717|       |  // vertical inverse transform
 1718|      0|  for( i=0; i<8 && !lossless_qpprime; i++)
 1719|      0|  {
 1720|      0|    int a[8], b[8];
 1721|      0|    a[0] = m6[i][0] + m6[i][4];
 1722|      0|    a[4] = m6[i][0] - m6[i][4];
 1723|      0|    a[2] = (m6[i][2]>>1) - m6[i][6];
 1724|      0|    a[6] = m6[i][2] + (m6[i][6]>>1);
 1725|       |
 1726|      0|    b[0] = a[0] + a[6];
 1727|      0|    b[2] = a[4] + a[2];
 1728|      0|    b[4] = a[4] - a[2];
 1729|      0|    b[6] = a[0] - a[6];
 1730|       |
 1731|      0|    a[1] = -m6[i][3] + m6[i][5] - m6[i][7] - (m6[i][7]>>1);
 1732|      0|    a[3] = m6[i][1] + m6[i][7] - m6[i][3] - (m6[i][3]>>1);
 1733|      0|    a[5] = -m6[i][1] + m6[i][7] + m6[i][5] + (m6[i][5]>>1);
 1734|      0|    a[7] = m6[i][3] + m6[i][5] + m6[i][1] + (m6[i][1]>>1);
 1735|       |
 1736|      0|    b[1] = a[1] + (a[7]>>2);
 1737|      0|    b[7] = -(a[1]>>2) + a[7];
 1738|      0|    b[3] = a[3] + (a[5]>>2);
 1739|      0|    b[5] = (a[3]>>2) - a[5];
 1740|       |		
 1741|      0|    img->m7[i][0] = b[0] + b[7];
 1742|      0|    img->m7[i][1] = b[2] + b[5];
 1743|      0|    img->m7[i][2] = b[4] + b[3];
 1744|      0|    img->m7[i][3] = b[6] + b[1];
 1745|      0|    img->m7[i][4] = b[6] - b[1];
 1746|      0|    img->m7[i][5] = b[4] - b[3];
 1747|      0|    img->m7[i][6] = b[2] - b[5];
 1748|      0|    img->m7[i][7] = b[0] - b[7];
 1749|      0|  }
 1750|       | 
 1751|      0|  for( i=0; i<8; i++)
 1752|      0|    for( j=0; j<8; j++)
 1753|      0|    {
 1754|      0|      if(lossless_qpprime)
 1755|      0|        img->m7[i][j] = img->m7[i][j]+img->mpr[i+block_x][j+block_y];
 1756|      0|      else{
 1757|       |      // Residue Color Transform
 1758|      0|        if (!img->residue_transform_flag)
 1759|      0|          img->m7[i][j] =min(img->max_imgpel_value,max(0,(img->m7[i][j]+((long)img->mpr[i+block_x][j+block_y] << DQ_BITS_8)+DQ_ROUND_8)>>DQ_BITS_8));
 1760|      0|        else
 1761|      0|          img->m7[i][j] =(img->m7[i][j]+DQ_ROUND_8)>>DQ_BITS_8;
 1762|      0|      }
 1763|      0|    }
 1764|       |
 1765|       |
 1766|       |  //  Decoded block moved to frame memory
 1767|      0|  if (!img->residue_transform_flag)
 1768|      0|    for (j=0; j < 2*BLOCK_SIZE; j++)
 1769|      0|      for (i=0; i < 2*BLOCK_SIZE; i++)
 1770|      0|        enc_picture->imgY[img->pix_y+block_y+j][img->pix_x+block_x+i]=img->m7[i][j];
 1771|       |    
 1772|      0|  return nonzero;
 1773|      0|}
 1774|       |

/home/xzp/speccpu2006-v1.0.1/benchspec/CPU2006/464.h264ref/run/build_base_ql_riscv_llvm17.0000/vlc.c:
    1|       |
    2|       |/*!
    3|       | ***************************************************************************
    4|       | * \file vlc.c
    5|       | *
    6|       | * \brief
    7|       | *    (CA)VLC coding functions
    8|       | *
    9|       | * \author
   10|       | *    Main contributors (see contributors.h for copyright, address and affiliation details)
   11|       | *    - Inge Lille-Langoy               <inge.lille-langoy@telenor.com>
   12|       | *    - Detlev Marpe                    <marpe@hhi.de>
   13|       | *    - Stephan Wenger                  <stewe@cs.tu-berlin.de>
   14|       | ***************************************************************************
   15|       | */
   16|       |
   17|       |#include "contributors.h"
   18|       |
   19|       |#include <stdlib.h>
   20|       |#include <math.h>
   21|       |#include <string.h>
   22|       |#include <assert.h>
   23|       |
   24|       |#include "global.h"
   25|       |
   26|       |#include "vlc.h"
   27|       |
   28|       |#if TRACE
   29|       |#define SYMTRACESTRING(s) strncpy(sym.tracestring,s,TRACESTRING_SIZE)
   30|       |#else
   31|       |#define SYMTRACESTRING(s) // do nothing
   32|       |#endif
   33|       |
   34|       |
   35|       |/*! 
   36|       | *************************************************************************************
   37|       | * \brief
   38|       | *    ue_v, writes an ue(v) syntax element, returns the length in bits
   39|       | *
   40|       | * \param tracestring
   41|       | *    the string for the trace file
   42|       | * \param value
   43|       | *    the value to be coded
   44|       | *  \param part
   45|       | *    the Data Partition the value should be coded into
   46|       | *
   47|       | * \return
   48|       | *    Number of bits used by the coded syntax element
   49|       | *
   50|       | * \ note
   51|       | *    This function writes always the bit buffer for the progressive scan flag, and
   52|       | *    should not be used (or should be modified appropriately) for the interlace crap
   53|       | *    When used in the context of the Parameter Sets, this is obviously not a
   54|       | *    problem.
   55|       | *
   56|       | *************************************************************************************
   57|       | */
   58|       |int ue_v (char *tracestring, int value, DataPartition *part)
   59|    841|{
   60|    841|  SyntaxElement symbol, *sym=&symbol;
   61|    841|  sym->type = SE_HEADER;
   62|    841|  sym->mapping = ue_linfo;               // Mapping rule: unsigned integer
   63|    841|  sym->value1 = value;
   64|    841|  sym->value2 = 0;
   65|       |#if TRACE
   66|       |  strncpy(sym->tracestring,tracestring,TRACESTRING_SIZE);
   67|       |#endif
   68|    841|  assert (part->bitstream->streamBuffer != NULL);
   69|    841|  return writeSyntaxElement_UVLC (sym, part);
   70|    841|}
   71|       |
   72|       |
   73|       |/*! 
   74|       | *************************************************************************************
   75|       | * \brief
   76|       | *    se_v, writes an se(v) syntax element, returns the length in bits
   77|       | *
   78|       | * \param tracestring
   79|       | *    the string for the trace file
   80|       | * \param value
   81|       | *    the value to be coded
   82|       | *  \param part
   83|       | *    the Data Partition the value should be coded into
   84|       | *
   85|       | * \return
   86|       | *    Number of bits used by the coded syntax element
   87|       | *
   88|       | * \ note
   89|       | *    This function writes always the bit buffer for the progressive scan flag, and
   90|       | *    should not be used (or should be modified appropriately) for the interlace crap
   91|       | *    When used in the context of the Parameter Sets, this is obviously not a
   92|       | *    problem.
   93|       | *
   94|       | *************************************************************************************
   95|       | */
   96|       |int se_v (char *tracestring, int value, DataPartition *part)
   97|    174|{
   98|    174|  SyntaxElement symbol, *sym=&symbol;
   99|    174|  sym->type = SE_HEADER;
  100|    174|  sym->mapping = se_linfo;               // Mapping rule: signed integer
  101|    174|  sym->value1 = value;
  102|    174|  sym->value2 = 0;
  103|       |#if TRACE
  104|       |  strncpy(sym->tracestring,tracestring,TRACESTRING_SIZE);
  105|       |#endif
  106|    174|  assert (part->bitstream->streamBuffer != NULL);
  107|    174|  return writeSyntaxElement_UVLC (sym, part);
  108|    174|}
  109|       |
  110|       |
  111|       |/*! 
  112|       | *************************************************************************************
  113|       | * \brief
  114|       | *    u_1, writes a flag (u(1) syntax element, returns the length in bits, 
  115|       | *    always 1
  116|       | *
  117|       | * \param tracestring
  118|       | *    the string for the trace file
  119|       | * \param value
  120|       | *    the value to be coded
  121|       | *  \param part
  122|       | *    the Data Partition the value should be coded into
  123|       | *
  124|       | * \return
  125|       | *    Number of bits used by the coded syntax element (always 1)
  126|       | *
  127|       | * \ note
  128|       | *    This function writes always the bit buffer for the progressive scan flag, and
  129|       | *    should not be used (or should be modified appropriately) for the interlace crap
  130|       | *    When used in the context of the Parameter Sets, this is obviously not a
  131|       | *    problem.
  132|       | *
  133|       | *************************************************************************************
  134|       | */
  135|       |int u_1 (char *tracestring, int value, DataPartition *part)
  136|    556|{
  137|    556|  SyntaxElement symbol, *sym=&symbol;
  138|       |
  139|    556|  sym->bitpattern = value;
  140|    556|  sym->len = 1;
  141|    556|  sym->type = SE_HEADER;
  142|    556|  sym->value1 = value;
  143|    556|  sym->value2 = 0;
  144|       |#if TRACE
  145|       |  strncpy(sym->tracestring,tracestring,TRACESTRING_SIZE);
  146|       |#endif
  147|    556|  assert (part->bitstream->streamBuffer != NULL);
  148|    556|  return writeSyntaxElement_fixed(sym, part);
  149|    556|}
  150|       |
  151|       |
  152|       |/*! 
  153|       | *************************************************************************************
  154|       | * \brief
  155|       | *    u_v, writes a n bit fixed length syntax element, returns the length in bits, 
  156|       | *
  157|       | * \param n
  158|       | *    length in bits
  159|       | * \param tracestring
  160|       | *    the string for the trace file
  161|       | * \param value
  162|       | *    the value to be coded
  163|       | *  \param part
  164|       | *    the Data Partition the value should be coded into
  165|       | *
  166|       | * \return
  167|       | *    Number of bits used by the coded syntax element 
  168|       | *
  169|       | * \ note
  170|       | *    This function writes always the bit buffer for the progressive scan flag, and
  171|       | *    should not be used (or should be modified appropriately) for the interlace crap
  172|       | *    When used in the context of the Parameter Sets, this is obviously not a
  173|       | *    problem.
  174|       | *
  175|       | *************************************************************************************
  176|       | */
  177|       |
  178|       |int u_v (int n, char *tracestring, int value, DataPartition *part)
  179|    346|{
  180|    346|  SyntaxElement symbol, *sym=&symbol;
  181|       |
  182|    346|  sym->bitpattern = value;
  183|    346|  sym->len = n;
  184|    346|  sym->type = SE_HEADER;
  185|    346|  sym->value1 = value;
  186|    346|  sym->value2 = 0;
  187|       |#if TRACE
  188|       |  strncpy(sym->tracestring,tracestring,TRACESTRING_SIZE);
  189|       |#endif
  190|    346|  assert (part->bitstream->streamBuffer != NULL);
  191|    346|  return writeSyntaxElement_fixed(sym, part);
  192|    346|}
  193|       |
  194|       |
  195|       |/*!
  196|       | ************************************************************************
  197|       | * \brief
  198|       | *    mapping for ue(v) syntax elements
  199|       | * \param ue
  200|       | *    value to be mapped
  201|       | * \param dummy
  202|       | *    dummy parameter
  203|       | * \param info
  204|       | *    returns mapped value
  205|       | * \param len
  206|       | *    returns mapped value length
  207|       | ************************************************************************
  208|       | */
  209|       |void ue_linfo(int ue, int dummy, int *len,int *info)
  210|    841|{
  211|    841|  int i,nn;
  212|       |
  213|    841|  nn=(ue+1)/2;
  214|       |
  215|  1.40k|  for (i=0; i < 16 && nn != 0; i++)
  216|    559|  {
  217|    559|    nn /= 2;
  218|    559|  }
  219|    841|  *len= 2*i + 1;
  220|    841|  *info=ue+1-(int)pow(2,i);
  221|    841|}
  222|       |
  223|       |
  224|       |/*!
  225|       | ************************************************************************
  226|       | * \brief
  227|       | *    mapping for se(v) syntax elements
  228|       | * \param se
  229|       | *    value to be mapped
  230|       | * \param dummy
  231|       | *    dummy parameter
  232|       | * \param len
  233|       | *    returns mapped value length
  234|       | * \param info
  235|       | *    returns mapped value
  236|       | ************************************************************************
  237|       | */
  238|       |void se_linfo(int se, int dummy, int *len,int *info)
  239|    174|{
  240|       |
  241|    174|  int i,n,sign,nn;
  242|       |
  243|    174|  sign=0;
  244|       |
  245|    174|  if (se <= 0)
  246|      3|  {
  247|      3|    sign=1;
  248|      3|  }
  249|    174|  n=abs(se) << 1;
  250|       |
  251|       |  /*
  252|       |  n+1 is the number in the code table.  Based on this we find length and info
  253|       |  */
  254|       |
  255|    174|  nn=n/2;
  256|    601|  for (i=0; i < 16 && nn != 0; i++)
  257|    427|  {
  258|    427|    nn /= 2;
  259|    427|  }
  260|    174|  *len=i*2 + 1;
  261|    174|  *info=n - (int)pow(2,i) + sign;
  262|    174|}
  263|       |
  264|       |
  265|       |/*!
  266|       | ************************************************************************
  267|       | * \par Input:
  268|       | *    Number in the code table
  269|       | * \par Output:
  270|       | *    length and info
  271|       | ************************************************************************
  272|       | */
  273|       |void cbp_linfo_intra(int cbp, int dummy, int *len,int *info)
  274|      0|{
  275|      0|  extern const unsigned char NCBP[2][48][2];
  276|      0|  ue_linfo(NCBP[img->yuv_format?1:0][cbp][0], dummy, len, info);
  277|      0|}
  278|       |
  279|       |
  280|       |/*!
  281|       | ************************************************************************
  282|       | * \par Input:
  283|       | *    Number in the code table
  284|       | * \par Output:
  285|       | *    length and info
  286|       | ************************************************************************
  287|       | */
  288|       |void cbp_linfo_inter(int cbp, int dummy, int *len,int *info)
  289|      0|{
  290|      0|  extern const unsigned char NCBP[2][48][2];
  291|      0|  ue_linfo(NCBP[img->yuv_format?1:0][cbp][1], dummy, len, info);
  292|      0|}
  293|       |
  294|       |
  295|       |/*!
  296|       | ************************************************************************
  297|       | * \brief
  298|       | *    2x2 transform of chroma DC
  299|       | * \par Input:
  300|       | *    level and run for coefficients
  301|       | * \par Output:
  302|       | *    length and info
  303|       | * \note
  304|       | *    see ITU document for bit assignment
  305|       | ************************************************************************
  306|       | */
  307|       |void levrun_linfo_c2x2(int level,int run,int *len,int *info)
  308|      0|{
  309|      0|  const int NTAB[2][2]=
  310|      0|  {
  311|      0|    {1,5},
  312|      0|    {3,0}
  313|      0|  };
  314|      0|  const int LEVRUN[4]=
  315|      0|  {
  316|      0|    2,1,0,0
  317|      0|  };
  318|       |
  319|      0|  int levabs,i,n,sign,nn;
  320|       |
  321|      0|  if (level == 0) //  check if the coefficient sign EOB (level=0)
  322|      0|  {
  323|      0|    *len=1;
  324|      0|    return;
  325|      0|  }
  326|      0|  sign=0;
  327|      0|  if (level <= 0)
  328|      0|  {
  329|      0|    sign=1;
  330|      0|  }
  331|      0|  levabs=abs(level);
  332|      0|  if (levabs <= LEVRUN[run])
  333|      0|  {
  334|      0|    n=NTAB[levabs-1][run]+1;
  335|      0|  }
  336|      0|  else
  337|      0|  {
  338|      0|    n=(levabs-LEVRUN[run])*8 + run*2;
  339|      0|  }
  340|       |
  341|      0|  nn=n/2;
  342|       |
  343|      0|  for (i=0; i < 16 && nn != 0; i++)
  344|      0|  {
  345|      0|    nn /= 2;
  346|      0|  }
  347|      0|  *len= 2*i + 1;
  348|      0|  *info=n-(int)pow(2,i)+sign;
  349|      0|}
  350|       |
  351|       |
  352|       |/*!
  353|       | ************************************************************************
  354|       | * \brief
  355|       | *    Single scan coefficients
  356|       | * \par Input:
  357|       | *    level and run for coefficients
  358|       | * \par Output:
  359|       | *    length and info
  360|       | * \note
  361|       | *    see ITU document for bit assignment
  362|       | ************************************************************************
  363|       | */
  364|       |void levrun_linfo_inter(int level,int run,int *len,int *info)
  365|      0|{
  366|      0|  const byte LEVRUN[16]=
  367|      0|  {
  368|      0|    4,2,2,1,1,1,1,1,1,1,0,0,0,0,0,0
  369|      0|  };
  370|      0|  const byte NTAB[4][10]=
  371|      0|  {
  372|      0|    { 1, 3, 5, 9,11,13,21,23,25,27},
  373|      0|    { 7,17,19, 0, 0, 0, 0, 0, 0, 0},
  374|      0|    {15, 0, 0, 0, 0, 0, 0, 0, 0, 0},
  375|      0|    {29, 0, 0, 0, 0, 0, 0, 0, 0, 0},
  376|      0|  };
  377|       |
  378|      0|  int levabs,i,n,sign,nn;
  379|       |
  380|      0|  if (level == 0)           //  check for EOB
  381|      0|  {
  382|      0|    *len=1;
  383|      0|    return;
  384|      0|  }
  385|       |
  386|      0|  if (level <= 0)
  387|      0|    sign=1;
  388|      0|  else
  389|      0|    sign=0;
  390|       |
  391|      0|  levabs=abs(level);
  392|      0|  if (levabs <= LEVRUN[run])
  393|      0|  {
  394|      0|    n=NTAB[levabs-1][run]+1;
  395|      0|  }
  396|      0|  else
  397|      0|  {
  398|      0|    n=(levabs-LEVRUN[run])*32 + run*2;
  399|      0|  }
  400|       |
  401|      0|  nn=n/2;
  402|       |
  403|      0|  for (i=0; i < 16 && nn != 0; i++)
  404|      0|  {
  405|      0|    nn /= 2;
  406|      0|  }
  407|      0|  *len= 2*i + 1;
  408|      0|  *info=n-(int)pow(2,i)+sign;
  409|       |
  410|      0|}
  411|       |
  412|       |
  413|       |/*!
  414|       | ************************************************************************
  415|       | * \brief
  416|       | *    Double scan coefficients
  417|       | * \par Input:
  418|       | *    level and run for coefficients
  419|       | * \par Output:
  420|       | *    length and info
  421|       | * \note
  422|       | *    see ITU document for bit assignment
  423|       | ************************************************************************
  424|       | */
  425|       |void levrun_linfo_intra(int level,int run,int *len,int *info)
  426|      0|{
  427|      0|  const byte LEVRUN[8]=
  428|      0|  {
  429|      0|    9,3,1,1,1,0,0,0
  430|      0|  };
  431|       |
  432|      0|  const byte NTAB[9][5] =
  433|      0|  {
  434|      0|    { 1, 3, 7,15,17},
  435|      0|    { 5,19, 0, 0, 0},
  436|      0|    { 9,21, 0, 0, 0},
  437|      0|    {11, 0, 0, 0, 0},
  438|      0|    {13, 0, 0, 0, 0},
  439|      0|    {23, 0, 0, 0, 0},
  440|      0|    {25, 0, 0, 0, 0},
  441|      0|    {27, 0, 0, 0, 0},
  442|      0|    {29, 0, 0, 0, 0},
  443|      0|  };
  444|       |
  445|      0|  int levabs,i,n,sign,nn;
  446|       |
  447|      0|  if (level == 0)     //  check for EOB
  448|      0|  {
  449|      0|    *len=1;
  450|      0|    return;
  451|      0|  }
  452|      0|  if (level <= 0)
  453|      0|    sign=1;
  454|      0|  else
  455|      0|    sign=0;
  456|       |
  457|      0|  levabs=abs(level);
  458|      0|  if (levabs <= LEVRUN[run])
  459|      0|  {
  460|      0|    n=NTAB[levabs-1][run]+1;
  461|      0|  }
  462|      0|  else
  463|      0|  {
  464|      0|    n=(levabs-LEVRUN[run])*16 + 16 + run*2;
  465|      0|  }
  466|       |
  467|      0|  nn=n/2;
  468|       |
  469|      0|  for (i=0; i < 16 && nn != 0; i++)
  470|      0|  {
  471|      0|    nn /= 2;
  472|      0|  }
  473|      0|  *len= 2*i + 1;
  474|      0|  *info=n-(int)pow(2,i)+sign;
  475|      0|}
  476|       |
  477|       |
  478|       |/*!
  479|       | ************************************************************************
  480|       | * \brief
  481|       | *    Makes code word and passes it back
  482|       | *    A code word has the following format: 0 0 0 ... 1 Xn ...X2 X1 X0.
  483|       | *
  484|       | * \par Input:
  485|       | *    Info   : Xn..X2 X1 X0                                             \n
  486|       | *    Length : Total number of bits in the codeword
  487|       | ************************************************************************
  488|       | */
  489|       | // NOTE this function is called with sym->inf > (1<<(sym->len/2)).  The upper bits of inf are junk
  490|       |int symbol2uvlc(SyntaxElement *sym)
  491|  1.01k|{
  492|  1.01k|  int suffix_len=sym->len/2;  
  493|  1.01k|  sym->bitpattern = (1<<suffix_len)|(sym->inf&((1<<suffix_len)-1));
  494|  1.01k|  return 0;
  495|  1.01k|}
  496|       |
  497|       |
  498|       |/*!
  499|       | ************************************************************************
  500|       | * \brief
  501|       | *    generates UVLC code and passes the codeword to the buffer
  502|       | ************************************************************************
  503|       | */
  504|       |int writeSyntaxElement_UVLC(SyntaxElement *se, DataPartition *this_dataPart)
  505|  1.01k|{
  506|  1.01k|  se->mapping(se->value1,se->value2,&(se->len),&(se->inf));
  507|  1.01k|  symbol2uvlc(se);
  508|       |
  509|  1.01k|  writeUVLC2buffer(se, this_dataPart->bitstream);
  510|       |
  511|  1.01k|  if(se->type != SE_HEADER)
  512|      0|    this_dataPart->bitstream->write_flag = 1;
  513|       |
  514|       |#if TRACE
  515|       |  if(se->type <= 1)
  516|       |    trace2out (se);
  517|       |#endif
  518|       |
  519|  1.01k|  return (se->len);
  520|  1.01k|}
  521|       |
  522|       |
  523|       |/*!
  524|       | ************************************************************************
  525|       | * \brief
  526|       | *    passes the fixed codeword to the buffer
  527|       | ************************************************************************
  528|       | */
  529|       |int writeSyntaxElement_fixed(SyntaxElement *se, DataPartition *this_dataPart)
  530|    902|{  
  531|    902|  writeUVLC2buffer(se, this_dataPart->bitstream);
  532|       |  
  533|    902|  if(se->type != SE_HEADER)
  534|      0|    this_dataPart->bitstream->write_flag = 1;
  535|       |
  536|       |#if TRACE
  537|       |  if(se->type <= 1)
  538|       |    trace2out (se);
  539|       |#endif
  540|       |
  541|    902|  return (se->len);
  542|    902|}
  543|       |
  544|       |
  545|       |/*!
  546|       | ************************************************************************
  547|       | * \brief
  548|       | *    generates code and passes the codeword to the buffer
  549|       | ************************************************************************
  550|       | */
  551|       |int writeSyntaxElement_Intra4x4PredictionMode(SyntaxElement *se, DataPartition *this_dataPart)
  552|      0|{
  553|       |
  554|      0|  if (se->value1 == -1)
  555|      0|  {
  556|      0|    se->len = 1;
  557|      0|    se->inf = 1;
  558|      0|  }
  559|      0|  else 
  560|      0|  {
  561|      0|    se->len = 4;  
  562|      0|    se->inf = se->value1;
  563|      0|  }
  564|       |
  565|      0|  se->bitpattern = se->inf;
  566|      0|  writeUVLC2buffer(se, this_dataPart->bitstream);
  567|       |
  568|      0|  if(se->type != SE_HEADER)
  569|      0|    this_dataPart->bitstream->write_flag = 1;
  570|       |
  571|       |#if TRACE
  572|       |  if(se->type <= 1)
  573|       |    trace2out (se);
  574|       |#endif
  575|       |
  576|      0|  return (se->len);
  577|      0|}
  578|       |
  579|       |
  580|       |/*!
  581|       | ************************************************************************
  582|       | * \brief
  583|       | *    generates UVLC code and passes the codeword to the buffer
  584|       | * \author
  585|       | *  Tian Dong
  586|       | ************************************************************************
  587|       | */
  588|       |int writeSyntaxElement2Buf_UVLC(SyntaxElement *se, Bitstream* this_streamBuffer )
  589|      0|{
  590|       |
  591|      0|  se->mapping(se->value1,se->value2,&(se->len),&(se->inf));
  592|       |
  593|      0|  symbol2uvlc(se);
  594|       |
  595|      0|  writeUVLC2buffer(se, this_streamBuffer );
  596|       |
  597|       |#if TRACE
  598|       |  if(se->type <= 1)
  599|       |    trace2out (se);
  600|       |#endif
  601|       |
  602|      0|  return (se->len);
  603|      0|}
  604|       |
  605|       |
  606|       |/*!
  607|       | ************************************************************************
  608|       | * \brief
  609|       | *    writes UVLC code to the appropriate buffer
  610|       | ************************************************************************
  611|       | */
  612|       |void  writeUVLC2buffer(SyntaxElement *se, Bitstream *currStream)
  613|  1.91k|{
  614|       |
  615|  1.91k|  int i;
  616|  1.91k|  unsigned int mask = 1 << (se->len-1);
  617|       |
  618|       |  // Add the new bits to the bitstream.
  619|       |  // Write out a byte if it is full
  620|  7.70k|  for (i=0; i<se->len; i++)
  621|  5.78k|  {
  622|  5.78k|    currStream->byte_buf <<= 1;
  623|  5.78k|    if (se->bitpattern & mask)
  624|  2.44k|      currStream->byte_buf |= 1;
  625|  5.78k|    currStream->bits_to_go--;
  626|  5.78k|    mask >>= 1;
  627|  5.78k|    if (currStream->bits_to_go==0)
  628|    610|    {
  629|    610|      currStream->bits_to_go = 8;
  630|    610|      currStream->streamBuffer[currStream->byte_pos++]=currStream->byte_buf;
  631|    610|      currStream->byte_buf = 0;
  632|    610|    }
  633|  5.78k|  }
  634|  1.91k|}
  635|       |
  636|       |
  637|       |/*!
  638|       | ************************************************************************
  639|       | * \brief
  640|       | *    generates UVLC code and passes the codeword to the buffer
  641|       | * \author
  642|       | *  Tian Dong
  643|       | ************************************************************************
  644|       | */
  645|       |int writeSyntaxElement2Buf_Fixed(SyntaxElement *se, Bitstream* this_streamBuffer )
  646|      0|{
  647|       |
  648|      0|  writeUVLC2buffer(se, this_streamBuffer );
  649|       |
  650|       |#if TRACE
  651|       |  if(se->type <= 1)
  652|       |    trace2out (se);
  653|       |#endif
  654|       |
  655|      0|  return (se->len);
  656|      0|}
  657|       |
  658|       |
  659|       |/*!
  660|       | ************************************************************************
  661|       | * \brief
  662|       | *    Makes code word and passes it back
  663|       | *
  664|       | * \par Input:
  665|       | *    Info   : Xn..X2 X1 X0                                             \n
  666|       | *    Length : Total number of bits in the codeword
  667|       | ************************************************************************
  668|       | */
  669|       |
  670|       |int symbol2vlc(SyntaxElement *sym)
  671|      0|{
  672|      0|  int info_len = sym->len;
  673|       |
  674|       |  // Convert info into a bitpattern int
  675|      0|  sym->bitpattern = 0;
  676|       |
  677|       |  // vlc coding
  678|      0|  while(--info_len >= 0)
  679|      0|  {
  680|      0|    sym->bitpattern <<= 1;
  681|      0|    sym->bitpattern |= (0x01 & (sym->inf >> info_len));
  682|      0|  }
  683|      0|  return 0;
  684|      0|}
  685|       |
  686|       |
  687|       |/*!
  688|       | ************************************************************************
  689|       | * \brief
  690|       | *    generates VLC code and passes the codeword to the buffer
  691|       | ************************************************************************
  692|       | */
  693|       |int writeSyntaxElement_VLC(SyntaxElement *se, DataPartition *this_dataPart)
  694|      0|{
  695|       |
  696|      0|  se->inf = se->value1;
  697|      0|  se->len = se->value2;
  698|      0|  symbol2vlc(se);
  699|       |
  700|      0|  writeUVLC2buffer(se, this_dataPart->bitstream);
  701|       |#if TRACE
  702|       |  if (se->type <= 1)
  703|       |    trace2out (se);
  704|       |#endif
  705|       |
  706|      0|  return (se->len);
  707|      0|}
  708|       |
  709|       |
  710|       |/*!
  711|       | ************************************************************************
  712|       | * \brief
  713|       | *    write VLC for NumCoeff and TrailingOnes
  714|       | ************************************************************************
  715|       | */
  716|       |
  717|       |int writeSyntaxElement_NumCoeffTrailingOnes(SyntaxElement *se, DataPartition *this_dataPart)
  718|      0|{
  719|      0|  static const int lentab[3][4][17] = 
  720|      0|  {
  721|      0|    {   // 0702
  722|      0|      { 1, 6, 8, 9,10,11,13,13,13,14,14,15,15,16,16,16,16},
  723|      0|      { 0, 2, 6, 8, 9,10,11,13,13,14,14,15,15,15,16,16,16},
  724|      0|      { 0, 0, 3, 7, 8, 9,10,11,13,13,14,14,15,15,16,16,16},
  725|      0|      { 0, 0, 0, 5, 6, 7, 8, 9,10,11,13,14,14,15,15,16,16},
  726|      0|    },                                                 
  727|      0|    {                                                  
  728|      0|      { 2, 6, 6, 7, 8, 8, 9,11,11,12,12,12,13,13,13,14,14},
  729|      0|      { 0, 2, 5, 6, 6, 7, 8, 9,11,11,12,12,13,13,14,14,14},
  730|      0|      { 0, 0, 3, 6, 6, 7, 8, 9,11,11,12,12,13,13,13,14,14},
  731|      0|      { 0, 0, 0, 4, 4, 5, 6, 6, 7, 9,11,11,12,13,13,13,14},
  732|      0|    },                                                 
  733|      0|    {                                                  
  734|      0|      { 4, 6, 6, 6, 7, 7, 7, 7, 8, 8, 9, 9, 9,10,10,10,10},
  735|      0|      { 0, 4, 5, 5, 5, 5, 6, 6, 7, 8, 8, 9, 9, 9,10,10,10},
  736|      0|      { 0, 0, 4, 5, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9,10,10,10},
  737|      0|      { 0, 0, 0, 4, 4, 4, 4, 4, 5, 6, 7, 8, 8, 9,10,10,10},
  738|      0|    },
  739|       |
  740|      0|  };
  741|       |
  742|      0|  static const int codtab[3][4][17] = 
  743|      0|  {
  744|      0|    {
  745|      0|      { 1, 5, 7, 7, 7, 7,15,11, 8,15,11,15,11,15,11, 7,4}, 
  746|      0|      { 0, 1, 4, 6, 6, 6, 6,14,10,14,10,14,10, 1,14,10,6}, 
  747|      0|      { 0, 0, 1, 5, 5, 5, 5, 5,13, 9,13, 9,13, 9,13, 9,5}, 
  748|      0|      { 0, 0, 0, 3, 3, 4, 4, 4, 4, 4,12,12, 8,12, 8,12,8},
  749|      0|    },
  750|      0|    {
  751|      0|      { 3,11, 7, 7, 7, 4, 7,15,11,15,11, 8,15,11, 7, 9,7}, 
  752|      0|      { 0, 2, 7,10, 6, 6, 6, 6,14,10,14,10,14,10,11, 8,6}, 
  753|      0|      { 0, 0, 3, 9, 5, 5, 5, 5,13, 9,13, 9,13, 9, 6,10,5}, 
  754|      0|      { 0, 0, 0, 5, 4, 6, 8, 4, 4, 4,12, 8,12,12, 8, 1,4},
  755|      0|    },
  756|      0|    {
  757|      0|      {15,15,11, 8,15,11, 9, 8,15,11,15,11, 8,13, 9, 5,1}, 
  758|      0|      { 0,14,15,12,10, 8,14,10,14,14,10,14,10, 7,12, 8,4},
  759|      0|      { 0, 0,13,14,11, 9,13, 9,13,10,13, 9,13, 9,11, 7,3},
  760|      0|      { 0, 0, 0,12,11,10, 9, 8,13,12,12,12, 8,12,10, 6,2},
  761|      0|    },
  762|      0|  };
  763|      0|  int vlcnum;
  764|       |
  765|      0|  vlcnum = se->len;
  766|       |
  767|       |  // se->value1 : numcoeff
  768|       |  // se->value2 : numtrailingones
  769|       |
  770|      0|  if (vlcnum == 3)
  771|      0|  {
  772|      0|    se->len = 6;  // 4 + 2 bit FLC
  773|      0|    if (se->value1 > 0)
  774|      0|    {
  775|      0|      se->inf = ((se->value1-1) << 2) | se->value2;
  776|      0|    }
  777|      0|    else
  778|      0|    {
  779|      0|      se->inf = 3;
  780|      0|    }
  781|      0|  }
  782|      0|  else
  783|      0|  {
  784|      0|    se->len = lentab[vlcnum][se->value2][se->value1];
  785|      0|    se->inf = codtab[vlcnum][se->value2][se->value1];
  786|      0|  }
  787|       |  //se->inf = 0;
  788|       |
  789|      0|  if (se->len == 0)
  790|      0|  {
  791|      0|    printf("ERROR: (numcoeff,trailingones) not valid: vlc=%d (%d, %d)\n", 
  792|      0|      vlcnum, se->value1, se->value2);
  793|      0|    exit(-1);
  794|      0|  }
  795|       |
  796|      0|  symbol2vlc(se);
  797|       |
  798|      0|  writeUVLC2buffer(se, this_dataPart->bitstream);
  799|       |#if TRACE
  800|       |  if (se->type <= 1)
  801|       |    trace2out (se);
  802|       |#endif
  803|       |
  804|      0|  return (se->len);
  805|      0|}
  806|       |
  807|       |
  808|       |/*!
  809|       | ************************************************************************
  810|       | * \brief
  811|       | *    write VLC for NumCoeff and TrailingOnes for Chroma DC
  812|       | ************************************************************************
  813|       | */
  814|       |int writeSyntaxElement_NumCoeffTrailingOnesChromaDC(SyntaxElement *se, DataPartition *this_dataPart)
  815|      0|{
  816|      0|  static const int lentab[3][4][17] = 
  817|      0|  {
  818|       |    //YUV420
  819|      0|   {{ 2, 6, 6, 6, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
  820|      0|    { 0, 1, 6, 7, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
  821|      0|    { 0, 0, 3, 7, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
  822|      0|    { 0, 0, 0, 6, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}},
  823|       |    //YUV422
  824|      0|   {{ 1, 7, 7, 9, 9,10,11,12,13, 0, 0, 0, 0, 0, 0, 0, 0},
  825|      0|    { 0, 2, 7, 7, 9,10,11,12,12, 0, 0, 0, 0, 0, 0, 0, 0}, 
  826|      0|    { 0, 0, 3, 7, 7, 9,10,11,12, 0, 0, 0, 0, 0, 0, 0, 0}, 
  827|      0|    { 0, 0, 0, 5, 6, 7, 7,10,11, 0, 0, 0, 0, 0, 0, 0, 0}},
  828|       |    //YUV444
  829|      0|   {{ 1, 6, 8, 9,10,11,13,13,13,14,14,15,15,16,16,16,16},
  830|      0|    { 0, 2, 6, 8, 9,10,11,13,13,14,14,15,15,15,16,16,16},
  831|      0|    { 0, 0, 3, 7, 8, 9,10,11,13,13,14,14,15,15,16,16,16},
  832|      0|    { 0, 0, 0, 5, 6, 7, 8, 9,10,11,13,14,14,15,15,16,16}}
  833|      0|  };
  834|       |
  835|      0|  static const int codtab[3][4][17] = 
  836|      0|  {
  837|       |    //YUV420
  838|      0|   {{ 1, 7, 4, 3, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
  839|      0|    { 0, 1, 6, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
  840|      0|    { 0, 0, 1, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
  841|      0|    { 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}},
  842|       |    //YUV422
  843|      0|   {{ 1,15,14, 7, 6, 7, 7, 7, 7, 0, 0, 0, 0, 0, 0, 0, 0},
  844|      0|    { 0, 1,13,12, 5, 6, 6, 6, 5, 0, 0, 0, 0, 0, 0, 0, 0},
  845|      0|    { 0, 0, 1,11,10, 4, 5, 5, 4, 0, 0, 0, 0, 0, 0, 0, 0},
  846|      0|    { 0, 0, 0, 1, 1, 9, 8, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0}},
  847|       |    //YUV444
  848|      0|   {{ 1, 5, 7, 7, 7, 7,15,11, 8,15,11,15,11,15,11, 7, 4}, 
  849|      0|    { 0, 1, 4, 6, 6, 6, 6,14,10,14,10,14,10, 1,14,10, 6}, 
  850|      0|    { 0, 0, 1, 5, 5, 5, 5, 5,13, 9,13, 9,13, 9,13, 9, 5}, 
  851|      0|    { 0, 0, 0, 3, 3, 4, 4, 4, 4, 4,12,12, 8,12, 8,12, 8}}
  852|       |  
  853|      0|  };
  854|      0|  int yuv = img->yuv_format - 1;
  855|       |
  856|       |  // se->value1 : numcoeff
  857|       |  // se->value2 : numtrailingones
  858|      0|  se->len = lentab[yuv][se->value2][se->value1];
  859|      0|  se->inf = codtab[yuv][se->value2][se->value1];
  860|       |
  861|      0|  if (se->len == 0)
  862|      0|  {
  863|      0|    printf("ERROR: (numcoeff,trailingones) not valid: (%d, %d)\n", 
  864|      0|      se->value1, se->value2);
  865|      0|    exit(-1);
  866|      0|  }
  867|       |
  868|      0|  symbol2vlc(se);
  869|       |
  870|      0|  writeUVLC2buffer(se, this_dataPart->bitstream);
  871|       |#if TRACE
  872|       |  if (se->type <= 1)
  873|       |    trace2out (se);
  874|       |#endif
  875|       |
  876|      0|  return (se->len);
  877|      0|}
  878|       |
  879|       |
  880|       |/*!
  881|       | ************************************************************************
  882|       | * \brief
  883|       | *    write VLC for TotalZeros
  884|       | ************************************************************************
  885|       | */
  886|       |int writeSyntaxElement_TotalZeros(SyntaxElement *se, DataPartition *this_dataPart)
  887|      0|{
  888|      0|  static const int lentab[TOTRUN_NUM][16] = 
  889|      0|  {
  890|      0|    { 1,3,3,4,4,5,5,6,6,7,7,8,8,9,9,9},  
  891|      0|    { 3,3,3,3,3,4,4,4,4,5,5,6,6,6,6},  
  892|      0|    { 4,3,3,3,4,4,3,3,4,5,5,6,5,6},  
  893|      0|    { 5,3,4,4,3,3,3,4,3,4,5,5,5},  
  894|      0|    { 4,4,4,3,3,3,3,3,4,5,4,5},  
  895|      0|    { 6,5,3,3,3,3,3,3,4,3,6},  
  896|      0|    { 6,5,3,3,3,2,3,4,3,6},  
  897|      0|    { 6,4,5,3,2,2,3,3,6},  
  898|      0|    { 6,6,4,2,2,3,2,5},  
  899|      0|    { 5,5,3,2,2,2,4},  
  900|      0|    { 4,4,3,3,1,3},  
  901|      0|    { 4,4,2,1,3},  
  902|      0|    { 3,3,1,2},  
  903|      0|    { 2,2,1},  
  904|      0|    { 1,1},  
  905|      0|  };
  906|       |
  907|      0|  static const int codtab[TOTRUN_NUM][16] = 
  908|      0|  {
  909|      0|    {1,3,2,3,2,3,2,3,2,3,2,3,2,3,2,1},
  910|      0|    {7,6,5,4,3,5,4,3,2,3,2,3,2,1,0},
  911|      0|    {5,7,6,5,4,3,4,3,2,3,2,1,1,0},
  912|      0|    {3,7,5,4,6,5,4,3,3,2,2,1,0},
  913|      0|    {5,4,3,7,6,5,4,3,2,1,1,0},
  914|      0|    {1,1,7,6,5,4,3,2,1,1,0},
  915|      0|    {1,1,5,4,3,3,2,1,1,0},
  916|      0|    {1,1,1,3,3,2,2,1,0},
  917|      0|    {1,0,1,3,2,1,1,1,},
  918|      0|    {1,0,1,3,2,1,1,},
  919|      0|    {0,1,1,2,1,3},
  920|      0|    {0,1,1,1,1},
  921|      0|    {0,1,1,1},
  922|      0|    {0,1,1},
  923|      0|    {0,1},  
  924|      0|  };
  925|      0|  int vlcnum;
  926|       |
  927|      0|  vlcnum = se->len;
  928|       |
  929|       |  // se->value1 : TotalZeros
  930|      0|  se->len = lentab[vlcnum][se->value1];
  931|      0|  se->inf = codtab[vlcnum][se->value1];
  932|       |
  933|      0|  if (se->len == 0)
  934|      0|  {
  935|      0|    printf("ERROR: (TotalZeros) not valid: (%d)\n",se->value1);
  936|      0|    exit(-1);
  937|      0|  }
  938|       |
  939|      0|  symbol2vlc(se);
  940|       |
  941|      0|  writeUVLC2buffer(se, this_dataPart->bitstream);
  942|       |#if TRACE
  943|       |  if (se->type <= 1)
  944|       |    trace2out (se);
  945|       |#endif
  946|       |
  947|      0|  return (se->len);
  948|      0|}
  949|       |
  950|       |
  951|       |/*!
  952|       | ************************************************************************
  953|       | * \brief
  954|       | *    write VLC for TotalZeros for Chroma DC
  955|       | ************************************************************************
  956|       | */
  957|       |int writeSyntaxElement_TotalZerosChromaDC(SyntaxElement *se, DataPartition *this_dataPart)
  958|      0|{
  959|      0|  static const int lentab[3][TOTRUN_NUM][16] = 
  960|      0|  {
  961|       |    //YUV420
  962|      0|   {{ 1,2,3,3},
  963|      0|    { 1,2,2},
  964|      0|    { 1,1}},
  965|       |    //YUV422
  966|      0|   {{ 1,3,3,4,4,4,5,5},
  967|      0|    { 3,2,3,3,3,3,3},
  968|      0|    { 3,3,2,2,3,3},
  969|      0|    { 3,2,2,2,3},
  970|      0|    { 2,2,2,2},
  971|      0|    { 2,2,1},   
  972|      0|    { 1,1}},
  973|       |    //YUV444
  974|      0|   {{ 1,3,3,4,4,5,5,6,6,7,7,8,8,9,9,9},  
  975|      0|    { 3,3,3,3,3,4,4,4,4,5,5,6,6,6,6},  
  976|      0|    { 4,3,3,3,4,4,3,3,4,5,5,6,5,6},  
  977|      0|    { 5,3,4,4,3,3,3,4,3,4,5,5,5},  
  978|      0|    { 4,4,4,3,3,3,3,3,4,5,4,5},  
  979|      0|    { 6,5,3,3,3,3,3,3,4,3,6},  
  980|      0|    { 6,5,3,3,3,2,3,4,3,6},  
  981|      0|    { 6,4,5,3,2,2,3,3,6},  
  982|      0|    { 6,6,4,2,2,3,2,5},  
  983|      0|    { 5,5,3,2,2,2,4},  
  984|      0|    { 4,4,3,3,1,3},  
  985|      0|    { 4,4,2,1,3},  
  986|      0|    { 3,3,1,2},  
  987|      0|    { 2,2,1},  
  988|      0|    { 1,1}}  
  989|      0|  };
  990|       |
  991|      0|  static const int codtab[3][TOTRUN_NUM][16] = 
  992|      0|  {
  993|       |    //YUV420
  994|      0|   {{ 1,1,1,0},
  995|      0|    { 1,1,0},
  996|      0|    { 1,0}},
  997|       |    //YUV422
  998|      0|   {{ 1,2,3,2,3,1,1,0},
  999|      0|    { 0,1,1,4,5,6,7},
 1000|      0|    { 0,1,1,2,6,7},
 1001|      0|    { 6,0,1,2,7},
 1002|      0|    { 0,1,2,3},
 1003|      0|    { 0,1,1},   
 1004|      0|    { 0,1}},
 1005|       |    //YUV444
 1006|      0|   {{1,3,2,3,2,3,2,3,2,3,2,3,2,3,2,1},
 1007|      0|    {7,6,5,4,3,5,4,3,2,3,2,3,2,1,0},
 1008|      0|    {5,7,6,5,4,3,4,3,2,3,2,1,1,0},
 1009|      0|    {3,7,5,4,6,5,4,3,3,2,2,1,0},
 1010|      0|    {5,4,3,7,6,5,4,3,2,1,1,0},
 1011|      0|    {1,1,7,6,5,4,3,2,1,1,0},
 1012|      0|    {1,1,5,4,3,3,2,1,1,0},
 1013|      0|    {1,1,1,3,3,2,2,1,0},
 1014|      0|    {1,0,1,3,2,1,1,1,},
 1015|      0|    {1,0,1,3,2,1,1,},
 1016|      0|    {0,1,1,2,1,3},
 1017|      0|    {0,1,1,1,1},
 1018|      0|    {0,1,1,1},
 1019|      0|    {0,1,1},
 1020|      0|    {0,1}}  
 1021|      0|  };
 1022|      0|  int vlcnum;
 1023|      0|  int yuv = img->yuv_format - 1;
 1024|       |  
 1025|      0|  vlcnum = se->len;
 1026|       |
 1027|       |  // se->value1 : TotalZeros
 1028|      0|  se->len = lentab[yuv][vlcnum][se->value1];
 1029|      0|  se->inf = codtab[yuv][vlcnum][se->value1];
 1030|       |
 1031|      0|  if (se->len == 0)
 1032|      0|  {
 1033|      0|    printf("ERROR: (TotalZeros) not valid: (%d)\n",se->value1);
 1034|      0|    exit(-1);
 1035|      0|  }
 1036|       |
 1037|      0|  symbol2vlc(se);
 1038|       |
 1039|      0|  writeUVLC2buffer(se, this_dataPart->bitstream);
 1040|       |#if TRACE
 1041|       |  if (se->type <= 1)
 1042|       |    trace2out (se);
 1043|       |#endif
 1044|       |
 1045|      0|  return (se->len);
 1046|      0|}
 1047|       |
 1048|       |
 1049|       |/*!
 1050|       | ************************************************************************
 1051|       | * \brief
 1052|       | *    write VLC for Run Before Next Coefficient, VLC0
 1053|       | ************************************************************************
 1054|       | */
 1055|       |int writeSyntaxElement_Run(SyntaxElement *se, DataPartition *this_dataPart)
 1056|      0|{
 1057|      0|  static const int lentab[TOTRUN_NUM][16] = 
 1058|      0|  {
 1059|      0|    {1,1},
 1060|      0|    {1,2,2},
 1061|      0|    {2,2,2,2},
 1062|      0|    {2,2,2,3,3},
 1063|      0|    {2,2,3,3,3,3},
 1064|      0|    {2,3,3,3,3,3,3},
 1065|      0|    {3,3,3,3,3,3,3,4,5,6,7,8,9,10,11},
 1066|      0|  };
 1067|       |
 1068|      0|  static const int codtab[TOTRUN_NUM][16] = 
 1069|      0|  {
 1070|      0|    {1,0},
 1071|      0|    {1,1,0},
 1072|      0|    {3,2,1,0},
 1073|      0|    {3,2,1,1,0},
 1074|      0|    {3,2,3,2,1,0},
 1075|      0|    {3,0,1,3,2,5,4},
 1076|      0|    {7,6,5,4,3,2,1,1,1,1,1,1,1,1,1},
 1077|      0|  };
 1078|      0|  int vlcnum;
 1079|       |
 1080|      0|  vlcnum = se->len;
 1081|       |
 1082|       |  // se->value1 : run
 1083|      0|  se->len = lentab[vlcnum][se->value1];
 1084|      0|  se->inf = codtab[vlcnum][se->value1];
 1085|       |
 1086|      0|  if (se->len == 0)
 1087|      0|  {
 1088|      0|    printf("ERROR: (run) not valid: (%d)\n",se->value1);
 1089|      0|    exit(-1);
 1090|      0|  }
 1091|       |
 1092|      0|  symbol2vlc(se);
 1093|       |
 1094|      0|  writeUVLC2buffer(se, this_dataPart->bitstream);
 1095|       |#if TRACE
 1096|       |  if (se->type <= 1)
 1097|       |    trace2out (se);
 1098|       |#endif
 1099|       |
 1100|      0|  return (se->len);
 1101|      0|}
 1102|       |
 1103|       |
 1104|       |/*!
 1105|       | ************************************************************************
 1106|       | * \brief
 1107|       | *    write VLC for Coeff Level (VLC1)
 1108|       | ************************************************************************
 1109|       | */
 1110|       |int writeSyntaxElement_Level_VLC1(SyntaxElement *se, DataPartition *this_dataPart)
 1111|      0|{
 1112|      0|  int level, levabs, sign;
 1113|       |
 1114|      0|  level = se->value1;
 1115|      0|  levabs = abs(level);
 1116|      0|  sign = (level < 0 ? 1 : 0);
 1117|       |
 1118|       |  
 1119|      0|  if (levabs < 8)
 1120|      0|  {
 1121|      0|    se->len = levabs * 2 + sign - 1;
 1122|      0|    se->inf = 1;
 1123|      0|  }
 1124|      0|  else if (levabs < 8+8)
 1125|      0|  {
 1126|       |    // escape code1
 1127|      0|    se->len = 14 + 1 + 4;
 1128|      0|    se->inf = (1 << 4) | ((levabs - 8) << 1) | sign;
 1129|      0|  }
 1130|      0|  else
 1131|      0|  {
 1132|       |    // escape code2
 1133|      0|    se->len = 14 + 2 + 12;
 1134|      0|    se->inf = (0x1 << 12) | ((levabs - 16)<< 1) | sign;
 1135|      0|  }
 1136|       |
 1137|       |
 1138|      0|  symbol2vlc(se);
 1139|       |
 1140|      0|  writeUVLC2buffer(se, this_dataPart->bitstream);
 1141|       |#if TRACE
 1142|       |  if (se->type <= 1)
 1143|       |    trace2out (se);
 1144|       |#endif
 1145|       |
 1146|      0|  return (se->len);
 1147|      0|}
 1148|       |
 1149|       |
 1150|       |/*!
 1151|       | ************************************************************************
 1152|       | * \brief
 1153|       | *    write VLC for Coeff Level
 1154|       | ************************************************************************
 1155|       | */
 1156|       |int writeSyntaxElement_Level_VLCN(SyntaxElement *se, int vlc, DataPartition *this_dataPart)
 1157|      0|{
 1158|      0|  int iCodeword;
 1159|      0|  int iLength;
 1160|       |
 1161|      0|  int level = se->value1;
 1162|       |
 1163|      0|  int levabs = abs(level);
 1164|      0|  int sign = (level < 0 ? 1 : 0);  
 1165|       |
 1166|      0|  int shift = vlc-1;
 1167|      0|  int escape = (15<<shift)+1;
 1168|       |
 1169|      0|  int numPrefix = (levabs-1)>>shift;
 1170|       |
 1171|      0|  int sufmask = ~((0xffffffff)<<shift);
 1172|      0|  int suffix = (levabs-1)&sufmask;
 1173|       |
 1174|      0|  if (levabs < escape)
 1175|      0|  {
 1176|      0|    iLength = numPrefix + vlc + 1;
 1177|      0|    iCodeword = (1<<(shift+1))|(suffix<<1)|sign;
 1178|      0|  }
 1179|      0|  else
 1180|      0|  {
 1181|      0|    iLength = 28;
 1182|      0|    iCodeword = (1<<12)|((levabs-escape)<<1)|sign;
 1183|      0|  }
 1184|      0|  se->len = iLength;
 1185|      0|  se->inf = iCodeword;
 1186|       |
 1187|      0|  symbol2vlc(se);
 1188|       |
 1189|      0|  writeUVLC2buffer(se, this_dataPart->bitstream);
 1190|       |#if TRACE
 1191|       |  if (se->type <= 1)
 1192|       |    trace2out (se);
 1193|       |#endif
 1194|       |
 1195|      0|  return (se->len);
 1196|      0|}
 1197|       |
 1198|       |
 1199|       |/*!
 1200|       | ************************************************************************
 1201|       | * \brief
 1202|       | *    Write out a trace string on the trace file
 1203|       | ************************************************************************
 1204|       | */
 1205|       |#if TRACE
 1206|       |void trace2out(SyntaxElement *sym)
 1207|       |{
 1208|       |  static int bitcounter = 0;
 1209|       |  int i, chars;
 1210|       |
 1211|       |  if (p_trace != NULL)
 1212|       |  {
 1213|       |    putc('@', p_trace);
 1214|       |    chars = fprintf(p_trace, "%i", bitcounter);
 1215|       |    while(chars++ < 6)
 1216|       |      putc(' ',p_trace);
 1217|       |
 1218|       |    chars += fprintf(p_trace, "%s", sym->tracestring);
 1219|       |    while(chars++ < 55)
 1220|       |      putc(' ',p_trace);
 1221|       |
 1222|       |  // Align bitpattern
 1223|       |    if(sym->len<15)
 1224|       |    {
 1225|       |      for(i=0 ; i<15-sym->len ; i++)
 1226|       |        fputc(' ', p_trace);
 1227|       |    }
 1228|       |    
 1229|       |    // Print bitpattern
 1230|       |    bitcounter += sym->len;
 1231|       |    for(i=1 ; i<=sym->len ; i++)
 1232|       |    {
 1233|       |      if((sym->bitpattern >> (sym->len-i)) & 0x1)
 1234|       |        fputc('1', p_trace);
 1235|       |      else
 1236|       |        fputc('0', p_trace);
 1237|       |    }
 1238|       |    fprintf(p_trace, " (%3d) \n",sym->value1);
 1239|       |  }
 1240|       |  fflush (p_trace);
 1241|       |}
 1242|       |#endif
 1243|       |
 1244|       |
 1245|       |/*!
 1246|       | ************************************************************************
 1247|       | * \brief
 1248|       | *    puts the less than 8 bits in the byte buffer of the Bitstream into
 1249|       | *    the streamBuffer.  
 1250|       | *
 1251|       | * \param
 1252|       | *   currStream: the Bitstream the alignment should be established
 1253|       | *
 1254|       | ************************************************************************
 1255|       | */
 1256|       |void writeVlcByteAlign(Bitstream* currStream)
 1257|    171|{
 1258|    171|  if (currStream->bits_to_go < 8)
 1259|    170|  { // trailing bits to process
 1260|    170|    currStream->byte_buf = (currStream->byte_buf <<currStream->bits_to_go) | (0xff >> (8 - currStream->bits_to_go));
 1261|    170|    stats->bit_use_stuffingBits[img->type]+=currStream->bits_to_go;
 1262|    170|    currStream->streamBuffer[currStream->byte_pos++]=currStream->byte_buf;
 1263|    170|    currStream->bits_to_go = 8;
 1264|    170|  }
 1265|    171|}

/home/xzp/speccpu2006-v1.0.1/benchspec/CPU2006/464.h264ref/run/build_base_ql_riscv_llvm17.0000/weighted_prediction.c:
    1|       |
    2|       |/*!
    3|       |*************************************************************************************
    4|       |* \file weighted_prediction.c
    5|       |*
    6|       |* \brief
    7|       |*    Estimate weights for WP
    8|       |*
    9|       |* \author
   10|       |*    Main contributors (see contributors.h for copyright, address and affiliation details)
   11|       |*     - Alexis Michael Tourapis         <alexismt@ieee.org>
   12|       |*************************************************************************************
   13|       |*/
   14|       |#include <stdlib.h>
   15|       |#include "contributors.h"
   16|       |
   17|       |#include "global.h"
   18|       |
   19|       |#include "image.h"
   20|       |
   21|       |/*!
   22|       |************************************************************************
   23|       |* \brief
   24|       |*    Estimates reference picture weighting factors
   25|       |************************************************************************
   26|       |*/
   27|       |
   28|       |void estimate_weighting_factor_P_slice(int select_offset)
   29|      0|{
   30|      0|  int i, j, n;
   31|       |  
   32|      0|  double dc_org = 0.0;
   33|      0|  int index;
   34|      0|  int comp;
   35|      0|  double dc_ref[MAX_REFERENCE_PICTURES];
   36|       |
   37|      0|  pel_t*  ref_pic;   
   38|      0|  pel_t*  ref_pic_w;   
   39|      0|  int default_weight[3];
   40|       |
   41|      0|  int list_offset   = ((img->MbaffFrameFlag)&&(img->mb_data[img->current_mb_nr].mb_field))? img->current_mb_nr%2 ? 4 : 2 : 0;
   42|      0|  int weight[2][MAX_REFERENCE_PICTURES][3]; 
   43|      0|  int offset[2][MAX_REFERENCE_PICTURES][3];       
   44|      0|  int clist;
   45|       |  
   46|       |  
   47|       |  
   48|      0|  luma_log_weight_denom = 5;
   49|      0|  chroma_log_weight_denom = 5;
   50|      0|  wp_luma_round = 1 << (luma_log_weight_denom - 1);
   51|      0|  wp_chroma_round = 1 << (chroma_log_weight_denom - 1);
   52|      0|  default_weight[0] = 1<<luma_log_weight_denom;
   53|      0|  default_weight[1] = default_weight[2] = 1<<chroma_log_weight_denom;
   54|       |  
   55|       |  /* set all values to defaults */
   56|      0|  for (i = 0; i < 2 + list_offset; i++)
   57|      0|  {
   58|      0|    for (j = 0; j < listXsize[i]; j++)
   59|      0|    {
   60|      0|      for (n = 0; n < 3; n++)
   61|      0|      {
   62|      0|        weight[i][j][n] = default_weight[n];
   63|      0|        wp_weight[i][j][n] = default_weight[n];
   64|      0|        wp_offset[i][j][n] = 0;
   65|      0|        offset[i][j][n] = 0;
   66|      0|      }
   67|      0|    }
   68|      0|  }
   69|       |  
   70|      0|  for (i = 0; i < img->height; i++)
   71|      0|  {
   72|      0|    for (j = 0; j < img->width; j++)
   73|      0|    {
   74|      0|      dc_org += (double) imgY_org[i][j];
   75|      0|    }
   76|      0|  } 
   77|       |    
   78|      0|  for (clist=0; clist<2 + list_offset; clist++)
   79|      0|  {
   80|      0|    for (n = 0; n < listXsize[clist]; n++)
   81|      0|    {
   82|      0|      dc_ref[n] = 0.0;
   83|       |      
   84|      0|      ref_pic       = listX[clist][n]->imgY_11;
   85|      0|      ref_pic_w     = listX[clist][n]->imgY_11_w;
   86|       |      
   87|       |      // Y
   88|      0|      for (i = 0; i < img->height * img->width; i++)
   89|      0|      {
   90|      0|        dc_ref[n] += (double) ref_pic[i];
   91|      0|      }
   92|       |      
   93|      0|      if (select_offset==0.0)
   94|      0|      {
   95|      0|        if (dc_ref[n] != 0)
   96|      0|          weight[clist][n][0] = (int) (default_weight[0] * dc_org / dc_ref[n] + 0.5);
   97|      0|        else
   98|      0|          weight[clist][n][0] = default_weight[0];  // only used when reference picture is black
   99|      0|        if (weight[clist][n][0] < -64 || weight[clist][n][0] >127)
  100|      0|          weight[clist][n][0] = default_weight[0];
  101|      0|      }
  102|      0|      else
  103|      0|      {        
  104|      0|        offset[clist][n][0] = (int) ((dc_org-dc_ref[n])/(img->height*img->width)+0.5);
  105|      0|        offset[clist][n][0] = (offset[clist][n][0]<-128) ? -128: (offset[clist][n][0]>127) ? 127:offset[clist][n][0];
  106|      0|        weight[clist][n][0] = default_weight[0];
  107|      0|      }
  108|       |      
  109|       |      
  110|       |      /* for now always use default weight for chroma weight */
  111|      0|      weight[clist][n][1] = default_weight[1];
  112|      0|      weight[clist][n][2] = default_weight[2];
  113|       |      
  114|       |      
  115|       |      
  116|       |      /* store weighted reference pic for motion estimation */
  117|      0|      for (i = 0; i < img->height * img->width; i++)
  118|      0|      {          
  119|      0|        ref_pic_w[i] = Clip3 (0, img->max_imgpel_value , (((int) ref_pic[i] * weight[clist][n][0] + wp_luma_round) >> luma_log_weight_denom) + offset[clist][n][0]);
  120|      0|      }
  121|      0|      for (i = 0; i < 4*(img->height + 2*IMG_PAD_SIZE) ; i++)
  122|      0|      {
  123|      0|        for (j = 0; j< 4*(img->width + 2*IMG_PAD_SIZE); j++)
  124|      0|        {
  125|      0|          listX[LIST_0][n]->imgY_ups_w[i][j] =   Clip3 (0, img->max_imgpel_value, (((int) listX[LIST_0 ][n]->imgY_ups[i][j] * weight[clist][n][0] + wp_luma_round) >> luma_log_weight_denom) + offset[clist][n][0]);
  126|      0|        }
  127|      0|      }
  128|      0|    }
  129|      0|  }
  130|       |  
  131|      0|  for (clist=0; clist<2 + list_offset; clist++)
  132|      0|  {
  133|      0|    for (index = 0; index < listXsize[clist]; index++)
  134|      0|    {
  135|      0|      for (comp=0; comp < 3; comp ++)
  136|      0|      {
  137|      0|        wp_weight[clist][index][comp] = weight[clist][index][comp];
  138|      0|        wp_offset[clist][index][comp] = offset[clist][index][comp];
  139|       |        // printf("index %d component %d weight %d offset %d\n",index,comp,weight[0][index][comp],offset[0][index][comp]);
  140|      0|      }
  141|      0|    }
  142|      0|  }
  143|       |  
  144|      0|}
  145|       |
  146|       |/*!
  147|       |************************************************************************
  148|       |* \brief
  149|       |*    Estimates reference picture weighting factors
  150|       |************************************************************************
  151|       |*/
  152|       |void estimate_weighting_factor_B_slice()
  153|      0|{
  154|      0|  int i, j, n, l;
  155|       |  
  156|      0|  int tx,DistScaleFactor;
  157|      0|  double dc_org = 0.0;
  158|      0|  int index;
  159|      0|  int comp;
  160|      0|  double dc_ref[6][MAX_REFERENCE_PICTURES];
  161|       |  
  162|      0|  int log_weight_denom;
  163|       |  
  164|      0|  pel_t*  ref_pic;   
  165|      0|  pel_t*  ref_pic_w;   
  166|      0|  int default_weight[3];
  167|      0|  int list_offset   = ((img->MbaffFrameFlag)&&(img->mb_data[img->current_mb_nr].mb_field))? img->current_mb_nr%2 ? 4 : 2 : 0;
  168|      0|  int weight[6][MAX_REFERENCE_PICTURES][3]; 
  169|      0|  int offset[6][MAX_REFERENCE_PICTURES][3];       
  170|      0|  int im_weight[6][MAX_REFERENCE_PICTURES][MAX_REFERENCE_PICTURES][3]; 
  171|      0|  int im_offset[6][MAX_REFERENCE_PICTURES][MAX_REFERENCE_PICTURES][3]; 
  172|      0|  int clist;
  173|      0|  int wf_weight, wf_offset;
  174|       |  
  175|      0|  if (active_pps->weighted_bipred_idc == 2) //! implicit mode
  176|      0|  {
  177|      0|    luma_log_weight_denom = 5;
  178|      0|    chroma_log_weight_denom = 5;
  179|      0|  }
  180|      0|  else
  181|      0|  {
  182|      0|    luma_log_weight_denom = 6;
  183|      0|    chroma_log_weight_denom = 6;
  184|      0|  }
  185|       |
  186|      0|  wp_luma_round = 1 << (luma_log_weight_denom - 1);
  187|      0|  wp_chroma_round = 1 << (chroma_log_weight_denom - 1);
  188|      0|  default_weight[0] = 1<<luma_log_weight_denom;
  189|      0|  default_weight[1] = 1<<chroma_log_weight_denom;
  190|      0|  default_weight[2] = 1<<chroma_log_weight_denom;
  191|       |  
  192|       |  /* set all values to defaults */
  193|      0|  for (i = 0; i < 2 + list_offset; i++)
  194|      0|  {
  195|      0|    for (j = 0; j < listXsize[i]; j++)
  196|      0|    {
  197|      0|      for (n = 0; n < 3; n++)
  198|      0|      {
  199|      0|        wp_weight[i][j][n] = default_weight[n];
  200|      0|        wp_offset[i][j][n] = 0;
  201|      0|        offset   [i][j][n] = 0;
  202|      0|        weight   [i][j][n] = default_weight[n];
  203|      0|      }
  204|      0|    }
  205|      0|  }
  206|       |  
  207|      0|  for (i = 0; i < listXsize[LIST_0]; i++)
  208|      0|  {
  209|      0|    for (j = 0; j < listXsize[LIST_1]; j++)
  210|      0|    {
  211|      0|      int td, tb;
  212|      0|      td = Clip3(-128,127,(listX[LIST_1][j]->poc - listX[LIST_0][i]->poc));
  213|      0|      tb = Clip3(-128,127,(enc_picture->poc - listX[LIST_0][i]->poc));
  214|      0|      for (comp = 0; comp < 3; comp++)
  215|      0|      {
  216|       |        // implicit weights          
  217|      0|        if (td == 0)
  218|      0|        {
  219|      0|          im_weight[1][i][j][comp] = default_weight[comp];
  220|      0|          im_weight[0][i][j][comp] = default_weight[comp];
  221|      0|          im_offset[1][i][j][comp] = 0;
  222|      0|          im_offset[0][i][j][comp] = 0;
  223|      0|        }
  224|      0|        else
  225|      0|        {            
  226|      0|          tx = (16384 + abs(td/2))/td;
  227|      0|          DistScaleFactor = Clip3(-1024, 1023, (tx*tb + 32 )>>6);
  228|      0|          im_weight[1][i][j][comp] = DistScaleFactor>>2;
  229|      0|          if (im_weight[1][i][j][comp] < -64 || im_weight[1][i][j][comp] >128)
  230|      0|            im_weight[1][i][j][comp] = default_weight[comp];
  231|      0|          im_weight[0][i][j][comp] = 64 - im_weight[1][i][j][comp];            
  232|      0|          im_offset[1][i][j][comp] = 0;
  233|      0|          im_offset[0][i][j][comp] = 0;
  234|      0|        }        
  235|      0|      }
  236|       |      /*
  237|       |      printf ("%d imp weight[%d][%d] = %d  , %d (%d %d %d) (%d %d) (%d %d)\n",enc_picture->poc, i, j,  im_weight[0][i][j][0], im_weight[1][i][j][0],
  238|       |        enc_picture->poc,listX[LIST_0][i]->poc, listX[LIST_1][j]->poc,
  239|       |        DistScaleFactor ,tx,td,tb);
  240|       |      */
  241|      0|    }
  242|      0|  }
  243|       |  
  244|       |  
  245|      0|  if (active_pps->weighted_bipred_idc == 2) //! implicit mode
  246|      0|  {
  247|       |    
  248|      0|    for (i = 0; i < listXsize[LIST_0]; i++)
  249|      0|    {
  250|      0|      for (j = 0; j < listXsize[LIST_1]; j++)
  251|      0|      {
  252|      0|        for (comp = 0; comp < 3; comp++)
  253|      0|        {
  254|      0|          log_weight_denom = (comp == 0) ? luma_log_weight_denom : chroma_log_weight_denom;         
  255|      0|          wbp_weight[1][i][j][comp] = im_weight[1][i][j][comp] ;
  256|      0|          wbp_weight[0][i][j][comp] = im_weight[0][i][j][comp];
  257|      0|        }
  258|      0|      }
  259|      0|    }
  260|       |    
  261|      0|    for (clist=0; clist<2 + list_offset; clist++)
  262|      0|    {
  263|      0|      for (index = 0; index < listXsize[clist]; index++)
  264|      0|      {
  265|      0|        wp_weight[clist][index][0] = default_weight[0];
  266|      0|        wp_weight[clist][index][1] = default_weight[1];
  267|      0|        wp_weight[clist][index][2] = default_weight[2];
  268|      0|        wp_offset[clist][index][0] = 0;
  269|      0|        wp_offset[clist][index][1] = 0;
  270|      0|        wp_offset[clist][index][2] = 0;
  271|      0|      }
  272|      0|    }
  273|      0|    for (i = 0; i < listXsize[LIST_0]; i++)
  274|      0|    {
  275|      0|      for (j = 0; j < listXsize[LIST_1]; j++)
  276|      0|      {
  277|       |        
  278|      0|        for (n = 0; n < img->height * img->width; n++)
  279|      0|        {
  280|      0|          listX[0][i]->imgY_11_w[n] = listX[0][i]->imgY_11[n];
  281|      0|          listX[1][j]->imgY_11_w[n] = listX[1][j]->imgY_11[n];
  282|      0|        }
  283|       |        
  284|      0|        for (n = 0; n < 4*(img->height + 2*IMG_PAD_SIZE) ; n++)
  285|      0|        {
  286|      0|          for (l = 0; l< 4*(img->width + 2*IMG_PAD_SIZE); l++)
  287|      0|          {
  288|      0|            listX[LIST_0][i]->imgY_ups_w[n][l] =   listX[LIST_0 ][i]->imgY_ups[n][l];
  289|      0|            listX[LIST_1][j]->imgY_ups_w[n][l] =   listX[LIST_1 ][j]->imgY_ups[n][l];
  290|      0|          }
  291|      0|        }
  292|      0|      }
  293|      0|    }
  294|      0|  }
  295|      0|  else
  296|      0|  {
  297|      0|    for (i = 0; i < img->height; i++)
  298|      0|    {
  299|      0|      for (j = 0; j < img->width; j++)
  300|      0|      {
  301|      0|        dc_org += (double) imgY_org[i][j];
  302|      0|      }
  303|      0|    }
  304|       |    
  305|      0|    for (clist=0; clist<2 + list_offset; clist++)
  306|      0|    {
  307|      0|      for (n = 0; n < listXsize[clist]; n++)
  308|      0|      {
  309|      0|        dc_ref[clist][n] = 0;
  310|       |        
  311|      0|        ref_pic       = listX[clist][n]->imgY_11;
  312|      0|        ref_pic_w     = listX[clist][n]->imgY_11_w;
  313|       |        
  314|       |        // Y
  315|      0|        for (i = 0; i < img->height * img->width; i++)
  316|      0|        {
  317|      0|          dc_ref[clist][n] += (double) ref_pic[i];
  318|      0|        }
  319|      0|        if (dc_ref[clist][n] != 0.0)
  320|      0|          wf_weight = (int) (default_weight[0] * dc_org / dc_ref[clist][n] + 0.5);
  321|      0|        else
  322|      0|          wf_weight = default_weight[0];  // only used when reference picture is black
  323|      0|        if ( (wf_weight<-64) || (wf_weight>127) )
  324|      0|        {
  325|      0|          wf_weight = default_weight[0];
  326|      0|        }
  327|      0|        wf_offset = 0;
  328|       |        
  329|       |        
  330|       |        //    printf("dc_org = %d, dc_ref = %d, weight[%d] = %d\n",dc_org, dc_ref[n],n,weight[n][0]);        
  331|       |        
  332|      0|        weight[clist][n][0] = wf_weight;
  333|      0|        weight[clist][n][1] = default_weight[1];
  334|      0|        weight[clist][n][2] = default_weight[2];
  335|      0|        offset[clist][n][0] = 0;
  336|      0|        offset[clist][n][1] = 0;
  337|      0|        offset[clist][n][2] = 0;
  338|       |        
  339|       |        
  340|       |        /* store weighted reference pic for motion estimation */
  341|      0|        for (i = 0; i < img->height * img->width; i++)
  342|      0|        {
  343|      0|          ref_pic_w[i] = Clip3 (0, img->max_imgpel_value, (((int) ref_pic[i] * wf_weight + wp_luma_round) >> luma_log_weight_denom) + wf_offset);
  344|      0|        }
  345|      0|        for (i = 0; i < 4*(img->height + 2*IMG_PAD_SIZE) ; i++)
  346|      0|        {
  347|      0|          for (j = 0; j< 4*(img->width + 2*IMG_PAD_SIZE); j++)
  348|      0|          {
  349|      0|            listX[LIST_0][n]->imgY_ups_w[i][j] =   Clip3 (0, img->max_imgpel_value, (((int) listX[LIST_0][n]->imgY_ups[i][j] * wf_weight + wp_luma_round) >> (luma_log_weight_denom)) + wf_offset );      	
  350|      0|          }
  351|       |          
  352|      0|        }
  353|      0|      }
  354|      0|    }
  355|       |    
  356|      0|    if (active_pps->weighted_bipred_idc == 1)
  357|      0|    {
  358|      0|      for (clist=0; clist<2 + list_offset; clist++)
  359|      0|      {
  360|      0|        for (index = 0; index < listXsize[clist]; index++)
  361|      0|        {
  362|      0|          for (comp = 0; comp < 3; comp++)
  363|      0|          {
  364|      0|            wp_weight[clist][index][comp] = weight[clist][index][comp];
  365|      0|            wp_offset[clist][index][comp] = offset[clist][index][comp];
  366|       |            //printf("%d %d\n",wp_weight[clist][index][comp],wp_offset[clist][index][comp]);
  367|      0|          }
  368|      0|        }
  369|      0|      }
  370|      0|    }
  371|      0|    else
  372|      0|    {    
  373|      0|      for (clist=0; clist<2 + list_offset; clist++)
  374|      0|      {
  375|      0|        for (index = 0; index < listXsize[clist]; index++)
  376|      0|        {
  377|      0|          wp_weight[clist][index][0] = 1<<luma_log_weight_denom;
  378|      0|          wp_weight[clist][index][1] = 1<<chroma_log_weight_denom;
  379|      0|          wp_weight[clist][index][2] = 1<<chroma_log_weight_denom;
  380|      0|          wp_offset[clist][index][0] = 0;
  381|      0|          wp_offset[clist][index][1] = 0;
  382|      0|          wp_offset[clist][index][2] = 0;
  383|      0|        }
  384|      0|      }
  385|      0|    }
  386|      0|    for (i = 0; i < listXsize[LIST_0]; i++)
  387|      0|    {
  388|      0|      for (j = 0; j < listXsize[LIST_1]; j++)
  389|      0|      {
  390|      0|        for (comp = 0; comp < 3; comp++)
  391|      0|        {
  392|      0|          log_weight_denom = (comp == 0) ? luma_log_weight_denom : chroma_log_weight_denom;
  393|      0|          wbp_weight[0][i][j][comp] = wp_weight[0][i][comp];
  394|      0|          wbp_weight[1][i][j][comp] = wp_weight[1][j][comp];
  395|      0|        }
  396|       |        /*
  397|       |        printf ("bpw weight[%d][%d] = %d  , %d (%d %d %d) (%d %d) (%d %d)\n", i, j, wbp_weight[0][i][j][0], wbp_weight[1][i][j][0],
  398|       |          enc_picture->poc,listX[LIST_0][i]->poc, listX[LIST_1][j]->poc,
  399|       |          DistScaleFactor ,tx,tx,tx);
  400|       |        */
  401|      0|      }
  402|      0|    }    
  403|      0|  }
  404|      0|}
  405|       |    
  406|       |    
  407|       |/*!
  408|       |************************************************************************
  409|       |* \brief
  410|       |*    Tests P slice weighting factors to perform or not WP RD decision
  411|       |************************************************************************
  412|       |*/
  413|       |
  414|       |int test_wp_P_slice(int select_offset)
  415|      0|{
  416|      0|  int i, j, n;
  417|       |  
  418|      0|  double dc_org = 0.0;
  419|      0|  int index;
  420|      0|  int comp;
  421|      0|  double dc_ref[MAX_REFERENCE_PICTURES];
  422|       |  
  423|      0|  pel_t*  ref_pic;   
  424|      0|  pel_t*  ref_pic_w;   
  425|      0|  int default_weight;
  426|      0|  int default_weight_chroma;
  427|      0|  int list_offset   = ((img->MbaffFrameFlag)&&(img->mb_data[img->current_mb_nr].mb_field))? img->current_mb_nr%2 ? 4 : 2 : 0;
  428|      0|  int weight[2][MAX_REFERENCE_PICTURES][3]; 
  429|      0|  int offset[2][MAX_REFERENCE_PICTURES][3];       
  430|      0|  int clist;
  431|      0|  int perform_wp = 0;      
  432|       |  
  433|       |  
  434|      0|  luma_log_weight_denom = 5;
  435|      0|  chroma_log_weight_denom = 5;
  436|      0|  wp_luma_round = 1 << (luma_log_weight_denom - 1);
  437|      0|  wp_chroma_round = 1 << (chroma_log_weight_denom - 1);
  438|      0|  default_weight = 1<<luma_log_weight_denom;
  439|      0|  default_weight_chroma = 1<<chroma_log_weight_denom;
  440|       |  
  441|       |  /* set all values to defaults */
  442|      0|  for (i = 0; i < 2 + list_offset; i++)
  443|      0|  {
  444|      0|    for (j = 0; j < listXsize[i]; j++)
  445|      0|    {
  446|      0|      for (n = 0; n < 3; n++)
  447|      0|      {
  448|      0|        weight[i][j][n] = default_weight;
  449|      0|        wp_weight[i][j][n] = default_weight;
  450|      0|        wp_offset[i][j][n] = 0;
  451|      0|        offset[i][j][n] = 0;
  452|      0|      }
  453|      0|    }
  454|      0|  }
  455|       |  
  456|      0|  for (i = 0; i < img->height; i++)
  457|      0|  {
  458|      0|    for (j = 0; j < img->width; j++)
  459|      0|    {
  460|      0|      dc_org += (double) imgY_org[i][j];
  461|      0|    }
  462|      0|  } 
  463|       |    
  464|      0|  for (clist=0; clist<2 + list_offset; clist++)
  465|      0|  {
  466|      0|    for (n = 0; n < listXsize[clist]; n++)
  467|      0|    {
  468|      0|      dc_ref[n] = 0.0;
  469|       |      
  470|      0|      ref_pic       = listX[clist][n]->imgY_11;
  471|      0|      ref_pic_w     = listX[clist][n]->imgY_11_w;
  472|       |      
  473|       |      // Y
  474|      0|      for (i = 0; i < img->height * img->width; i++)
  475|      0|      {
  476|      0|        dc_ref[n] += (double) ref_pic[i];
  477|      0|      }
  478|       |      
  479|      0|      if (select_offset==0)
  480|      0|      {
  481|      0|        if (dc_ref[n] != 0.0)
  482|      0|          weight[clist][n][0] = (int) (default_weight * dc_org / dc_ref[n] + 0.5);
  483|      0|        else
  484|      0|          weight[clist][n][0] = default_weight;  // only used when reference picture is black
  485|      0|        if (weight[clist][n][0] < -64 || weight[clist][n][0] >127)
  486|      0|          weight[clist][n][0] = 32;
  487|      0|      }
  488|      0|      else
  489|      0|      {        
  490|      0|        offset[clist][n][0] = (int) ((dc_org-dc_ref[n])/(img->height*img->width)+0.5);
  491|       |        //printf("offset[clist][%d][0] %d %.2f %.2f\n",n,offset[clist][n][0], dc_org,dc_ref[n] );
  492|      0|        offset[clist][n][0] = (offset[clist][n][0]<-128) ? -128: (offset[clist][n][0]>127) ? 127:offset[clist][n][0];
  493|      0|        weight[clist][n][0] = default_weight;
  494|      0|      }
  495|       |      
  496|       |      
  497|       |      /* for now always use default weight for chroma weight */
  498|      0|      weight[clist][n][1] = default_weight_chroma;
  499|      0|      weight[clist][n][2] = default_weight_chroma;
  500|       |                  
  501|      0|    }
  502|      0|  }
  503|       |  
  504|      0|  for (clist=0; clist<2 + list_offset; clist++)
  505|      0|  {
  506|      0|    for (index = 0; index < listXsize[clist]; index++)
  507|      0|    {
  508|      0|      for (comp=0; comp < 3; comp ++)
  509|      0|      {
  510|      0|        if (weight[clist][index][comp] != default_weight ||  offset[clist][index][comp] != 0)
  511|      0|        {
  512|      0|          perform_wp = 1;
  513|      0|          break;
  514|      0|        }
  515|      0|      }
  516|      0|      if (perform_wp == 1) break;
  517|      0|    }
  518|      0|    if (perform_wp == 1) break;
  519|      0|  }
  520|       |  
  521|      0|  return perform_wp;
  522|      0|}
  523|       |
  524|       |/*!
  525|       |************************************************************************
  526|       |* \brief
  527|       |*    test_wp_B_slice:
  528|       |*    Tests B slice weighting prediction
  529|       |************************************************************************
  530|       |*/
  531|       |int test_wp_B_slice(int select_method)
  532|      0|{
  533|      0|  int i, j, n;
  534|       |  
  535|      0|  int tx,DistScaleFactor;
  536|      0|  double dc_org = 0.0;
  537|      0|  int index;
  538|      0|  int comp;
  539|      0|  double dc_ref[6][MAX_REFERENCE_PICTURES];
  540|       |  
  541|      0|  int log_weight_denom;
  542|       |  
  543|      0|  pel_t*  ref_pic;   
  544|      0|  pel_t*  ref_pic_w;   
  545|      0|  int default_weight;
  546|      0|  int default_weight_chroma;
  547|      0|  int list_offset   = ((img->MbaffFrameFlag)&&(img->mb_data[img->current_mb_nr].mb_field))? img->current_mb_nr%2 ? 4 : 2 : 0;
  548|      0|  int weight[6][MAX_REFERENCE_PICTURES][3]; 
  549|      0|  int offset[6][MAX_REFERENCE_PICTURES][3];       
  550|      0|  int im_weight[6][MAX_REFERENCE_PICTURES][MAX_REFERENCE_PICTURES][3]; 
  551|      0|  int im_offset[6][MAX_REFERENCE_PICTURES][MAX_REFERENCE_PICTURES][3]; 
  552|      0|  int clist;
  553|      0|  int wf_weight, wf_offset;
  554|      0|  int perform_wp = 0;      
  555|       |  
  556|      0|  luma_log_weight_denom = 5;
  557|      0|  chroma_log_weight_denom = 5;
  558|      0|  wp_luma_round = 1 << (luma_log_weight_denom - 1);
  559|      0|  wp_chroma_round = 1 << (chroma_log_weight_denom - 1);
  560|      0|  default_weight = 1<<luma_log_weight_denom;
  561|      0|  default_weight_chroma = 1<<chroma_log_weight_denom;
  562|       |  
  563|       |  /* set all values to defaults */
  564|      0|  for (i = 0; i < 2 + list_offset; i++)
  565|      0|  {
  566|      0|    for (j = 0; j < listXsize[i]; j++)
  567|      0|    {
  568|      0|      for (n = 0; n < 3; n++)
  569|      0|      {
  570|      0|        wp_weight[i][j][n] = default_weight;
  571|      0|        wp_offset[i][j][n] = 0;
  572|      0|        offset   [i][j][n] = 0;
  573|      0|        weight   [i][j][n] = default_weight;
  574|      0|      }
  575|      0|    }
  576|      0|  }
  577|       |  
  578|      0|  for (i = 0; i < listXsize[LIST_0]; i++)
  579|      0|  {
  580|      0|    for (j = 0; j < listXsize[LIST_1]; j++)
  581|      0|    {
  582|      0|      int td, tb;
  583|      0|      td = Clip3(-128,127,(listX[LIST_1][j]->poc - listX[LIST_0][i]->poc));
  584|      0|      tb = Clip3(-128,127,(enc_picture->poc - listX[LIST_0][i]->poc));
  585|      0|      for (comp = 0; comp < 3; comp++)
  586|      0|      {
  587|       |        // implicit weights          
  588|      0|        if (td == 0)
  589|      0|        {
  590|      0|          im_weight[1][i][j][comp] = 32 ;
  591|      0|          im_weight[0][i][j][comp] = 32;
  592|      0|          im_offset[1][i][j][comp] = 0;
  593|      0|          im_offset[0][i][j][comp] = 0;
  594|      0|        }
  595|      0|        else
  596|      0|        {            
  597|      0|          tx = (16384 + abs(td/2))/td;
  598|      0|          DistScaleFactor = Clip3(-1024, 1023, (tx*tb + 32 )>>6);
  599|      0|          im_weight[1][i][j][comp] = DistScaleFactor>>2;
  600|      0|          if (im_weight[1][i][j][comp] < -64 || im_weight[1][i][j][comp] >128)
  601|      0|            im_weight[1][i][j][comp] = 32;
  602|      0|          im_weight[0][i][j][comp] = 64 - im_weight[1][i][j][comp];            
  603|      0|          im_offset[1][i][j][comp] = 0;
  604|      0|          im_offset[0][i][j][comp] = 0;
  605|      0|        }        
  606|      0|      }
  607|       |      /*
  608|       |      printf ("%d imp weight[%d][%d] = %d  , %d (%d %d %d) (%d %d) (%d %d)\n",enc_picture->poc, i, j,  im_weight[0][i][j][0], im_weight[1][i][j][0],
  609|       |        enc_picture->poc,listX[LIST_0][i]->poc, listX[LIST_1][j]->poc,
  610|       |        DistScaleFactor ,tx,td,tb);
  611|       |      */
  612|      0|    }
  613|      0|  }
  614|       |  
  615|       |  
  616|      0|  if (select_method == 1) //! implicit mode
  617|      0|  {
  618|       |    
  619|      0|    for (i = 0; i < listXsize[LIST_0]; i++)
  620|      0|    {
  621|      0|      for (j = 0; j < listXsize[LIST_1]; j++)
  622|      0|      {
  623|      0|        for (comp = 0; comp < 3; comp++)
  624|      0|        {
  625|      0|          log_weight_denom = (comp == 0) ? luma_log_weight_denom : chroma_log_weight_denom;         
  626|      0|          wbp_weight[1][i][j][comp] = im_weight[1][i][j][comp] ;
  627|      0|          wbp_weight[0][i][j][comp] = im_weight[0][i][j][comp];
  628|      0|        }
  629|      0|      }
  630|      0|    }
  631|       |    
  632|      0|    for (clist=0; clist<2 + list_offset; clist++)
  633|      0|    {
  634|      0|      for (index = 0; index < listXsize[clist]; index++)
  635|      0|      {
  636|      0|        wp_weight[clist][index][0] = 1<<luma_log_weight_denom;
  637|      0|        wp_weight[clist][index][1] = 1<<chroma_log_weight_denom;
  638|      0|        wp_weight[clist][index][2] = 1<<chroma_log_weight_denom;
  639|      0|        wp_offset[clist][index][0] = 0;
  640|      0|        wp_offset[clist][index][1] = 0;
  641|      0|        wp_offset[clist][index][2] = 0;
  642|      0|      }
  643|      0|    }
  644|      0|  }
  645|      0|  else
  646|      0|  {
  647|      0|    for (i = 0; i < img->height; i++)
  648|      0|    {
  649|      0|      for (j = 0; j < img->width; j++)
  650|      0|      {
  651|      0|        dc_org += (double) imgY_org[i][j];
  652|      0|      }
  653|      0|    }
  654|       |    
  655|      0|    for (clist=0; clist<2 + list_offset; clist++)
  656|      0|    {
  657|      0|      for (n = 0; n < listXsize[clist]; n++)
  658|      0|      {
  659|      0|        dc_ref[clist][n] = 0;
  660|       |        
  661|      0|        ref_pic       = listX[clist][n]->imgY_11;
  662|      0|        ref_pic_w     = listX[clist][n]->imgY_11_w;
  663|       |        
  664|       |        // Y
  665|      0|        for (i = 0; i < img->height * img->width; i++)
  666|      0|        {
  667|      0|          dc_ref[clist][n] += (double) ref_pic[i];
  668|      0|        }
  669|      0|        if (dc_ref[clist][n] != 0.0)
  670|      0|          wf_weight = (int) (default_weight * dc_org / dc_ref[clist][n] + 0.5);
  671|      0|        else
  672|      0|          wf_weight = default_weight;  // only used when reference picture is black
  673|      0|        if ( (wf_weight<-64) || (wf_weight>127) )
  674|      0|        {
  675|      0|          wf_weight = default_weight;
  676|      0|        }
  677|      0|        wf_offset = 0;
  678|       |        
  679|       |               
  680|      0|        weight[clist][n][0] = wf_weight;
  681|      0|        weight[clist][n][1] = default_weight_chroma;
  682|      0|        weight[clist][n][2] = default_weight_chroma;
  683|      0|        offset[clist][n][0] = 0;
  684|      0|        offset[clist][n][1] = 0;
  685|      0|        offset[clist][n][2] = 0;
  686|       |        
  687|      0|      }
  688|      0|    }
  689|       |    
  690|      0|    if (active_pps->weighted_bipred_idc == 1)
  691|      0|    {
  692|      0|      for (clist=0; clist<2 + list_offset; clist++)
  693|      0|      {
  694|      0|        for (index = 0; index < listXsize[clist]; index++)
  695|      0|        {
  696|      0|          for (comp = 0; comp < 3; comp++)
  697|      0|          {
  698|      0|            wp_weight[clist][index][comp] = weight[clist][index][comp];
  699|      0|            wp_offset[clist][index][comp] = offset[clist][index][comp];
  700|      0|          }
  701|      0|        }
  702|      0|      }
  703|      0|    }
  704|      0|    else
  705|      0|    {    
  706|      0|      for (clist=0; clist<2 + list_offset; clist++)
  707|      0|      {
  708|      0|        for (index = 0; index < listXsize[clist]; index++)
  709|      0|        {
  710|      0|          wp_weight[clist][index][0] = 1<<luma_log_weight_denom;
  711|      0|          wp_weight[clist][index][1] = 1<<chroma_log_weight_denom;
  712|      0|          wp_weight[clist][index][2] = 1<<chroma_log_weight_denom;
  713|      0|          wp_offset[clist][index][0] = 0;
  714|      0|          wp_offset[clist][index][1] = 0;
  715|      0|          wp_offset[clist][index][2] = 0;
  716|      0|        }
  717|      0|      }
  718|      0|    }
  719|      0|    for (i = 0; i < listXsize[LIST_0]; i++)
  720|      0|    {
  721|      0|      for (j = 0; j < listXsize[LIST_1]; j++)
  722|      0|      {
  723|      0|        for (comp = 0; comp < 3; comp++)
  724|      0|        {
  725|      0|          log_weight_denom = (comp == 0) ? luma_log_weight_denom : chroma_log_weight_denom;
  726|      0|          wbp_weight[0][i][j][comp] = wp_weight[0][i][comp];
  727|      0|          wbp_weight[1][i][j][comp] = wp_weight[1][j][comp];
  728|      0|        }
  729|       |        /*
  730|       |        printf ("bpw weight[%d][%d] = %d  , %d (%d %d %d) (%d %d) (%d %d)\n", i, j, wbp_weight[0][i][j][0], wbp_weight[1][i][j][0],
  731|       |          enc_picture->poc,listX[LIST_0][i]->poc, listX[LIST_1][j]->poc,
  732|       |          DistScaleFactor ,tx,tx,tx);
  733|       |        */
  734|      0|      }
  735|      0|    }
  736|      0|  }
  737|       |
  738|      0|  for (clist=0; clist<2 + list_offset; clist++)
  739|      0|  {
  740|      0|    for (index = 0; index < listXsize[clist]; index++)
  741|      0|    {
  742|      0|      for (comp=0; comp < 3; comp ++)
  743|      0|      {
  744|      0|        if (wp_weight[clist][index][comp] != default_weight ||  wp_offset[clist][index][comp] != 0)
  745|      0|        {
  746|      0|          perform_wp = 1;
  747|      0|          break;
  748|      0|        }
  749|      0|      }
  750|      0|      if (perform_wp == 1) break;
  751|      0|    }
  752|      0|    if (perform_wp == 1) break;
  753|      0|  }
  754|       |
  755|      0|  return perform_wp;
  756|      0|}
  757|       |    
  758|       |    

